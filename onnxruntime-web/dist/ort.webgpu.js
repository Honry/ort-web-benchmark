/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";
var ort = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // common/dist/esm/backend-impl.js
  var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
  var init_backend_impl = __esm({
    "common/dist/esm/backend-impl.js"() {
      "use strict";
      backends = /* @__PURE__ */ new Map();
      backendsSortedByPriority = [];
      registerBackend = (name, backend, priority) => {
        if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
          const currentBackend = backends.get(name);
          if (currentBackend === void 0) {
            backends.set(name, { backend, priority });
          } else if (currentBackend.priority > priority) {
            return;
          } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
              throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
          }
          if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
              backendsSortedByPriority.splice(i, 1);
            }
            for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
              if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
                backendsSortedByPriority.splice(i2, 0, name);
                return;
              }
            }
            backendsSortedByPriority.push(name);
          }
          return;
        }
        throw new TypeError("not a valid backend");
      };
      tryResolveAndInitializeBackend = async (backendName) => {
        const backendInfo = backends.get(backendName);
        if (!backendInfo) {
          return "backend not found.";
        }
        if (backendInfo.initialized) {
          return backendInfo.backend;
        } else if (backendInfo.aborted) {
          return backendInfo.error;
        } else {
          const isInitializing = !!backendInfo.initPromise;
          try {
            if (!isInitializing) {
              backendInfo.initPromise = backendInfo.backend.init(backendName);
            }
            await backendInfo.initPromise;
            backendInfo.initialized = true;
            return backendInfo.backend;
          } catch (e) {
            if (!isInitializing) {
              backendInfo.error = `${e}`;
              backendInfo.aborted = true;
            }
            return backendInfo.error;
          } finally {
            delete backendInfo.initPromise;
          }
        }
      };
      resolveBackendAndExecutionProviders = async (options) => {
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
        const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
        let backend;
        const errors = [];
        const availableBackendNames = /* @__PURE__ */ new Set();
        for (const backendName of backendNames) {
          const resolveResult = await tryResolveAndInitializeBackend(backendName);
          if (typeof resolveResult === "string") {
            errors.push({ name: backendName, err: resolveResult });
          } else {
            if (!backend) {
              backend = resolveResult;
            }
            if (backend === resolveResult) {
              availableBackendNames.add(backendName);
            }
          }
        }
        if (!backend) {
          throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
        }
        for (const { name, err } of errors) {
          if (backendHints.includes(name)) {
            console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
          }
        }
        const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
        return [
          backend,
          new Proxy(options, {
            get: (target, prop) => {
              if (prop === "executionProviders") {
                return filteredEps;
              }
              return Reflect.get(target, prop);
            }
          })
        ];
      };
    }
  });

  // common/dist/esm/backend.js
  var init_backend = __esm({
    "common/dist/esm/backend.js"() {
      "use strict";
      init_backend_impl();
    }
  });

  // common/dist/esm/version.js
  var version;
  var init_version = __esm({
    "common/dist/esm/version.js"() {
      "use strict";
      version = "1.19.0";
    }
  });

  // common/dist/esm/env-impl.js
  var logLevelValue, env;
  var init_env_impl = __esm({
    "common/dist/esm/env-impl.js"() {
      "use strict";
      init_version();
      logLevelValue = "warning";
      env = {
        wasm: {},
        webgl: {},
        webgpu: {},
        versions: { common: version },
        set logLevel(value) {
          if (value === void 0) {
            return;
          }
          if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
          }
          logLevelValue = value;
        },
        get logLevel() {
          return logLevelValue;
        }
      };
      Object.defineProperty(env, "logLevel", { enumerable: true });
    }
  });

  // common/dist/esm/env.js
  var env2;
  var init_env = __esm({
    "common/dist/esm/env.js"() {
      "use strict";
      init_env_impl();
      env2 = env;
    }
  });

  // common/dist/esm/tensor-conversion-impl.js
  var tensorToDataURL, tensorToImageData;
  var init_tensor_conversion_impl = __esm({
    "common/dist/esm/tensor-conversion-impl.js"() {
      "use strict";
      tensorToDataURL = (tensor, options) => {
        const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
        canvas.width = tensor.dims[3];
        canvas.height = tensor.dims[2];
        const pixels2DContext = canvas.getContext("2d");
        if (pixels2DContext != null) {
          let width;
          let height;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
          }
          const inputformat = options?.format !== void 0 ? options.format : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          for (let i = 0; i < height; i++) {
            for (let j = 0; j < width; j++) {
              const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
              const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
              const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
              const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
              pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
              pixels2DContext.fillRect(j, i, 1, 1);
            }
          }
          if ("toDataURL" in canvas) {
            return canvas.toDataURL();
          } else {
            throw new Error("toDataURL is not supported");
          }
        } else {
          throw new Error("Can not access image data");
        }
      };
      tensorToImageData = (tensor, options) => {
        const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
        let image;
        if (pixels2DContext != null) {
          let width;
          let height;
          let channels;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[1];
            channels = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
            channels = tensor.dims[1];
          }
          const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          if (options !== void 0) {
            if (options.format !== void 0 && (channels === 4 && options.format !== "RGBA") || channels === 3 && (options.format !== "RGB" && options.format !== "BGR")) {
              throw new Error("Tensor format doesn't match input tensor dims");
            }
          }
          const step = 4;
          let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          image = pixels2DContext.createImageData(width, height);
          for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
          }
        } else {
          throw new Error("Can not access image data");
        }
        return image;
      };
    }
  });

  // common/dist/esm/tensor-factory-impl.js
  var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromPinnedBuffer;
  var init_tensor_factory_impl = __esm({
    "common/dist/esm/tensor-factory-impl.js"() {
      "use strict";
      init_tensor_impl();
      bufferToTensor = (buffer, options) => {
        if (buffer === void 0) {
          throw new Error("Image buffer must be defined");
        }
        if (options.height === void 0 || options.width === void 0) {
          throw new Error("Image height and width must be defined");
        }
        if (options.tensorLayout === "NHWC") {
          throw new Error("NHWC Tensor layout is not supported yet");
        }
        const { height, width } = options;
        const norm = options.norm ?? { mean: 255, bias: 0 };
        let normMean;
        let normBias;
        if (typeof norm.mean === "number") {
          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
        } else {
          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
        }
        if (typeof norm.bias === "number") {
          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
        } else {
          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
        }
        const inputformat = options.format !== void 0 ? options.format : "RGBA";
        const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
        const stride = height * width;
        const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGB") {
          step = 3;
          rImagePointer = 0;
          gImagePointer = 1;
          bImagePointer = 2;
          aImagePointer = -1;
        }
        if (outputformat === "RGBA") {
          aTensorPointer = stride * 3;
        } else if (outputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        } else if (outputformat === "BGR") {
          bTensorPointer = 0;
          gTensorPointer = stride;
          rTensorPointer = stride * 2;
        }
        for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
          float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
          float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
          float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
          if (aTensorPointer !== -1 && aImagePointer !== -1) {
            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
          }
        }
        const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
        return outputTensor;
      };
      tensorFromImage = async (image, options) => {
        const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
        const isString = typeof image === "string";
        let data;
        let bufferToTensorOptions = options ?? {};
        const createCanvas = () => {
          if (typeof document !== "undefined") {
            return document.createElement("canvas");
          } else if (typeof OffscreenCanvas !== "undefined") {
            return new OffscreenCanvas(1, 1);
          } else {
            throw new Error("Canvas is not supported");
          }
        };
        const createCanvasContext = (canvas) => {
          if (canvas instanceof HTMLCanvasElement) {
            return canvas.getContext("2d");
          } else if (canvas instanceof OffscreenCanvas) {
            return canvas.getContext("2d");
          } else {
            return null;
          }
        };
        if (isHTMLImageEle) {
          const canvas = createCanvas();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            let height = image.height;
            let width = image.width;
            if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
              height = options.resizedHeight;
              width = options.resizedWidth;
            }
            if (options !== void 0) {
              bufferToTensorOptions = options;
              if (options.tensorFormat !== void 0) {
                throw new Error("Image input config format must be RGBA for HTMLImageElement");
              } else {
                bufferToTensorOptions.tensorFormat = "RGBA";
              }
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            }
            pixels2DContext.drawImage(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isImageDataEle) {
          let height;
          let width;
          if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          } else {
            height = image.height;
            width = image.width;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
          }
          bufferToTensorOptions.format = "RGBA";
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          if (options !== void 0) {
            const tempCanvas = createCanvas();
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = createCanvasContext(tempCanvas);
            if (pixels2DContext != null) {
              pixels2DContext.putImageData(image, 0, 0);
              data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
              throw new Error("Can not access image data");
            }
          } else {
            data = image.data;
          }
        } else if (isImageBitmap) {
          if (options === void 0) {
            throw new Error("Please provide image config with format for Imagebitmap");
          }
          const canvas = createCanvas();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
            return bufferToTensor(data, bufferToTensorOptions);
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isString) {
          return new Promise((resolve, reject) => {
            const canvas = createCanvas();
            const context = createCanvasContext(canvas);
            if (!image || !context) {
              return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = "Anonymous";
            newImage.src = image;
            newImage.onload = () => {
              canvas.width = newImage.width;
              canvas.height = newImage.height;
              context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
              const img = context.getImageData(0, 0, canvas.width, canvas.height);
              bufferToTensorOptions.height = canvas.height;
              bufferToTensorOptions.width = canvas.width;
              resolve(bufferToTensor(img.data, bufferToTensorOptions));
            };
          });
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
        if (data !== void 0) {
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
      };
      tensorFromTexture = (texture, options) => {
        const { width, height, download, dispose } = options;
        const dims = [1, height, width, 4];
        return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
      };
      tensorFromGpuBuffer = (gpuBuffer, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
      };
      tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
    }
  });

  // common/dist/esm/tensor-impl-type-mapping.js
  var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
  var init_tensor_impl_type_mapping = __esm({
    "common/dist/esm/tensor-impl-type-mapping.js"() {
      "use strict";
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
        ["float32", Float32Array],
        ["uint8", Uint8Array],
        ["int8", Int8Array],
        ["uint16", Uint16Array],
        ["int16", Int16Array],
        ["int32", Int32Array],
        ["bool", Uint8Array],
        ["float64", Float64Array],
        ["uint32", Uint32Array]
      ]);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
        [Float32Array, "float32"],
        [Uint8Array, "uint8"],
        [Int8Array, "int8"],
        [Uint16Array, "uint16"],
        [Int16Array, "int16"],
        [Int32Array, "int32"],
        [Float64Array, "float64"],
        [Uint32Array, "uint32"]
      ]);
      isTypedArrayChecked = false;
      checkTypedArray = () => {
        if (!isTypedArrayChecked) {
          isTypedArrayChecked = true;
          const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
          const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
          const isFloat16ArrayAvailable = typeof Float16Array !== "undefined" && Float16Array.from;
          if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
          }
          if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
          }
          if (isFloat16ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, "float16");
          } else {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
          }
        }
      };
    }
  });

  // common/dist/esm/tensor-utils-impl.js
  var calculateSize, tensorReshape;
  var init_tensor_utils_impl = __esm({
    "common/dist/esm/tensor-utils-impl.js"() {
      "use strict";
      init_tensor_impl();
      calculateSize = (dims) => {
        let size = 1;
        for (let i = 0; i < dims.length; i++) {
          const dim = dims[i];
          if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
          }
          if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
          }
          size *= dim;
        }
        return size;
      };
      tensorReshape = (tensor, dims) => {
        switch (tensor.location) {
          case "cpu":
            return new Tensor(tensor.type, tensor.data, dims);
          case "cpu-pinned":
            return new Tensor({
              location: "cpu-pinned",
              data: tensor.data,
              type: tensor.type,
              dims
            });
          case "texture":
            return new Tensor({
              location: "texture",
              texture: tensor.texture,
              type: tensor.type,
              dims
            });
          case "gpu-buffer":
            return new Tensor({
              location: "gpu-buffer",
              gpuBuffer: tensor.gpuBuffer,
              type: tensor.type,
              dims
            });
          default:
            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
        }
      };
    }
  });

  // common/dist/esm/tensor-impl.js
  var Tensor;
  var init_tensor_impl = __esm({
    "common/dist/esm/tensor-impl.js"() {
      "use strict";
      init_tensor_conversion_impl();
      init_tensor_factory_impl();
      init_tensor_impl_type_mapping();
      init_tensor_utils_impl();
      Tensor = class {
        /**
         * implementation.
         */
        constructor(arg0, arg1, arg2) {
          checkTypedArray();
          let type;
          let dims;
          if (typeof arg0 === "object" && "location" in arg0) {
            this.dataLocation = arg0.location;
            type = arg0.type;
            dims = arg0.dims;
            switch (arg0.location) {
              case "cpu-pinned": {
                const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
                if (!expectedTypedArrayConstructor) {
                  throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
                }
                if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                  throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
                }
                this.cpuData = arg0.data;
                break;
              }
              case "texture": {
                if (type !== "float32") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
                }
                this.gpuTextureData = arg0.texture;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "gpu-buffer": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
                }
                this.gpuBufferData = arg0.gpuBuffer;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              default:
                throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
            }
          } else {
            let data;
            let maybeDims;
            if (typeof arg0 === "string") {
              type = arg0;
              maybeDims = arg2;
              if (arg0 === "string") {
                if (!Array.isArray(arg1)) {
                  throw new TypeError("A string tensor's data must be a string array.");
                }
                data = arg1;
              } else {
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === void 0) {
                  throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                  if (arg0 === "float16" && typedArrayConstructor === Uint16Array) {
                    throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");
                  } else if (arg0 === "uint64" || arg0 === "int64") {
                    data = typedArrayConstructor.from(arg1, BigInt);
                  } else {
                    data = typedArrayConstructor.from(arg1);
                  }
                } else if (arg1 instanceof typedArrayConstructor) {
                  data = arg1;
                } else {
                  throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
              }
            } else {
              maybeDims = arg1;
              if (Array.isArray(arg0)) {
                if (arg0.length === 0) {
                  throw new TypeError("Tensor type cannot be inferred from an empty array.");
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === "string") {
                  type = "string";
                  data = arg0;
                } else if (firstElementType === "boolean") {
                  type = "bool";
                  data = Uint8Array.from(arg0);
                } else {
                  throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
              } else {
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === void 0) {
                  throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
              }
            }
            if (maybeDims === void 0) {
              maybeDims = [data.length];
            } else if (!Array.isArray(maybeDims)) {
              throw new TypeError("A tensor's dims must be a number array");
            }
            dims = maybeDims;
            this.cpuData = data;
            this.dataLocation = "cpu";
          }
          const size = calculateSize(dims);
          if (this.cpuData && size !== this.cpuData.length) {
            throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
          }
          this.type = type;
          this.dims = dims;
          this.size = size;
        }
        // #endregion
        // #region factory
        static async fromImage(image, options) {
          return tensorFromImage(image, options);
        }
        static fromTexture(texture, options) {
          return tensorFromTexture(texture, options);
        }
        static fromGpuBuffer(gpuBuffer, options) {
          return tensorFromGpuBuffer(gpuBuffer, options);
        }
        static fromPinnedBuffer(type, buffer, dims) {
          return tensorFromPinnedBuffer(type, buffer, dims);
        }
        // #endregion
        // #region conversions
        toDataURL(options) {
          return tensorToDataURL(this, options);
        }
        toImageData(options) {
          return tensorToImageData(this, options);
        }
        // #endregion
        // #region properties
        get data() {
          this.ensureValid();
          if (!this.cpuData) {
            throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
          }
          return this.cpuData;
        }
        get location() {
          return this.dataLocation;
        }
        get texture() {
          this.ensureValid();
          if (!this.gpuTextureData) {
            throw new Error("The data is not stored as a WebGL texture.");
          }
          return this.gpuTextureData;
        }
        get gpuBuffer() {
          this.ensureValid();
          if (!this.gpuBufferData) {
            throw new Error("The data is not stored as a WebGPU buffer.");
          }
          return this.gpuBufferData;
        }
        // #endregion
        // #region methods
        async getData(releaseData) {
          this.ensureValid();
          switch (this.dataLocation) {
            case "cpu":
            case "cpu-pinned":
              return this.data;
            case "texture":
            case "gpu-buffer": {
              if (!this.downloader) {
                throw new Error("The current tensor is not created with a specified data downloader.");
              }
              if (this.isDownloading) {
                throw new Error("The current tensor is being downloaded.");
              }
              try {
                this.isDownloading = true;
                const data = await this.downloader();
                this.downloader = void 0;
                this.dataLocation = "cpu";
                this.cpuData = data;
                if (releaseData && this.disposer) {
                  this.disposer();
                  this.disposer = void 0;
                }
                return data;
              } finally {
                this.isDownloading = false;
              }
            }
            default:
              throw new Error(`cannot get data from location: ${this.dataLocation}`);
          }
        }
        dispose() {
          if (this.isDownloading) {
            throw new Error("The current tensor is being downloaded.");
          }
          if (this.disposer) {
            this.disposer();
            this.disposer = void 0;
          }
          this.cpuData = void 0;
          this.gpuTextureData = void 0;
          this.gpuBufferData = void 0;
          this.downloader = void 0;
          this.isDownloading = void 0;
          this.dataLocation = "none";
        }
        // #endregion
        // #region tensor utilities
        ensureValid() {
          if (this.dataLocation === "none") {
            throw new Error("The tensor is disposed.");
          }
        }
        reshape(dims) {
          this.ensureValid();
          if (this.downloader || this.disposer) {
            throw new Error("Cannot reshape a tensor that owns GPU resource.");
          }
          return tensorReshape(this, dims);
        }
      };
    }
  });

  // common/dist/esm/tensor.js
  var Tensor2;
  var init_tensor = __esm({
    "common/dist/esm/tensor.js"() {
      "use strict";
      init_tensor_impl();
      Tensor2 = Tensor;
    }
  });

  // common/dist/esm/trace.js
  var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;
  var init_trace = __esm({
    "common/dist/esm/trace.js"() {
      "use strict";
      init_env_impl();
      TRACE = (deviceType, label) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.timeStamp(`${deviceType}::ORT::${label}`);
      };
      TRACE_FUNC = (msg, extraMsg) => {
        const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
        let hasTraceFunc = false;
        for (let i = 0; i < stack.length; i++) {
          if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
            let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
            if (extraMsg) {
              label += `::${extraMsg}`;
            }
            TRACE("CPU", label);
            return;
          }
          if (stack[i].includes("TRACE_FUNC")) {
            hasTraceFunc = true;
          }
        }
      };
      TRACE_FUNC_BEGIN = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("BEGIN", extraMsg);
      };
      TRACE_FUNC_END = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("END", extraMsg);
      };
    }
  });

  // common/dist/esm/inference-session-impl.js
  var InferenceSession;
  var init_inference_session_impl = __esm({
    "common/dist/esm/inference-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      init_trace();
      InferenceSession = class _InferenceSession {
        constructor(handler) {
          this.handler = handler;
        }
        async run(feeds, arg1, arg2) {
          TRACE_FUNC_BEGIN();
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name of arg1) {
                if (typeof name !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (this.outputNames.indexOf(name) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                }
                fetches[name] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name of this.outputNames) {
                if (arg1Keys.indexOf(name) !== -1) {
                  const v = arg1[name];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name of this.inputNames) {
            if (typeof feeds[name] === "undefined") {
              throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name of this.outputNames) {
              fetches[name] = null;
            }
          }
          const results = await this.handler.run(feeds, fetches, options);
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          TRACE_FUNC_END();
          return returnValue;
        }
        async release() {
          return this.handler.dispose();
        }
        static async create(arg0, arg1, arg2, arg3) {
          TRACE_FUNC_BEGIN();
          let filePathOrUint8Array;
          let options = {};
          if (typeof arg0 === "string") {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 === "number") {
              byteOffset = arg1;
              if (!Number.isSafeInteger(byteOffset)) {
                throw new RangeError("'byteOffset' must be an integer.");
              }
              if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
              }
              byteLength = arg0.byteLength - byteOffset;
              if (typeof arg2 === "number") {
                byteLength = arg2;
                if (!Number.isSafeInteger(byteLength)) {
                  throw new RangeError("'byteLength' must be an integer.");
                }
                if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                  throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                }
                if (typeof arg3 === "object" && arg3 !== null) {
                  options = arg3;
                } else if (typeof arg3 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'byteLength' must be a number.");
              }
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
          } else {
            throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
          }
          const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
          TRACE_FUNC_END();
          return new _InferenceSession(handler);
        }
        startProfiling() {
          this.handler.startProfiling();
        }
        endProfiling() {
          this.handler.endProfiling();
        }
        get inputNames() {
          return this.handler.inputNames;
        }
        get outputNames() {
          return this.handler.outputNames;
        }
      };
    }
  });

  // common/dist/esm/inference-session.js
  var InferenceSession2;
  var init_inference_session = __esm({
    "common/dist/esm/inference-session.js"() {
      "use strict";
      init_inference_session_impl();
      InferenceSession2 = InferenceSession;
    }
  });

  // common/dist/esm/tensor-conversion.js
  var init_tensor_conversion = __esm({
    "common/dist/esm/tensor-conversion.js"() {
      "use strict";
    }
  });

  // common/dist/esm/tensor-factory.js
  var init_tensor_factory = __esm({
    "common/dist/esm/tensor-factory.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-model.js
  var init_onnx_model = __esm({
    "common/dist/esm/onnx-model.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-value.js
  var init_onnx_value = __esm({
    "common/dist/esm/onnx-value.js"() {
      "use strict";
    }
  });

  // common/dist/esm/training-session-impl.js
  var noBackendErrMsg, TrainingSession;
  var init_training_session_impl = __esm({
    "common/dist/esm/training-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      noBackendErrMsg = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
      TrainingSession = class _TrainingSession {
        constructor(handler, hasOptimizerModel, hasEvalModel) {
          this.handler = handler;
          this.hasOptimizerModel = hasOptimizerModel;
          this.hasEvalModel = hasEvalModel;
        }
        get trainingInputNames() {
          return this.handler.inputNames;
        }
        get trainingOutputNames() {
          return this.handler.outputNames;
        }
        get evalInputNames() {
          if (this.hasEvalModel) {
            return this.handler.evalInputNames;
          } else {
            throw new Error("This training session has no evalModel loaded.");
          }
        }
        get evalOutputNames() {
          if (this.hasEvalModel) {
            return this.handler.evalOutputNames;
          } else {
            throw new Error("This training session has no evalModel loaded.");
          }
        }
        static async create(trainingOptions, sessionOptions) {
          const evalModel = trainingOptions.evalModel || "";
          const optimizerModel = trainingOptions.optimizerModel || "";
          const options = sessionOptions || {};
          const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          if (backend.createTrainingSessionHandler) {
            const handler = await backend.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
            return new _TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
          } else {
            throw new Error(noBackendErrMsg);
          }
        }
        /**
         * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
         * the given parameters to SessionHandler.FetchesType and RunOptions.
         *
         * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
         * names.
         * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
         * names.
         * @param feeds the required input
         * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
         * @param arg2 optional RunOptions object.
         * @returns
         */
        typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name of arg1) {
                if (typeof name !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (outputNames.indexOf(name) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                }
                fetches[name] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name of outputNames) {
                if (arg1Keys.indexOf(name) !== -1) {
                  const v = arg1[name];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name of inputNames) {
            if (typeof feeds[name] === "undefined") {
              throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name of outputNames) {
              fetches[name] = null;
            }
          }
          return [fetches, options];
        }
        /**
         * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
         * and changes it into a map of Tensors.
         *
         * @param results
         * @returns
         */
        convertHandlerReturnTypeToMapOfTensors(results) {
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          return returnValue;
        }
        async lazyResetGrad() {
          await this.handler.lazyResetGrad();
        }
        async runTrainStep(feeds, arg1, arg2) {
          const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
          const results = await this.handler.runTrainStep(feeds, fetches, options);
          return this.convertHandlerReturnTypeToMapOfTensors(results);
        }
        async runOptimizerStep(options) {
          if (this.hasOptimizerModel) {
            await this.handler.runOptimizerStep(options || {});
          } else {
            throw new Error("This TrainingSession has no OptimizerModel loaded.");
          }
        }
        async runEvalStep(feeds, arg1, arg2) {
          if (this.hasEvalModel) {
            const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
            const results = await this.handler.runEvalStep(feeds, fetches, options);
            return this.convertHandlerReturnTypeToMapOfTensors(results);
          } else {
            throw new Error("This TrainingSession has no EvalModel loaded.");
          }
        }
        async getParametersSize(trainableOnly = true) {
          return this.handler.getParametersSize(trainableOnly);
        }
        async loadParametersBuffer(array, trainableOnly = true) {
          const paramsSize = await this.getParametersSize(trainableOnly);
          if (array.length !== 4 * paramsSize) {
            throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
          }
          return this.handler.loadParametersBuffer(array, trainableOnly);
        }
        async getContiguousParameters(trainableOnly = true) {
          return this.handler.getContiguousParameters(trainableOnly);
        }
        async release() {
          return this.handler.dispose();
        }
      };
    }
  });

  // common/dist/esm/training-session.js
  var TrainingSession2;
  var init_training_session = __esm({
    "common/dist/esm/training-session.js"() {
      "use strict";
      init_training_session_impl();
      TrainingSession2 = TrainingSession;
    }
  });

  // common/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    TrainingSession: () => TrainingSession2,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  var init_esm = __esm({
    "common/dist/esm/index.js"() {
      "use strict";
      init_backend();
      init_env();
      init_inference_session();
      init_tensor();
      init_tensor_conversion();
      init_tensor_factory();
      init_trace();
      init_onnx_model();
      init_onnx_value();
      init_training_session();
    }
  });

  // web/lib/wasm/wasm-utils-env.ts
  var isNode;
  var init_wasm_utils_env = __esm({
    "web/lib/wasm/wasm-utils-env.ts"() {
      "use strict";
      isNode = false;
    }
  });

  // web/lib/wasm/proxy-worker/main.ts
  var main_exports = {};
  __export(main_exports, {
    default: () => main_default
  });
  var WORKER_NAME, isProxyWorker, main_default;
  var init_main = __esm({
    "web/lib/wasm/proxy-worker/main.ts"() {
      "use strict";
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      WORKER_NAME = "ort-wasm-proxy-worker";
      isProxyWorker = globalThis.self?.name === WORKER_NAME;
      if (isProxyWorker) {
        self.onmessage = (ev) => {
          const { type, in: message } = ev.data;
          try {
            switch (type) {
              case "init-wasm":
                initializeWebAssembly(message.wasm).then(
                  () => {
                    initRuntime(message).then(
                      () => {
                        postMessage({ type });
                      },
                      (err) => {
                        postMessage({ type, err });
                      }
                    );
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              case "init-ep": {
                const { epName, env: env3 } = message;
                initEp(env3, epName).then(
                  () => {
                    postMessage({ type });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "copy-from": {
                const { buffer } = message;
                const bufferData = copyFromExternalBuffer(buffer);
                postMessage({ type, out: bufferData });
                break;
              }
              case "create": {
                const { model, options } = message;
                createSession(model, options).then(
                  (sessionMetadata) => {
                    postMessage({ type, out: sessionMetadata });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "release":
                releaseSession(message);
                postMessage({ type });
                break;
              case "run": {
                const { sessionId, inputIndices, inputs, outputIndices, options } = message;
                run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                  (outputs) => {
                    if (outputs.some((o) => o[3] !== "cpu")) {
                      postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                    } else {
                      postMessage(
                        { type, out: outputs },
                        extractTransferableBuffers([...inputs, ...outputs])
                      );
                    }
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "end-profiling":
                endProfiling(message);
                postMessage({ type });
                break;
              default:
            }
          } catch (err) {
            postMessage({ type, err });
          }
        };
      }
      main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: false ? "module" : "classic", name: WORKER_NAME });
    }
  });

  // web/lib/wasm/wasm-utils-import.ts
  var scriptSrc, origin, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
  var init_wasm_utils_import = __esm({
    "web/lib/wasm/wasm-utils-import.ts"() {
      "use strict";
      init_wasm_utils_env();
      scriptSrc = // if Nodejs, return undefined
      isNode ? void 0 : (
        // use `document.currentScript.src` if available
        typeof document !== "undefined" ? document.currentScript?.src : (
          // use `self.location.href` if available
          typeof self !== "undefined" ? self.location?.href : void 0
        )
      );
      origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
      isSameOrigin = (filename, prefixOverride) => {
        try {
          const baseUrl = prefixOverride ?? scriptSrc;
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.origin === origin;
        } catch {
          return false;
        }
      };
      normalizeUrl = (filename, prefixOverride) => {
        const baseUrl = prefixOverride ?? scriptSrc;
        try {
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.href;
        } catch {
          return void 0;
        }
      };
      fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
      preload = async (absoluteUrl) => {
        const response = await fetch(absoluteUrl, { credentials: "same-origin" });
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      };
      dynamicImportDefault = async (url) => (await import(
        /* webpackIgnore: true */
        url
      )).default;
      createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
      importProxyWorker = async () => {
        if (!scriptSrc) {
          throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
        }
        if (isSameOrigin(scriptSrc)) {
          return [void 0, createProxyWorker()];
        }
        const url = await preload(scriptSrc);
        return [url, createProxyWorker(url)];
      };
      embeddedWasmModule = false ? (
        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
        (false ? null : true ? null : null).default
      ) : void 0;
      importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded) => {
        if (false) {
          return [void 0, embeddedWasmModule];
        } else {
          const wasmModuleFilename = false ? "ort-training-wasm-simd-threaded.mjs" : true ? "ort-wasm-simd-threaded.jsep.mjs" : "ort-wasm-simd-threaded.mjs";
          const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
          const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
          const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
          return [needPreload ? url : void 0, await dynamicImportDefault(url)];
        }
      };
    }
  });

  // web/lib/wasm/wasm-factory.ts
  var wasm, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, initializeWebAssembly, getInstance;
  var init_wasm_factory = __esm({
    "web/lib/wasm/wasm-factory.ts"() {
      "use strict";
      init_wasm_utils_import();
      initialized = false;
      initializing = false;
      aborted = false;
      isMultiThreadSupported = () => {
        if (typeof SharedArrayBuffer === "undefined") {
          return false;
        }
        try {
          if (typeof MessageChannel !== "undefined") {
            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
          }
          return WebAssembly.validate(new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            5,
            4,
            1,
            3,
            1,
            1,
            10,
            11,
            1,
            9,
            0,
            65,
            0,
            254,
            16,
            2,
            0,
            26,
            11
          ]));
        } catch (e) {
          return false;
        }
      };
      isSimdSupported = () => {
        try {
          return WebAssembly.validate(new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            10,
            30,
            1,
            28,
            0,
            65,
            0,
            253,
            15,
            253,
            12,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            253,
            186,
            1,
            26,
            11
          ]));
        } catch (e) {
          return false;
        }
      };
      initializeWebAssembly = async (flags) => {
        if (initialized) {
          return Promise.resolve();
        }
        if (initializing) {
          throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        }
        if (aborted) {
          throw new Error("previous call to 'initializeWebAssembly()' failed.");
        }
        initializing = true;
        const timeout = flags.initTimeout;
        let numThreads = flags.numThreads;
        if (!isSimdSupported()) {
          throw new Error("WebAssembly SIMD is not supported in the current environment.");
        }
        const multiThreadSupported = isMultiThreadSupported();
        if (numThreads > 1 && !multiThreadSupported) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            console.warn(
              "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
            );
          }
          console.warn(
            "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
          );
          flags.numThreads = numThreads = 1;
        }
        const wasmPaths = flags.wasmPaths;
        const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
        const mjsPathOverrideFlag = wasmPaths?.mjs;
        const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
        const wasmPathOverrideFlag = wasmPaths?.wasm;
        const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
        const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);
        let isTimeout = false;
        const tasks = [];
        if (timeout > 0) {
          tasks.push(new Promise((resolve) => {
            setTimeout(() => {
              isTimeout = true;
              resolve();
            }, timeout);
          }));
        }
        tasks.push(new Promise((resolve, reject) => {
          const config = {
            /**
             * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
             * created.
             */
            numThreads
          };
          if (wasmPathOverride || wasmPrefixOverride) {
            config.locateFile = (fileName, scriptDirectory) => wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName;
          }
          ortWasmFactory(config).then(
            // wasm module initialized successfully
            (module) => {
              initializing = false;
              initialized = true;
              wasm = module;
              resolve();
              if (objectUrl) {
                URL.revokeObjectURL(objectUrl);
              }
            },
            // wasm module failed to initialize
            (what) => {
              initializing = false;
              aborted = true;
              reject(what);
            }
          );
        }));
        await Promise.race(tasks);
        if (isTimeout) {
          throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
        }
      };
      getInstance = () => {
        if (initialized && wasm) {
          return wasm;
        }
        throw new Error("WebAssembly is not initialized yet.");
      };
    }
  });

  // web/lib/wasm/wasm-utils.ts
  var allocWasmString, iterateExtraOptions, checkLastError;
  var init_wasm_utils = __esm({
    "web/lib/wasm/wasm-utils.ts"() {
      "use strict";
      init_wasm_factory();
      allocWasmString = (data, allocs) => {
        const wasm2 = getInstance();
        const dataLength = wasm2.lengthBytesUTF8(data) + 1;
        const dataOffset = wasm2._malloc(dataLength);
        wasm2.stringToUTF8(data, dataOffset, dataLength);
        allocs.push(dataOffset);
        return dataOffset;
      };
      iterateExtraOptions = (options, prefix, seen, handler) => {
        if (typeof options == "object" && options !== null) {
          if (seen.has(options)) {
            throw new Error("Circular reference in options");
          } else {
            seen.add(options);
          }
        }
        Object.entries(options).forEach(([key, value]) => {
          const name = prefix ? prefix + key : key;
          if (typeof value === "object") {
            iterateExtraOptions(value, name + ".", seen, handler);
          } else if (typeof value === "string" || typeof value === "number") {
            handler(name, value.toString());
          } else if (typeof value === "boolean") {
            handler(name, value ? "1" : "0");
          } else {
            throw new Error(`Can't handle extra config type: ${typeof value}`);
          }
        });
      };
      checkLastError = (message) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        try {
          const paramsOffset = wasm2.stackAlloc(8);
          wasm2._OrtGetLastError(paramsOffset, paramsOffset + 4);
          const errorCode = wasm2.HEAP32[paramsOffset / 4];
          const errorMessagePointer = wasm2.HEAPU32[paramsOffset / 4 + 1];
          const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";
          throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
        } finally {
          wasm2.stackRestore(stack);
        }
      };
    }
  });

  // web/lib/wasm/run-options.ts
  var setRunOptions;
  var init_run_options = __esm({
    "web/lib/wasm/run-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      setRunOptions = (options) => {
        const wasm2 = getInstance();
        let runOptionsHandle = 0;
        const allocs = [];
        const runOptions = options || {};
        try {
          if (options?.logSeverityLevel === void 0) {
            runOptions.logSeverityLevel = 2;
          } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
          }
          if (options?.logVerbosityLevel === void 0) {
            runOptions.logVerbosityLevel = 0;
          } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
          }
          if (options?.terminate === void 0) {
            runOptions.terminate = false;
          }
          let tagDataOffset = 0;
          if (options?.tag !== void 0) {
            tagDataOffset = allocWasmString(options.tag, allocs);
          }
          runOptionsHandle = wasm2._OrtCreateRunOptions(
            runOptions.logSeverityLevel,
            runOptions.logVerbosityLevel,
            !!runOptions.terminate,
            tagDataOffset
          );
          if (runOptionsHandle === 0) {
            checkLastError("Can't create run options.");
          }
          if (options?.extra !== void 0) {
            iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
              }
            });
          }
          return [runOptionsHandle, allocs];
        } catch (e) {
          if (runOptionsHandle !== 0) {
            wasm2._OrtReleaseRunOptions(runOptionsHandle);
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/session-options.ts
  var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, setExecutionProviders, setSessionOptions;
  var init_session_options = __esm({
    "web/lib/wasm/session-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      getGraphOptimzationLevel = (graphOptimizationLevel) => {
        switch (graphOptimizationLevel) {
          case "disabled":
            return 0;
          case "basic":
            return 1;
          case "extended":
            return 2;
          case "all":
            return 99;
          default:
            throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
        }
      };
      getExecutionMode = (executionMode) => {
        switch (executionMode) {
          case "sequential":
            return 0;
          case "parallel":
            return 1;
          default:
            throw new Error(`unsupported execution mode: ${executionMode}`);
        }
      };
      appendDefaultOptions = (options) => {
        if (!options.extra) {
          options.extra = {};
        }
        if (!options.extra.session) {
          options.extra.session = {};
        }
        const session = options.extra.session;
        if (!session.use_ort_model_bytes_directly) {
          session.use_ort_model_bytes_directly = "1";
        }
        if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
          options.enableMemPattern = false;
        }
      };
      setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {
        for (const ep of executionProviders) {
          let epName = typeof ep === "string" ? ep : ep.name;
          switch (epName) {
            case "webnn":
              epName = "WEBNN";
              if (typeof ep !== "string") {
                const webnnOptions = ep;
                const deviceType = webnnOptions?.deviceType;
                if (deviceType) {
                  const keyDataOffset = allocWasmString("deviceType", allocs);
                  const valueDataOffset = allocWasmString(deviceType, allocs);
                  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);
                  }
                }
              }
              break;
            case "webgpu":
              epName = "JS";
              if (typeof ep !== "string") {
                const webgpuOptions = ep;
                if (webgpuOptions?.preferredLayout) {
                  if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                    throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                  }
                  const keyDataOffset = allocWasmString("preferredLayout", allocs);
                  const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);
                  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    checkLastError(
                      `Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`
                    );
                  }
                }
              }
              break;
            case "wasm":
            case "cpu":
              continue;
            default:
              throw new Error(`not supported execution provider: ${epName}`);
          }
          const epNameDataOffset = allocWasmString(epName, allocs);
          if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {
            checkLastError(`Can't append execution provider: ${epName}.`);
          }
        }
      };
      setSessionOptions = (options) => {
        const wasm2 = getInstance();
        let sessionOptionsHandle = 0;
        const allocs = [];
        const sessionOptions = options || {};
        appendDefaultOptions(sessionOptions);
        try {
          const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
          const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
          const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
          const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
          if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);
          }
          const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
          if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
            throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
          }
          const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
          sessionOptionsHandle = wasm2._OrtCreateSessionOptions(
            graphOptimizationLevel,
            !!sessionOptions.enableCpuMemArena,
            !!sessionOptions.enableMemPattern,
            executionMode,
            !!sessionOptions.enableProfiling,
            0,
            logIdDataOffset,
            logSeverityLevel,
            logVerbosityLevel,
            optimizedModelFilePathOffset
          );
          if (sessionOptionsHandle === 0) {
            checkLastError("Can't create session options.");
          }
          if (sessionOptions.executionProviders) {
            setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
          }
          if (sessionOptions.enableGraphCapture !== void 0) {
            if (typeof sessionOptions.enableGraphCapture !== "boolean") {
              throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
            }
            const keyDataOffset = allocWasmString("enableGraphCapture", allocs);
            const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);
            if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(
                `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`
              );
            }
          }
          if (sessionOptions.freeDimensionOverrides) {
            for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
              if (typeof name !== "string") {
                throw new Error(`free dimension override name must be a string: ${name}`);
              }
              if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
                throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
              }
              const nameOffset = allocWasmString(name, allocs);
              if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
                checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);
              }
            }
          }
          if (sessionOptions.extra !== void 0) {
            iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
              }
            });
          }
          return [sessionOptionsHandle, allocs];
        } catch (e) {
          if (sessionOptionsHandle !== 0) {
            wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/wasm-common.ts
  var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, getTensorElementSize, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, dataLocationStringToEnum;
  var init_wasm_common = __esm({
    "web/lib/wasm/wasm-common.ts"() {
      "use strict";
      tensorDataTypeStringToEnum = (type) => {
        switch (type) {
          case "int8":
            return 3 /* int8 */;
          case "uint8":
            return 2 /* uint8 */;
          case "bool":
            return 9 /* bool */;
          case "int16":
            return 5 /* int16 */;
          case "uint16":
            return 4 /* uint16 */;
          case "int32":
            return 6 /* int32 */;
          case "uint32":
            return 12 /* uint32 */;
          case "float16":
            return 10 /* float16 */;
          case "float32":
            return 1 /* float */;
          case "float64":
            return 11 /* double */;
          case "string":
            return 8 /* string */;
          case "int64":
            return 7 /* int64 */;
          case "uint64":
            return 13 /* uint64 */;
          default:
            throw new Error(`unsupported data type: ${type}`);
        }
      };
      tensorDataTypeEnumToString = (typeProto) => {
        switch (typeProto) {
          case 3 /* int8 */:
            return "int8";
          case 2 /* uint8 */:
            return "uint8";
          case 9 /* bool */:
            return "bool";
          case 5 /* int16 */:
            return "int16";
          case 4 /* uint16 */:
            return "uint16";
          case 6 /* int32 */:
            return "int32";
          case 12 /* uint32 */:
            return "uint32";
          case 10 /* float16 */:
            return "float16";
          case 1 /* float */:
            return "float32";
          case 11 /* double */:
            return "float64";
          case 8 /* string */:
            return "string";
          case 7 /* int64 */:
            return "int64";
          case 13 /* uint64 */:
            return "uint64";
          default:
            throw new Error(`unsupported data type: ${typeProto}`);
        }
      };
      getTensorElementSize = (dateType) => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][dateType];
      tensorTypeToTypedArrayConstructor = (type) => {
        switch (type) {
          case "float16":
            return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
          case "float32":
            return Float32Array;
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "uint16":
            return Uint16Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "bool":
            return Uint8Array;
          case "float64":
            return Float64Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "uint64":
            return BigUint64Array;
          default:
            throw new Error(`unsupported type: ${type}`);
        }
      };
      logLevelStringToEnum = (logLevel) => {
        switch (logLevel) {
          case "verbose":
            return 0;
          case "info":
            return 1;
          case "warning":
            return 2;
          case "error":
            return 3;
          case "fatal":
            return 4;
          default:
            throw new Error(`unsupported logging level: ${logLevel}`);
        }
      };
      isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool";
      dataLocationStringToEnum = (location2) => {
        switch (location2) {
          case "none":
            return 0;
          case "cpu":
            return 1;
          case "cpu-pinned":
            return 2;
          case "texture":
            return 3;
          case "gpu-buffer":
            return 4;
          default:
            throw new Error(`unsupported data location: ${location2}`);
        }
      };
    }
  });

  // web/lib/wasm/wasm-utils-load-file.ts
  var loadFile;
  var init_wasm_utils_load_file = __esm({
    "web/lib/wasm/wasm-utils-load-file.ts"() {
      "use strict";
      init_wasm_utils_env();
      loadFile = async (file) => {
        if (typeof file === "string") {
          if (isNode) {
            try {
              const { readFile } = __require("node:fs/promises");
              return new Uint8Array(await readFile(file));
            } catch (e) {
              if (e.code === "ERR_FS_FILE_TOO_LARGE") {
                const { createReadStream } = __require("node:fs");
                const stream = createReadStream(file);
                const chunks = [];
                for await (const chunk of stream) {
                  chunks.push(chunk);
                }
                return new Uint8Array(Buffer.concat(chunks));
              }
              throw e;
            }
          } else {
            const response = await fetch(file);
            if (!response.ok) {
              throw new Error(`failed to load external data file: ${file}`);
            }
            const contentLengthHeader = response.headers.get("Content-Length");
            const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
            if (fileSize < 1073741824) {
              return new Uint8Array(await response.arrayBuffer());
            } else {
              if (!response.body) {
                throw new Error(`failed to load external data file: ${file}, no response body.`);
              }
              const reader = response.body.getReader();
              let buffer;
              try {
                buffer = new ArrayBuffer(fileSize);
              } catch (e) {
                if (e instanceof RangeError) {
                  const pages = Math.ceil(fileSize / 65536);
                  buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
                } else {
                  throw e;
                }
              }
              let offset = 0;
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  break;
                }
                const chunkSize = value.byteLength;
                const chunk = new Uint8Array(buffer, offset, chunkSize);
                chunk.set(value);
                offset += chunkSize;
              }
              return new Uint8Array(buffer, 0, fileSize);
            }
          }
        } else if (file instanceof Blob) {
          return new Uint8Array(await file.arrayBuffer());
        } else if (file instanceof Uint8Array) {
          return file;
        } else {
          return new Uint8Array(file);
        }
      };
    }
  });

  // web/lib/wasm/jsep/log.ts
  var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;
  var init_log = __esm({
    "web/lib/wasm/jsep/log.ts"() {
      "use strict";
      init_wasm_common();
      logLevelPrefix = ["V", "I", "W", "E", "F"];
      doLog = (level, message) => {
        console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);
      };
      configureLogger = ($configLogLevel, $debug) => {
        configLogLevel = $configLogLevel;
        debug = $debug;
      };
      LOG = (logLevel, msg) => {
        const messageLevel = logLevelStringToEnum(logLevel);
        const configLevel = logLevelStringToEnum(configLogLevel);
        if (messageLevel >= configLevel) {
          doLog(messageLevel, typeof msg === "function" ? msg() : msg);
        }
      };
      LOG_DEBUG = (...args) => {
        if (debug) {
          LOG(...args);
        }
      };
    }
  });

  // web/lib/wasm/jsep/tensor-view.ts
  var createView;
  var init_tensor_view = __esm({
    "web/lib/wasm/jsep/tensor-view.ts"() {
      "use strict";
      init_wasm_common();
      createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);
    }
  });

  // web/lib/wasm/jsep/webgpu/types.ts
  var init_types = __esm({
    "web/lib/wasm/jsep/webgpu/types.ts"() {
      "use strict";
    }
  });

  // web/lib/wasm/jsep/webgpu/gpu-data-manager.ts
  var bucketFreelist, bucketArr, calcNormalizedBufferSize, calcBucketBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;
  var init_gpu_data_manager = __esm({
    "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {
      "use strict";
      init_log();
      init_types();
      bucketFreelist = /* @__PURE__ */ new Map([
        [64, 250],
        [128, 200],
        [256, 200],
        [512, 200],
        [2048, 230],
        [4096, 200],
        [8192, 50],
        [16384, 50],
        [32768, 50],
        [65536, 50],
        [131072, 50],
        [262144, 50],
        [524288, 50],
        [1048576, 50],
        [2097152, 30],
        [4194304, 20],
        [8388608, 10],
        [12582912, 10],
        [16777216, 10],
        [26214400, 15],
        [33554432, 22],
        [44236800, 2],
        [58982400, 6],
        // we don't want to cache the bucket sizes below but not caching them
        // results in some major performance hits for models like sd-turbo.
        [67108864, 6],
        [134217728, 6],
        [167772160, 6]
      ]);
      bucketArr = [];
      calcNormalizedBufferSize = (size) => Math.ceil(size / 16) * 16;
      calcBucketBufferSize = (size) => {
        for (let idx = 0; idx < bucketArr.length; idx++) {
          const sizeForBucket = bucketArr[idx];
          if (size <= sizeForBucket) {
            return sizeForBucket;
          }
        }
        return Math.ceil(size / 16) * 16;
      };
      guid = 1;
      createNewGpuDataId = () => guid++;
      downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {
        const bufferSize = calcNormalizedBufferSize(originalSize);
        const gpuReadBuffer = backend.device.createBuffer(
          // eslint-disable-next-line no-bitwise
          { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }
        );
        try {
          const commandEncoder = backend.getCommandEncoder();
          backend.endComputePass();
          commandEncoder.copyBufferToBuffer(
            gpuBuffer,
            0,
            gpuReadBuffer,
            0,
            bufferSize
            /* size */
          );
          backend.flush();
          await gpuReadBuffer.mapAsync(GPUMapMode.READ);
          const arrayBuffer = gpuReadBuffer.getMappedRange();
          if (getTargetBuffer) {
            const targetBuffer = getTargetBuffer();
            targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));
            return targetBuffer;
          } else {
            return new Uint8Array(arrayBuffer.slice(0, originalSize));
          }
        } finally {
          gpuReadBuffer.destroy();
        }
      };
      GpuDataManagerImpl = class {
        constructor(backend) {
          this.backend = backend;
          this.storageCache = /* @__PURE__ */ new Map();
          this.freeBuffers = /* @__PURE__ */ new Map();
          this.freeUniformBuffers = /* @__PURE__ */ new Map();
          this.buffersForUploadingPending = [];
          this.buffersPending = [];
          this.externalBuffers = /* @__PURE__ */ new Map();
          this.capturedPendingBuffers = /* @__PURE__ */ new Map();
          for (const [key] of bucketFreelist) {
            bucketArr.push(key);
            this.freeBuffers.set(key, []);
            this.freeUniformBuffers.set(key, []);
          }
        }
        upload(id, data) {
          const srcArrayBuffer = data.buffer;
          const srcOffset = data.byteOffset;
          const srcLength = data.byteLength;
          const size = calcNormalizedBufferSize(srcLength);
          const gpuDataCache = this.storageCache.get(id);
          if (!gpuDataCache) {
            throw new Error("gpu data for uploading does not exist");
          }
          if (gpuDataCache.originalSize !== srcLength) {
            throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);
          }
          const gpuBufferForUploading = this.backend.device.createBuffer(
            // eslint-disable-next-line no-bitwise
            { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }
          );
          const arrayBuffer = gpuBufferForUploading.getMappedRange();
          new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));
          gpuBufferForUploading.unmap();
          const commandEncoder = this.backend.getCommandEncoder();
          this.backend.endComputePass();
          commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);
          this.buffersForUploadingPending.push(gpuBufferForUploading);
        }
        memcpy(sourceId, destinationId) {
          const sourceGpuDataCache = this.storageCache.get(sourceId);
          if (!sourceGpuDataCache) {
            throw new Error("source gpu data for memcpy does not exist");
          }
          const destinationGpuDataCache = this.storageCache.get(destinationId);
          if (!destinationGpuDataCache) {
            throw new Error("destination gpu data for memcpy does not exist");
          }
          if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {
            throw new Error("inconsistent source and destination gpu data size");
          }
          const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);
          const commandEncoder = this.backend.getCommandEncoder();
          this.backend.endComputePass();
          commandEncoder.copyBufferToBuffer(
            sourceGpuDataCache.gpuData.buffer,
            0,
            destinationGpuDataCache.gpuData.buffer,
            0,
            size
          );
        }
        registerExternalBuffer(buffer, originalSize, previousBuffer) {
          let id;
          if (previousBuffer) {
            id = this.externalBuffers.get(previousBuffer);
            if (id === void 0) {
              throw new Error("previous buffer is not registered");
            }
            if (buffer === previousBuffer) {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`
              );
              return id;
            } else if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) {
              throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
            }
            this.externalBuffers.delete(previousBuffer);
          } else {
            id = createNewGpuDataId();
          }
          this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });
          this.externalBuffers.set(buffer, id);
          LOG_DEBUG(
            "verbose",
            () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`
          );
          return id;
        }
        unregisterExternalBuffer(buffer) {
          const id = this.externalBuffers.get(buffer);
          if (id !== void 0) {
            this.storageCache.delete(id);
            this.externalBuffers.delete(buffer);
            LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);
          }
        }
        // eslint-disable-next-line no-bitwise
        create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
          const bufferSize = calcBucketBufferSize(size);
          let gpuBuffer;
          const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;
          const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
          if (isStorage || isUniform) {
            const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;
            const buffers = freeBuffers.get(bufferSize);
            if (!buffers) {
              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
            } else {
              if (buffers.length > 0) {
                gpuBuffer = buffers.pop();
              } else {
                gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
              }
            }
          } else {
            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
          }
          const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };
          this.storageCache.set(gpuData.id, { gpuData, originalSize: size });
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);
          return gpuData;
        }
        get(id) {
          return this.storageCache.get(id)?.gpuData;
        }
        release(id) {
          const cachedData = this.storageCache.get(id);
          if (!cachedData) {
            throw new Error("releasing data does not exist");
          }
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);
          this.storageCache.delete(id);
          this.buffersPending.push(cachedData.gpuData.buffer);
          return cachedData.originalSize;
        }
        async download(id, getTargetBuffer) {
          const cachedData = this.storageCache.get(id);
          if (!cachedData) {
            throw new Error("data does not exist");
          }
          await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);
        }
        refreshPendingBuffers() {
          for (const buffer of this.buffersForUploadingPending) {
            buffer.destroy();
          }
          this.buffersForUploadingPending = [];
          if (this.buffersPending.length === 0) {
            return;
          }
          if (this.backend.sessionStatus === "default") {
            for (const buffer of this.buffersPending) {
              const maxInFreeList = bucketFreelist.get(buffer.size);
              if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
                const freelist = this.freeBuffers.get(buffer.size) || [];
                if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                  buffer.destroy();
                } else {
                  freelist.push(buffer);
                }
              } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
                const freelist = this.freeUniformBuffers.get(buffer.size) || [];
                if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                  buffer.destroy();
                } else {
                  freelist.push(buffer);
                }
              } else {
                buffer.destroy();
              }
            }
            this.buffersPending = [];
          } else {
            let capturedBuffers = this.capturedPendingBuffers.get(this.backend.currentSessionId);
            if (!capturedBuffers) {
              capturedBuffers = [];
              this.capturedPendingBuffers.set(this.backend.currentSessionId, capturedBuffers);
            }
            for (const buffer of this.buffersPending) {
              capturedBuffers.push(buffer);
            }
            this.buffersPending = [];
          }
        }
        dispose() {
          this.freeBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.freeUniformBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.storageCache.forEach((storage) => {
            storage.gpuData.buffer.destroy();
          });
          this.capturedPendingBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.storageCache = /* @__PURE__ */ new Map();
          this.freeBuffers = /* @__PURE__ */ new Map();
          this.freeUniformBuffers = /* @__PURE__ */ new Map();
          this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        }
        onReleaseSession(sessionId) {
          const pendingBuffers = this.capturedPendingBuffers.get(sessionId);
          if (pendingBuffers) {
            pendingBuffers.forEach((buffer) => {
              buffer.destroy();
            });
            this.capturedPendingBuffers.delete(sessionId);
          }
        }
      };
      createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);
    }
  });

  // web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts
  var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
  var init_attribute_with_cache_key = __esm({
    "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {
      "use strict";
      AttributeWithCacheKeyImpl = class {
        constructor(attribute) {
          Object.assign(this, attribute);
        }
        get cacheKey() {
          if (!this.key) {
            this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");
          }
          return this.key;
        }
      };
      createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
    }
  });

  // web/lib/wasm/jsep/util.ts
  var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;
  var init_util = __esm({
    "web/lib/wasm/jsep/util.ts"() {
      "use strict";
      MatMulUtil = class {
        /**
         * Calculate the expected shape when matrix multiplication
         * @param a The shape of tensor A. Should be a tuple of 2 positive integers
         * @param b The shape of tensor B. Should be a tuple of 2 positive integers
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcMatMulShape(a, b) {
          return a[1] !== b[0] ? void 0 : [a[0], b[1]];
        }
      };
      BroadcastUtil = class {
        /**
         * Calculate the expected shape when broadcasting 2 tensors
         * @param a The shape of tensor A. Should be an array of positive integers
         * @param b The shape of tensor B. Should be an array of positive integers
         * @param isMatMul Whether the operation is MatMul
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcShape(adims, bdims, isMatMul = false) {
          const arank = adims.length;
          const brank = bdims.length;
          if (arank === 0) {
            return bdims;
          }
          if (brank === 0) {
            return adims;
          }
          const crank = Math.max(adims.length, bdims.length);
          const cdims = new Array(crank);
          if (isMatMul) {
            if (arank < 2 || brank < 2) {
              return void 0;
            }
            const cShapeMatMul = MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);
            if (cShapeMatMul === void 0) {
              return void 0;
            }
            [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
          }
          for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
            const aLen = arank - i < 0 ? 1 : adims[arank - i];
            const bLen = brank - i < 0 ? 1 : bdims[brank - i];
            if (aLen !== bLen && aLen > 1 && bLen > 1) {
              return void 0;
            }
            const max = Math.max(aLen, bLen);
            if (aLen && bLen) {
              cdims[crank - i] = Math.max(aLen, bLen);
            } else {
              if (max > 1) {
                return void 0;
              }
              cdims[crank - i] = 0;
            }
          }
          return cdims;
        }
        /**
         * Determine if a shape is unidirectional broadcastable to another shape
         * @param shape The input shape
         * @param finalShape The desired shape after broadcasting
         */
        static isValidBroadcast(shape, finalShape) {
          const inputRank = shape.length;
          const finalRank = finalShape.length;
          if (inputRank > finalRank) {
            return false;
          }
          for (let i = 1; i <= inputRank; i++) {
            if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
              return false;
            }
          }
          return true;
        }
      };
      ShapeUtil = class _ShapeUtil {
        /**
         * calculate the size (number of elements)
         */
        static size(dims) {
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
        }
        /**
         * convert dims corresponding to type change to pack. ex. uint8 data to uint32
         */
        static convertShape(dims, size = 4) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          }
          const newDims = new Array(rank);
          let i = rank - 1;
          while (i >= 0) {
            if (dims[i] % size === 0) {
              newDims[i] = dims[i] / size;
              break;
            }
            if (size % dims[i] !== 0) {
              throw new Error("cannot convert shape");
            }
            newDims[i] = 1;
            size /= dims[i];
            i--;
          }
          for (i--; i >= 0; i--) {
            newDims[i] = dims[i];
          }
          return newDims;
        }
        /**
         * calculate the size (number of elements) from the given axis (inclusive)
         */
        static sizeFromDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
        }
        /**
         * calculate the size (number of elements) to the given axis (exclusive)
         */
        static sizeToDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
        }
        /**
         * calculate the size (number of elements) from and to the given axis [start, end)
         */
        static getSizeFromDimensionRange(dims, start, end) {
          let size = 1;
          for (let i = start; i < end; i++) {
            if (dims[i] < 0) {
              throw new Error(
                // eslint-disable-next-line max-len
                "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
              );
            }
            size *= dims[i];
          }
          return size;
        }
        static computeStrides(dims) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [1];
          }
          const strides = new Array(rank);
          strides[rank - 1] = 1;
          strides[rank - 2] = dims[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * dims[i + 1];
          }
          return strides;
        }
        /**
         * normailze axis of range [-r, r) into [0, r).
         */
        static normalizeAxis(axis, tensorRank) {
          if (axis < -tensorRank && axis >= tensorRank) {
            throw new Error("unsupported axis for this operation.");
          }
          return axis < 0 ? axis + tensorRank : axis;
        }
        static normalizeAxes(axes, tensorRank) {
          return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));
        }
        /**
         * Sorts a given array based on the indices in the Perm array
         * Used in Transpose
         * @param a Array to be sorted such as dims or strides
         * @param perm Perm given; if null a will be reversed
         */
        static sortBasedOnPerm(a, perm) {
          if (perm) {
            return perm.map((v) => a[v]);
          } else {
            return a.slice().reverse();
          }
        }
        /**
         * Pads a given shape according to the padding values
         * @param dims shape of the Tensor to be padded
         * @param pad pad values
         */
        static padShape(dims, pad2) {
          const rank = dims.length;
          return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);
        }
        /**
         * Determines if the two shapes are identical
         * @param shape1
         * @param shape2
         */
        static areEqual(shape1, shape2) {
          if (shape1.length !== shape2.length) {
            return false;
          }
          return shape1.every((v, i) => v === shape2[i]);
        }
      };
      PoolConvUtil = class _PoolConvUtil {
        /**
         * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension.
         * @param kernelShape The size of the kernel along each axis.
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         */
        static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
          if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
          }
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              if (dim >= kernelShape.length) {
                kernelShape.push(inputDims[dim + 2]);
              } else {
                kernelShape[dim] = inputDims[dim + 2];
              }
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < strides.length) {
              if (strides[dim] < 0) {
                throw new Error("strides should be greater than or equal to 1");
              }
            } else {
              strides.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < dilations.length) {
              if (dilations[dim] < 0) {
                throw new Error("dilations should be greater than or equal to 1");
              }
            } else {
              dilations.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length * 2; dim++) {
            if (dim < pads.length) {
              if (pads[dim] < 0) {
                throw new Error("pad should be greater than or equal to 1");
              }
            } else {
              pads.push(0);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (kernelShape[dim] <= 0) {
              throw new Error("kernel shapes need to be greater than 0");
            }
            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
              throw new Error("pads should be smaller than kernel");
            }
          }
        }
        // adjust pad values based on 'autoPad' attribute
        static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {
          if (!autoPad) {
            return;
          }
          if (pads.length !== 2 * (inputDims.length - 2)) {
            throw new Error("length of pads should be twice the length of data dimensions");
          }
          if (strides.length !== inputDims.length - 2) {
            throw new Error("length of strides should be the length of data dimensions");
          }
          if (kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of kernel shapes should be the length of data dimensions");
          }
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            _PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + (isChannelLast ? 1 : 2)],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            );
          }
        }
        /**
         * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0) {
            throw new Error("input shape must be of size greater than 0");
          }
          const outputDims = [inputDims[0], inputDims[1]];
          _PoolConvUtil.computeShapeHelper(
            isGlobalOperator,
            inputDims,
            outputDims,
            strides,
            dilations,
            kernelShape,
            pads,
            autoPad
          );
          return outputDims;
        }
        /**
         * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param filterDims The filter tensor dimension. (inputs[1].dims)
         * @param strides Stride along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0 || filterDims.length <= 0) {
            throw new Error("invalid input tensor dims or invalid filter tensor dims");
          }
          const outputDims = [inputDims[0], filterDims[0]];
          _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
          return outputDims;
        }
        // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
        // called by computePoolOutputShape() and computeConvOutputShape()
        // adjust pads based on 'autoPad' attribute prior to shape computation
        static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(1);
            }
          } else {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(_PoolConvUtil.adjustPadAndReturnShape(
                inputDims[dim + 2],
                strides[dim],
                dilations[dim],
                kernelShape[dim],
                pads,
                dim,
                dim + inputDims.length - 2,
                autoPad
              ));
            }
          }
        }
        // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
        // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
        static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
          const dkernel = dilation * (kernel - 1) + 1;
          if (autoPad && autoPad !== "NOTSET") {
            switch (autoPad) {
              case "VALID":
                pads[padHeadIndex] = 0;
                pads[padTailIndex] = 0;
                return Math.floor((inSize - dkernel) / stride + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (dilation !== 1) {
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                } else {
                  const legacyTargetSize = (inSize + stride - 1) / stride;
                  const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                  pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                  pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                  return Math.floor((inSize + padNeeded - kernel) / stride + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          } else {
            return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
          }
        }
      };
      GemmUtil = class {
        // will make sure input shapes are compatible for this op
        // and return back the shape of the output in the form of a tuple
        // will throw exception if the input shapes are not compatible
        static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
          if (leftShape.length !== 2 || rightShape.length !== 2) {
            throw new Error("shape need to be of size 2");
          }
          let M;
          let K;
          let N;
          if (transLeft) {
            M = leftShape[1];
            K = leftShape[0];
          } else {
            M = leftShape[0];
            K = leftShape[1];
          }
          let kDim = -1;
          if (transRight) {
            N = rightShape[0];
            kDim = 1;
          } else {
            N = rightShape[1];
            kDim = 0;
          }
          if (rightShape[kDim] !== K) {
            throw new Error("dimension mismatch");
          }
          if (M <= 0 || N <= 0 || K <= 0) {
            throw new Error("invalid shape specified");
          }
          if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
            throw new Error("gemm: invalid bias shape for broadcast");
          }
          return [M, N, K];
        }
      };
      MIN_CLIP = -34028234663852886e22;
      MAX_CLIP = 34028234663852886e22;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/common.ts
  var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, internalVariable, ShaderHelperImpl, createShaderHelper, getBroadcastDims;
  var init_common = __esm({
    "web/lib/wasm/jsep/webgpu/ops/common.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      WORKGROUP_SIZE = 64;
      getWgslMappedType = (type, components) => {
        if (components === 3) {
          throw new Error("vec3 has same alignment as vec4, use vec4 instead");
        }
        switch (type) {
          case 10 /* float16 */:
            return components > 1 ? `vec${components}<f16>` : "f16";
          case 1 /* float */:
            return components > 1 ? `vec${components}<f32>` : "f32";
          case 6 /* int32 */:
            return components > 1 ? `vec${components}<i32>` : "i32";
          case 12 /* uint32 */:
            return components > 1 ? `vec${components}<u32>` : "u32";
          case 7 /* int64 */:
            if (components > 1) {
              throw new Error("currently not supported vecX of uint64 yet");
            }
            return ["vec2<u32>", "i32"];
          case 13 /* uint64 */:
            if (components > 1) {
              throw new Error("currently not supported vecX of uint64 yet");
            }
            return ["vec2<u32>", "u32"];
          case 9 /* bool */:
            if (components !== 4) {
              throw new Error("bool must be vec4");
            }
            return ["u32", "vec4<bool>"];
          default:
            throw new Error(`Unknown data type: ${type}`);
        }
      };
      tensorTypeToWsglStorageType = (type, components = 1) => {
        const mappedType = getWgslMappedType(type, components);
        return typeof mappedType === "string" ? mappedType : mappedType[0];
      };
      tensorTypeToWsglValueType = (type, components = 1) => {
        const mappedType = getWgslMappedType(type, components);
        return typeof mappedType === "string" ? mappedType : mappedType[1];
      };
      createTensorShapeVariables = (...dims) => {
        const programUniforms = [];
        dims.forEach((dim) => {
          if (dim.length !== 0) {
            programUniforms.push(
              { type: 12 /* uint32 */, data: dim },
              { type: 12 /* uint32 */, data: ShapeUtil.computeStrides(dim) }
            );
          }
        });
        return programUniforms;
      };
      getMaxComponents = (size) => {
        if (size % 4 === 0) {
          return 4;
        } else if (size % 2 === 0) {
          return 2;
        }
        return 1;
      };
      fillVector = (dataType = "f32", components, value = "0") => {
        if (!components || components === 1) {
          return `${dataType}(${value})`;
        }
        return `vec${components}<${dataType}>(${value})`;
      };
      castToF32 = (dataType, components, value) => {
        if (dataType === "f32") {
          return value;
        }
        if (components === 1) {
          return `f32(${value})`;
        }
        return `vec${components}<f32>(${value})`;
      };
      sumVector = (name, components) => {
        if (components === 4) {
          return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;
        } else if (components === 2) {
          return `(${name}.x + ${name}.y)`;
        } else if (components === 3) {
          return `(${name}.x + ${name}.y + ${name}.z)`;
        }
        return name;
      };
      getElementAt = (name, index, length, type) => {
        if (name.startsWith("uniforms.") && length > 4) {
          if (typeof index === "string") {
            if (type === "f16") {
              return `${name}[(${index}) / 8][(${index}) % 8 / 4][(${index}) % 8 % 4]`;
            } else {
              return `${name}[(${index}) / 4][(${index}) % 4]`;
            }
          } else {
            if (type === "f16") {
              return `${name}[${Math.floor(index / 8)}][${Math.floor(index % 8 / 4)}][${index % 8 % 4}]`;
            } else {
              return `${name}[${Math.floor(index / 4)}][${index % 4}]`;
            }
          }
        } else {
          return length > 1 ? `${name}[${index}]` : name;
        }
      };
      createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {
        const useUniform = typeof shapeOrRank === "number";
        const rank = useUniform ? shapeOrRank : shapeOrRank.length;
        const rankIdentity = [...new Array(rank).keys()];
        const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;
        const mappedType = getWgslMappedType(tensorType, components);
        const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];
        const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];
        const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };
        const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;
        const implementationUsed = {
          offsetToIndices: false,
          indicesToOffset: false,
          broadcastedIndicesToOffset: false,
          set: false,
          setByIndices: false,
          get: false,
          getByIndices: false
        };
        const uniformPrefix = useUniform ? "uniforms." : "";
        const shape = `${uniformPrefix}${name}_shape`;
        const strides = `${uniformPrefix}${name}_strides`;
        let o2iSnippet = "";
        for (let i = 0; i < rank - 1; i++) {
          o2iSnippet += `
    let dim${i} = current / ${getElementAt(strides, i, rank)};
    let rest${i} = current % ${getElementAt(strides, i, rank)};
    indices[${i}] = dim${i};
    current = rest${i};
    `;
        }
        o2iSnippet += `indices[${rank - 1}] = current;`;
        const offsetToIndicesImplementation = rank < 2 ? "" : `
  fn o2i_${name}(offset: u32) -> ${type.indices} {
    var indices: ${type.indices};
    var current = offset;
    ${o2iSnippet}
    return indices;
  }`;
        const offsetToIndices = (varOffset) => {
          implementationUsed.offsetToIndices = true;
          return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;
        };
        const offsets = [];
        if (rank >= 2) {
          for (let i = rank - 1; i >= 0; i--) {
            offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);
          }
        }
        const indicesToOffsetImplementation = rank < 2 ? "" : `
  fn i2o_${name}(indices: ${type.indices}) -> u32 {
    return ${offsets.join("+")};
  }`;
        const indicesToOffset = (varIndices) => {
          implementationUsed.indicesToOffset = true;
          return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;
        };
        const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;
        const indicesGet = (varIndices, idx) => {
          if (rank < 2) {
            return `${varIndices}`;
          } else {
            return `${getElementAt(varIndices, idx, rank)}`;
          }
        };
        const indicesSet = (varIndices, idx, value) => {
          if (rank < 2) {
            return `${varIndices}=${value};`;
          } else {
            return `${getElementAt(varIndices, idx, rank)}=${value};`;
          }
        };
        const broadcastedIndicesToOffsetImplementation = {};
        const broadcastedIndicesToOffset = (varIndices, output) => {
          implementationUsed.broadcastedIndicesToOffset = true;
          const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;
          if (implKey in broadcastedIndicesToOffsetImplementation) {
            return `${implKey}(${varIndices})`;
          }
          const offsets2 = [];
          for (let i = rank - 1; i >= 0; i--) {
            const idx = output.indicesGet("outputIndices", i + output.rank - rank);
            offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);
          }
          broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {
             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};
           }`;
          return `${implKey}(${varIndices})`;
        };
        const setByOffset = (offset, value) => (() => {
          if (type.storage === type.value) {
            return `${name}[${offset}]=${value};`;
          } else if (type.storage === "vec2<u32>" && type.value === "i32") {
            return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;
          } else if (type.storage === "vec2<u32>" && type.value === "u32") {
            return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;
          } else if (type.storage === "u32" && type.value === "vec4<bool>") {
            return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;
          } else {
            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
          }
        })();
        const getByOffset = (offset) => (() => {
          if (type.storage === type.value) {
            return `${name}[${offset}]`;
          } else if (type.storage === "vec2<u32>" && type.value === "i32") {
            return `i32(${name}[${offset}].x)`;
          } else if (type.storage === "vec2<u32>" && type.value === "u32") {
            return `u32(${name}[${offset}].x)`;
          } else if (type.storage === "u32" && type.value === "vec4<bool>") {
            return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;
          } else {
            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
          }
        })();
        const getByIndicesImplementation = rank < 2 ? "" : `
  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {
    return ${getByOffset(`i2o_${name}(indices)`)};
  }`;
        const getImplementation = rank < 2 ? "" : (() => {
          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
          return `
  fn get_${name}(${functionParams}) -> ${valueType} {
    return get_${name}ByIndices(${indices(dimsParams)});
  }`;
        })();
        const get = (...indices2) => {
          if (indices2.length !== rank) {
            throw new Error(`indices length must be ${rank}`);
          }
          const normalizedIndices = indices2.map(normalizeDim).join(",");
          if (rank === 0) {
            return getByOffset("0u");
          } else if (rank === 1) {
            return getByOffset(normalizedIndices[0]);
          } else {
            implementationUsed.get = true;
            implementationUsed.getByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `get_${name}(${normalizedIndices})`;
          }
        };
        const getByIndices = (varIndices) => {
          if (rank < 2) {
            return getByOffset(varIndices);
          } else {
            implementationUsed.getByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `get_${name}ByIndices(${varIndices})`;
          }
        };
        const setByIndicesImplementation = rank < 2 ? "" : `
  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {
    ${setByOffset(`i2o_${name}(indices)`, "value")}
  }`;
        const setImplementation = rank < 2 ? "" : (() => {
          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
          return `
  fn set_${name}(${functionParams}, value: ${valueType}) {
    set_${name}ByIndices(${indices(dimsParams)}, value);
  }`;
        })();
        const set = (...indicesAndValue) => {
          if (indicesAndValue.length !== rank + 1) {
            throw new Error(`indices length must be ${rank}`);
          }
          const value = indicesAndValue[rank];
          if (typeof value !== "string") {
            throw new Error("value must be string");
          }
          const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");
          if (rank === 0) {
            return setByOffset("0u", value);
          } else if (rank === 1) {
            return setByOffset(normalizedIndices[0], value);
          } else {
            implementationUsed.set = true;
            implementationUsed.setByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `set_${name}(${normalizedIndices}, ${value})`;
          }
        };
        const setByIndices = (varIndices, value) => {
          if (rank < 2) {
            return setByOffset(varIndices, value);
          } else {
            implementationUsed.setByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `set_${name}ByIndices(${varIndices}, ${value});`;
          }
        };
        const impl = () => {
          const impls = [];
          let needShapeStrides = false;
          if (implementationUsed.offsetToIndices) {
            impls.push(offsetToIndicesImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.indicesToOffset) {
            impls.push(indicesToOffsetImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.broadcastedIndicesToOffset) {
            Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));
            needShapeStrides = true;
          }
          if (implementationUsed.set) {
            impls.push(setImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.setByIndices) {
            impls.push(setByIndicesImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.get) {
            impls.push(getImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.getByIndices) {
            impls.push(getByIndicesImplementation);
            needShapeStrides = true;
          }
          if (!useUniform && needShapeStrides) {
            impls.unshift(
              `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,
              `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`
            );
          }
          return impls.join("\n");
        };
        return {
          impl,
          type,
          offsetToIndices,
          indicesToOffset,
          broadcastedIndicesToOffset,
          indices,
          indicesGet,
          indicesSet,
          set,
          setByOffset,
          setByIndices,
          get,
          getByOffset,
          getByIndices,
          // isVec4,
          usage,
          name,
          strides,
          shape,
          rank
        };
      };
      inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);
      outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);
      internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);
      ShaderHelperImpl = class {
        constructor(normalizedDispatchGroup, limits) {
          this.normalizedDispatchGroup = normalizedDispatchGroup;
          this.limits = limits;
          this.internalVariables = [];
          this.variables = [];
          this.uniforms = [];
          this.variableIndex = 0;
        }
        guardAgainstOutOfBoundsWorkgroupSizes(size) {
          const sizeInCode = typeof size === "number" ? `${size}u` : size;
          return `if (global_idx >= ${sizeInCode}) { return; }`;
        }
        mainStart(workgroupSize = WORKGROUP_SIZE) {
          const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];
          const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];
          const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];
          if (workgroupSizeX > this.limits.maxComputeWorkgroupSizeX || workgroupSizeY > this.limits.maxComputeWorkgroupSizeY || workgroupSizeZ > this.limits.maxComputeWorkgroupSizeZ) {
            throw new Error(`workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);
          }
          if (workgroupSizeX * workgroupSizeY * workgroupSizeZ > this.limits.maxComputeInvocationsPerWorkgroup) {
            throw new Error(`workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);
          }
          const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
          const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`;
          const globalIdxDefinition = is1DimensionDispatch ? "let global_idx = global_id.x; let local_idx = local_id.x;" : `let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;
          return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})
  fn main(${paramList}) {
    ${globalIdxDefinition}
  `;
        }
        appendVariableUniforms(variable) {
          if (variable.rank !== 0) {
            if (variable.shape.startsWith("uniforms.")) {
              this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });
            }
            if (variable.strides.startsWith("uniforms.")) {
              this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });
            }
          }
        }
        declareVariable(variable, bindingIndex) {
          if (variable.usage === "internal") {
            throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
          }
          this.variables.push(variable);
          this.appendVariableUniforms(variable);
          const access = variable.usage === "input" ? "read" : "read_write";
          const storageType = variable.type.storage;
          return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;
        }
        declareVariables(...variables) {
          return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\n");
        }
        registerInternalVariable(variable) {
          if (variable.usage !== "internal") {
            throw new Error(
              "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
            );
          }
          this.internalVariables.push(variable);
          this.appendVariableUniforms(variable);
        }
        registerInternalVariables(...variables) {
          variables.forEach((v) => this.registerInternalVariable(v));
          return this;
        }
        registerUniform(name, type, length = 1) {
          this.uniforms.push({ name, type, length });
          return this;
        }
        registerUniforms(additionalUniforms) {
          this.uniforms = this.uniforms.concat(additionalUniforms);
          return this;
        }
        uniformDeclaration() {
          if (this.uniforms.length === 0) {
            return "";
          }
          const uniformSnippets = [];
          for (const { name, type, length } of this.uniforms) {
            if (length && length > 4) {
              if (type === "f16") {
                uniformSnippets.push(`@align(16) ${name}:array<mat2x4<${type}>, ${Math.ceil(length / 8)}>`);
              } else {
                uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);
              }
            } else {
              const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;
              uniformSnippets.push(`${name}:${typeTemp}`);
            }
          }
          return `
      struct Uniforms { ${uniformSnippets.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
        }
        /**
         * Get additional implementation that needs to be added to the shader source.
         */
        get additionalImplementations() {
          return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\n") + this.internalVariables.map((i) => i.impl()).join("\n");
        }
        /**
         * Get the variable info of the shader program.
         */
        get variablesInfo() {
          if (this.uniforms.length === 0) {
            return void 0;
          }
          const uniformWgslTypeToDataType = (type) => [
            12 /* uint32 */,
            10 /* float16 */,
            1 /* float */,
            6 /* int32 */
          ][["u32", "f16", "f32", "i32"].indexOf(type)];
          return this.uniforms.map((u) => [uniformWgslTypeToDataType(u.type), u.length ?? 1]);
        }
      };
      createShaderHelper = (dispatchGroup, limits) => new ShaderHelperImpl(dispatchGroup, limits);
      getBroadcastDims = (inShape, outShape) => {
        const inRank = inShape.length;
        const dims = [];
        for (let i = 0; i < inRank; i++) {
          const dim = inRank - 1 - i;
          const a = inShape[dim] || 1;
          const b = outShape[outShape.length - 1 - i] || 1;
          if (b > 1 && a === 1) {
            dims.unshift(dim);
          }
        }
        return dims;
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/transpose.ts
  var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, createTransposeProgramInfo, transpose, parseTransposeAttributes;
  var init_transpose = __esm({
    "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Transpose requires 1 input.");
        }
      };
      getAdjustedPerm = (inputRank, perm) => perm && perm.length !== inputRank ? [...new Array(inputRank).keys()].reverse() : perm;
      getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));
      permFunctionBody = (perm, rank, input, output) => {
        const reverseFunc = [];
        reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
        for (let i = 0; i < rank; ++i) {
          reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
        }
        reverseFunc.push("return a;}");
        return reverseFunc.join("\n");
      };
      createTransposeProgramInfo = (inputTensor, permAttr) => {
        const inputDataType = inputTensor.dataType;
        const inputRank = inputTensor.dims.length;
        const perm = getAdjustedPerm(inputRank, permAttr);
        const outputShape = getOutputShape(inputTensor.dims, perm);
        const output = outputVariable("output", inputDataType, outputShape.length);
        const input = inputVariable("a", inputDataType, inputRank);
        let getShaderSource;
        if (perm.length === 2 && perm[0] === 1 && perm[1] === 0) {
          const wgslType = output.type.value;
          const workgroupSize = [16, 16, 1];
          getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  var<workgroup> tile : array<array<${wgslType}, ${workgroupSize[0] + 1}>, ${workgroupSize[0]}>;
  ${shaderHelper.mainStart(workgroupSize)}
    var x = workgroup_id.x * ${workgroupSize[0]}u + local_id.x;
    var y = workgroup_id.y * ${workgroupSize[0]}u + local_id.y;
    let width = uniforms.output_shape[0];
    let height = uniforms.output_shape[1];
    if (x < width && y < height) {
      tile[local_id.y][local_id.x] = ${input.getByOffset("y * width + x")};
    }
    workgroupBarrier();
    x = workgroup_id.y * ${workgroupSize[0]}u + local_id.x;
    y = workgroup_id.x * ${workgroupSize[0]}u + local_id.y;
    if (x < height && y < width) {
      ${output.setByOffset("y * height + x", "tile[local_id.x][local_id.y]")}
    }
  }`;
        } else {
          getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

  ${permFunctionBody(perm, inputRank, input, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${output.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}
  }`;
        }
        return {
          name: "Transpose",
          shaderCache: { hint: `${permAttr}`, inputDependencies: ["rank"] },
          getRunData: (inputs) => {
            const outputSize = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(inputs[0].dims, outputShape)]
            };
          },
          getShaderSource
        };
      };
      transpose = (context, attributes) => {
        validateInputs(context.inputs);
        context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));
      };
      parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts
  var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;
  var init_reduce_shared = __esm({
    "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_reduce();
      init_transpose();
      reduceOps = {
        max: "select(bestValue, candidate, candidate > bestValue)",
        min: "select(bestValue, candidate, candidate < bestValue)",
        mean: "bestValue + candidate",
        sum: "bestValue + candidate",
        prod: "bestValue * candidate",
        sumSquare: "bestValue + candidate * candidate",
        logSumExp: "bestValue + exp(candidate)",
        l1: "bestValue + abs(candidate)",
        l2: "bestValue + candidate * candidate",
        logSum: "bestValue + candidate"
      };
      reduceSharedOps = {
        max: "select(bestValue, candidate, candidate > bestValue)",
        min: "select(bestValue, candidate, candidate < bestValue)",
        mean: "bestValue + candidate",
        sum: "bestValue + candidate",
        prod: "bestValue * candidate",
        sumSquare: "bestValue + candidate",
        logSumExp: "bestValue + candidate",
        l1: "bestValue + candidate",
        l2: "bestValue + candidate",
        logSum: "bestValue + candidate"
      };
      reduceInitValues = {
        max: "_A[offset]",
        min: "_A[offset]",
        mean: "0",
        sum: "0",
        prod: "1",
        sumSquare: "0",
        logSumExp: "0",
        l1: "0",
        l2: "0",
        logSum: "0"
      };
      reduceOutputValues = {
        max: "bestValue",
        min: "bestValue",
        sum: "bestValue",
        prod: "bestValue",
        sumSquare: "bestValue",
        logSumExp: "log(bestValue)",
        l1: "bestValue",
        l2: "sqrt(bestValue)",
        logSum: "log(bestValue)"
      };
      getInnerMostAxes = (numInnerAxes, rank) => {
        const res = [];
        for (let i = rank - numInnerAxes; i < rank; ++i) {
          res.push(i);
        }
        return res;
      };
      computeOutAndReduceShapes = (shape, axes) => {
        const outputShape = [];
        const rank = shape.length;
        for (let dim = 0; dim < rank; dim++) {
          if (axes.indexOf(dim) === -1) {
            outputShape.push(shape[dim]);
          }
        }
        const reduceShape = axes.map((dim) => shape[dim]);
        return [outputShape, reduceShape];
      };
      expandShapeToKeepDim = (shape, axes) => {
        const rank = shape.length + axes.length;
        const expandShape = [];
        let shapeIdx = 0;
        for (let dim = 0; dim < rank; dim++) {
          if (axes.indexOf(dim) === -1) {
            expandShape.push(shape[shapeIdx++]);
          } else {
            expandShape.push(1);
          }
        }
        return expandShape;
      };
      areAxesInnerMostDims = (axes, rank) => {
        for (let i = 0; i < axes.length; ++i) {
          if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
          }
        }
        return true;
      };
      getAxesPermutation = (axes, rank) => {
        const res = [];
        if (!areAxesInnerMostDims(axes, rank)) {
          for (let i = 0; i < rank; ++i) {
            if (axes.indexOf(i) === -1) {
              res.push(i);
            }
          }
          axes.forEach((axis) => res.push(axis));
        }
        return res;
      };
      createReduceSharedProgramInfo = (name, shaderCache, inputs, reduceType, outputDataType, outputShape, reduceShape) => {
        const inputShape = inputs[0].dims;
        const outputSize = ShapeUtil.size(outputShape);
        const reduceSize = ShapeUtil.size(reduceShape);
        const input = inputVariable("_A", inputs[0].dataType, inputShape);
        const output = outputVariable("output", outputDataType, outputShape);
        const workgroupSize = 32;
        const sharedMemorySnippet = `
          var<workgroup> aBestValues : array<f32, ${workgroupSize}>;
       `;
        const getShaderSource = (shaderHelper) => `
        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}
        ${sharedMemorySnippet}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${shaderHelper.mainStart(workgroupSize)}

          let outputIndex = global_idx / ${workgroupSize};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${reduceInitValues[reduceType]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {
           let candidate = f32(${input.getByOffset("offset + k")});
           bestValue = ${reduceOps[reduceType]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${workgroupSize}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${reduceSharedOps[reduceType]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${output.setByOffset(
          "outputIndex",
          `${reduceType === "mean" ? `${output.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${output.type.storage}(${reduceOutputValues[reduceType]})`}`
        )};
         }
        }`;
        return {
          name,
          shaderCache,
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: outputSize },
            programUniforms: [{ type: 12 /* uint32 */, data: reduceSize }]
          })
        };
      };
      reduceCommon = (context, name, attributes, reduceType) => {
        const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);
        let updatedAxes = updatedAttributes.axes;
        if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {
          updatedAxes = context.inputs[0].dims.map((_dim, i) => i);
        }
        const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);
        let axes = normalizeAxes;
        let input = context.inputs[0];
        const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);
        if (permutedAxes.length > 0) {
          input = context.compute(
            createTransposeProgramInfo(context.inputs[0], permutedAxes),
            { inputs: [0], outputs: [-1] }
          )[0];
          axes = getInnerMostAxes(axes.length, input.dims.length);
        }
        const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);
        let finalOutputShape = outputShape;
        if (updatedAttributes.keepDims) {
          finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);
        }
        context.compute(
          createReduceSharedProgramInfo(
            name,
            { hint: updatedAttributes.cacheKey, inputDependencies: ["type"] },
            [input],
            reduceType,
            context.inputs[0].dataType,
            finalOutputShape,
            reduceShape
          ),
          { inputs: [input] }
        );
      };
      reduceMeanShared = (context, attributes) => {
        reduceCommon(context, "ReduceMeanShared", attributes, "mean");
      };
      reduceL1Shared = (context, attributes) => {
        reduceCommon(context, "ReduceL1Shared", attributes, "l1");
      };
      reduceL2Shared = (context, attributes) => {
        reduceCommon(context, "ReduceL2Shared", attributes, "l2");
      };
      reduceLogSumExpShared = (context, attributes) => {
        reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");
      };
      reduceMaxShared = (context, attributes) => {
        reduceCommon(context, "ReduceMaxShared", attributes, "max");
      };
      reduceMinShared = (context, attributes) => {
        reduceCommon(context, "ReduceMinShared", attributes, "min");
      };
      reduceProdShared = (context, attributes) => {
        reduceCommon(context, "ReduceProdShared", attributes, "prod");
      };
      reduceSumShared = (context, attributes) => {
        reduceCommon(context, "ReduceSumShared", attributes, "sum");
      };
      reduceSumSquareShared = (context, attributes) => {
        reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");
      };
      reduceLogSumShared = (context, attributes) => {
        reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/reduce.ts
  var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;
  var init_reduce = __esm({
    "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      init_reduce_shared();
      validateInputs2 = (inputs) => {
        if (!inputs || inputs.length === 0 || inputs.length > 2) {
          throw new Error("Reduce op requires 1 or 2 inputs.");
        }
        if (inputs.length === 2 && inputs[1].dims.length !== 1) {
          throw new Error("Invalid axes input dims.");
        }
      };
      noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];
      createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {
        const outputShape = [];
        const inputShape = inputs[0].dims;
        const inputRank = inputShape.length;
        const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);
        const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;
        inputShape.forEach((d, i) => {
          if (reduceOnAllAxes || axes.indexOf(i) >= 0) {
            if (keepDims) {
              outputShape.push(1);
            }
          } else {
            outputShape.push(d);
          }
        });
        const outputRank = outputShape.length;
        const outputSize = ShapeUtil.size(outputShape);
        const getShaderSource = (shaderHelper) => {
          const idxCopy = [];
          const input = inputVariable("_A", inputs[0].dataType, inputRank);
          const output = outputVariable("output", outputDataType, outputRank);
          const ops = reduceOp(input, output, axes);
          let reduceOps2 = ops[2];
          for (let k = 0, l = 0; k < inputRank; k++) {
            if (reduceOnAllAxes || axes.indexOf(k) >= 0) {
              if (keepDims) {
                l++;
              }
              reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {
                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}
                  ${input.indicesSet("input_indices", k, `j${k}`)}
                  ${reduceOps2}
                }`;
            } else {
              idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);
              l++;
            }
          }
          return `

        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${input.type.indices};
          let output_indices = ${output.offsetToIndices("global_idx")};

          ${idxCopy.join("\n")}
          ${ops[0]}       // init ops for reduce max/min
          ${ops[1]}
          ${reduceOps2}
          ${ops[3]}
          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\n")}
        }`;
        };
        return {
          name,
          shaderCache,
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(inputShape, outputShape)]
          })
        };
      };
      createReduceAttributesFromInputs = (inputs, attributes) => {
        const axes = [];
        if (inputs[1].dims[0] > 0) {
          inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));
        }
        return createAttributeWithCacheKey(
          { axes, keepDims: attributes.keepDims, noopWithEmptyAxes: attributes.noopWithEmptyAxes }
        );
      };
      runReduceProgram = (context, name, attributes, reduceOp) => {
        const inputs = context.inputs;
        const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);
        context.compute(
          createReduceProgramInfo(
            name,
            { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },
            [inputs[0]],
            updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,
            updatedAttributes.axes,
            inputs[0].dataType,
            updatedAttributes.keepDims,
            updatedAttributes.noopWithEmptyAxes
          ),
          { inputs: [0] }
        );
      };
      reduceLogSumNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += ${input.getByIndices("input_indices")};`,
          "value = log(value);"
        ];
        runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);
      };
      reduceL1Naive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += abs(${input.getByIndices("input_indices")});`,
          ""
        ];
        runReduceProgram(context, "ReduceL1", attributes, reduceOp);
      };
      reduceL2Naive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
          "",
          `t = ${input.getByIndices("input_indices")}; value += (t * t);`,
          "value = sqrt(value);"
        ];
        runReduceProgram(context, "ReduceL2", attributes, reduceOp);
      };
      reduceLogSumExpNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += exp(${input.getByIndices("input_indices")});`,
          "value = log(value);"
        ];
        runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);
      };
      reduceMaxNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, _output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(input.indicesSet("input_indices", k, 0));
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};`,
            `value = max(value, ${input.getByIndices("input_indices")});`,
            ""
          ];
        };
        runReduceProgram(context, "ReduceMax", attributes, reduceOp);
      };
      reduceMeanNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output, axes) => {
          let size = 1;
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              size *= context.inputs[0].dims[k];
            }
          }
          return [
            "var sum = f32(0);",
            "",
            `sum += f32(${input.getByIndices("input_indices")});`,
            `let value = ${output.type.value}(sum / ${size});`
          ];
        };
        runReduceProgram(context, "ReduceMean", attributes, reduceOp);
      };
      reduceMinNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, _output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};`,
            `value = min(value, ${input.getByIndices("input_indices")});`,
            ""
          ];
        };
        runReduceProgram(context, "ReduceMin", attributes, reduceOp);
      };
      reduceProdNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(1);`,
          "",
          `value *= ${input.getByIndices("input_indices")};`,
          ""
        ];
        runReduceProgram(context, "ReduceProd", attributes, reduceOp);
      };
      reduceSumNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += ${input.getByIndices("input_indices")};`,
          ""
        ];
        runReduceProgram(context, "ReduceSum", attributes, reduceOp);
      };
      reduceSumSquareNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
          "",
          `t = ${input.getByIndices("input_indices")}; value += t * t;`,
          ""
        ];
        runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);
      };
      useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {
        if (axes.length === 0) {
          return noopWithEmptyAxes;
        }
        let outputSize = 1;
        let reduceSize = 1;
        for (let dim = 0; dim < axes.length; dim++) {
          if (axes.indexOf(dim) === -1) {
            outputSize *= shape[dim];
          } else {
            reduceSize *= shape[dim];
          }
        }
        return reduceSize < 32 && outputSize > 1024;
      };
      reduceMean = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMeanNaive(context, attributes);
        } else {
          reduceMeanShared(context, attributes);
        }
      };
      reduceL1 = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceL1Naive(context, attributes);
        } else {
          reduceL1Shared(context, attributes);
        }
      };
      reduceL2 = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceL2Naive(context, attributes);
        } else {
          reduceL2Shared(context, attributes);
        }
      };
      reduceLogSumExp = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceLogSumExpNaive(context, attributes);
        } else {
          reduceLogSumExpShared(context, attributes);
        }
      };
      reduceMax = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMaxNaive(context, attributes);
        } else {
          reduceMaxShared(context, attributes);
        }
      };
      reduceMin = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMinNaive(context, attributes);
        } else {
          reduceMinShared(context, attributes);
        }
      };
      reduceProd = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceProdNaive(context, attributes);
        } else {
          reduceProdShared(context, attributes);
        }
      };
      reduceSum = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceSumNaive(context, attributes);
        } else {
          reduceSumShared(context, attributes);
        }
      };
      reduceSumSquare = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceSumSquareNaive(context, attributes);
        } else {
          reduceSumSquareShared(context, attributes);
        }
      };
      reduceLogSum = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceLogSumNaive(context, attributes);
        } else {
          reduceLogSumShared(context, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/argminmax.ts
  var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;
  var init_argminmax = __esm({
    "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {
      "use strict";
      init_wasm_common();
      init_attribute_with_cache_key();
      init_reduce();
      validateInputs3 = (inputs) => {
        if (!inputs || inputs.length === 0 || inputs.length > 2) {
          throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
        }
        if (inputs[0].dataType !== 1 /* float */) {
          throw new Error("Invalid input type.");
        }
      };
      argMin = (context, attributes) => {
        validateInputs3(context.inputs);
        const argMinMaxOp = (input, output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
            "",
            output.setByOffset("global_idx", "best_index")
          ];
        };
        context.compute(
          createReduceProgramInfo(
            "ArgMin",
            { hint: attributes.cacheKey, inputDependencies: ["rank"] },
            [context.inputs[0]],
            argMinMaxOp,
            [attributes.axis],
            7 /* int64 */,
            attributes.keepDims
          ),
          { inputs: [0] }
        );
      };
      argMax = (context, attributes) => {
        validateInputs3(context.inputs);
        const argMinMaxOp = (input, output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
            "",
            output.setByOffset("global_idx", "best_index")
          ];
        };
        context.compute(
          createReduceProgramInfo(
            "argMax",
            { hint: attributes.cacheKey, inputDependencies: ["rank"] },
            [context.inputs[0]],
            argMinMaxOp,
            [attributes.axis],
            7 /* int64 */,
            attributes.keepDims
          ),
          { inputs: [0] }
        );
      };
      parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/attention.ts
  var validateAttentionInputs, createInPlaceSoftmaxProgramInfo, createAttentionProbsProgramInfo, createVxAttentionScoreProgramInfo, applyAttention, prepare, attention;
  var init_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {
      "use strict";
      init_wasm_common();
      init_types();
      init_common();
      validateAttentionInputs = (inputs, attributes) => {
        const input = inputs[0];
        const weights = inputs[1];
        const bias = inputs[2];
        const maskIndex = inputs[3];
        const past = inputs[4];
        const relativePositionBias = inputs[5];
        if (past && relativePositionBias) {
          throw new Error("Attention cannot have both past and relative_position_bias");
        }
        if (input.dims.length !== 3) {
          throw new Error('Input "input" must have 3 dimensions');
        }
        const batchSize = input.dims[0];
        const sequenceLength = input.dims[1];
        const inputHiddenSize = input.dims[2];
        if (bias.dims.length !== 1) {
          throw new Error('Input "bias" is expected to have 1 dimensions');
        }
        if (weights.dims.length !== 2) {
          throw new Error('Input "weights" is expected to have 2 dimensions');
        }
        if (weights.dims[0] !== inputHiddenSize) {
          throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
        }
        if (bias.dims[0] !== weights.dims[1]) {
          throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
        }
        let qHiddenSize = bias.dims[0] / 3;
        let kHiddenSize = qHiddenSize;
        let vHiddenSize = kHiddenSize;
        if (attributes.qkvHiddenSizes.length > 0) {
          if (attributes.qkvHiddenSizes.length !== 3) {
            throw new Error("qkv_hidden_sizes attribute should have 3 elements");
          }
          for (const sz of attributes.qkvHiddenSizes) {
            if (sz % attributes.numHeads !== 0) {
              throw new Error("qkv_hidden_sizes should be divisible by num_heads");
            }
          }
          qHiddenSize = attributes.qkvHiddenSizes[0];
          kHiddenSize = attributes.qkvHiddenSizes[1];
          vHiddenSize = attributes.qkvHiddenSizes[2];
        }
        const kvSequenceLength = sequenceLength;
        if (qHiddenSize !== kHiddenSize) {
          throw new Error("qkv_hidden_sizes first element should be same as the second");
        }
        if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {
          throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
        }
        let pastSequenceLength = 0;
        if (past) {
          if (kHiddenSize !== vHiddenSize) {
            throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
          }
          if (past.dims.length !== 5) {
            throw new Error('Input "past" must have 5 dimensions');
          }
          if (past.dims[0] !== 2) {
            throw new Error('Input "past" first dimension must be 2');
          }
          if (past.dims[1] !== batchSize) {
            throw new Error('Input "past" second dimension must be batch_size');
          }
          if (past.dims[2] !== attributes.numHeads) {
            throw new Error('Input "past" third dimension must be num_heads');
          }
          if (past.dims[4] !== kHiddenSize / attributes.numHeads) {
            throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
          }
          if (!attributes.pastPresentShareBuffer) {
            pastSequenceLength = past.dims[3];
          }
        }
        const totalSequenceLength = kvSequenceLength + pastSequenceLength;
        const maxSequenceLength = -1;
        const maskType = 0 /* none */;
        if (maskIndex) {
          throw new Error("Mask not supported");
        }
        if (past) {
          throw new Error("past is not supported");
        }
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize,
          hiddenSize: qHiddenSize,
          vHiddenSize,
          headSize: Math.floor(qHiddenSize / attributes.numHeads),
          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
          numHeads: attributes.numHeads,
          isUnidirectional: false,
          pastPresentShareBuffer: false,
          maskFilterValue: attributes.maskFilterValue,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias: false,
          passPastInKv: false,
          qkvFormat: 1 /* qkvBNSH */
        };
      };
      createInPlaceSoftmaxProgramInfo = (_context, input, n, d) => {
        const components = getMaxComponents(d);
        let WG = 64;
        const dComp = d / components;
        if (dComp < WG) {
          WG = 1;
        } else if (dComp / 8 < 64) {
          WG = Math.ceil(dComp / 8);
        }
        const elementsPerThread = Math.ceil(d / components / WG);
        const programUniforms = [
          { type: input.dataType, data: 1 / d },
          { type: 12 /* uint32 */, data: dComp },
          { type: 12 /* uint32 */, data: elementsPerThread }
        ];
        const dataType = tensorTypeToWsglStorageType(input.dataType, components);
        const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
        const getShaderSource = (shaderHelper) => {
          const inputHelper = outputVariable("x", input.dataType, input.dims, components);
          const elemValueType = tensorTypeToWsglValueType(input.dataType);
          const uniforms = [
            { name: "d_inv", type: elemValueType },
            { name: "d_comp", type: "u32" },
            { name: "elements_per_thread", type: "u32" }
          ];
          return `
  var<workgroup> thread_max: array<f32, ${WG}>;
  var<workgroup> thread_sum: array<f32, ${WG}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(inputHelper)}
  ${shaderHelper.mainStart([
            WG,
            1,
            1
          ])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = workgroup_id.x * uniforms.d_comp + local_offset;

    var thread_max_vector = ${f32Type}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${f32Type}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
            switch (components) {
              case 1:
                return "thread_max_vector";
              case 2:
                return "max(thread_max_vector.x, thread_max_vector.y)";
              case 4:
                return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${WG}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f32Type}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${f32Type}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
            switch (components) {
              case 1:
                return "sum_vector";
              case 2:
                return "sum_vector.x + sum_vector.y";
              case 4:
                return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${WG}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${inputHelper.type.value}(uniforms.d_inv);
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${f32Type}(x[offset + i]);
        x[offset + i] = ${inputHelper.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`;
        };
        return {
          name: "AttentionProbsSoftmax",
          shaderCache: { hint: `${WG};${dataType};${components}` },
          getShaderSource,
          getRunData: () => ({ outputs: [], dispatchGroup: { x: n }, programUniforms })
        };
      };
      createAttentionProbsProgramInfo = (context, q, key, pastKey, relativePositionBias, parameters, attributes, pastSequenceLength) => {
        const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
        const probsShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, totalSequenceLength];
        const presentKey = parameters.kvNumHeads === void 0 && context.outputCount > 1;
        const presentKeyShape = presentKey ? [parameters.batchSize, parameters.numHeads, totalSequenceLength, parameters.headSize] : void 0;
        const alpha = attributes.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : attributes.scale;
        const components = getMaxComponents(parameters.headSize);
        const vectorizedHeadSize = parameters.headSize / components;
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(totalSequenceLength / TILE_SIZE),
          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
          z: parameters.batchSize * parameters.numHeads
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: parameters.sequenceLength },
          { type: 12 /* uint32 */, data: vectorizedHeadSize },
          { type: 12 /* uint32 */, data: totalSequenceLength },
          { type: 12 /* uint32 */, data: parameters.numHeads },
          { type: 1 /* float */, data: alpha },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: parameters.kvSequenceLength }
        ];
        const inputDependencies = ["type", "type"];
        if (pastKey) {
          inputDependencies.push("type");
        }
        if (relativePositionBias) {
          inputDependencies.push("type");
        }
        const outputs = [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }];
        if (presentKey) {
          outputs.push({ dims: presentKeyShape, dataType: q.dataType, gpuDataType: 0 /* default */ });
        }
        const getShaderSource = (shaderHelper) => {
          const qInput = inputVariable("q", q.dataType, q.dims, components);
          const kInput = inputVariable("key", key.dataType, key.dims, components);
          const inputVars = [qInput, kInput];
          if (pastKey) {
            const pastKeyInput = inputVariable("past_key", pastKey.dataType, pastKey.dims, components);
            inputVars.push(pastKeyInput);
          }
          if (relativePositionBias) {
            inputVars.push(
              inputVariable("relative_position_bias", relativePositionBias.dataType, relativePositionBias.dims)
            );
          }
          const output = outputVariable("output", q.dataType, probsShape);
          const outputVars = [output];
          if (presentKey) {
            outputVars.push(outputVariable("present_key", q.dataType, presentKeyShape, components));
          }
          const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "kv_sequence_length", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;

  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([
            TILE_SIZE,
            TILE_SIZE,
            1
          ])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    ${(() => {
            if (pastKey && presentKey) {
              return `
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;
    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`;
            } else {
              return `
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`;
            }
          })()}
    ${presentKey ? "let presentKeyOffset = headIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${f32Type}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${(() => {
            if (pastKey && presentKey) {
              return `
              if (n + local_id.y < uniforms.past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else {
                tileK[idx] =
                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];
              }`;
            } else {
              return "tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];";
            }
          })()}
      ${presentKey ? "present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];" : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${f32Type}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
            switch (components) {
              case 1:
                return "value";
              case 2:
                return "value.x + value.y";
              case 4:
                return "value.x + value.y + value.z + value.w";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
        output[outputIdx] = ${output.type.value} (sum * uniforms.alpha) + ${relativePositionBias ? "relative_position_bias[outputIdx]" : "0.0"};
    }
  }`;
        };
        return {
          name: "AttentionProbs",
          shaderCache: {
            hint: `${components};${relativePositionBias !== void 0};${pastKey !== void 0};${context.outputCount}`,
            inputDependencies
          },
          getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
          getShaderSource
        };
      };
      createVxAttentionScoreProgramInfo = (context, probs, v, pastValue, params, pastSequenceLength) => {
        const totalSequenceLength = pastSequenceLength + params.kvSequenceLength;
        const nReps = params.nReps ? params.nReps : 1;
        const repeatedVHiddenSize = params.vHiddenSize * nReps;
        const presentValue = params.kvNumHeads == null && context.outputCount > 1;
        const presentValueShape = presentValue ? [params.batchSize, params.numHeads, totalSequenceLength, params.headSize] : void 0;
        const outputShape = [params.batchSize, params.sequenceLength, repeatedVHiddenSize];
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(params.vHeadSize / TILE_SIZE),
          y: Math.ceil(params.sequenceLength / TILE_SIZE),
          z: params.batchSize * params.numHeads
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: params.sequenceLength },
          { type: 12 /* uint32 */, data: totalSequenceLength },
          { type: 12 /* uint32 */, data: params.vHeadSize },
          { type: 12 /* uint32 */, data: params.numHeads },
          { type: 12 /* uint32 */, data: repeatedVHiddenSize },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: params.kvSequenceLength }
        ];
        const inputDependencies = pastValue ? ["type", "type", "type"] : ["type", "type"];
        const outputs = [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }];
        if (presentValue) {
          outputs.push({ dims: presentValueShape, dataType: probs.dataType, gpuDataType: 0 /* default */ });
        }
        const getShaderSource = (shaderHelper) => {
          const probsHelper = inputVariable("probs", probs.dataType, probs.dims);
          const vHelper = inputVariable("v", v.dataType, v.dims);
          const inputVars = [probsHelper, vHelper];
          if (pastValue) {
            inputVars.push(inputVariable("past_value", pastValue.dataType, pastValue.dims));
          }
          const output = outputVariable("output", probs.dataType, outputShape);
          const outputVars = [output];
          if (presentValue) {
            outputVars.push(outputVariable("present_value", probs.dataType, presentValueShape));
          }
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "v_hidden_size", type: "u32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "kv_sequence_length", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([
            TILE_SIZE,
            TILE_SIZE,
            1
          ])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   ${(() => {
            if (pastValue && presentValue) {
              return `
    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;
    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;
      `;
            } else {
              return `
   let offsetB = headIdx * uniforms.N * uniforms.K + n;
            `;
            }
          })()}
    ${presentValue ? "let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${probsHelper.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${(() => {
            if (pastValue && presentValue) {
              return `
        if (w + local_id.y < uniforms.past_sequence_length) {
          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else {
          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];
        }
      `;
            } else {
              return `
        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];
      `;
            }
          })()}
        ${presentValue ? "present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];" : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
        };
        return {
          name: "AttentionScore",
          shaderCache: { hint: `${pastValue !== void 0};${context.outputCount}`, inputDependencies },
          getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
          getShaderSource
        };
      };
      applyAttention = (context, q, k, v, _maskIndex, _past, pastKey, pastValue, relativePositionBias, parameters, attributes) => {
        const outputCount = context.outputCount;
        const pastSequenceLength = parameters.kvNumHeads !== void 0 || outputCount > 1 ? parameters.pastSequenceLength : 0;
        const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
        const inputsK = parameters.kvNumHeads === void 0 && outputCount > 1 && pastKey ? [q, k, pastKey] : [q, k];
        if (relativePositionBias) {
          inputsK.push(relativePositionBias);
        }
        const probs = context.compute(
          createAttentionProbsProgramInfo(
            context,
            q,
            k,
            outputCount > 1 ? pastKey : void 0,
            relativePositionBias,
            parameters,
            attributes,
            pastSequenceLength
          ),
          { inputs: inputsK, outputs: parameters.kvNumHeads === void 0 && outputCount > 1 ? [-1, 1] : [-1] }
        )[0];
        context.compute(
          createInPlaceSoftmaxProgramInfo(
            context,
            probs,
            parameters.batchSize * parameters.numHeads * parameters.sequenceLength,
            totalSequenceLength
          ),
          { inputs: [probs], outputs: [] }
        );
        const inputsV = parameters.kvNumHeads === void 0 && outputCount > 1 && pastValue ? [probs, v, pastValue] : [probs, v];
        context.compute(
          createVxAttentionScoreProgramInfo(
            context,
            probs,
            v,
            outputCount > 1 && pastValue ? pastValue : void 0,
            parameters,
            pastSequenceLength
          ),
          { inputs: inputsV, outputs: parameters.kvNumHeads === void 0 && outputCount > 1 ? [0, 2] : [0] }
        );
      };
      prepare = (context, parameters) => {
        const outputShape = [
          parameters.batchSize,
          parameters.numHeads,
          parameters.sequenceLength,
          parameters.headSize
        ];
        const M = parameters.sequenceLength;
        const K = parameters.inputHiddenSize;
        const N = parameters.headSize;
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(parameters.headSize / TILE_SIZE),
          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
          z: parameters.batchSize * parameters.numHeads
        };
        const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];
        const programUniforms = [
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: K },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: parameters.numHeads },
          { type: 12 /* uint32 */, data: parameters.headSize },
          { type: 12 /* uint32 */, data: parameters.hiddenSize },
          { type: 12 /* uint32 */, data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);
          const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);
          const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);
          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);
          const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
          const dataType = input.type.storage;
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "head_size", type: "u32" },
            { name: "hidden_size", type: "u32" },
            { name: "ldb", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}
  ${shaderHelper.mainStart([
            TILE_SIZE,
            TILE_SIZE,
            1
          ])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${dataType}(0);
    var valueK = ${dataType}(0);
    var valueV = ${dataType}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
        };
        return context.compute(
          {
            name: "AttentionPrepare",
            shaderCache: { inputDependencies: ["type", "type", "type"] },
            getRunData: () => ({
              outputs: [
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }
              ],
              dispatchGroup: dispatch,
              programUniforms
            }),
            getShaderSource
          },
          { inputs, outputs: [-1, -1, -1] }
        );
      };
      attention = (context, attributes) => {
        const params = validateAttentionInputs(context.inputs, attributes);
        const [q, k, v] = prepare(context, params);
        return applyAttention(
          context,
          q,
          k,
          v,
          context.inputs[4],
          void 0,
          void 0,
          void 0,
          context.inputs[5],
          params,
          attributes
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/batch-norm.ts
  var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;
  var init_batch_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs4 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 5) {
          throw new Error("BatchNormalization requires 5 inputs");
        }
        const checkShapeEqual = (actual, expected, message) => {
          const r = expected.length;
          if (r !== actual.length) {
            throw new Error(`${message}: num dimensions != ${r}`);
          }
          expected.forEach((v, i) => {
            if (v !== actual[i]) {
              throw new Error(`${message}: dim[${i}] do not match`);
            }
          });
        };
        if (inputs[0].dims.length > 1) {
          const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);
          checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");
          checkShapeEqual(inputs[2].dims, shape, "Invalid input B");
          checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");
          checkShapeEqual(inputs[4].dims, shape, "Invalid input var");
        } else {
          checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");
          checkShapeEqual(inputs[2].dims, [1], "Invalid input B");
          checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");
          checkShapeEqual(inputs[4].dims, [1], "Invalid input var");
        }
      };
      createBatchNormInferenceProgramInfo = (inputs, attributes) => {
        const { epsilon, spatial, format } = attributes;
        const yShape = inputs[0].dims;
        const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;
        const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;
        const outputSize = ShapeUtil.size(yShape) / components;
        const useShapesUniforms = spatial;
        const shapeOrRank = useShapesUniforms ? yShape.length : yShape;
        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);
        const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);
        const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);
        const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);
        const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);
        const calcCOffset = () => {
          let cOffset = "";
          if (spatial) {
            cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;
          } else {
            if (format === "NCHW") {
              cOffset = `
            ${y.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${y.indicesToOffset("outputIndices")};`;
            } else {
              cOffset = `var cIndices = ${scale.type.indices}(0);
                       cIndices[0] = outputIndices[${yShape.length - 1}];`;
              for (let i = 1; i < scale.rank; i++) {
                cOffset += `cIndices[${i}] = outputIndices[${i}];`;
              }
              cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;
            }
          }
          return cOffset;
        };
        const getInferenceModeShaderSource = (helper) => `
  const epsilon = ${epsilon};
  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}
  ${helper.mainStart()}
  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};
    ${calcCOffset()}
    let scale = ${scale.getByOffset("cOffset")};
    let bias = ${bias.getByOffset("cOffset")};
    let inputMean = ${inputMean.getByOffset("cOffset")};
    let inputVar = ${inputVar.getByOffset("cOffset")};
    let x = ${x.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${y.setByOffset("global_idx", "value")}
  }`;
        return {
          name: "BatchNormalization",
          shaderCache: {
            hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,
            inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0
          },
          getShaderSource: getInferenceModeShaderSource,
          getRunData: () => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: useShapesUniforms ? [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(yShape)
            ] : [
              { type: 12 /* uint32 */, data: outputSize }
            ]
          })
        };
      };
      parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      batchNorm = (context, attributes) => {
        const { inputs, outputCount } = context;
        const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });
        if (env2.webgpu.validateInputContent) {
          validateInputs4(inputs, updatedAttributes);
        }
        if (attributes.trainingMode) {
          throw new Error("BatchNormalization trainingMode is not supported yet.");
        } else {
          context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/bias-add.ts
  var validateInputs5, createBiasAddProgramInfo, biasAdd;
  var init_bias_add = __esm({
    "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {
      "use strict";
      init_util();
      init_common();
      validateInputs5 = (inputs) => {
        if (inputs[0].dims.length !== 3) {
          throw new Error("input should have 3 dimensions");
        }
        if (![320, 640, 1280].includes(inputs[0].dims[2])) {
          throw new Error("number of channels should be 320, 640 or 1280");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("bias is expected to have 1 dimensions");
        }
        if (inputs[0].dims[2] !== inputs[1].dims[0]) {
          throw new Error("last dimension of input and bias are not the same");
        }
      };
      createBiasAddProgramInfo = (inputs) => {
        const outputShape = inputs[0].dims;
        const channels = inputs[0].dims[2];
        const outputSize = ShapeUtil.size(outputShape) / 4;
        const dataType = inputs[0].dataType;
        const input = inputVariable("input", dataType, outputShape, 4);
        const bias = inputVariable("bias", dataType, [channels], 4);
        const residual = inputVariable("residual", dataType, outputShape, 4);
        const output = outputVariable("output", dataType, outputShape, 4);
        const getShaderSource = (shaderHelper) => `
  const channels = ${channels}u / 4;
  ${shaderHelper.declareVariables(input, bias, residual, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let value = ${input.getByOffset("global_idx")}
      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", "value")}
  }`;
        return {
          name: "BiasAdd",
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) }
          }),
          getShaderSource
        };
      };
      biasAdd = (context) => {
        validateInputs5(context.inputs);
        context.compute(createBiasAddProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/unary-op.ts
  var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, parseHardSigmoidAttributes, hardSigmoid, sin, sinh, sqrt, tan, tanhExpression, tanh, fastGeluImpl, fastGeluExpression, fastGelu, thresholdedRelu, log, quickGeluImpl, quickGeluExpression, quickgelu;
  var init_unary_op = __esm({
    "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation) => {
        const vecSize = Math.ceil(datasize / 4);
        let expression = "";
        if (typeof funcCall === "string") {
          expression = `${funcCall}(a)`;
        } else {
          expression = funcCall("a");
        }
        const input = inputVariable("inputData", inputDataType, [vecSize], 4);
        const output = outputVariable("outputData", outputDataType, [vecSize], 4);
        return `
      ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}

  ${additionalImplementation ?? ""}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${input.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", expression)}
  }`;
      };
      createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType) => ({
        name,
        shaderCache: { hint: cacheKey, inputDependencies: ["type"] },
        getShaderSource: (shaderHelper) => createElementwiseProgramShader(
          shaderHelper,
          ShapeUtil.size(input.dims),
          input.dataType,
          outputDataType,
          funcCall,
          additionalImplementation
        ),
        getRunData: (inputTensors) => ({
          outputs: [{ dims: input.dims, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(inputTensors[0].dims) / 64 / 4
            /* vec size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(input.dims) / 4) }
          ]
        })
      });
      abs = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));
      };
      acos = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));
      };
      acosh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));
      };
      asin = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));
      };
      asinh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));
      };
      atan = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));
      };
      atanh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));
      };
      parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      cast = (context, attributes) => {
        let func;
        switch (attributes.to) {
          case 10 /* float16 */:
            func = "vec4<f16>";
            break;
          case 1 /* float */:
            func = "vec4<f32>";
            break;
          case 12 /* uint32 */:
            func = "vec4<u32>";
            break;
          case 6 /* int32 */:
            func = "vec4<i32>";
            break;
          case 9 /* bool */:
            func = "vec4<bool>";
            break;
          default:
            throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${attributes.to}`);
        }
        context.compute(
          createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)
        );
      };
      generateClipAttributesFromInputs = (inputs) => {
        const min = inputs.length >= 2 && inputs[1].data !== 0 ? inputs[1].getFloat32Array()[0] : MIN_CLIP;
        const max = inputs.length >= 3 && inputs[2].data !== 0 ? inputs[2].getFloat32Array()[0] : MAX_CLIP;
        return createAttributeWithCacheKey({ min, max });
      };
      clip = (context, clipAttributes) => {
        const attributes = context.inputs.length === 1 ? clipAttributes : generateClipAttributesFromInputs(context.inputs);
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Clip",
            (a) => `clamp(${a}, clip_min_, clip_max_)`,
            `
    const clip_min_: vec4<${dataType}> = vec4(${dataType}(${attributes.min}));
    const clip_max_: vec4<${dataType}> = vec4(${dataType}(${attributes.max}));
`,
            attributes.cacheKey
          ),
          { inputs: [0] }
        );
      };
      ceil = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));
      };
      cos = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));
      };
      cosh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));
      };
      parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      elu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(
          context.inputs[0],
          "Elu",
          (a) => `elu_vf32(${a})`,
          `
  const elu_alpha_ = ${dataType}(${attributes.alpha});

  fn elu_f32(a: ${dataType}) -> ${dataType} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
          attributes.cacheKey
        ));
      };
      erfImpl = (varType = "f32") => `
const r0: ${varType} = 0.3275911;
const r1: ${varType} = 0.254829592;
const r2: ${varType} = -0.284496736;
const r3: ${varType} = 1.421413741;
const r4: ${varType} = -1.453152027;
const r5: ${varType} = 1.061405429;

fn erf_vf32(v: vec4<${varType}>) -> vec4<${varType}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`;
      erf = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Erf", (a) => `erf_vf32(${a})`, erfImpl(dataType)));
      };
      exp = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));
      };
      floor = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));
      };
      gelu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(
          context.inputs[0],
          "Gelu",
          (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,
          erfImpl(dataType)
        ));
      };
      leakyRelu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(
          context.inputs[0],
          "LeakyRelu",
          (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,
          `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,
          attributes.cacheKey
        ));
      };
      not = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));
      };
      neg = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));
      };
      reciprocal = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));
      };
      relu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(
          context.inputs[0],
          "Relu",
          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`
        ));
      };
      sigmoid = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));
      };
      parseHardSigmoidAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      hardSigmoid = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(
          context.inputs[0],
          "HardSigmoid",
          (a) => `max(vec4<${dataType}>(0.0), min(vec4<${dataType}>(1.0), ${attributes.alpha} * ${a} + vec4<${dataType}>(${attributes.beta})))`,
          void 0,
          attributes.cacheKey
        ));
      };
      sin = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));
      };
      sinh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));
      };
      sqrt = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));
      };
      tan = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));
      };
      tanhExpression = (a) => `sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`;
      tanh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", tanhExpression));
      };
      fastGeluImpl = (varType = "f32") => `
const fast_gelu_a: ${varType} = 0.5;
const fast_gelu_b: ${varType} = 0.7978845608028654;
const fast_gelu_c: ${varType} = 0.035677408136300125;

fn tanh_v(v: vec4<${varType}>) -> vec4<${varType}> {
  return ${tanhExpression("v")};
}
`;
      fastGeluExpression = (x) => `(fast_gelu_a + fast_gelu_a * tanh_v(${x} * (fast_gelu_c * ${x} * ${x} + fast_gelu_b))) * ${x}`;
      fastGelu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(
          context.inputs[0],
          "FastGelu",
          fastGeluExpression,
          fastGeluImpl(dataType),
          void 0,
          context.inputs[0].dataType
        ));
      };
      thresholdedRelu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(
          context.inputs[0],
          "ThresholdedRelu",
          (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,
          `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,
          attributes.cacheKey
        ));
        return 0;
      };
      log = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));
      };
      quickGeluImpl = (varType, alpha) => `
const alpha = vec4<${varType}>(${alpha});
const one = ${varType}(1.0);
const zero = ${varType}(0.0);

fn quick_gelu_impl(x: vec4<${varType}>) -> vec4<${varType}> {
  let v = x *alpha;
  var x1 : vec4<${varType}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`;
      quickGeluExpression = (x) => `quick_gelu_impl(${x})`;
      quickgelu = (context, attributes) => {
        const dType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(
          context.inputs[0],
          "QuickGelu",
          quickGeluExpression,
          quickGeluImpl(dType, attributes.alpha),
          attributes.cacheKey,
          context.inputs[0].dataType
        ));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts
  var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;
  var init_bias_split_gelu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {
      "use strict";
      init_util();
      init_common();
      init_unary_op();
      validateInputs6 = (inputs) => {
        if (inputs[0].dims.length !== 3) {
          throw new Error("input should have 3 dimensions");
        }
        if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {
          throw new Error("hidden state should be 2560, 5120 or 10240");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("bias is expected to have 1 dimensions");
        }
        if (inputs[0].dims[2] !== inputs[1].dims[0]) {
          throw new Error("last dimension of input and bias are not the same");
        }
      };
      createBiasSplitGeluProgramInfo = (inputs) => {
        const outputShape = inputs[0].dims.slice();
        outputShape[2] = outputShape[2] / 2;
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);
        const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);
        const output = outputVariable("output", inputs[0].dataType, outputShape, 4);
        const outputSize = ShapeUtil.size(outputShape) / 4;
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const getShaderSource = (shaderHelper) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;

  ${shaderHelper.declareVariables(input, bias, output)}

  ${erfImpl(dataType)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${output.setByOffset("global_idx", "valueLeft * geluRight")}
  }`;
        return {
          name: "BiasSplitGelu",
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) }
          }),
          getShaderSource
        };
      };
      biasSplitGelu = (context) => {
        validateInputs6(context.inputs);
        context.compute(createBiasSplitGeluProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/binary-op.ts
  var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;
  var init_binary_op = __esm({
    "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, additionalImplementation) => {
        let expressionScalar;
        let expressionVector;
        if (typeof funcCall === "string") {
          expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;
        } else if (typeof funcCall === "function") {
          expressionScalar = expressionVector = funcCall;
        } else {
          expressionScalar = funcCall.scalar;
          expressionVector = funcCall.vector;
        }
        const output = outputVariable("outputData", typeOutput, dimsOutput.length, 4);
        const a = inputVariable("aData", typeA, dimsA.length, 4);
        const b = inputVariable("bData", typeB, dimsB.length, 4);
        let assignment;
        if (vectorize) {
          if (doBroadcast) {
            const isAOneElement = ShapeUtil.size(dimsA) === 1;
            const isBOneElement = ShapeUtil.size(dimsB) === 1;
            const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;
            const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;
            if (isAOneElement || isBOneElement) {
              assignment = output.setByOffset(
                "global_idx",
                expressionVector(
                  isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),
                  isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")
                )
              );
            } else {
              assignment = `
            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};
            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};
            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};
            ${output.setByOffset(
                "global_idx",
                expressionVector(
                  sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,
                  sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`
                )
              )}
          `;
            }
          } else {
            assignment = output.setByOffset(
              "global_idx",
              expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))
            );
          }
        } else {
          if (!doBroadcast) {
            throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
          }
          const singleAssignment = (resStr, x, typeCast = "") => {
            const expressionA = `aData[indexA${x}][componentA${x}]`;
            const expressionB = `bData[indexB${x}][componentB${x}]`;
            return `
            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});
          `;
          };
          if (typeOutput === 9 /* bool */) {
            assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
          } else {
            assignment = `
            ${singleAssignment("outputData[global_idx]", 0)}
            ${singleAssignment("outputData[global_idx]", 1)}
            ${singleAssignment("outputData[global_idx]", 2)}
            ${singleAssignment("outputData[global_idx]", 3)}
          `;
          }
        }
        return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}

        ${additionalImplementation ?? ""}

        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
      };
      createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {
        const isBroadcast = !ShapeUtil.areEqual(a.dims, b.dims);
        let outputShape = a.dims;
        let outputSize = ShapeUtil.size(a.dims);
        let vectorize = false;
        let sharedDimensionDivisibleBy4 = false;
        const cacheKeyAux = [isBroadcast];
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(a.dims, b.dims, false);
          if (!calculatedShape) {
            throw new Error("Can't perform binary op on the given tensors");
          }
          outputShape = calculatedShape;
          outputSize = ShapeUtil.size(outputShape);
          const isAOneElement = ShapeUtil.size(a.dims) === 1;
          const isBOneElement = ShapeUtil.size(b.dims) === 1;
          const aLastDimDivisibleBy4 = a.dims.length > 0 && a.dims[a.dims.length - 1] % 4 === 0;
          const bLastDimDivisibleBy4 = b.dims.length > 0 && b.dims[b.dims.length - 1] % 4 === 0;
          cacheKeyAux.push(isAOneElement);
          cacheKeyAux.push(isBOneElement);
          cacheKeyAux.push(aLastDimDivisibleBy4);
          cacheKeyAux.push(bLastDimDivisibleBy4);
          let sharedDimension = 1;
          for (let i = 1; i < outputShape.length; i++) {
            const dimA = a.dims[a.dims.length - i] ?? 1;
            const dimB = b.dims[b.dims.length - i] ?? 1;
            if (dimA === dimB) {
              sharedDimension *= dimA;
            } else {
              break;
            }
          }
          if (sharedDimension % 4 === 0) {
            sharedDimensionDivisibleBy4 = true;
            vectorize = true;
          } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {
            vectorize = true;
          }
        } else {
          vectorize = true;
        }
        cacheKeyAux.push(vectorize);
        return {
          name,
          shaderCache: {
            hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),
            inputDependencies: ["rank", "rank"]
          },
          getShaderSource: (shaderHelper) => createBinaryOpProgramShader(
            shaderHelper,
            a.dims,
            b.dims,
            outputShape,
            vectorize,
            isBroadcast,
            sharedDimensionDivisibleBy4,
            funcCall,
            a.dataType,
            b.dataType,
            outputDataType,
            additionalImplementation
          ),
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64 / 4
              /* component size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(outputShape) / 4) },
              ...createTensorShapeVariables(a.dims, b.dims, outputShape)
            ]
          })
        };
      };
      runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {
        context.compute(createBinaryOpProgramInfo(
          name,
          cacheKey ?? "",
          context.inputs[0],
          context.inputs[1],
          funcCall,
          additionalImplementation,
          outputDataType
        ));
      };
      add = (context) => {
        runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);
      };
      div = (context) => {
        runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);
      };
      equal = (context) => {
        runBinaryOp(
          context,
          "Equal",
          { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      mul = (context) => {
        runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);
      };
      pow = (context) => {
        const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;
        const roundStr = type === "i32" ? "round" : "";
        runBinaryOp(
          context,
          "Pow",
          { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },
          `
    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {
      if (b == ${type}(0.0)) {
        return ${type}(1.0);
      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {
        return ${type}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {
      // TODO: implement vectorized pow
      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
        );
      };
      sub = (context) => {
        runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);
      };
      greater = (context) => {
        runBinaryOp(
          context,
          "Greater",
          { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      less = (context) => {
        runBinaryOp(
          context,
          "Less",
          { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      greaterOrEqual = (context) => {
        runBinaryOp(
          context,
          "GreaterOrEqual",
          { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      lessOrEqual = (context) => {
        runBinaryOp(
          context,
          "LessOrEqual",
          { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/concat.ts
  var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;
  var init_concat = __esm({
    "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs7 = (inputs, axis) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        const referenceIndex = 0;
        const referenceInput = inputs[referenceIndex];
        const inputType = referenceInput.dataType;
        const inputRank = referenceInput.dims.length;
        inputs.forEach((input, i) => {
          if (i === referenceIndex) {
            return;
          }
          if (input.dataType !== inputType) {
            throw new Error("input tensors should be one type");
          }
          if (input.dims.length !== inputRank) {
            throw new Error("input tensors should have the same shape");
          }
          input.dims.forEach((dim, i2) => {
            if (i2 !== axis && dim !== referenceInput.dims[i2]) {
              throw new Error("non concat dimensions must match");
            }
          });
        });
      };
      calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});
    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${numberOfTensors}u;
  }`;
      assignOutputData = (inputs, output) => {
        const numberOfTensors = inputs.length;
        const codeLines = [];
        for (let i = 0; i < numberOfTensors; ++i) {
          const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));
          if (numberOfTensors === 1) {
            codeLines.push(returnSnippet);
          } else if (i === 0) {
            codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`else { ${returnSnippet} }`);
          } else {
            codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);
          }
        }
        return codeLines.join("\n");
      };
      createConcatProgramInfo = (inputs, adjustedAxis, outputShape, dataType) => {
        const outputSize = ShapeUtil.size(outputShape);
        const sizeInConcatAxis = new Array(inputs.length);
        const inputVars = new Array(inputs.length);
        let previousSum = 0;
        const inputDependencies = [];
        const inputRanks = [];
        const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }];
        for (let i = 0; i < inputs.length; ++i) {
          previousSum += inputs[i].dims[adjustedAxis];
          sizeInConcatAxis[i] = previousSum;
          inputRanks.push(inputs[i].dims.length);
          inputVars[i] = inputVariable(`input${i}`, dataType, inputRanks[i]);
          inputDependencies.push("rank");
          programUniforms.push({ type: 12 /* uint32 */, data: sizeInConcatAxis[i] });
        }
        for (let i = 0; i < inputs.length; ++i) {
          programUniforms.push(...createTensorShapeVariables(inputs[i].dims));
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const output = outputVariable("output", dataType, outputShape.length);
        const indicesAxis = output.indicesGet("indices", adjustedAxis);
        const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");
        const getShaderSource = (shaderHelper) => `

  ${(() => {
          shaderHelper.registerUniform("outputSize", "u32");
          for (let i = 0; i < inputs.length; i++) {
            shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");
          }
          return shaderHelper.declareVariables(...inputVars, output);
        })()}

  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${output.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${indicesAxis});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});
      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${assignOutputData(inputVars, output)}
  }`;
        return {
          name: "Concat",
          shaderCache: { hint: `${adjustedAxis}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      concat = (context, attributes) => {
        const inputs = context.inputs;
        const inputShape = inputs[0].dims;
        const adjustedAxis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        validateInputs7(inputs, adjustedAxis);
        const outputShape = inputShape.slice();
        outputShape[adjustedAxis] = inputs.reduce((sum, input) => sum + (input.dims.length > adjustedAxis ? input.dims[adjustedAxis] : 0), 0);
        const nonEmptyInputs = inputs.filter((input) => ShapeUtil.size(input.dims) > 0);
        context.compute(
          createConcatProgramInfo(nonEmptyInputs, adjustedAxis, outputShape, inputs[0].dataType),
          { inputs: nonEmptyInputs }
        );
      };
      parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts
  var getActivationSnippet, appendActivationUniformsData, appendActivationUniforms, parseInternalActivationAttributes;
  var init_fuse_utils = __esm({
    "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      getActivationSnippet = (attributes, valueType, baseType = "f32") => {
        switch (attributes.activation) {
          case "Relu":
            return `value = max(value, ${valueType}(0.0));`;
          case "Sigmoid":
            return `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`;
          case "Clip":
            return `value = clamp(value, ${valueType}(${baseType}(uniforms.clip_min)), ${valueType}(${baseType}(uniforms.clip_max)));`;
          case "HardSigmoid":
            return `value = max(${valueType}(0.0), min(${valueType}(1.0), ${baseType}(uniforms.alpha) * value + ${baseType}(uniforms.beta)));`;
          case "LeakyRelu":
            return `value = select(${baseType}(uniforms.alpha) * value, value, value >= ${valueType}(0.0));`;
          case "":
            return "";
          default:
            throw new Error(`Unsupported activation ${attributes.activation}`);
        }
      };
      appendActivationUniformsData = (attributes, programUniform) => {
        if (attributes.activation === "Clip") {
          programUniform.push(
            { type: 1 /* float */, data: attributes.clipMax },
            { type: 1 /* float */, data: attributes.clipMin }
          );
        } else if (attributes.activation === "HardSigmoid") {
          programUniform.push(
            { type: 1 /* float */, data: attributes.alpha },
            { type: 1 /* float */, data: attributes.beta }
          );
        } else if (attributes.activation === "LeakyRelu") {
          programUniform.push({ type: 1 /* float */, data: attributes.alpha });
        }
      };
      appendActivationUniforms = (attributes, uniforms) => {
        if (attributes.activation === "Clip") {
          uniforms.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" });
        } else if (attributes.activation === "HardSigmoid") {
          uniforms.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" });
        } else if (attributes.activation === "LeakyRelu") {
          uniforms.push({ name: "alpha", type: "f32" });
        }
      };
      parseInternalActivationAttributes = (attributes) => {
        const activation = attributes?.activation || "";
        if (activation === "HardSigmoid") {
          const [alpha, beta] = attributes?.activation_params || [0.2, 0.5];
          return { activation, alpha, beta };
        } else if (activation === "Clip") {
          const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];
          return { activation, clipMax, clipMin };
        } else if (activation === "LeakyRelu") {
          const [alpha] = attributes?.activation_params || [0.01];
          return { activation, alpha };
        }
        return { activation };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts
  var typeSnippet, biasSnippet;
  var init_activation_util = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {
      "use strict";
      typeSnippet = (component, dataType) => {
        switch (component) {
          case 1:
            return dataType;
          case 2:
            return `vec2<${dataType}>`;
          case 3:
            return `vec3<${dataType}>`;
          case 4:
            return `vec4<${dataType}>`;
          default:
            throw new Error(`${component}-component is not supported.`);
        }
      };
      biasSnippet = (hasBias) => `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts
  var utilFunctions;
  var init_conv_util = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {
      "use strict";
      utilFunctions = (strideStr) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));
}
`;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts
  var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;
  var init_matmul_packed_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      init_activation_util();
      writeDataToSubAVec4Snippet = (transpose2, batchDims) => {
        if (transpose2) {
          return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
        } else {
          return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
        }
      };
      calculateResultSnippet = (transposeA, innerElementSize) => {
        if (transposeA) {
          return `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`;
        } else {
          return `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;
        }
      };
      makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {
        const tileAOuter = workgroupSize[1] * workPerThread[1];
        const tileBOuter = workgroupSize[0] * workPerThread[0];
        const tileAWidth = transposeA ? tileAOuter : tileInner;
        const tileAHight = transposeA ? tileInner : tileAOuter;
        const innerElementSize = tileAWidth / workgroupSize[0];
        const rowPerThreadB = tileInner / workgroupSize[1];
        if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {
          throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
        }
        return `
var<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
var<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

const rowPerThread = ${workPerThread[1]};
const colPerThread = ${workPerThread[0]};
const innerElementSize = ${innerElementSize};
const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${splitK ? "0" : "i32(globalId.z)"};
  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

  var acc: array<vec4<${type}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${rowPerThreadB};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${calculateResultSnippet(transposeA, innerElementSize)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
      };
      writeDataToSubASnippet = (transpose2, batchDims) => {
        if (transpose2) {
          return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
        } else {
          return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
        }
      };
      readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
      makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {
        const tileAOuter = workPerThread[1] * workgroupSize[1];
        const tileBOuter = workPerThread[0] * workgroupSize[0];
        const tileAWidth = transposeA ? tileAOuter : tileInner;
        const tileAHight = transposeA ? tileInner : tileAOuter;
        if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {
          throw new Error(`tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`);
        }
        const rowPerThreadA = tileAHight / workgroupSize[1];
        const colPerThreadA = tileAWidth / workgroupSize[0];
        const rowPerThreadB = tileInner / workgroupSize[1];
        const matmulSnippet = sequentialAccessByThreads ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
    let globalColStart = i32(workgroupId.x) * ${tileBOuter};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
          ${writeDataToSubASnippet(transposeA, batchDims)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${type}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

let tileRowA = i32(localId.y) * ${rowPerThreadA};
let tileColA = i32(localId.x) * ${colPerThreadA};
let tileRowB = i32(localId.y) * ${rowPerThreadB};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${writeDataToSubASnippet(transposeA, batchDims)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${batchDims ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${type}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${readDataFromSubASnippet(transposeA)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
        return `
  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;
  const rowPerThread = ${workPerThread[1]};
  const colPerThread = ${workPerThread[0]};
  const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc : array<array<${type}, colPerThread>, rowPerThread>;
    ${matmulSnippet}
  }
`;
      };
      matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, batchShapes, isChannelsLast = false) => {
        const [batchAShape, batchBShape, batchShape] = batchShapes;
        const [batchVariable, aVariable, bVariable, outputVariable2] = variables;
        const broadCastADims = getBroadcastDims(batchAShape, batchShape);
        const broadCastBDims = getBroadcastDims(batchBShape, batchShape);
        const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);
        const getAIndices = () => {
          const aRank = aVariable.rank;
          const batchRank = batchVariable.rank;
          let resStr = `var aIndices: ${aVariable.type.indices};`;
          for (let i = aRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
            resStr += `
aIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;
          }
          broadCastADims.forEach((i) => {
            resStr += `
aIndices[${i}] = 0;`;
          });
          resStr += `
aIndices[${aRank - 2}] = u32(row);
                   aIndices[${aRank - 1}] = u32(colIn);`;
          return resStr;
        };
        const getBIndices = () => {
          const bRank = bVariable.rank;
          const batchRank = batchVariable.rank;
          let resStr = `var bIndices: ${bVariable.type.indices};`;
          for (let i = bRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
            resStr += `
bIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;
          }
          broadCastBDims.forEach((i) => {
            resStr += `
bIndices[${i}] = 0;`;
          });
          resStr += `
bIndices[${bRank - 2}] = u32(row);
                   bIndices[${bRank - 1}] = u32(colIn);`;
          return resStr;
        };
        const source = `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(component, dataType)} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${getAIndices()}
        value = ${aVariable.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(component, dataType)} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${getBIndices()}
        value = ${bVariable.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {
      let col = colIn * ${component};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}
        ${applyActivation}
        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
        return source;
      };
      createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false) => {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const outerDimsA = aShape.slice(0, -2);
        const outerDimsB = bShape.slice(0, -2);
        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
        const batchSize = ShapeUtil.size(outerDims);
        const dimAOuter = aShape[aShape.length - 2];
        const dimInner = aShape[aShape.length - 1];
        const dimBOuter = bShape[bShape.length - 1];
        const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const workgroupSize = [8, 8, 1];
        const dispatch = [
          Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),
          Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])
        ];
        const components = isVec4 ? 4 : 1;
        const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];
        const aRank = aShapeTemp.length;
        const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];
        const bRank = bShapeTemp.length;
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner }
        ];
        appendActivationUniformsData(activationAttributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(outerDims, aShapeTemp, bShapeTemp));
        const inputDependencies = ["rank", "rank"];
        const hasBias = inputs.length > 2;
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const batchRank = outerDims.length;
          const batchDims = internalVariable("batchDims", inputs[0].dataType, batchRank, 1);
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const A = inputVariable("a", inputs[0].dataType, aRank, components);
          const B = inputVariable("b", inputs[1].dataType, bRank, components);
          const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);
          const inputVariables = [A, B];
          if (hasBias) {
            const biasComponents = isChannelsLast ? components : 1;
            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
          }
          const uniforms = [{ name: "dim_a_outer", type: "i32" }, { name: "dim_b_outer", type: "i32" }, { name: "dim_inner", type: "i32" }];
          appendActivationUniforms(activationAttributes, uniforms);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
          const declareFunctions = matMulReadWriteFnSource(
            components,
            hasBias,
            applyActivation,
            [batchDims, A, B, output],
            [outerDimsA, outerDimsB, outerDims],
            isChannelsLast
          );
          return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(
            ...inputVariables,
            output
          )}
  ${declareFunctions}
  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}
                   `;
        };
        return {
          name: "MatMul",
          shaderCache: {
            hint: `${elementsPerThread};${activationAttributes.activation};${isVec4};${isChannelsLast}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts
  var conv2dCommonSnippet, createConv2DMatMulProgramInfo;
  var init_conv2d_mm_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_common();
      init_fuse_utils();
      init_activation_util();
      init_conv_util();
      init_matmul_packed_webgpu();
      conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {
        const getXSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "resData = x[xIndex];";
            case 3:
              return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
            case 4:
              return "resData = x[xIndex / 4];";
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const getWSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
            case 4:
              return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const coordASnippet = isChannelsLast ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `;
        const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
        const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
        const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
        const row = isChannelsLast ? "row" : "col";
        const col = isChannelsLast ? "col" : "row";
        const readXSnippet = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${row} / outWidth;
    let outCol = ${row} % outWidth;

    let WRow = ${col} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${col} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${col} % inChannels;
    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {
      ${coordASnippet}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${getXSnippet(innerElementSizeX)}
    }
    return resData;`;
        const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;
        const sampleW = `${getWSnippet(innerElementSizeW)}`;
        const resType = typeSnippet(innerElementSize, dataType);
        const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);
        const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);
        const applyActivation = getActivationSnippet(attributes, resType, dataType);
        const userCode = `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {
      ${isChannelsLast ? sampleX : sampleW}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {
      ${isChannelsLast ? sampleW : sampleX}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
        return userCode;
      };
      createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const batchSize = outputShape[0];
        const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
        const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
        const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
        const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
        const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
        const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
        const workGroupSize = [8, 8, 1];
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const dispatch = [
          Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
          Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
        ];
        LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
        const tileAOuter = workGroupSize[1] * elementsPerThread[1];
        const tileBOuter = workGroupSize[0] * elementsPerThread[0];
        const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
        const fitAOuter = dimAOuter % tileAOuter === 0;
        const fitBOuter = dimBOuter % tileBOuter === 0;
        const fitInner = dimInner % tileInner === 0;
        const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner },
          { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] },
          { type: 6 /* int32 */, data: attributes.strides },
          { type: 6 /* int32 */, data: attributes.dilations }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" },
            { name: "pad", type: "i32", length: 2 },
            { name: "stride", type: "i32", length: 2 },
            { name: "dilation", type: "i32", length: 2 }
          ];
          appendActivationUniforms(attributes, uniforms);
          const components = isVec4 ? 4 : 1;
          const t = tensorTypeToWsglStorageType(inputs[0].dataType);
          let declareFunctions = `
      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);
      }`;
          const x = inputVariable(
            "x",
            inputs[0].dataType,
            inputs[0].dims.length,
            innerElementSize === 3 ? 1 : innerElementSize
          );
          const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);
          const inputVariables = [x, w];
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
        }`;
          }
          return `
        ${utilFunctions("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${declareFunctions}
        ${conv2dCommonSnippet(
            isChannelsLast,
            fitAOuter,
            fitBOuter,
            fitInner,
            hasBias,
            attributes,
            elementsSize[0],
            elementsSize[1],
            elementsSize[2],
            t
          )}
        ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(
            elementsPerThread,
            workGroupSize,
            t,
            void 0,
            !isChannelsLast,
            tileInner,
            false,
            void 0,
            sequentialAccessByThreads
          )}`;
        };
        return {
          name: "Conv2DMatMul",
          shaderCache: {
            hint: `${attributes.cacheKey};${innerElementSize};${isVec4};${fitAOuter};${fitBOuter};${fitInner};${tileAOuter};${tileBOuter};${tileInner}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
  var arrayProduct, parse3TupleParam, getEffectiveFilterSize, computeDefaultPad, computeOutputShape4D, get3DPadAndOutInfo, computeConv3DInfo, createConv3DNaiveProgramInfo;
  var init_conv3d_naive_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_common();
      arrayProduct = (arr) => {
        let product = 1;
        for (let i = 0; i < arr.length; i++) {
          product *= arr[i];
        }
        return product;
      };
      parse3TupleParam = (param) => typeof param === "number" ? [param, param, param] : param;
      getEffectiveFilterSize = (filterSize, dilation) => {
        if (dilation <= 1) {
          return filterSize;
        }
        return filterSize + (filterSize - 1) * (dilation - 1);
      };
      computeDefaultPad = (inputShape, fieldSize, stride, dilation = 1) => {
        const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
        return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
      };
      computeOutputShape4D = (inShape, filterShape, outChannels, strides, zeroPad) => {
        if (zeroPad == null) {
          zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
        }
        const outShape = [0, 0, 0, outChannels];
        for (let index = 0; index < 3; index++) {
          if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
            outShape[index] = Math.trunc((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1);
          }
        }
        return outShape;
      };
      get3DPadAndOutInfo = (pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth) => {
        let padInfo;
        let outDepth;
        let outHeight;
        let outWidth;
        if (pad2 === "VALID") {
          pad2 = 0;
        }
        if (typeof pad2 === "number") {
          padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, front: pad2, back: pad2 };
          const outShape = computeOutputShape4D(
            [inDepth, inHeight, inWidth, 1],
            [filterDepth, filterHeight, filterWidth],
            1,
            [strideDepth, strideHeight, strideWidth],
            pad2
          );
          outDepth = outShape[0];
          outHeight = outShape[1];
          outWidth = outShape[2];
        } else if (Array.isArray(pad2)) {
          if (!pad2.every((val, _, arr) => val === arr[0])) {
            throw Error(`Unsupported padding parameter: ${pad2}`);
          }
          padInfo = { top: pad2[0], bottom: pad2[1], left: pad2[2], right: pad2[3], front: pad2[4], back: pad2[5] };
          const outShape = computeOutputShape4D(
            [inDepth, inHeight, inWidth, 1],
            [filterDepth, filterHeight, filterWidth],
            1,
            [strideDepth, strideHeight, strideWidth],
            pad2[0]
          );
          outDepth = outShape[0];
          outHeight = outShape[1];
          outWidth = outShape[2];
        } else if (pad2 === "SAME_UPPER") {
          outDepth = Math.ceil(inDepth / strideDepth);
          outHeight = Math.ceil(inHeight / strideHeight);
          outWidth = Math.ceil(inWidth / strideWidth);
          const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
          const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
          const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
          const front = Math.floor(padAlongDepth / 2);
          const back = padAlongDepth - front;
          const top = Math.floor(padAlongHeight / 2);
          const bottom = padAlongHeight - top;
          const left = Math.floor(padAlongWidth / 2);
          const right = padAlongWidth - left;
          padInfo = { top, bottom, left, right, front, back };
        } else {
          throw Error(`Unknown padding parameter: ${pad2}`);
        }
        return { padInfo, outDepth, outHeight, outWidth };
      };
      computeConv3DInfo = (inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast") => {
        let batchSize, inDepth, inHeight, inWidth, inChannels;
        if (dataFormat === "channelsLast") {
          [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
        } else if (dataFormat === "channelsFirst") {
          [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
        } else {
          throw new Error(`Unknown dataFormat ${dataFormat}`);
        }
        const [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
        const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
        const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
        const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
        const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
        const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
        const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(
          pad2,
          inDepth,
          inHeight,
          inWidth,
          strideDepth,
          strideHeight,
          strideWidth,
          effectiveFilterDepth,
          effectiveFilterHeight,
          effectiveFilterWidth
        );
        const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
        let outShape = [0, 0, 0, 0, 0];
        if (dataFormat === "channelsFirst") {
          outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
        } else if (dataFormat === "channelsLast") {
          outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
        }
        return {
          batchSize,
          dataFormat,
          inDepth,
          inHeight,
          inWidth,
          inChannels,
          outDepth,
          outHeight,
          outWidth,
          outChannels,
          padInfo,
          strideDepth,
          strideHeight,
          strideWidth,
          filterDepth,
          filterHeight,
          filterWidth,
          effectiveFilterDepth,
          effectiveFilterHeight,
          effectiveFilterWidth,
          dilationDepth,
          dilationHeight,
          dilationWidth,
          inShape,
          outShape,
          filterShape
        };
      };
      createConv3DNaiveProgramInfo = (inputs, attributes, outputShape, filterDims, pads, dataFormat) => {
        const isChannelsLast = dataFormat === "channelsLast";
        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const isVec4 = false;
        const workGroupSize = [64, 1, 1];
        const dispatchLayout = { x: outputShape.map((_, i) => i) };
        const dispatch = [Math.ceil(arrayProduct(dispatchLayout.x.map((d) => outputShape[d])) / workGroupSize[0]), 1, 1];
        LOG_DEBUG("verbose", () => `[conv3d_naive_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: filterDims },
          { type: 12 /* uint32 */, data: pads },
          { type: 12 /* uint32 */, data: attributes.strides },
          { type: 12 /* uint32 */, data: attributes.dilations }
        ];
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        const hasBias = inputs.length === 3;
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "filter_dims", type: "u32", length: filterDims.length },
            { name: "pads", type: "u32", length: pads.length },
            { name: "strides", type: "u32", length: attributes.strides.length },
            { name: "dilations", type: "u32", length: attributes.dilations.length }
          ];
          const components = isVec4 ? 4 : 1;
          const t = tensorTypeToWsglStorageType(inputs[0].dataType);
          const x = inputVariable(
            "x",
            inputs[0].dataType,
            inputs[0].dims.length,
            innerElementSize === 3 ? 1 : innerElementSize
          );
          const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
          const inputVariables = [x, w];
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          let declareFunctions = "";
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[${isChannelsLast ? getElementAt("coords", 4, 5) : getElementAt("coords", 1, 5)}${isVec4 ? "/ 4" : ""}];
        }`;
          }
          return `
            ${declareFunctions}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
          ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${output.offsetToIndices("global_idx")};
              let batch = ${getElementAt("coords", 0, x.rank)};
              let d2 = ${isChannelsLast ? getElementAt("coords", x.rank - 1, x.rank) : getElementAt("coords", 1, x.rank)};
              let xFRCCorner = vec3<u32>(${isChannelsLast ? getElementAt("coords", 1, x.rank) : getElementAt("coords", 2, x.rank)},
              ${isChannelsLast ? getElementAt("coords", 2, x.rank) : getElementAt("coords", 3, x.rank)},
              ${isChannelsLast ? getElementAt("coords", 3, x.rank) : getElementAt("coords", 4, x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${isChannelsLast ? getElementAt("uniforms.x_shape", 1, x.rank) : getElementAt("uniforms.x_shape", 2, x.rank)};
              let xShapeZ = ${isChannelsLast ? getElementAt("uniforms.x_shape", 2, x.rank) : getElementAt("uniforms.x_shape", 3, x.rank)};
              let xShapeW = ${isChannelsLast ? getElementAt("uniforms.x_shape", 3, x.rank) : getElementAt("uniforms.x_shape", 4, x.rank)};
              let xShapeU = ${isChannelsLast ? getElementAt("uniforms.x_shape", 4, x.rank) : getElementAt("uniforms.x_shape", 1, x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var dotProd = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${isChannelsLast ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      dotProd += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${isChannelsLast ? `dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `dotProd += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${isChannelsLast ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      dotProd += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${isChannelsLast ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      dotProd += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${hasBias ? "dotProd = dotProd + getBiasByOutputCoords(coords)" : ""};
              result[global_idx] = f32(dotProd);
          }`;
        };
        return {
          name: "Conv3DNaive",
          shaderCache: { hint: `${attributes.cacheKey};${isChannelsLast};${innerElementSize};${hasBias}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts
  var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;
  var init_conv_grouped = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_conv();
      init_fuse_utils();
      createGroupedConvProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? "value += b[output_channel];" : "";
        const xShape = inputs[0].dims;
        const wShape = inputs[1].dims;
        const outputChannelsPerGroup = wShape[0] / attributes.group;
        const isChannelLast = attributes.format === "NHWC";
        const outputShape = calculateOutputShape(
          xShape,
          wShape,
          attributes.dilations,
          attributes.pads,
          attributes.strides,
          isChannelLast
        );
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: attributes.dilations },
          { type: 12 /* uint32 */, data: [attributes.strides[0], attributes.strides[1]] },
          { type: 12 /* uint32 */, data: [attributes.pads[0], attributes.pads[1]] },
          { type: 12 /* uint32 */, data: outputChannelsPerGroup }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(xShape, wShape));
        const inputDependencies = ["rank", "rank"];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
          const x = inputVariable("x", inputs[0].dataType, xShape.length);
          const w = inputVariable("w", inputs[1].dataType, wShape.length);
          const inputVars = [x, w];
          if (hasBias) {
            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims.length));
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "dilations", type: "u32", length: attributes.dilations.length },
            { name: "strides", type: "u32", length: 2 },
            { name: "pads", type: "u32", length: 2 },
            { name: "output_channels_per_group", type: "u32" }
          ];
          appendActivationUniforms(attributes, uniforms);
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${output.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel / uniforms.output_channels_per_group;

    var value: ${output.type.value} = ${output.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[${isChannelLast ? 1 : 2}]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[${isChannelLast ? 2 : 3}]) {
            continue;
          }

          let xVal = ${isChannelLast ? x.get("batch", "xHeight", "xWidth", "input_channel") : x.get("batch", "input_channel", "xHeight", "xWidth")};
          let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${processBias}
    ${applyActivation}
    ${output.setByOffset("global_idx", "value")}
  }`;
        };
        return {
          name: "GroupedConv",
          shaderCache: { hint: attributes.cacheKey, inputDependencies },
          getRunData: () => ({
            outputs: [{
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape) => {
        const hasBias = inputs.length > 2;
        const components = getMaxComponents(outputShape[3]);
        const outputNumber = getMaxComponents(outputShape[2]);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];
        const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];
        const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: [attributes.strides[0], attributes.strides[1]] },
          { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(xShape, wShape, outputShapeInShader));
        const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
          const x = inputVariable("x", inputs[0].dataType, xShape.length, components);
          const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
          const inputVars = [x, w];
          if (hasBias) {
            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
          }
          const processBias = hasBias ? "value += b[output_channel];" : "";
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "strides", type: "i32", length: 2 },
            { name: "pads", type: "i32", length: 2 }
          ];
          appendActivationUniforms(attributes, uniforms);
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${outputNumber}u;
    let col = (index1 % width1) * ${outputNumber}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${xNumber}>;
    var values: array<${output.type.value}, ${outputNumber}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${xNumber}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {
          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${outputNumber}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      ${output.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
        };
        return {
          name: "GroupedConv-Vectorize",
          shaderCache: {
            hint: `${attributes.cacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,
            inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmul.ts
  var createNaiveMatmulProgramInfo, validateInputs8, matMul;
  var init_matmul = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_matmul_packed_webgpu();
      init_common();
      init_fuse_utils();
      createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false) => {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const M = aShape[aShape.length - 2];
        const N = bShape[bShape.length - 1];
        const K = aShape[aShape.length - 1];
        const components = getMaxComponents(N);
        const aComponents = getMaxComponents(K);
        const outputNumber = getMaxComponents(M);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const hasBias = inputs.length > 2;
        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
        const batchSize = ShapeUtil.size(outerDims);
        const outputShapeInShader = [batchSize, M, N];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: K }
        ];
        appendActivationUniformsData(activationAttributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(outerDims, aShape, bShape));
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        }
        programUniforms.push(...createTensorShapeVariables(outputShapeInShader));
        const getShaderSource = (shaderHelper) => {
          const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);
          const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);
          const b = inputVariable("b", inputs[1].dataType, bShape.length, components);
          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
          const inputVariables = [a, b];
          let processBias = "";
          if (hasBias) {
            const biasComponents = isChannelsLast ? components : 1;
            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
            processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;
          }
          const outerDimsA = aShape.slice(0, -2);
          const outerDimsB = bShape.slice(0, -2);
          const broadCastADims = getBroadcastDims(outerDimsA, outerDims);
          const broadCastBDims = getBroadcastDims(outerDimsB, outerDims);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" }
          ];
          appendActivationUniforms(activationAttributes, uniforms);
          const getIndices = (variable, broadCastDims) => {
            const rank = variable.rank;
            const name = variable.name;
            if (rank === 2) {
              return `var ${name}_indices = ${variable.type.indices}(0u, 0u);`;
            }
            const batchRank = batchDims.rank;
            let resStr = `var ${name}_indices: ${variable.type.indices};`;
            for (let i = rank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
              resStr += `
${name}_indices[${i}] = ${batchRank > 1 ? `batch_indices[${j}]` : "batch_indices"};`;
            }
            broadCastDims.forEach((i) => {
              resStr += `
${name}_indices[${i}] = 0;`;
            });
            resStr += `${name}_indices[${rank - 2}] = 0u;
                     ${name}_indices[${rank - 1}] = 0u;`;
            return resStr;
          };
          const calcResult = () => {
            let calcStr = `var a_data: ${a.type.value};`;
            for (let i = 0; i < aComponents; i++) {
              calcStr += `
              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;
            }
            for (let i = 0; i < outputNumber; i++) {
              calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;
              for (let j = 0; j < aComponents; j++) {
                calcStr += `
            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);
`;
              }
            }
            return calcStr;
          };
          return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(
            ...inputVariables,
            output
          )}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${components})) * ${components};
    var index1 = global_idx / (uniforms.N / ${components});
    let stride1 = uniforms.M / ${outputNumber};
    let row = (index1 % stride1) * ${outputNumber};
    let batch = index1 / stride1;

    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}
    ${getIndices(a, broadCastADims)}
    let a_offset = ${a.indicesToOffset("a_indices")};
    ${getIndices(b, broadCastBDims)}
    let b_offset = ${b.indicesToOffset("b_indices")};
    var values: array<${output.type.value}, ${outputNumber}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {
      ${calcResult()}
    }
    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      let cur_indices = ${output.type.indices}(batch, row + i, col);
      let offset = ${output.indicesToOffset("cur_indices")};
      ${output.setByOffset(`offset / ${components}`, "value")};
    }
  }
  `;
        };
        return {
          name: "MatMulNaive",
          shaderCache: {
            hint: `${activationAttributes.activation};${components};${aComponents};${outputNumber};${isChannelsLast}`,
            inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      validateInputs8 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("MatMul requires 2 inputs.");
        }
        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
          throw new Error("shared dimension does not match.");
        }
      };
      matMul = (context) => {
        validateInputs8(context.inputs);
        const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);
        if (!outputShape) {
          throw new Error("Can't use matmul on the given tensors");
        }
        const N = outputShape[outputShape.length - 1];
        const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];
        if (N < 8 && K < 8) {
          context.compute(createNaiveMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
        } else {
          context.compute(createMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv.ts
  var calculateOutputShape, weightTransposeAttribute, validateInputs9, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv3d, conv;
  var init_conv = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {
      "use strict";
      init_util();
      init_conv2d_mm_webgpu();
      init_conv3d_naive_webgpu();
      init_matmul_packed_webgpu();
      init_conv_grouped();
      init_fuse_utils();
      init_matmul();
      init_transpose();
      calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {
        const batchSize = inputShape[0];
        const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);
        const spatialRank = inputSpatialShape.length;
        const outChannels = kernelShape[0];
        const kernelSpatialShape = kernelShape.slice(2);
        const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
        const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
        const outputShape = inputSpatialShapeWithPad.map((v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]));
        outputShape.splice(0, 0, batchSize);
        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
        return outputShape;
      };
      weightTransposeAttribute = [2, 3, 1, 0];
      validateInputs9 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length > 5) {
          throw new Error("greater than 5D is not supported");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("filter does not have same dimension as input");
        }
        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
        const filterInChannel = inputs[1].dims[1] * attributes.group;
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        if (attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        if (attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        if (attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
      };
      getAdjustedConvAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          if (kernelShape[i - 2] === 0) {
            kernelShape[i - 2] = inputs[1].dims[i];
          }
        }
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPadsBasedOnAutoPad(
          inputs[0].dims,
          attributes.strides,
          attributes.dilations,
          kernelShape,
          pads,
          attributes.format === "NHWC",
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads });
        return newAttributes;
      };
      parseConvAttributes = (attributes) => {
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const format = attributes.format;
        const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];
        const dilations = attributes.dilations;
        const group = attributes.group;
        const kernelShape = attributes.kernel_shape;
        const pads = attributes.pads;
        const strides = attributes.strides;
        const wIsConst = attributes.w_is_const();
        return {
          autoPad,
          format,
          dilations,
          group,
          kernelShape,
          pads,
          strides,
          wIsConst,
          ...activationAttributes,
          cacheKey: `${attributes.format};${activationAttributes.activation};`
        };
      };
      conv2d = (context, inputs, attributes) => {
        const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
        const isChannelsLast = attributes.format === "NHWC";
        if (attributes.group !== 1) {
          const enableGroupedConvVectorize = !context.adapterInfo.isArchitecture("ampere");
          if (enableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {
            const outputShape2 = calculateOutputShape(
              inputs[0].dims,
              inputs[1].dims,
              attributes.dilations,
              adjustedAttributes.pads,
              attributes.strides,
              isChannelsLast
            );
            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(
              createTransposeProgramInfo(inputs[1], weightTransposeAttribute),
              { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }
            )[0];
            if (attributes.wIsConst && !context.kernelCustomData.wT) {
              context.kernelCustomData.wT = transposedWeight2;
            }
            const convInputs2 = [inputs[0], transposedWeight2];
            if (inputs.length === 3) {
              convInputs2.push(inputs[2]);
            }
            context.compute(
              createGroupedConvVectorizeProgramInfo(convInputs2, adjustedAttributes, outputShape2),
              { inputs: convInputs2 }
            );
          } else {
            context.compute(createGroupedConvProgramInfo(inputs, adjustedAttributes));
          }
          return;
        }
        const hasBias = inputs.length === 3;
        const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];
        const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];
        const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
        const weightHeight = inputs[1].dims[2];
        const weightWidth = inputs[1].dims[3];
        const outputShape = calculateOutputShape(
          inputs[0].dims,
          inputs[1].dims,
          attributes.dilations,
          adjustedAttributes.pads,
          attributes.strides,
          isChannelsLast
        );
        const outHeight = outputShape[isChannelsLast ? 1 : 2];
        const outWidth = outputShape[isChannelsLast ? 2 : 3];
        const outChannels = outputShape[isChannelsLast ? 3 : 1];
        const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;
        if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {
          const batch = outputShape[0];
          let xReshaped, wReshaped, matmulOutputShape;
          const matmulInputs = [];
          if (isChannelsLast) {
            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(
              createTransposeProgramInfo(inputs[1], weightTransposeAttribute),
              { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }
            )[0];
            if (attributes.wIsConst && !context.kernelCustomData.wT) {
              context.kernelCustomData.wT = transposedWeight2;
            }
            if (sameSize) {
              const sharedDim = inputHeight * inputWidth * inputChannels;
              xReshaped = inputs[0].reshape([1, batch, sharedDim]);
              wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);
              matmulOutputShape = [1, batch, outChannels];
            } else {
              xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);
              wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);
              matmulOutputShape = [batch, outHeight * outWidth, outChannels];
            }
            matmulInputs.push(xReshaped);
            matmulInputs.push(wReshaped);
          } else {
            xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);
            wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);
            matmulOutputShape = [batch, outChannels, outHeight * outWidth];
            matmulInputs.push(wReshaped);
            matmulInputs.push(xReshaped);
          }
          if (hasBias) {
            matmulInputs.push(inputs[2]);
          }
          const N = matmulOutputShape[2];
          const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];
          if (N < 8 && K < 8) {
            context.compute(
              createNaiveMatmulProgramInfo(
                matmulInputs,
                adjustedAttributes,
                outputShape,
                matmulOutputShape,
                isChannelsLast
              ),
              { inputs: matmulInputs }
            );
          } else {
            context.compute(
              createMatmulProgramInfo(matmulInputs, adjustedAttributes, outputShape, matmulOutputShape, isChannelsLast),
              { inputs: matmulInputs }
            );
          }
          return;
        }
        const sequentialAccessByThreads = (
          /* backend.adapterInfo.isIntel() */
          true
        );
        const transposedWeight = context.kernelCustomData.wT ?? context.compute(
          createTransposeProgramInfo(inputs[1], weightTransposeAttribute),
          { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }
        )[0];
        if (attributes.wIsConst && !context.kernelCustomData.wT) {
          context.kernelCustomData.wT = transposedWeight;
        }
        const convInputs = [inputs[0], transposedWeight];
        if (hasBias) {
          convInputs.push(inputs[2]);
        }
        const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
        const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
        const dimInner = weightHeight * weightWidth * inputChannels;
        context.compute(
          createConv2DMatMulProgramInfo(
            convInputs,
            adjustedAttributes,
            outputShape,
            dimAOuter,
            dimBOuter,
            dimInner,
            hasBias,
            sequentialAccessByThreads
          ),
          { inputs: convInputs }
        );
      };
      conv1d = (context, attributes) => {
        const isChannelLast = attributes.format === "NHWC";
        const inputs = [
          context.inputs[0].reshape(
            isChannelLast ? (
              // [N, W, C] -> [N, H=1, W, C]
              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
            ) : (
              // [N, C, W] -> [N, C, H=1, W]
              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
            )
          ),
          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
        ];
        if (context.inputs.length === 3) {
          inputs.push(context.inputs[2]);
        }
        const pads = [0, attributes.pads[0], 0, attributes.pads[1]];
        const strides = [1].concat(attributes.strides);
        const dilations = [1].concat(attributes.dilations);
        const kernelShape = [1].concat(attributes.kernelShape);
        const adjustedAttributes = getAdjustedConvAttributes({ ...attributes, pads, strides, dilations, kernelShape }, inputs);
        context.compute(createGroupedConvProgramInfo(
          inputs,
          adjustedAttributes,
          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : []
        ));
      };
      conv3d = (context, inputs, attributes) => {
        const format = attributes.format === "NHWC" ? "channelsLast" : "channelsFirst";
        const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
        const pads = attributes.autoPad === "NOTSET" ? attributes.pads : attributes.autoPad;
        const convInfo = computeConv3DInfo(
          inputs[0].dims,
          inputs[1].dims,
          attributes.strides,
          attributes.dilations,
          pads,
          false,
          format
        );
        context.compute(createConv3DNaiveProgramInfo(
          inputs,
          adjustedAttributes,
          convInfo.outShape,
          [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth],
          [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left],
          format
        ));
      };
      conv = (context, attributes) => {
        validateInputs9(context.inputs, attributes);
        if (context.inputs[0].dims.length === 3) {
          conv1d(context, attributes);
        } else if (context.inputs[0].dims.length === 5) {
          conv3d(context, context.inputs, attributes);
        } else {
          conv2d(context, context.inputs, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts
  var conv2dTransposeCommonSnippet, createConv2DTransposeMatMulProgramInfo;
  var init_conv_backprop_mm_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_common();
      init_fuse_utils();
      init_activation_util();
      init_conv_util();
      init_matmul_packed_webgpu();
      conv2dTransposeCommonSnippet = (isChannelsLast, addBias = false, attributes, type, innerElementSize = 4) => {
        const getWSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";
            case 4:
              return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${type}(v0, v1, v2, v3);
            `;
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const coordASnippet = isChannelsLast ? `
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `;
        const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
        const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
        const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
        const row = isChannelsLast ? "row" : "col";
        const col = isChannelsLast ? "col" : "row";
        const readASnippet = `
      let inChannels = ${isChannelsLast ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"};
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      let outRow = ${row} / outWidth;
      let outCol = ${row} % outWidth;

      let WRow = ${col} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${col} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${xHeight}) || fract(xR) > 0.0) {
        return ${type}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${xWidth}) || fract(xC) > 0.0) {
        return ${type}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${col} % inChannels;
      ${coordASnippet}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${innerElementSize}];`;
        const sampleA = isChannelsLast ? `
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${readASnippet}
      }
      return ${type}(0.0);` : `
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${readASnippet}
      }
      return ${type}(0.0);`;
        const sampleW = `
      let col = colIn * ${innerElementSize};
      let inChannels = ${isChannelsLast ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${isChannelsLast ? "row < uniforms.dim_inner && col < uniforms.dim_b_outer" : "row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${getWSnippet(innerElementSize)}
      }
      return ${type}(0.0);
      `;
        const applyActivation = getActivationSnippet(attributes, type);
        const userCode = `
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${type} {
    ${isChannelsLast ? sampleA : sampleW}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${type} {
    ${isChannelsLast ? sampleW : sampleA}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${type}) {
    let col = colIn * ${innerElementSize};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${innerElementSize}] = value;
    }
  }`;
        return userCode;
      };
      createConv2DTransposeMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const batchSize = outputShape[0];
        const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
        const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
        const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
        const isVec4 = isChannelsLast && (inChannels % 4 === 0 && inChannels % 3) && outChannels % 4 === 0;
        const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
        const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
        const workGroupSize = [8, 8, 1];
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const dispatch = [
          Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
          Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
        ];
        LOG_DEBUG("verbose", () => `[conv_backprop_mm_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? 4 : 1;
        const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
        const components = isVec4 ? 4 : 1;
        const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
        const effectiveFilterDims = [
          filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (filterDims[0] - 1) * (attributes.dilations[0] - 1)),
          filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (filterDims[1] - 1) * (attributes.dilations[1] - 1))
        ];
        const pads = [
          effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
          effectiveFilterDims[1] - 1 - Math.floor((attributes.pads[1] + attributes.pads[3]) / 2)
        ];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner },
          { type: 6 /* int32 */, data: attributes.strides },
          { type: 6 /* int32 */, data: attributes.dilations },
          { type: 6 /* int32 */, data: filterDims },
          { type: 6 /* int32 */, data: pads }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length, components);
          const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, 1);
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          const inputVariables = [x, w];
          let declareFunctions = "";
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${bias.type.value} {
            return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
          }`;
          }
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" },
            { name: "strides", type: "i32", length: 2 },
            { name: "dilations", type: "i32", length: 2 },
            { name: "filter_dims", type: "i32", length: filterDims.length },
            { name: "pads", type: "i32", length: pads.length }
          ];
          appendActivationUniforms(attributes, uniforms);
          const elemType = tensorTypeToWsglStorageType(inputs[0].dataType, 1);
          if (elemType !== "f16" && elemType !== "f32") {
            throw new Error(`elemType ${elemType} is not supported.`);
          }
          return `
        ${utilFunctions("uniforms.result_strides")}
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)};
        ${declareFunctions}
        ${conv2dTransposeCommonSnippet(isChannelsLast, hasBias, attributes, x.type.value, innerElementSize)}
        ${isVec4 ? makeMatMulPackedVec4Source(
            elementsPerThread,
            workGroupSize,
            elemType,
            void 0,
            !isChannelsLast,
            tileInner
          ) : makeMatMulPackedSource(
            elementsPerThread,
            workGroupSize,
            elemType,
            void 0,
            !isChannelsLast,
            tileInner,
            false,
            void 0,
            sequentialAccessByThreads
          )}`;
        };
        return {
          name: "Conv2DTransposeMatMul",
          shaderCache: { hint: `${attributes.cacheKey};${elementsPerThread};${workGroupSize};${isVec4}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts
  var createConvTranspose2DOpProgramShaderSource, createConvTranspose2DProgramInfo;
  var init_conv_backprop_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_common();
      createConvTranspose2DOpProgramShaderSource = (shaderHelper, inputs, outputShape, hasBias, is1DimensionDispatch, isVec4 = false, dataType, uniforms, isChannelsLast = false) => {
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        const workPerThread = isVec4 ? 2 : 1;
        let declareFunctions = `
  fn setOutputAtIndex(flatIndex : u32, value : ${isVec4 ? `vec4<${dataType}>` : dataType}) {
    result[flatIndex] = ${isVec4 ? `vec4<${dataType}>` : dataType}(value);
  }`;
        if (hasBias) {
          declareFunctions += `
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${isVec4 ? `vec4<${dataType}>` : dataType} {
      return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
    }`;
        }
        const components = isVec4 ? 4 : 1;
        const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
        const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims.length, components);
        const inputVariables = [dy, w];
        if (hasBias) {
          inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]].length, components));
        }
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        const codeSnippet4 = `{
        let batch: u32 = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${is1DimensionDispatch ? "global_id.y" : "workgroup_id.y"} * ${workPerThread};
        let d1: u32 = ${is1DimensionDispatch ? "global_id.x" : "workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${dataType}>, ${workPerThread}>;
        for (var i = 0; i < ${workPerThread}; i++) {
          dotProd[i] = vec4<${dataType}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${dataType}(dyCorner.x) + ${dataType}(wR)) / ${dataType}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${dataType}(dyCorner.y) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
            let dyC2 = (${dataType}(dyCorner.y) + 1.0 + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${dataType}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${dy.get("batch", "idyR", "idyC2", "d2")};

                dotProd[1] = dotProd[1] + vec4<${dataType}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${channelDim}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC2", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${workPerThread}; i = i + 1) {
          let value = dotProd[i] + ${hasBias ? "bias[c+i]" : `vec4<${dataType}>(0.0)`};
          ${output.set("batch", "r", "c + i", "d1", "value")};
        }
      }`;
        const codeSnippet = `
          let outputIndices = ${output.offsetToIndices("global_idx")};
          let batch = ${output.indicesGet("outputIndices", 0)};
          let d1 = ${output.indicesGet("outputIndices", channelDim)};
          let r = ${output.indicesGet("outputIndices", rowDim)};
          let c = ${output.indicesGet("outputIndices", colDim)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${dataType}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[${rowDim}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[${colDim}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${isChannelsLast ? dy.get("batch", "idyR", "idyC", "inputChannel") : dy.get("batch", "inputChannel", "idyR", "idyC")};
                let wValue = ${w.get("inputChannel", "wOutChannel", "u32(wRPerm)", "u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${hasBias ? "bias[d1]" : `${dataType}(0.0)`};
          ${output.setByOffset("global_idx", "value")};
        `;
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
  ${declareFunctions}

    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${isVec4 ? codeSnippet4 : codeSnippet}}`;
      };
      createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const outputShape = attributes.outputShape;
        const outputSize = ShapeUtil.size(outputShape);
        const dispatch = [
          Math.ceil(outputSize / 64),
          1,
          1
        ];
        LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);
        const isChannelsLast = attributes.format === "NHWC";
        const inputDependencies = ["rank", "rank"];
        const strides = [attributes.strides[0], attributes.strides[1]];
        const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
        const dilations = [attributes.dilations[0], attributes.dilations[1]];
        const effectiveFilterDims = [
          filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)),
          filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1))
        ];
        const pads = [
          effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
          effectiveFilterDims[1] - 1 - Math.floor(attributes.pads[1] + attributes.pads[3]) / 2
        ];
        const isVec4 = false;
        const group = attributes.group;
        const wShape = inputs[1].dims;
        const inputChannelsPerGroup = wShape[0] / group;
        const outputChannelsPerGroup = wShape[1];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: strides },
          { type: 12 /* uint32 */, data: filterDims },
          { type: 12 /* uint32 */, data: dilations },
          { type: 12 /* uint32 */, data: effectiveFilterDims },
          { type: 6 /* int32 */, data: pads },
          { type: 12 /* uint32 */, data: inputChannelsPerGroup },
          { type: 12 /* uint32 */, data: outputChannelsPerGroup },
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims)
        ];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const is1DimensionDispatch = dispatch[1] === 1 && dispatch[2] === 1;
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "strides", type: "u32", length: strides.length },
            { name: "filter_dims", type: "u32", length: filterDims.length },
            { name: "dilations", type: "u32", length: filterDims.length },
            { name: "effective_filter_dims", type: "u32", length: effectiveFilterDims.length },
            { name: "pads", type: "i32", length: pads.length },
            { name: "input_channels_per_group", type: "u32" },
            { name: "output_channels_per_group", type: "u32" }
          ];
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          return `${createConvTranspose2DOpProgramShaderSource(
            shaderHelper,
            inputs,
            outputShape,
            hasBias,
            is1DimensionDispatch,
            isVec4,
            dataType,
            uniforms,
            isChannelsLast
          )}`;
        };
        return {
          name: "ConvTranspose2D",
          shaderCache: { hint: `${attributes.cacheKey};`, inputDependencies },
          getRunData: () => ({
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            outputs: [{
              dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
              dataType: inputs[0].dataType
            }],
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts
  var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs10, weightTransposePerm, convTranspose2d, convTranspose1d, convTranspose;
  var init_conv_transpose = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {
      "use strict";
      init_conv_backprop_mm_webgpu();
      init_conv_backprop_webgpu();
      init_fuse_utils();
      init_transpose();
      computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
      distributePadding = (totalPad, autoPad, pads, head, tail) => {
        const smallPad = Math.floor(totalPad / 2);
        if (autoPad === "SAME_UPPER") {
          pads[head] = smallPad;
          pads[tail] = totalPad - smallPad;
        } else if (autoPad === "SAME_LOWER") {
          pads[head] = totalPad - smallPad;
          pads[tail] = smallPad;
        }
      };
      calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {
        const spatialRank = inputShape.length - 2;
        const updateOutputShape = outputShape.length === 0;
        if (outputPadding.length === 0) {
          for (let i = 0; i < spatialRank; ++i) {
            outputPadding.push(0);
          }
        }
        const batchSize = inputShape[0];
        const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;
        for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {
          const inSize = inputShape[j];
          const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];
          const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);
          distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
          if (updateOutputShape) {
            outputShape.push(
              strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
            );
          }
        }
        outputShape.splice(0, 0, batchSize);
        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
      };
      getAdjustedConvTransposeAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {
          kernelShape.length = 0;
          for (let i = 2; i < inputs[1].dims.length; ++i) {
            kernelShape.push(inputs[1].dims[i]);
          }
        }
        const isChannelsLast = attributes.format === "NHWC";
        kernelShape.splice(0, 0, inputs[1].dims[0]);
        kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);
        const pads = attributes.pads.slice();
        const outputShape = attributes.outputShape.slice();
        const outputPadding = attributes.outputPadding.slice();
        const inputShape = inputs[0].dims;
        let dilations = attributes.dilations.slice();
        if (dilations.reduce((a, b) => a + b, 0) === 0) {
          const spatialRank = inputs[0].dims.length - 2;
          dilations = new Array(spatialRank).fill(1);
        }
        let strides = attributes.strides.slice();
        if (strides.reduce((a, b) => a + b, 0) === 0) {
          const spatialRank = inputs[0].dims.length - 2;
          strides = new Array(spatialRank).fill(1);
        }
        calculateOutputShapeAndPads(
          inputShape,
          kernelShape,
          dilations,
          attributes.autoPad,
          attributes.group,
          pads,
          strides,
          isChannelsLast,
          outputPadding,
          outputShape
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides });
        return newAttributes;
      };
      parseConvTransposeAttributes = (attributes) => {
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const format = attributes.format;
        const autoPad = [
          "NOTSET",
          "VALID",
          "SAME_UPPER",
          "SAME_LOWER"
        ][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];
        const dilations = attributes.dilations;
        const group = attributes.group;
        const kernelShape = attributes.kernelShape;
        const pads = attributes.pads;
        const strides = attributes.strides;
        const wIsConst = attributes.wIsConst();
        const outputPadding = attributes.outputPadding;
        const outputShape = attributes.outputShape;
        return {
          autoPad,
          format,
          dilations,
          group,
          kernelShape,
          outputPadding,
          outputShape,
          pads,
          strides,
          wIsConst,
          ...activationAttributes,
          cacheKey: `${attributes.format};${activationAttributes.activation};`
        };
      };
      validateInputs10 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
          throw new Error("currently only support 2-dimensional conv");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("filter does not have same dimension as input");
        }
        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
        const filterInChannel = inputs[1].dims[0];
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        const featureMaps = inputs[1].dims[1] * attributes.group;
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;
        if (dilationsSet && attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;
        if (stridesSet && attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;
        if (padsSet && attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {
          throw new Error(`output_padding should be ${spatialRank}D`);
        }
        const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;
        if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
        if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
          throw new Error("invalid output shape");
        }
      };
      weightTransposePerm = [2, 3, 1, 0];
      convTranspose2d = (context, inputs, attributes) => {
        const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);
        const isChannelsLast = attributes.format === "NHWC";
        const outputShape = adjustedAttributes.outputShape;
        const outChannels = outputShape[isChannelsLast ? 3 : 1];
        const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
        if (adjustedAttributes.group !== 1 || outChannels === 1 && inputChannels === 1) {
          context.compute(createConvTranspose2DProgramInfo(inputs, adjustedAttributes));
          return;
        }
        const outHeight = outputShape[isChannelsLast ? 1 : 2];
        const outWidth = outputShape[isChannelsLast ? 2 : 3];
        const weightHeight = inputs[1].dims[2];
        const weightWidth = inputs[1].dims[3];
        const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
        const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
        const dimInner = weightHeight * weightWidth * inputChannels;
        const sequentialAccessByThreads = (
          /* backend.adapterInfo.isIntel() */
          true
        );
        const transposedWeight = context.kernelCustomData.wT ?? context.compute(
          createTransposeProgramInfo(inputs[1], weightTransposePerm),
          { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }
        )[0];
        if (attributes.wIsConst && !context.kernelCustomData.wT) {
          context.kernelCustomData.wT = transposedWeight;
        }
        const convTransposeInputs = [inputs[0], transposedWeight];
        const hasBias = inputs.length === 3;
        if (hasBias) {
          if (!isChannelsLast && inputs[2].dims.length === 1) {
            convTransposeInputs.push(inputs[2].reshape([inputs[2].dims[0], 1, 1]));
          } else {
            convTransposeInputs.push(inputs[2]);
          }
        }
        context.compute(
          createConv2DTransposeMatMulProgramInfo(
            convTransposeInputs,
            adjustedAttributes,
            outputShape,
            dimAOuter,
            dimBOuter,
            dimInner,
            hasBias,
            sequentialAccessByThreads
          ),
          { inputs: convTransposeInputs }
        );
      };
      convTranspose1d = (context, attributes) => {
        const isChannelLast = attributes.format === "NHWC";
        const inputs = [
          context.inputs[0].reshape(
            isChannelLast ? (
              // [N, W, C] -> [N, H=1, W, C]
              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
            ) : (
              // [N, C, W] -> [N, C, H=1, W]
              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
            )
          ),
          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
        ];
        if (context.inputs.length === 3) {
          inputs.push(context.inputs[2]);
        }
        let kernelShape = attributes.kernelShape;
        if (kernelShape.length === 0 || kernelShape[0] === 0) {
          kernelShape = [context.inputs[1].dims[2]];
        }
        let dilations = attributes.dilations;
        if (dilations.length === 0 || dilations[0] === 0) {
          dilations = [1];
        }
        let strides = attributes.strides;
        if (strides.length === 0 || strides[0] === 0) {
          strides = [1];
        }
        let pads = attributes.pads;
        if (pads.length === 0) {
          pads = [0, 0];
        }
        pads = [0, pads[0], 0, pads[1]];
        strides = [1].concat(strides);
        dilations = [1].concat(dilations);
        kernelShape = [1].concat(kernelShape);
        const adjustedAttributes = getAdjustedConvTransposeAttributes({ ...attributes, pads, strides, dilations, kernelShape }, inputs);
        context.compute(createConvTranspose2DProgramInfo(
          inputs,
          adjustedAttributes,
          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
        ));
      };
      convTranspose = (context, attributes) => {
        validateInputs10(context.inputs, attributes);
        if (context.inputs[0].dims.length === 3) {
          convTranspose1d(context, attributes);
        } else {
          convTranspose2d(context, context.inputs, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/cumsum.ts
  var createCumsumProgramInfo, cumsum, parseCumSumAttributes;
  var init_cumsum = __esm({
    "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {
        const outputSize = ShapeUtil.size(inputShape);
        const rank = inputShape.length;
        const input = inputVariable("input", inputType, rank);
        const output = outputVariable("output", inputType, rank);
        const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);
        const axis = ShapeUtil.normalizeAxis(axisValue, rank);
        const getShaderSource = (shaderHelper) => {
          const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;
          const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);
          const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";
          const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");
          return `
                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}
                ${shaderHelper.mainStart()}
                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${output.offsetToIndices("global_idx")};
                  var sum = ${output.type.value}(0);
                  let first : i32 = ${lowerLimit};
                  let last : i32 = ${upperLimit};
                  for (var i : i32 = first; i < last; i++) {
                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${input.getByIndices("inputIndices")};
                  }
                  ${output.setByOffset("global_idx", "sum")};
                }`;
        };
        return {
          name: "CumSum",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: inputShape, dataType: inputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              { type: 12 /* uint32 */, data: axis },
              ...createTensorShapeVariables(inputShape, inputShape)
            ]
          }),
          getShaderSource
        };
      };
      cumsum = (context, attributes) => {
        const inputShape = context.inputs[0].dims;
        const inputType = context.inputs[0].dataType;
        const axis = context.inputs[1];
        context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });
      };
      parseCumSumAttributes = (attributes) => {
        const exclusive = attributes.exclusive === 1;
        const reverse = attributes.reverse === 1;
        return createAttributeWithCacheKey({ exclusive, reverse });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts
  var validateInputs11, permFunctionBody2, createDepthToSpaceProgramInfo, depthToSpace, parseDepthToSpaceAttributes;
  var init_depth_to_space = __esm({
    "web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs11 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("DepthToSpace requires 1 input.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error("DepthToSpace requires 4D input.");
        }
      };
      permFunctionBody2 = (perm, rank, input, output) => {
        const reverseFunc = [];
        reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
        for (let i = 0; i < rank; ++i) {
          reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
        }
        reverseFunc.push("return a;}");
        return reverseFunc.join("\n");
      };
      createDepthToSpaceProgramInfo = (inputTensor, attributes) => {
        let n, h, w, c;
        let shape;
        let perm;
        const isChannelLast = attributes.format === "NHWC";
        const blocksize = attributes.blocksize;
        const isDCRmode = attributes.mode === "DCR";
        if (isChannelLast) {
          [n, h, w, c] = inputTensor.dims;
          shape = isDCRmode ? [n, h, w, blocksize, blocksize, c / blocksize ** 2] : [n, h, w, c / blocksize ** 2, blocksize, blocksize];
          perm = isDCRmode ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3];
        } else {
          [n, h, w, c] = [inputTensor.dims[0], inputTensor.dims[2], inputTensor.dims[3], inputTensor.dims[1]];
          shape = isDCRmode ? [n, blocksize, blocksize, c / blocksize ** 2, h, w] : [n, c / blocksize ** 2, blocksize, blocksize, h, w];
          perm = isDCRmode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
        }
        const reshapedInputTensor = inputTensor.reshape(shape);
        const reshapedInputRank = reshapedInputTensor.dims.length;
        const inputDataType = inputTensor.dataType;
        const reshapedInput = inputVariable("a", inputDataType, reshapedInputRank);
        const permedOutput = outputVariable("output", inputDataType, reshapedInputRank);
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(reshapedInput, permedOutput)}

  ${permFunctionBody2(perm, reshapedInputRank, reshapedInput, permedOutput)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${permedOutput.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${permedOutput.setByOffset("global_idx", reshapedInput.getByIndices("aIndices"))}
  }`;
        return {
          name: "DepthToSpace",
          shaderCache: { hint: `${inputTensor.dims};${attributes.blocksize};${attributes.mode}`, inputDependencies: ["rank"] },
          getRunData: (inputs) => {
            const outputShape = isChannelLast ? [n, h * blocksize, w * blocksize, c / blocksize ** 2] : [n, c / blocksize ** 2, h * blocksize, w * blocksize];
            const outputSize = ShapeUtil.size(outputShape);
            const shapeBeforePerm = reshapedInputTensor.dims;
            const shapeAfterPerm = ShapeUtil.sortBasedOnPerm(shapeBeforePerm, perm);
            return {
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(shapeBeforePerm, shapeAfterPerm)]
            };
          },
          getShaderSource
        };
      };
      depthToSpace = (context, attributes) => {
        validateInputs11(context.inputs);
        context.compute(createDepthToSpaceProgramInfo(context.inputs[0], attributes));
      };
      parseDepthToSpaceAttributes = (attributes) => createAttributeWithCacheKey({
        blocksize: attributes.blocksize,
        mode: attributes.mode,
        format: attributes.format
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/einsum.ts
  var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;
  var init_einsum = __esm({
    "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      symbolPattern = "[a-zA-Z]|\\.\\.\\.";
      termPattern = "(" + symbolPattern + ")+";
      termPatternOnly = "^" + termPattern + "$";
      lhsPattern = "(" + termPattern + ",)*" + termPattern;
      lhsPatternOnly = "^" + lhsPattern + "$";
      EinsumTerm = class {
        constructor(inputIndex = -1) {
          this.symbolToIndices = /* @__PURE__ */ new Map();
          this.inputIndex = inputIndex;
        }
        // Add a symbol to the term
        addSymbol(symbol, index) {
          let value = this.symbolToIndices.get(symbol);
          if (value === void 0) {
            value = [index];
          } else {
            value.push(index);
          }
          this.symbolToIndices.set(symbol, value);
        }
        // -1 for output and 0, 1, 2, ... for inputs
      };
      EinsumEquation = class {
        constructor(inputs, equation) {
          this.equation = equation;
          this.hasEllipsis = false;
          this.symbolToInfo = /* @__PURE__ */ new Map();
          this.lhs = new Array();
          this.outputDims = [];
          let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];
          if (!lhs.match(RegExp(lhsPatternOnly))) {
            throw new Error("Invalid LHS term");
          }
          const inputTerms = lhs.split(",");
          inputTerms.forEach((inputTerm, index) => {
            const dims = inputs[index].dims.slice();
            if (!inputTerm.match(RegExp(termPatternOnly))) {
              throw new Error("Invalid LHS term");
            }
            const einsumTerm = this.processTerm(inputTerm, true, dims, index);
            this.lhs.push(einsumTerm);
          });
          if (rhs === "") {
            rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");
          } else {
            if (!rhs.match(RegExp(termPattern))) {
              throw new Error("Invalid RHS");
            }
          }
          const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));
          rhsSymbols?.forEach((symbol) => {
            if (symbol === "...") {
              this.outputDims = this.outputDims.concat(this.ellipsisDims);
            } else {
              const info = this.symbolToInfo.get(symbol);
              if (info === void 0) {
                throw new Error("Invalid RHS symbol");
              }
              this.outputDims.push(info.dimValue);
            }
          });
          this.rhs = this.processTerm(rhs, false, this.outputDims);
        }
        // End of EinsumEqation constructor
        // Add a symbol to the equation
        addSymbol(symbol, dimValue, inputIndex) {
          let info = this.symbolToInfo.get(symbol);
          if (info !== void 0) {
            if (info.dimValue !== dimValue && info.count !== 1) {
              throw new Error("Dimension mismatch");
            } else {
              info.count++;
              info.inputIndices.push(inputIndex);
            }
          } else {
            info = { count: 1, dimValue, inputIndices: [inputIndex] };
          }
          this.symbolToInfo.set(symbol, info);
        }
        // Process one input/output term
        processTerm(term, isInput, dims, index = -1) {
          const rank = dims.length;
          let ellipsis = false;
          let ellipsisDims = [];
          let nextDim = 0;
          if (!term.match(RegExp(termPatternOnly)) && (!isInput && term !== "")) {
            throw new Error("Invalid LHS term");
          }
          const indexSymbols = term.match(RegExp(symbolPattern, "g"));
          const einsumTerm = new EinsumTerm(index);
          indexSymbols?.forEach((symbol, i) => {
            if (symbol === "...") {
              if (ellipsis) {
                throw new Error("Only one ellipsis is allowed per input term");
              }
              ellipsis = true;
              const ellipsisDimLength = rank - indexSymbols.length + 1;
              if (ellipsisDimLength < 0) {
                throw new Error("Ellipsis out of bounds");
              }
              ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);
              if (this.hasEllipsis) {
                if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {
                  throw new Error("Ellipsis dimensions mismatch");
                }
              } else if (isInput) {
                this.hasEllipsis = true;
                this.ellipsisDims = ellipsisDims;
              } else {
                throw new Error("Ellipsis must be specified in the LHS");
              }
              for (let j = 0; j < ellipsisDims.length; j++) {
                const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);
                einsumTerm.addSymbol(symbol2, i + j);
                this.addSymbol(symbol2, dims[nextDim++], index);
              }
            } else {
              einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));
              this.addSymbol(symbol, dims[nextDim++], index);
            }
          });
          return einsumTerm;
        }
        // Output dimensions of the equation
      };
      appendMax = (name) => name + "_max";
      createEinsumProgramInfo = (inputShapes, dataType, einsumEquation, outputShape) => {
        const ranks = inputShapes.map((dims) => dims.length);
        const inputVars = ranks.map((rank, index) => inputVariable(`input${index}`, dataType, rank));
        const outputSize = ShapeUtil.size(outputShape);
        const output = outputVariable("output", dataType, outputShape.length);
        const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter((symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol));
        const getShaderSource = (shaderHelper) => {
          const idxCopy = [];
          const initProd = "var prod = 1.0;";
          const initSum = "var sum = 0.0;";
          const updateSum = "sum += prod;";
          const reduceOpsSetIndices = [];
          const reduceOpsLoopHeaders = [];
          const reduceOpsLoopFooters = [];
          const reduceOpCompute = [];
          const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;
          einsumEquation.symbolToInfo.forEach((info, symbol) => {
            if (einsumEquation.rhs.symbolToIndices.has(symbol)) {
              const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];
              if (outputIndex !== void 0) {
                einsumEquation.lhs.forEach((term, i) => {
                  if (info.inputIndices.includes(i)) {
                    const indices = term.symbolToIndices.get(symbol);
                    if (indices === void 0) {
                      throw new Error("Invalid symbol error");
                    }
                    indices.forEach((index) => {
                      idxCopy.push(`${inputVars[i].indicesSet(
                        `input${i}Indices`,
                        index,
                        output.indicesGet("outputIndices", outputIndex)
                      )}`);
                    });
                  }
                });
              }
            } else {
              einsumEquation.lhs.forEach((term, i) => {
                if (info.inputIndices.includes(i)) {
                  const indices = term.symbolToIndices.get(symbol);
                  if (indices === void 0) {
                    throw new Error("Invalid symbol error");
                  }
                  indices.forEach((index) => {
                    reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);
                  });
                  reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);
                }
              });
              reduceOpsLoopHeaders.push(
                `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`
              );
              reduceOpsLoopFooters.push("}");
            }
          });
          const reduceOps2 = isReduceOpsWithoutLoop ? [
            ...idxCopy,
            `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`
          ] : [
            ...idxCopy,
            initSum,
            ...reduceOpsLoopHeaders,
            ...reduceOpsSetIndices,
            initProd,
            ...reduceOpCompute,
            updateSum,
            ...reduceOpsLoopFooters
          ];
          return `
            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}

            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${output.offsetToIndices("global_idx")};
            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\n")}
            ${reduceOps2.join("\n")};
            ${output.setByOffset("global_idx", "sum")};
          }`;
        };
        return {
          name: "Einsum",
          shaderCache: { hint: einsumEquation.equation, inputDependencies: inputShapes.map(() => "rank") },
          getRunData: () => {
            const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map(
              (symbol) => ({ type: 12 /* uint32 */, data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 })
            );
            programUniformsInit.push({ type: 12 /* uint32 */, data: outputSize });
            const programUniforms = inputShapes.map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);
            programUniforms.push(...createTensorShapeVariables(outputShape));
            return {
              outputs: [{ dims: outputShape, dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            };
          },
          getShaderSource
        };
      };
      einsum = (context, attributes) => {
        const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);
        const outputShape = einsumEquation.outputDims;
        const inputShapes = context.inputs.map((input, _) => input.dims);
        context.compute(createEinsumProgramInfo(inputShapes, context.inputs[0].dataType, einsumEquation, outputShape));
      };
      parseEinsumAttributes = (attributes) => {
        const equation = attributes.equation.replace(/\s+/g, "");
        return createAttributeWithCacheKey({ equation });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/expand.ts
  var validateInputs12, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;
  var init_expand = __esm({
    "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs12 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Expand requires 2 input.");
        }
        const inputShape = inputs[0].dims;
        const shape = Array.from(inputs[1].getBigInt64Array(), Number);
        let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;
        let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;
        for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {
          if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {
            throw new Error("Expand requires shape to be broadcastable to input");
          }
        }
      };
      getAdjustedShape = (shape1, shape2) => {
        const diff = shape1.length - shape2.length;
        const shape = [];
        for (let i = 0; i < diff; ++i) {
          shape.push(shape1[i]);
        }
        for (let i = 0; i < shape2.length; ++i) {
          shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);
        }
        return shape;
      };
      calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);
      createExpandProgramInfo = (inputs) => {
        const inputShape = inputs[0].dims;
        const shape = Array.from(inputs[1].getBigInt64Array(), Number);
        const outputShape = calculateOutputShape2(inputShape, shape);
        const dataType = inputs[0].dataType;
        const components = dataType === 9 /* bool */ ? 4 : 1;
        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", dataType, inputShape.length, components);
          const output = outputVariable("output", dataType, outputShape.length, components);
          let assignment;
          if (dataType === 9 /* bool */) {
            const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);
        `;
            assignment = `
        let outputOffset = global_idx * ${components};
        var data = vec4<u32>(0);
        ${singleAssignment("data", 0, "u32")}
        ${singleAssignment("data", 1, "u32")}
        ${singleAssignment("data", 2, "u32")}
        ${singleAssignment("data", 3, "u32")}
        ${output.setByOffset("global_idx", "data")}
      }`;
          } else {
            assignment = `
        let outputIndices = ${output.offsetToIndices("global_idx")};
        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};
        ${output.setByOffset("global_idx", input.getByOffset("inputOffset"))}
      }`;
          }
          return `
    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}
    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${assignment}`;
        };
        const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(inputShape, outputShape)];
        return {
          name: "Expand",
          shaderCache: { hint: `${outputShape.length}`, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      expand = (context) => {
        validateInputs12(context.inputs);
        context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts
  var createFastGeluProgramInfo, fastGelu2;
  var init_fast_gelu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_unary_op();
      createFastGeluProgramInfo = (inputTensors) => {
        const dataType = inputTensors[0].dataType;
        const outputSize = ShapeUtil.size(inputTensors[0].dims);
        const biasLength = ShapeUtil.size(inputTensors[1].dims);
        const useVec4 = biasLength % 4 === 0;
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", dataType, [1], 4);
          const bias = inputVariable("bias", dataType, [1], 4);
          const y = outputVariable("y", dataType, [1], 4);
          const uniforms = [{ name: "output_vec_size", type: "u32" }, { name: "bias_size", type: "u32" }];
          const singleElementBias = (i) => `
      let bias${i}_offset: u32 = (global_idx * 4 + ${i}) % uniforms.bias_size;
      let bias${i} = ${bias.getByOffset(`bias${i}_offset / 4`)}[bias${i}_offset % 4];`;
          const biasGetExpression = useVec4 ? `
      let bias = ${bias.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${singleElementBias(0)}${singleElementBias(1)}${singleElementBias(2)}${singleElementBias(3)}
      let bias = ${x.type.value}(bias0, bias1, bias2, bias3);`;
          return `${shaderHelper.registerUniforms(uniforms).declareVariables(x, bias, y)}

    ${fastGeluImpl(tensorTypeToWsglValueType(dataType))}

    ${shaderHelper.mainStart(WORKGROUP_SIZE)}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${x.getByOffset("global_idx")};
      ${biasGetExpression}
      let x_in = x + bias;
      ${y.setByOffset("global_idx", fastGeluExpression("x_in"))}
    }`;
        };
        return {
          name: "FastGeluWithBias",
          shaderCache: { hint: `${useVec4}`, inputDependencies: ["type", "type"] },
          getShaderSource,
          getRunData: (inputs) => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            programUniforms: [{ type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) }, { type: 12 /* uint32 */, data: biasLength }],
            dispatchGroup: { x: Math.ceil(outputSize / WORKGROUP_SIZE / 4) }
          })
        };
      };
      fastGelu2 = (context) => {
        if (context.inputs.length < 2 || ShapeUtil.size(context.inputs[1].dims) === 0) {
          fastGelu(context);
        } else {
          context.compute(createFastGeluProgramInfo(context.inputs));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather.ts
  var validateInputs13, createGatherProgramInfo, parseGatherAttributes, gather;
  var init_gather = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs13 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Gather requires 2 inputs.");
        }
      };
      createGatherProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const inputRank = inputShape.length;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const outputShape = inputShape.slice(0);
        outputShape.splice(axis, 1, ...indicesShape);
        const axisDimLimit = inputShape[axis];
        const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;
        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: axisDimLimit },
          { type: 12 /* uint32 */, data: axis },
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length, components);
          const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
          const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
          const calcDataIndices = (x) => {
            const indicesRank = indicesShape.length;
            let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;
            for (let i = 0; i < indicesRank; i++) {
              calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;
            }
            calcStr += `
          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${data.type.indices};
        `;
            for (let i = 0, j = 0; i < inputRank; i++) {
              if (i === axis) {
                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;
                j += indicesRank;
              } else {
                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;
                j++;
              }
            }
            return calcStr;
          };
          let assignment;
          if (inputs[0].dataType === 9 /* bool */) {
            const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          ${calcDataIndices(x)};
          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);
        `;
            assignment = `
        let outputOffset = global_idx * ${components};
        var value = vec4<u32>(0);
        ${singleAssignment("value", 0, "u32")}
        ${singleAssignment("value", 1, "u32")}
        ${singleAssignment("value", 2, "u32")}
        ${singleAssignment("value", 3, "u32")}
        ${output.setByOffset("global_idx", "value")}
      `;
          } else {
            assignment = `
      let outputIndices = ${output.offsetToIndices("global_idx")};
      ${calcDataIndices("")};
      let value = ${data.getByIndices("dataIndices")};
      ${output.setByOffset("global_idx", "value")};
      `;
          }
          return `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${assignment}
      }`;
        };
        return {
          name: "Gather",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
          getRunData: () => ({
            outputs: [
              { dims: outputShape, dataType: inputs[0].dataType }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
      gather = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs13(inputs);
        context.compute(createGatherProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-elements.ts
  var validateInputs14, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;
  var init_gather_elements = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs14 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("GatherElements requires 2 inputs.");
        }
        if (inputs[0].dims.length < 1) {
          throw new Error("GatherElements requires that the data input be rank >= 1.");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
        }
      };
      createGatherElementsProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputOutputDataType = inputs[0].dataType;
        const inputRank = inputShape.length;
        const indicesShape = inputs[1].dims;
        const indicesDataType = inputs[1].dataType;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const axisDimLimit = inputShape[axis];
        const outputShape = indicesShape.slice(0);
        const outputSize = ShapeUtil.size(outputShape);
        const input = inputVariable("input", inputOutputDataType, inputRank);
        const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);
        const output = outputVariable("output", inputOutputDataType, outputShape.length);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: axisDimLimit },
          { type: 12 /* uint32 */, data: axis }
        ];
        programUniforms.push(...createTensorShapeVariables(inputShape, indicesShape, outputShape));
        const inputDependencies = ["rank", "rank"];
        const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${output.offsetToIndices("global_idx")};

      var idx = ${indices.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${input.type.indices}(outputIndices);
      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${input.getByIndices("inputIndices")};

      ${output.setByOffset("global_idx", "value")};
  }`;
        return {
          name: "GatherElements",
          shaderCache: { inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
      gatherElements = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs14(inputs);
        context.compute(createGatherElementsProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gemm.ts
  var validateInputs15, createGemmProgramInfo, parseGemmAttributes, gemm;
  var init_gemm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs15 = (inputs) => {
        if (!inputs) {
          throw new Error("Input is missing");
        }
        if (inputs.length < 2 || inputs.length > 3) {
          throw new Error("Invaid input number.");
        }
        if (inputs.length === 3 && inputs[2].dims.length > 2) {
          throw new Error("Invalid input shape of C");
        }
        if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("Input types are mismatched");
        }
      };
      createGemmProgramInfo = (inputs, attributes) => {
        const aShape = inputs[0].dims.slice();
        const bShape = inputs[1].dims.slice();
        const [M, N, K] = GemmUtil.getShapeOfGemmResult(
          aShape,
          attributes.transA,
          bShape,
          attributes.transB,
          inputs.length === 3 ? inputs[2].dims : void 0
        );
        const outputShape = [M, N];
        if (!outputShape) {
          throw new Error("Can't use gemm on the given tensors");
        }
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: K },
          { type: 1 /* float */, data: attributes.alpha },
          { type: 1 /* float */, data: attributes.beta }
        ];
        const inputDependencies = ["type", "type"];
        if (inputs.length === 3) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          let line = "";
          if (attributes.transA && attributes.transB) {
            line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";
          } else if (attributes.transA && !attributes.transB) {
            line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";
          } else if (!attributes.transA && attributes.transB) {
            line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";
          } else if (!attributes.transA && !attributes.transB) {
            line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";
          }
          const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
          const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
          const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
          const dataType = a.type.value;
          let c = null;
          const variables = [a, b];
          if (inputs.length === 3) {
            c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
            variables.push(c);
          }
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          variables.push(output);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "beta", type: "f32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${dataType}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${line}
    }

    ${calculateAlpha}
    ${(() => {
            if (c != null) {
              return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
            }
            return "";
          })()}
    output[global_idx] = value;
  }`;
        };
        return {
          name: "Gemm",
          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGemmAttributes = (attributes) => {
        const transA = attributes.transA;
        const transB = attributes.transB;
        const alpha = attributes.alpha;
        const beta = attributes.beta;
        return { transA, transB, alpha, beta, cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}` };
      };
      gemm = (context, attributes) => {
        validateInputs15(context.inputs);
        context.compute(createGemmProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts
  var getInput, validateInputs16, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;
  var init_multihead_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_types();
      init_attention();
      init_common();
      init_transpose();
      getInput = (inputs, i) => inputs.length > i && inputs[i].dims.length > 0 && ShapeUtil.size(inputs[i].dims) > 0 ? inputs[i] : void 0;
      validateInputs16 = (inputs, attributes) => {
        const query = inputs[0];
        const key = getInput(inputs, 1);
        const value = getInput(inputs, 2);
        const bias = getInput(inputs, 3);
        const keyPaddingMask = getInput(inputs, 4);
        const relativePositionBias = getInput(inputs, 5);
        const pastKey = getInput(inputs, 6);
        const pastValue = getInput(inputs, 7);
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error("Input query is expected to have 3 or 5 dimensions");
        }
        const dmmhaPacking = false;
        const batchSize = query.dims[0];
        const sequenceLength = query.dims[1];
        const hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
        let kvSequenceLength = sequenceLength;
        let pastSequenceLength = 0;
        let maxSequenceLength = 0;
        const headSize = Math.floor(hiddenSize / attributes.numHeads);
        if (pastKey && pastValue) {
          if (pastKey.dims.length !== 4) {
            throw new Error('Input "past_key" is expected to have 4 dimensions');
          }
          if (pastKey.dims[0] !== batchSize || pastKey.dims[1] !== attributes.numHeads || pastKey.dims[3] !== headSize) {
            throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
          }
          if (pastValue.dims[0] !== batchSize || pastValue.dims[1] !== attributes.numHeads || pastValue.dims[3] !== headSize) {
            throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
          }
          if (pastKey.dims[2] !== pastValue.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
          }
          if (pastValue.dims.length !== 4) {
            throw new Error('Input "past_value" is expected to have 4 dimensions');
          }
          pastSequenceLength = pastKey.dims[2];
          maxSequenceLength = pastKey.dims[2];
        } else if (pastKey || pastValue) {
          throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
        }
        let qkvFormat;
        if (key) {
          if (query.dims.length !== 3) {
            throw new Error('Input "query" is expected to have 3 dimensions when key is given');
          }
          if (key.dims.length < 3 || key.dims.length > 5) {
            throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
          }
          if (query.dims[0] !== key.dims[0]) {
            throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
          }
          if (key.dims.length === 3) {
            if (key.dims[2] !== query.dims[2]) {
              throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
            }
            qkvFormat = 2 /* qkvBSNH */;
            kvSequenceLength = key.dims[1];
          } else if (key.dims.length === 5) {
            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
            }
            if (value) {
              throw new Error('Expect "value" be none when "key" has packed kv format.');
            }
            qkvFormat = 5 /* qKvBSNHxBSN2H */;
            kvSequenceLength = key.dims[1];
          } else {
            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
            }
            qkvFormat = 0 /* unknown */;
            kvSequenceLength = key.dims[2];
          }
        } else {
          if (query.dims.length !== 3 && query.dims.length !== 5) {
            throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
          }
          if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
            throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
          }
          qkvFormat = 3 /* qkvBSN3H */;
        }
        if (bias) {
          if (bias.dims.length !== 1) {
            throw new Error('Input "bias" is expected to have 1 dimension');
          }
          if (value) {
            if (query.dims.length === 5 && query.dims[3] === 2) {
              throw new Error("bias is not allowed for packed kv.");
            }
          }
        }
        let maskType = 0 /* none */;
        if (keyPaddingMask) {
          maskType = 8 /* maskUnknown */;
          const maskDims = keyPaddingMask.dims;
          if (maskDims.length === 1) {
            if (maskDims[0] === batchSize) {
              maskType = 1 /* mask1dKeySeqLen */;
            } else if (maskDims[0] === 3 * batchSize + 2) {
              maskType = 3 /* mask1DKeySeqLenStart */;
            }
          } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === kvSequenceLength) {
            maskType = 5 /* mask2dKeyPadding */;
          }
          if (maskType === 8 /* maskUnknown */) {
            throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)');
          }
          throw new Error("Mask not supported");
        }
        let passPastInKv = false;
        let vHiddenSize = hiddenSize;
        if (value) {
          if (value.dims.length !== 3 && value.dims.length !== 4) {
            throw new Error('Input "value" is expected to have 3 or 4 dimensions');
          }
          if (query.dims[0] !== value.dims[0]) {
            throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
          }
          if (value.dims.length === 3) {
            if (kvSequenceLength !== value.dims[1]) {
              throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[2];
          } else {
            if (kvSequenceLength !== value.dims[2]) {
              throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[1] * value.dims[3];
            passPastInKv = true;
          }
        }
        const totalSequenceLength = pastSequenceLength + kvSequenceLength;
        const broadcastResPosBias = false;
        if (keyPaddingMask) {
          throw new Error("Key padding mask is not supported");
        }
        if (relativePositionBias) {
          if (relativePositionBias.dims.length !== 4) {
            throw new Error('Input "relative_position_bias" is expected to have 4 dimensions');
          }
          if (relativePositionBias.dims[0] !== batchSize && relativePositionBias.dims[0] !== 1 || relativePositionBias.dims[1] !== attributes.numHeads || relativePositionBias.dims[2] !== sequenceLength || relativePositionBias.dims[3] !== totalSequenceLength) {
            throw new Error('Input "relative_position_bias" shape (batch_size, 1, sequence_length, kv_sequence_length)');
          }
        }
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize: 0,
          hiddenSize,
          vHiddenSize,
          headSize,
          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
          numHeads: attributes.numHeads,
          isUnidirectional: false,
          pastPresentShareBuffer: false,
          maskFilterValue: attributes.maskFilterValue,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias,
          passPastInKv,
          qkvFormat
        };
      };
      parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
      weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
      addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {
        const outputShape = [batchSize, sequenceLength, hiddenSize];
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: biasOffset },
          { type: 12 /* uint32 */, data: hiddenSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);
          const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);
          const biasInput = inputVariable("bias", bias.dataType, outputShape);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "bias_offset", type: "u32" },
            { name: "hidden_size", type: "u32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
        };
        return context.compute(
          {
            name: "MultiHeadAttentionAddBias",
            shaderCache: { inputDependencies: ["type", "type"] },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [qkv, bias], outputs: [-1] }
        )[0];
      };
      maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {
        let reshapedInput = input;
        if (!bias) {
          if (input.dims.length === 3) {
            reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);
          }
          return context.compute(
            createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm),
            { inputs: [reshapedInput], outputs: [-1] }
          )[0];
        } else {
          if (sequenceLength === 1) {
            throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
          } else {
            reshapedInput = addBiasTranspose(context, input, bias, batchSize, sequenceLength, numHeads * headSize, biasOffset);
            reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);
            return context.compute(
              createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm),
              { inputs: [reshapedInput], outputs: [-1] }
            )[0];
          }
        }
      };
      multiHeadAttention = (context, attributes) => {
        const params = validateInputs16(context.inputs, attributes);
        const query = context.inputs[0];
        const key = getInput(context.inputs, 1);
        const value = getInput(context.inputs, 2);
        const bias = getInput(context.inputs, 3);
        const keyPaddingMask = getInput(context.inputs, 4);
        const relativePositionBias = getInput(context.inputs, 5);
        const pastKey = getInput(context.inputs, 6);
        const pastValue = getInput(context.inputs, 7);
        if (query.dims.length === 5) {
          throw new Error("Packed QKV is not implemented");
        }
        if (key?.dims.length === 5) {
          throw new Error("Packed KV is not implemented");
        }
        const kvBNSH = key && value && key.dims.length === 4 && value.dims.length === 4;
        const Q = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.sequenceLength,
          params.headSize,
          query,
          bias,
          0
        );
        if (kvBNSH) {
          return applyAttention(
            context,
            Q,
            key,
            value,
            keyPaddingMask,
            void 0,
            pastKey,
            pastValue,
            relativePositionBias,
            params,
            attributes
          );
        }
        if (!key || !value) {
          throw new Error("key and value must be provided");
        }
        const K = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.kvSequenceLength,
          params.headSize,
          key,
          bias,
          params.hiddenSize
        );
        const V = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.kvSequenceLength,
          params.vHeadSize,
          value,
          bias,
          2 * params.hiddenSize
        );
        applyAttention(
          context,
          Q,
          K,
          V,
          keyPaddingMask,
          void 0,
          pastKey,
          pastValue,
          relativePositionBias,
          params,
          attributes
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/tile.ts
  var getRepeats, validateInputs17, getOutputShape2, createTileProgramInfo, tile;
  var init_tile = __esm({
    "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);
      validateInputs17 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Tile requires 2 inputs.");
        }
        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {
          throw new Error("Tile only support float, float16, int32, and uint32 data types");
        }
        if (inputs[1].dataType !== 7 /* int64 */) {
          throw new Error("Tile `repeats` input should be of int64 data type");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("Tile `repeats` input should be 1-D");
        }
        const repeats = getRepeats(inputs[1]);
        if (repeats.length !== inputs[0].dims.length) {
          throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
        }
      };
      getOutputShape2 = (inputShape, repeats) => {
        const outputShape = [];
        for (let i = 0; i < inputShape.length; ++i) {
          outputShape.push(inputShape[i] * repeats[i]);
        }
        return outputShape;
      };
      createTileProgramInfo = (inputs, shape) => {
        const inputShape = inputs[0].dims;
        const repeats = shape == null ? getRepeats(inputs[1]) : shape;
        const outputShape = getOutputShape2(inputShape, repeats);
        const outputSize = ShapeUtil.size(outputShape);
        const dataType = inputs[0].dataType;
        const input = inputVariable("input", dataType, inputShape.length);
        const output = outputVariable("output", dataType, outputShape.length);
        const getShaderSource = (shaderHelper) => `
      const inputShape = ${input.indices(...inputShape)};
      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${output.offsetToIndices("global_idx")};
      var input_indices: ${input.type.indices};
      for (var i = 0; i < ${inputShape.length}; i++) {
        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;

        ${input.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
    }`;
        return {
          name: "Tile",
          shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(inputs[0].dims, outputShape)]
          }),
          getShaderSource
        };
      };
      tile = (context) => {
        validateInputs17(context.inputs);
        context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts
  var validateInputs18, createConcatProgramInfo2, parseGroupQueryAttentionAttributes, weightTransposeAttribute3, maybeExpandAndTransposeToBNSH, groupQueryAttention;
  var init_group_query_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_attention();
      init_common();
      init_multihead_attention();
      init_tile();
      init_transpose();
      validateInputs18 = (inputs, attributes) => {
        const query = inputs[0];
        const key = inputs[1];
        const value = inputs[2];
        const pastKey = inputs[3];
        const pastValue = inputs[4];
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error("Input query is expected to have 3 or 5 dimensions");
        }
        const dmmhaPacking = false;
        const batchSize = query.dims[0];
        const sequenceLength = query.dims[1];
        const hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
        let kvSequenceLength = sequenceLength;
        let pastSequenceLength = 0;
        let maxSequenceLength = 0;
        const headSize = Math.floor(hiddenSize / attributes.numHeads);
        const hasPastKey = pastKey && pastKey.dims.length !== 0;
        const hasPastValue = pastValue && pastValue.dims.length !== 0;
        const isPastkvBSNH = true;
        if (hasPastKey && hasPastValue) {
          if (pastKey.dims.length !== 4) {
            throw new Error('Input "past_key" is expected to have 4 dimensions');
          }
          if (pastValue.dims.length !== 4) {
            throw new Error('Input "past_value" is expected to have 4 dimensions');
          }
          if (isPastkvBSNH) {
            pastSequenceLength = pastKey.dims[1];
            maxSequenceLength = pastKey.dims[1];
          } else {
            pastSequenceLength = pastKey.dims[2];
            maxSequenceLength = pastKey.dims[2];
          }
        } else if (hasPastKey || hasPastValue) {
          throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
        }
        let qkvFormat;
        if (key) {
          if (query.dims.length !== 3) {
            throw new Error('Input "query" is expected to have 3 dimensions when key is given');
          }
          if (key.dims.length < 3 || key.dims.length > 5) {
            throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
          }
          if (query.dims[0] !== key.dims[0]) {
            throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
          }
          if (key.dims.length === 3) {
            if (query.dims[2] % key.dims[2] !== 0) {
              throw new Error('Dimension 2 of "query" should be a multiple of "key"');
            }
            qkvFormat = 2 /* qkvBSNH */;
            kvSequenceLength = key.dims[1];
          } else if (key.dims.length === 5) {
            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
            }
            if (value) {
              throw new Error('Expect "value" be none when "key" has packed kv format.');
            }
            qkvFormat = 5 /* qKvBSNHxBSN2H */;
            kvSequenceLength = key.dims[1];
          } else {
            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
            }
            qkvFormat = 0 /* unknown */;
            kvSequenceLength = key.dims[2];
          }
        } else {
          if (query.dims.length !== 3 && query.dims.length !== 5) {
            throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
          }
          if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
            throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
          }
          qkvFormat = 3 /* qkvBSN3H */;
        }
        const maskType = 0 /* none */;
        let passPastInKv = false;
        let vHiddenSize = hiddenSize;
        if (value) {
          if (value.dims.length !== 3 && value.dims.length !== 4) {
            throw new Error('Input "value" is expected to have 3 or 4 dimensions');
          }
          if (query.dims[0] !== value.dims[0]) {
            throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
          }
          if (value.dims.length === 3) {
            if (kvSequenceLength !== value.dims[1]) {
              throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[2];
          } else {
            if (kvSequenceLength !== value.dims[2]) {
              throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[1] * value.dims[3];
            passPastInKv = true;
          }
        }
        const totalSequenceLength = pastSequenceLength + kvSequenceLength;
        const broadcastResPosBias = false;
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize: 0,
          hiddenSize,
          vHiddenSize,
          headSize,
          vHeadSize: Math.floor(vHiddenSize / attributes.kvNumHeads),
          numHeads: attributes.numHeads,
          kvNumHeads: attributes.kvNumHeads,
          nReps: attributes.numHeads / attributes.kvNumHeads,
          pastPresentShareBuffer: false,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias,
          passPastInKv,
          qkvFormat,
          isPastkvBSNH
        };
      };
      createConcatProgramInfo2 = (a, b, dataType, params) => {
        const outputShape = [params.batchSize, params.totalSequenceLength, params.kvNumHeads, params.headSize];
        const component = 4;
        const outputSize = ShapeUtil.size(outputShape) / component;
        const presentSequenceLength = params.totalSequenceLength;
        const output = outputVariable("present_kv", dataType, outputShape.length, component);
        const inputA = inputVariable("new_kv", a.dataType, a.dims.length, component);
        const inputB = b ? inputVariable("past_kv", b.dataType, b.dims.length, component) : void 0;
        const H = Math.ceil(params.headSize / component);
        const dispatch = { x: presentSequenceLength, y: a.dims[0], z: 1 };
        const inputDependencies = b ? ["rank", "rank"] : ["rank"];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: params.pastSequenceLength },
          { type: 12 /* uint32 */, data: params.kvSequenceLength },
          { type: 12 /* uint32 */, data: params.totalSequenceLength }
        ];
        const inputs = [inputA];
        if (inputB) {
          programUniforms.push(
            ...createTensorShapeVariables(a.dims),
            ...createTensorShapeVariables(b.dims),
            ...createTensorShapeVariables(outputShape)
          );
          inputs.push(inputB);
        } else {
          programUniforms.push(...createTensorShapeVariables(a.dims), ...createTensorShapeVariables(outputShape));
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "past_seqlen", type: "u32" },
          { name: "new_seqlen", type: "u32" },
          { name: "present_seqlen", type: "u32" }
        ];
        const pastStr = `      let past_batch_stride = uniforms.past_seqlen * num_heads * H;
        var past_head_stride = uniforms.past_seqlen * H;
        if (is_bsnh) {
          past_head_stride = H;
        }
        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;
        present_kv[out_offset] = past_kv[in_offset];`;
        const newStr = `      let new_batch_stride = uniforms.new_seqlen * num_heads * H;
        let new_row_stride = num_heads * H;
        let new_head_stride = H;
        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;
        present_kv[out_offset] = new_kv[in_offset];`;
        const concatStr = b ? `if (s < past_seqlen) {
        ${pastStr}
        } else if (s < past_seqlen + uniforms.new_seqlen) {
        ${newStr}
        }` : `if (s < past_seqlen + uniforms.new_seqlen) {
          ${newStr}
        }`;
        const getShaderSource = (shaderHelper) => `

  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputs, output)}
  ${shaderHelper.mainStart([
          H,
          params.kvNumHeads,
          1
        ])}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    var indices = ${output.offsetToIndices("global_idx")};
    let h = local_id.x;
    let n = local_id.y;
    let s = workgroup_id.x;
    let b = workgroup_id.y;
    let num_heads = ${params.kvNumHeads}u;
    let H = ${H}u;

    let present_seqlen = uniforms.present_seqlen;
    let present_batch_stride = present_seqlen * num_heads * H;
    var row_stride = H;
    let is_bsnh = ${params.isPastkvBSNH};

    if (is_bsnh) {
      row_stride = num_heads * H;
    }
    var present_head_stride = present_seqlen * H;
    if (is_bsnh) {
      present_head_stride = H;
    }

    let past_seqlen = uniforms.past_seqlen;

    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;
    ${concatStr}
  }`;
        return {
          name: "ConcatPastNew",
          shaderCache: { hint: `${params.kvNumHeads}${H}${!!b}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: dispatch,
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGroupQueryAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
      weightTransposeAttribute3 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
      maybeExpandAndTransposeToBNSH = (context, input, pastKV, params, outputIndex) => {
        let reshapedInput = input;
        const numHeads = params.kvNumHeads;
        const nReps = params.nReps;
        if (input.dims.length === 3 && params.kvSequenceLength !== 0) {
          reshapedInput = input.reshape([params.batchSize, params.kvSequenceLength, numHeads, params.headSize]);
        }
        if (pastKV) {
          reshapedInput = context.compute(
            createConcatProgramInfo2(reshapedInput, pastKV, reshapedInput.dataType, params),
            { inputs: [reshapedInput, pastKV], outputs: [params.isPastkvBSNH ? outputIndex : -1] }
          )[0];
        } else {
          reshapedInput = context.compute(
            createConcatProgramInfo2(reshapedInput, void 0, reshapedInput.dataType, params),
            { inputs: [reshapedInput], outputs: [params.isPastkvBSNH ? outputIndex : -1] }
          )[0];
        }
        if (nReps !== 1) {
          reshapedInput = context.compute(
            createTileProgramInfo([reshapedInput], [1, 1, 1, nReps]),
            { inputs: [reshapedInput], outputs: [-1] }
          )[0];
          reshapedInput = reshapedInput.reshape([params.batchSize, params.totalSequenceLength, numHeads * nReps, params.headSize]);
        }
        return context.compute(
          createTransposeProgramInfo(reshapedInput, weightTransposeAttribute3.perm),
          { inputs: [reshapedInput], outputs: [-1] }
        )[0];
      };
      groupQueryAttention = (context, attributes) => {
        const params = validateInputs18(context.inputs, attributes);
        if (context.inputs[0].dims.length === 5) {
          throw new Error("Packed QKV is not implemented");
        }
        if (context.inputs[1]?.dims.length === 5) {
          throw new Error("Packed KV is not implemented");
        }
        const Q = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.sequenceLength,
          params.headSize,
          context.inputs[0],
          void 0,
          0
        );
        const pastKey = context.inputs[3] && context.inputs[3].dims.length !== 0 ? context.inputs[3] : void 0;
        const pastValue = context.inputs[4] && context.inputs[4].dims.length !== 0 ? context.inputs[4] : void 0;
        const K = maybeExpandAndTransposeToBNSH(context, context.inputs[1], pastKey, params, 1);
        const V = maybeExpandAndTransposeToBNSH(context, context.inputs[2], pastValue, params, 2);
        applyAttention(context, Q, K, V, void 0, void 0, void 0, void 0, void 0, params, attributes);
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/instance-norm.ts
  var createInstanceNormProgramInfo, computeMean, createInstanceNormNHWCProgramInfo, instanceNorm;
  var init_instance_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createInstanceNormProgramInfo = (inputs, attributes) => {
        const xShape = inputs[0].dims;
        const outputShape = xShape;
        const axis = 2;
        const normCount = ShapeUtil.sizeToDimension(xShape, axis);
        const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
        const components = getMaxComponents(normSize);
        const normPackedSize = normSize / components;
        const inputShape = [xShape[0], xShape[1], normPackedSize];
        const inputDependencies = ["rank", "type", "type"];
        const programUniforms = [{ type: 12 /* uint32 */, data: normSize }, { type: 12 /* uint32 */, data: normPackedSize }];
        programUniforms.push(...createTensorShapeVariables(inputShape, inputShape));
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);
          const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims);
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
          const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);
          const variables = [x, scale, bias, output];
          const dataType = x.type.value;
          const f32Type = components === 1 ? "f32" : `vec${components}<f32>`;
          const workgroupSize = 64;
          const uniforms = [{ name: "normSize", type: "u32" }, { name: "normPackedSize", type: "u32" }];
          return `
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${f32Type}, ${workgroupSize}>;
  const workgroupSize = ${workgroupSize}u;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart(workgroupSize)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${f32Type}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${f32Type}(${x.get("batch", "channel", "h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${sumVector("workgroupShared[0]", components)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${f32Type}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${f32Type}(${x.get("batch", "channel", "h")}) - ${f32Type}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${sumVector("workgroupShared[0]", components)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${attributes.epsilon}));
    let channelScale = invStdDev * f32(${scale.getByOffset("channel")});
    let channelShift = f32(${bias.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${x.get("batch", "channel", "h")} * ${dataType}(${f32Type}(channelScale)) + ${dataType}(${f32Type}(channelShift));
      ${output.set("batch", "channel", "h", "value")};
    }
  }`;
        };
        return {
          ...{ name: "InstanceNormalization" },
          // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
          shaderCache: { hint: `${attributes.epsilon};${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [
              { dims: outputShape, dataType: inputs[0].dataType }
            ],
            dispatchGroup: { x: normCount },
            programUniforms
          }),
          getShaderSource
        };
      };
      computeMean = (context, input, scale, bias, n, h, c, epsilon) => {
        const components = getMaxComponents(c);
        const WG = 64;
        const outputType = components === 1 ? "vec2f" : `mat2x${components}f`;
        const sumCastType = components === 1 ? "f32" : `vec${components}f`;
        const setOutputValue = (var1, var2) => `${outputType}(${var1}, ${var2})`;
        const unitsOfWork = n * c / components;
        const wgSize = Math.ceil(h / WG);
        const meanInputDependencies = ["type"];
        const meanProgramUniforms = [
          { type: 12 /* uint32 */, data: wgSize },
          { type: 12 /* uint32 */, data: h },
          { type: 12 /* uint32 */, data: Math.floor(c / components) },
          { type: 12 /* uint32 */, data: Math.floor(h * c / components) }
        ];
        const getMeanShaderSource = (shaderHelper) => {
          const inputHelper = inputVariable("input", input.dataType, input.dims, components);
          return `
  ${shaderHelper.declareVariables(inputHelper)}
  @group(0) @binding(1) var<storage, read_write> output : array<${outputType}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart(WG)}
    let currentImageNumber = global_idx / ${WG} / uniforms.C;
    let currentChannelNumber = (global_idx / ${WG}) % uniforms.C;
    let wgOffset = local_id.x * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${fillVector("f32", components)};
    var squaredSum = ${fillVector("f32", components)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${sumCastType}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${setOutputValue("sum", "squaredSum")};
  }`;
        };
        const meanValues = context.compute(
          {
            name: "InstanceNormComputeMean",
            shaderCache: { hint: `${components}`, inputDependencies: meanInputDependencies },
            getRunData: () => ({
              outputs: [
                { dims: [n, c, WG, 2], dataType: 1 /* float */ }
              ],
              dispatchGroup: { x: n * c / components },
              programUniforms: meanProgramUniforms
            }),
            getShaderSource: getMeanShaderSource
          },
          { inputs: [input], outputs: [-1] }
        )[0];
        const programUniforms = [
          { type: 12 /* uint32 */, data: unitsOfWork },
          { type: 12 /* uint32 */, data: h },
          { type: 12 /* uint32 */, data: Math.floor(c / components) },
          { type: 12 /* uint32 */, data: Math.floor(WG * c / components) }
        ];
        const inputDependencies = ["type", "type", "type"];
        const getShaderSource = (shaderHelper) => {
          const scaleHelper = inputVariable("scale", scale.dataType, scale.dims, components);
          const biasHelper = inputVariable("bias", bias.dataType, bias.dims, components);
          return `
  @group(0) @binding(0) var<storage, read> input : array<${outputType}>;
  @group(0) @binding(1) var<storage, read> scale : array<${scaleHelper.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${biasHelper.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${outputType}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${fillVector("f32", components)};
    var squaredSum = ${fillVector("f32", components)};
    for (var i: u32 = 0; i < min(${WG}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${WG}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${epsilon}));
    let channelScale = invStdDev * ${sumCastType}(scale[currentChannelNumber]);
    let channelShift = ${sumCastType}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${setOutputValue("channelScale", "channelShift")};
  }`;
        };
        return context.compute(
          {
            name: "InstanceNormComputeChannelScaleShift",
            // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
            shaderCache: { hint: `${components};${epsilon}`, inputDependencies },
            getRunData: () => ({
              outputs: [
                { dims: [n, c, 2], dataType: 1 /* float */ }
              ],
              dispatchGroup: { x: Math.ceil(
                unitsOfWork / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [meanValues, scale, bias], outputs: [-1] }
        )[0];
      };
      createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {
        const xShape = inputs[0].dims;
        const outputShape = xShape;
        const N = xShape[0];
        const C = xShape[xShape.length - 1];
        const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;
        const components = getMaxComponents(C);
        const outputSize = ShapeUtil.size(outputShape) / components;
        const programUniforms = [{ type: 12 /* uint32 */, data: H }, { type: 12 /* uint32 */, data: Math.floor(C / components) }];
        const inputDependencies = ["type", "type"];
        const channelScaleShift = computeMean(context, inputs[0], inputs[1], inputs[2], N, H, C, attributes.epsilon);
        const getShaderSource = (shaderHelper) => {
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const scaleType = components === 1 ? "vec2f" : `mat2x${components}f`;
          const scaleCastType = components === 1 ? dataType : `vec${components}<${dataType}>`;
          const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);
          const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);
          return `
  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${scaleType}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${scaleCastType}(scale[0]), ${scaleCastType}(scale[1]));
  }`;
        };
        context.compute(
          {
            name: "InstanceNormalizationNHWC",
            shaderCache: { hint: `${components}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [inputs[0], channelScaleShift] }
        );
      };
      instanceNorm = (context, attributes) => {
        if (attributes.format === "NHWC") {
          createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);
        } else {
          context.compute(createInstanceNormProgramInfo(context.inputs, attributes));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/layer-norm.ts
  var validateInputs19, createLayerNormProgramInfo, layerNorm;
  var init_layer_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs19 = (inputs) => {
        if (!inputs || inputs.length < 2) {
          throw new Error("layerNorm requires at least 2 inputs.");
        }
      };
      createLayerNormProgramInfo = (inputs, attributes, outputCount) => {
        const simplified = attributes.simplified;
        const xShape = inputs[0].dims;
        const scale = inputs[1];
        const bias = !simplified && inputs[2];
        const outputShape = xShape;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);
        const normCount = ShapeUtil.sizeToDimension(xShape, axis);
        const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
        const scaleSize = ShapeUtil.size(scale.dims);
        const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;
        if (scaleSize !== normSize || bias && biasSize !== normSize) {
          throw new Error(`Size of X.shape()[axis:] == ${normSize}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${scaleSize} and bias size of ${biasSize}`);
        }
        const meanInvStdDevDim = [];
        for (let i = 0; i < xShape.length; ++i) {
          if (i < axis) {
            meanInvStdDevDim.push(xShape[i]);
          } else {
            meanInvStdDevDim.push(1);
          }
        }
        const components = getMaxComponents(normSize);
        const inputDependencies = ["type", "type"];
        const programUniforms = [
          { type: 12 /* uint32 */, data: normCount },
          { type: 1 /* float */, data: normSize },
          { type: 12 /* uint32 */, data: Math.floor(normSize / components) },
          { type: 1 /* float */, data: attributes.epsilon }
        ];
        if (bias) {
          inputDependencies.push("type");
        }
        const hasMeanDataOutput = outputCount > 1;
        const hasInvStdOutput = outputCount > 2;
        const getShaderSource = (shaderHelper) => {
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const variables = [
            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
            inputVariable("scale", scale.dataType, scale.dims, components)
          ];
          if (bias) {
            variables.push(inputVariable("bias", bias.dataType, bias.dims, components));
          }
          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
          if (hasMeanDataOutput) {
            variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInvStdOutput) {
            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
          }
          const uniforms = [
            { name: "norm_count", type: "u32" },
            { name: "norm_size", type: "f32" },
            { name: "norm_size_vectorized", type: "u32" },
            { name: "epsilon", type: "f32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${fillVector("f32", components)};
    var mean_square_vector = ${fillVector("f32", components)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${castToF32(dataType, components, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${sumVector("mean_vector", components)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${sumVector("mean_square_vector", components)} / uniforms.norm_size ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${castToF32(dataType, components, "x[j + offset]")};
      let f32scale = ${castToF32(dataType, components, "scale[j]")};
      output[j + offset] = ${variables[0].type.value}((f32input ${simplified ? "" : "- mean"}) * inv_std_dev * f32scale
        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}
      );
    }

    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};
    ${hasInvStdOutput ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
        };
        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
        if (hasMeanDataOutput) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (hasInvStdOutput) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        return {
          name: "LayerNormalization",
          shaderCache: { hint: `${components};${outputCount};${simplified}`, inputDependencies },
          getRunData: () => ({ outputs, dispatchGroup: { x: Math.ceil(
            normCount / 64
            /* workgroup size */
          ) }, programUniforms }),
          getShaderSource
        };
      };
      layerNorm = (context, attributes) => {
        validateInputs19(context.inputs);
        context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts
  var validateInputs20, createMatMulNBitsProgramInfo, matMulNBits, parseMatMulNBitsAttributes;
  var init_matmulnbits = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs20 = (inputs, attributes) => {
        if (inputs.length < 3 || inputs.length > 4) {
          throw new Error("MatMulNBits requires 3 or 4 inputs");
        }
        const a = inputs[0];
        const aRank = a.dims.length;
        if (a.dims[aRank - 1] !== attributes.k) {
          throw new Error("The last dim of input shape does not match the k value");
        }
        const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
        const blobSize = attributes.blockSize / 8 * attributes.bits;
        const b = inputs[1];
        if (!ShapeUtil.areEqual(b.dims, [attributes.n, nBlocksPerCol, blobSize])) {
          throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
        }
        const scales = inputs[2];
        const scalesShape = scales.dims;
        if (ShapeUtil.size(scalesShape) !== attributes.n * nBlocksPerCol) {
          throw new Error("scales input size error.");
        }
        if (inputs.length === 4) {
          const zeroPoints = inputs[3];
          const zeroPointsShape = zeroPoints.dims;
          const expectedZeroPointsSize = attributes.bits > 4 ? attributes.n * nBlocksPerCol : attributes.n * Math.floor((nBlocksPerCol + 1) / 2);
          if (ShapeUtil.size(zeroPointsShape) !== expectedZeroPointsSize) {
            throw new Error("zeroPoints input size error.");
          }
        }
      };
      createMatMulNBitsProgramInfo = (inputs, attributes, maxComputeWorkgroupSizes, maxComputeWorkgroupStorageSize) => {
        const inputShape = inputs[0].dims;
        const aRank = inputShape.length;
        const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
        const dimAOuter = inputShape[aRank - 2];
        const dimInner = attributes.k;
        const dimBOuter = attributes.n;
        const batchDims = inputShape.slice(0, aRank - 2);
        const batchSize = ShapeUtil.size(batchDims);
        const blobSize = attributes.blockSize / 8 * attributes.bits;
        const blobSizeInWords = blobSize / 4;
        const dataType = inputs[0].dataType;
        const outputNumber = getMaxComponents(dimAOuter);
        const aComponents = getMaxComponents(attributes.k);
        const bComponents = getMaxComponents(blobSizeInWords);
        const elementSize = getTensorElementSize(dataType);
        const workgroupOutputSize = dimAOuter * nBlocksPerCol * elementSize;
        const maxNumberOfComponents = Math.floor(maxComputeWorkgroupStorageSize / workgroupOutputSize);
        const useBlockwiseMatMulNBits = nBlocksPerCol <= maxComputeWorkgroupSizes[0] && maxNumberOfComponents > 0;
        const components = !useBlockwiseMatMulNBits || maxNumberOfComponents >= 4 ? getMaxComponents(dimBOuter) : maxNumberOfComponents >= 2 && getMaxComponents(dimBOuter) >= 2 ? 2 : 1;
        const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const programUniforms = useBlockwiseMatMulNBits ? [] : [{ type: 12 /* uint32 */, data: outputSize }, { type: 12 /* uint32 */, data: attributes.blockSize }];
        const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
        const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
        bShape.splice(-1, 1, blobSizeInWords / bComponents);
        programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
        programUniforms.push(...createTensorShapeVariables(bShape));
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        if (inputs.length === 4) {
          programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
        }
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const inputRank = inputShapeTemp.length;
          const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
          const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const inputVariables = [a, b, scales];
          const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
          if (zeroPoints) {
            inputVariables.push(zeroPoints);
          }
          const outputRank = outputShapeTemp.length;
          const output = outputVariable("output", inputs[0].dataType, outputRank, components);
          const uniforms = [{ name: "output_size", type: "u32" }, { name: "block_size", type: "u32" }];
          const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
          const qDqDataType = (() => {
            switch (aComponents) {
              case 1:
                return `array<${dataType2}, 8>`;
              case 2:
                return `mat4x2<${dataType2}>`;
              case 4:
                return `mat2x4<${dataType2}>`;
              default:
                throw new Error(`${aComponents}-component is not supported.`);
            }
          })();
          const processOneBlock = `
        for (var word: u32 = 0; word < ${blobSizeInWords}; word += ${bComponents}) {
          ${b.indicesSet("b_indices", "2", "word")};
          let b_data = ${b.getByIndices("b_indices")};
          for (var i: u32 = 0; i < ${bComponents}; i++) {
            let b_value: u32 = ${bComponents === 1 ? "b_data" : "b_data[word + i]"};
            let b_mask: u32 = 0x0F0F0F0Fu;
            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);
            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);
            let b_quantized_values = ${qDqDataType}(${Array.from({ length: 4 }, (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`).join(", ")});
            let b_dequantized_values = ${(() => {
            if (aComponents === 1) {
              return `${qDqDataType}(${Array.from({ length: 8 }, (_, i) => `(b_quantized_values[${i}] - zero_point) * scale`).join(", ")});`;
            } else {
              return `(b_quantized_values - ${qDqDataType}(${Array(8).fill("zero_point").join(",")})) * scale;`;
            }
          })()};
            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8
            for (var m: u32 = 0; m < ${useBlockwiseMatMulNBits ? dimAOuter : outputNumber}u; m++) {
              ${a.indicesSet("a_indices", inputRank - 2, useBlockwiseMatMulNBits ? "m" : `row * ${outputNumber} + m`)};
              ${a.indicesSet("a_indices", inputRank - 1, "word_offset")};
              var input_offset = ${a.indicesToOffset("a_indices")};
              var a_data: ${qDqDataType};
              for (var j: u32 = 0; j < ${8 / aComponents}; j++) {
                a_data[j] = ${a.getByOffset("input_offset")};
                input_offset++;
              }
              ${useBlockwiseMatMulNBits ? "workgroup_shared[workgroup_shared_offset + m]" : "output_values[m]"}${components > 1 ? "[c]" : ""} += ${Array.from(
            { length: 8 / aComponents },
            (_, i) => `${aComponents === 1 ? `a_data[${i}] * b_dequantized_values[${i}]` : `dot(a_data[${i}], b_dequantized_values[${i}])`}`
          ).join(" + ")};
            }
            word_offset += ${8 / aComponents};
          }
        }`;
          const updateZeroPointIndex = zeroPoints ? `
          zero_point_offset += 4;
          if (zero_point_offset == 32) {
            zero_point_offset = 0;
            zero_point_index++;
            zero_point_word = ${zeroPoints.getByOffset("zero_point_index")};
          }` : "";
          return useBlockwiseMatMulNBits ? `
        var<workgroup> workgroup_shared: array<${output.type.value}, ${dimAOuter * nBlocksPerCol}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([
            nBlocksPerCol,
            1,
            1
          ])}
          var a_indices: ${a.type.indices};
          var block = local_id.x;
          var col = workgroup_id.y;
          var batch = workgroup_id.z;
          ${a.indicesSet("a_indices", "0", "batch")};
          // Two zero points are packed into one byte when uniforms.bits is 4.
          for (var c: u32 = 0; c < ${components}; c++) {
            let col_times_components_plus_c = col * ${components} + c;
              ${zeroPoints ? `
            var zero_point_bytes_per_col: u32 = (${nBlocksPerCol} + 1) / 2;
            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);
            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;
            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;
            var zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            var zero_point_word: u32 = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;` : ""}
            var b_indices: ${b.type.indices};
            ${b.indicesSet("b_indices", "0", "col_times_components_plus_c")};
            // The scale and zero points are computed per block.
            var scales_index = col_times_components_plus_c * ${nBlocksPerCol} + block;
            let scale = ${scales.getByOffset("scales_index")};
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${zeroPoints ? "(zero_point_word) & 0xFu" : 8});
            ${b.indicesSet("b_indices", "1", "block")};
            var word_offset: u32 = block * ${attributes.blockSize / aComponents};
            var workgroup_shared_offset: u32 = block * ${dimAOuter};
            ${processOneBlock}
          }
          workgroupBarrier();
          var output_indices: ${output.type.indices};
          var elements_per_thread: u32 = ${Math.ceil(dimAOuter / nBlocksPerCol)};
          ${output.indicesSet("output_indices", "0", "batch")};
          ${output.indicesSet("output_indices", outputRank - 1, "col")};
          ${output.indicesSet("output_indices", outputRank - 2, "local_id.x * elements_per_thread")};
          var output_offset = ${output.indicesToOffset("output_indices")};
          for (var m: u32 = 0u; m < elements_per_thread; m++) {
            var row = m + local_id.x * elements_per_thread;
            if (row < ${dimAOuter}) {
              var output_value: ${output.type.value} = ${output.type.value}(0);
              var workgroup_shared_offset: u32 = row;
              for (var b: u32 = 0u; b < ${nBlocksPerCol}u; b++) {
                output_value += workgroup_shared[workgroup_shared_offset];
                workgroup_shared_offset += ${dimAOuter};
              }
              ${output.setByOffset("output_offset", "output_value")};
              output_offset += ${dimBOuter / components};
            }
          }
        }` : `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var output_values: array<${output.type.value}, ${outputNumber}>;
          var output_indices = ${output.offsetToIndices("global_idx")};
          var col = ${output.indicesGet("output_indices", outputRank - 1)};
          var row = ${output.indicesGet("output_indices", outputRank - 2)};
          var a_indices: ${a.type.indices} = output_indices;
          // Two zero points are packed into one byte because uniforms.bits <= 4.
          // zero_point_offset is either 0 or 4. It is bit offset within one byte.
          // TODO support zero_point_offset for bits > 4
          ${zeroPoints ? `
          var zero_point_abs_offset = col * ${components} * ((${nBlocksPerCol} + 1) / 2);
          var zero_point_index: u32 = zero_point_abs_offset / 4;
          var zero_point_word: u32 = ${zeroPoints.getByOffset("zero_point_index")};
          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;` : ""}
          var scale_index = col * ${nBlocksPerCol * components};
          var b_indices: ${b.type.indices};
          for (var c: u32 = 0; c < ${components}; c++) {
            ${b.indicesSet("b_indices", "0", `col * ${components} + c`)};
            var block_offset: u32 = 0;
            for (var block: u32 = 0; block < ${nBlocksPerCol}; block++) {
              // The scale and zero points are computed per block.
              let scale = ${scales.getByOffset("scale_index")};
              // The default zero point is 8 for unsigned 4-bit quantization.
              let zero_point = ${dataType2}(${zeroPoints ? "extractBits(zero_point_word, zero_point_offset, 4)" : 8});
              ${b.indicesSet("b_indices", "1", "block")};
              var word_offset: u32 = block_offset;
              ${processOneBlock}
              scale_index++;
              ${updateZeroPointIndex}
              block_offset += uniforms.block_size / ${aComponents};
            }
            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.
            ${zeroPoints ? `if (zero_point_offset % 8 > 0) {
                ${updateZeroPointIndex}
              }` : ""}
            }
            for (var k: u32 = 0u; k < ${outputNumber}u; k++) {
              ${output.indicesSet("output_indices", outputRank - 2, `${outputNumber} * row + k`)};
              ${output.setByIndices("output_indices", "output_values[k]")}
            }
        }`;
        };
        return {
          name: useBlockwiseMatMulNBits ? "BlockwiseMatMulNBits" : "MatMulNBits",
          shaderCache: {
            hint: `${attributes.cacheKey};${dimAOuter};${dataType};${inputs.length}`,
            inputDependencies: Array(inputs.length).fill("rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            name: useBlockwiseMatMulNBits ? "BlockwiseMatMulNBits" : "MatMulNBits",
            dispatchGroup: useBlockwiseMatMulNBits ? { x: 1, y: Math.ceil(dimBOuter / components), z: batchSize } : { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      matMulNBits = (context, attributes) => {
        validateInputs20(context.inputs, attributes);
        const maxComputeWorkgroupSizes = context.getMaxComputeWorkgroupSizes();
        const maxComputeWorkgroupStorageSize = context.getMaxComputeWorkgroupStoragesize();
        context.compute(createMatMulNBitsProgramInfo(
          context.inputs,
          attributes,
          maxComputeWorkgroupSizes,
          maxComputeWorkgroupStorageSize
        ));
      };
      parseMatMulNBitsAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/pad.ts
  var validateInputs21, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;
  var init_pad = __esm({
    "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs21 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("Too few inputs");
        }
        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */) {
          throw new Error("Input type must be float or float16.");
        }
        if (inputs.length >= 2) {
          let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];
          if (inputs.length === 4) {
            validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];
          }
          if (!validPads) {
            throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
          }
        }
      };
      getPadConstant = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
              break;
            }
            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
        `;
        }
        return `
          value = ${output.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${block}
            value = x[offset];
          }
      `;
      };
      getPadReflect = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadEdge = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadWrap = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0)  {
                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadSnippet = (output, inputRank, attributes) => {
        switch (attributes.mode) {
          case 0:
            return getPadConstant(output, inputRank, attributes.pads.length);
          case 1:
            return getPadReflect(output, inputRank, attributes.pads.length);
          case 2:
            return getPadEdge(output, inputRank, attributes.pads.length);
          case 3:
            return getPadWrap(output, inputRank, attributes.pads.length);
          default:
            throw new Error("Invalid mode");
        }
      };
      createPadProgramInfo = (inputs, attributes) => {
        const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);
        const inputDims = inputs[0].dims;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }, { type: 6 /* int32 */, data: attributes.pads }];
        if (attributes.mode === 0) {
          programUniforms.push({ type: inputs[0].dataType, data: attributes.value });
        }
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, outputShape));
        const inputDependencies = ["rank"];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          const input = inputVariable("x", inputs[0].dataType, inputDims.length);
          const dataType = input.type.value;
          const padSnippet = getPadSnippet(output, inputDims.length, attributes);
          const uniforms = [{ name: "output_size", type: "u32" }, { name: "pads", type: "i32", length: attributes.pads.length }];
          if (attributes.mode === 0) {
            uniforms.push({ name: "constant_value", type: dataType });
          }
          return `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${output.offsetToIndices("global_idx")};

            var value = ${dataType}(0);
            ${padSnippet}
            output[global_idx] = value;
        }`;
        };
        return {
          name: "Pad",
          shaderCache: { hint: `${attributes.mode}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      createPadAttributesFromInputs = (inputs, attributes) => {
        if (inputs.length > 1) {
          const bigInt64Pads = inputs[1].getBigInt64Array();
          const value = inputs.length >= 3 && inputs[2].data ? inputs[2].getFloat32Array()[0] : 0;
          const inputRank = inputs[0].dims.length;
          const updatePads = new Int32Array(2 * inputRank).fill(0);
          if (inputs.length >= 4) {
            const axes = inputs[3].getBigInt64Array();
            for (let i = 0; i < axes.length; i++) {
              updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);
              updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);
            }
          } else {
            bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));
          }
          const pads = [];
          updatePads.forEach((v) => pads.push(v));
          return { mode: attributes.mode, value, pads };
        } else {
          return attributes;
        }
      };
      pad = (context, attributes) => {
        validateInputs21(context.inputs);
        const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);
        context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/pool.ts
  var validateInputs22, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;
  var init_pool = __esm({
    "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_util();
      init_common();
      validateInputs22 = (inputs) => {
        if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {
          throw new Error("Pool ops requires 1 input.");
        }
      };
      getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inputShapeAsChannelFirst = input.dims.slice();
        if (isChannelsLast) {
          inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());
        }
        const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
        const kernelShape = attributes.kernelShape.slice();
        const strides = attributes.strides.slice();
        const dilations = hasDilations ? attributes.dilations.slice() : [];
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);
        const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(
          isGlobalOperator,
          inputShapeAsChannelFirst,
          strides,
          dilations,
          kernelShape,
          pads,
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        if (hasDilations) {
          Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
        } else {
          Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
        }
        const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();
        outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);
        return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];
      };
      getUniformAndPadInfo = (outputShape, attributes) => {
        const isChannelsLast = attributes.format === "NHWC";
        const outputSize = ShapeUtil.size(outputShape);
        const kernelSize = ShapeUtil.size(attributes.kernelShape);
        const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }, { type: 12 /* uint32 */, data: kernelSize }];
        const uniforms = [{ name: "outputSize", type: "u32" }, { name: "kernelSize", type: "u32" }];
        if (attributes.kernelShape.length <= 2) {
          const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
          const sw = attributes.strides[attributes.strides.length - 1];
          const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
          const pwEnd = attributes.pads[attributes.pads.length - 1];
          const pwStartEndNotZero = !!(pwStart + pwEnd);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kw },
            { type: 12 /* uint32 */, data: sw },
            { type: 12 /* uint32 */, data: pwStart },
            { type: 12 /* uint32 */, data: pwEnd }
          );
          uniforms.push(
            { name: "kw", type: "u32" },
            { name: "sw", type: "u32" },
            { name: "pwStart", type: "u32" },
            { name: "pwEnd", type: "u32" }
          );
          let phStartEndNotZero = false;
          if (attributes.kernelShape.length === 2) {
            const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
            const sh = attributes.strides[attributes.strides.length - 2];
            const phStart = attributes.pads[attributes.pads.length / 2 - 2];
            const phEnd = attributes.pads[attributes.pads.length - 2];
            phStartEndNotZero = !!(phStart + phEnd);
            programUniforms.push(
              { type: 12 /* uint32 */, data: kh },
              { type: 12 /* uint32 */, data: sh },
              { type: 12 /* uint32 */, data: phStart },
              { type: 12 /* uint32 */, data: phEnd }
            );
            uniforms.push(
              { name: "kh", type: "u32" },
              { name: "sh", type: "u32" },
              { name: "phStart", type: "u32" },
              { name: "phEnd", type: "u32" }
            );
          }
          return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];
        } else {
          if (isChannelsLast) {
            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
          }
          const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kernelStrides },
            { type: 12 /* uint32 */, data: attributes.pads },
            { type: 12 /* uint32 */, data: attributes.strides }
          );
          uniforms.push(
            { name: "kernelStrides", type: "u32", length: kernelStrides.length },
            { name: "pads", type: "u32", length: attributes.pads.length },
            { name: "strides", type: "u32", length: attributes.strides.length }
          );
          const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);
          return [programUniforms, uniforms, !!hasPads, false, false];
        }
      };
      generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {
        const isChannelsLast = attributes.format === "NHWC";
        const dataType = x.type.value;
        const output = outputVariable("output", x.type.tensor, outputShapeRank);
        if (attributes.kernelShape.length <= 2) {
          let codeW = "";
          let codeH = "";
          let codeHEnd = "";
          const dimIdxW = rank - (isChannelsLast ? 2 : 1);
          if (pwStartEndNotZero) {
            codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]
                      >= uniforms.x_shape[${dimIdxW}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
          } else {
            codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
          }
          if (attributes.kernelShape.length === 2) {
            const dimIdxH = rank - (isChannelsLast ? 3 : 2);
            if (phStartEndNotZero) {
              codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `;
            } else {
              codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                `;
            }
            codeHEnd = `
              }
            `;
          }
          const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var value = ${dataType}(${start});
              var pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}

              output[global_idx] = value;
            }`;
          return poolingCode;
        } else {
          if (isChannelsLast) {
            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
          }
          const stridesRank = attributes.kernelShape.length;
          const padsRank = attributes.pads.length;
          let padCode = "";
          if (hasPads) {
            padCode = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${x.indicesToOffset("xIndices")}];
                ${op1}
              }`;
          } else {
            padCode = `
              }
              let x_val = x[${x.indicesToOffset("xIndices")}];
              ${op1}
            `;
          }
          const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var offsets: array<u32, ${stridesRank}>;

              var value = ${dataType}(${start});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${stridesRank - 1}u; j++) {
                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                }
                offsets[${stridesRank - 1}] = offset;

                isPad = false;
                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {
                  xIndices[j] = indices[j] * ${getElementAt("uniforms.strides", `j - ${rank - stridesRank}u`, stridesRank)}
                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};
                  ${padCode}
              }
              ${op2}

              output[global_idx] = value;
            }`;
          return poolingCode;
        }
      };
      createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;
      createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;
      createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;
      parsePoolCommonAttributes = (attributes) => ({
        format: attributes.format,
        autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],
        ceilMode: attributes.ceil_mode,
        kernelShape: attributes.kernel_shape,
        strides: attributes.strides,
        pads: attributes.pads
      });
      createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(input, attributes, isGlobalOperator);
        const x = inputVariable("x", input.dataType, input.dims.length);
        const dataType = x.type.value;
        const op1 = "value += x_val;";
        let op2 = "";
        if (adjustedAttributes.countIncludePad) {
          op2 += `value /= ${dataType}(uniforms.kernelSize);`;
        } else {
          op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;
        }
        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(outputShape, adjustedAttributes);
        programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
        const inputDependencies = ["rank"];
        return {
          name,
          shaderCache: { hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: input.dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource: (shaderHelper) => generatePoolingCode(
            shaderHelper,
            x,
            input.dims.length,
            outputShape.length,
            adjustedAttributes,
            op1,
            op2,
            0,
            uniforms,
            hasPads,
            pwStartEndNotZero,
            phStartEndNotZero
          )
        };
      };
      parseAveragePoolAttributes = (attributes) => {
        const countIncludePad = attributes.count_include_pad === 0 ? false : true;
        const attr = parsePoolCommonAttributes(attributes);
        if (attr.ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
        }
        const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };
        return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };
      };
      averagePool = (context, attributes) => {
        validateInputs22(context.inputs);
        context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));
      };
      globalPoolAttributes = {
        autoPad: "",
        ceilMode: 0,
        countIncludePad: false,
        kernelShape: [],
        strides: [],
        pads: [],
        storageOrder: 0,
        dilations: []
      };
      parseGlobalAveragePoolAttributes = (attributes) => {
        const format = attributes.format;
        return { format, ...globalPoolAttributes, cacheKey: format };
      };
      globalAveragePool = (context, attributes) => {
        validateInputs22(context.inputs);
        context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));
      };
      createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(input, attributes, isGlobalOperator);
        const op1 = `
      value = max(x_val, value);
    `;
        const op2 = "";
        const x = inputVariable("x", input.dataType, input.dims.length);
        const inputDependencies = ["rank"];
        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(outputShape, adjustedAttributes);
        programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
        return {
          name,
          shaderCache: { hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: input.dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource: (shaderHelper) => generatePoolingCode(
            shaderHelper,
            x,
            input.dims.length,
            outputShape.length,
            adjustedAttributes,
            op1,
            op2,
            input.dataType === 10 /* float16 */ ? -65504 : -1e5,
            uniforms,
            hasPads,
            pwStartEndNotZero,
            phStartEndNotZero
          )
        };
      };
      maxPool = (context, attributes) => {
        validateInputs22(context.inputs);
        context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));
      };
      parseMaxPoolAttributes = (attributes) => {
        const storageOrder = attributes.storage_order;
        const dilations = attributes.dilations;
        const attr = parsePoolCommonAttributes(attributes);
        if (storageOrder !== 0) {
          throw new Error("column major storage order is not yet supported for MaxPool");
        }
        if (attr.ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
        }
        const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };
        return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };
      };
      parseGlobalMaxPoolAttributes = (attributes) => {
        const format = attributes.format;
        return { format, ...globalPoolAttributes, cacheKey: format };
      };
      globalMaxPool = (context, attributes) => {
        validateInputs22(context.inputs);
        context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/range.ts
  var validateInputsContent, createRangeProgramInfo, range;
  var init_range = __esm({
    "web/lib/wasm/jsep/webgpu/ops/range.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_common();
      validateInputsContent = (start, limit, delta) => {
        const sameStartLimit = start === limit;
        const increasingRangeNegativeStep = start < limit && delta < 0;
        const decreasingRangePositiveStep = start > limit && delta > 0;
        if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {
          throw new Error("Range these inputs' contents are invalid.");
        }
      };
      createRangeProgramInfo = (start, limit, delta, dataType) => {
        const numElements = Math.abs(Math.ceil((limit - start) / delta));
        const outputShape = [numElements];
        const outputSize = numElements;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: dataType, data: start },
          { type: dataType, data: delta },
          ...createTensorShapeVariables(outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", dataType, outputShape.length);
          const wgslType = output.type.value;
          const uniforms = [
            { name: "outputSize", type: "u32" },
            { name: "start", type: wgslType },
            { name: "delta", type: wgslType }
          ];
          return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;
      }`;
        };
        return {
          name: "Range",
          shaderCache: { hint: `${dataType}` },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      range = (context) => {
        let start = 0;
        let limit = 0;
        let delta = 0;
        if (context.inputs[0].dataType === 6 /* int32 */) {
          start = context.inputs[0].getInt32Array()[0];
          limit = context.inputs[1].getInt32Array()[0];
          delta = context.inputs[2].getInt32Array()[0];
        } else if (context.inputs[0].dataType === 1 /* float */) {
          start = context.inputs[0].getFloat32Array()[0];
          limit = context.inputs[1].getFloat32Array()[0];
          delta = context.inputs[2].getFloat32Array()[0];
        }
        if (env2.webgpu.validateInputContent) {
          validateInputsContent(start, limit, delta);
        }
        context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/resize.ts
  var validateScales, updateScales, validateInputs23, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;
  var init_resize = __esm({
    "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateScales = (scales, attributes) => {
        scales.every((value) => value > 0 || (() => {
          throw new Error("Resize requires scales input values to be positive");
        }));
        if (scales.length > 0) {
          if (attributes.mode === "linear") {
            if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {
              throw new Error(
                `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`
              );
            }
          } else if (attributes.mode === "cubic") {
            if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {
              throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
            }
          }
        }
      };
      updateScales = (scales, axes, rank) => {
        axes.every((value) => value >= 0 && value < rank || (() => {
          throw new Error("Resize requires axes input values to be positive and less than rank");
        }));
        const newScales = new Array(rank).fill(1);
        axes.forEach((value, index) => newScales[value] = scales[index]);
        return newScales;
      };
      validateInputs23 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {
        const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];
        const rank = inputs[0].dims.length;
        if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {
          inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));
        } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {
          throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
        }
        if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length > 0) {
          inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));
          if (scales.length !== 0 && (scales.length !== rank && (opsetVersion >= 18 && scales.length !== attributes.axes.length))) {
            throw new Error(
              "Resize requires scales input size to be same as input rank or axes size for opset 18 and up"
            );
          }
          validateScales(scales, attributes);
          if (attributes.axes.length > 0) {
            updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);
          }
        }
        if (sizesInputIndex > 0 && inputs.length > sizesInputIndex) {
          inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));
          if (sizes.length !== rank || opsetVersion >= 18 && sizes.length === attributes.axes.length) {
            throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
          }
        }
        if (attributes.axes.length > 0) {
          if (scales.length !== attributes.axes.length) {
            throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
          }
          if (sizes.length !== attributes.axes.length) {
            throw new Error(
              'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified'
            );
          }
        }
        if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {
          throw new Error("Resize requires only of scales or sizes to be specified");
        }
      };
      getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {
        switch (coordinateTransferMode) {
          case "asymmetric":
            return `return ${dType}(xResized) / ${dType}(xScale);`;
          case "pytorch_half_pixel":
            return `if (lengthResized > 1) {
                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
          case "tf_half_pixel_for_nn":
            return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;
          case "align_corners":
            return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${dType}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${dType}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${dType}(lengthResized - 1);
                    return whole + fract;
                  }`;
          case "tf_crop_and_resize":
            return `if (lengthResized > 1) {
                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +
                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /
                        ${dType}(lengthResized - 1);
                  } else {
                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);
                  }`;
          case "half_pixel_symmetric":
            return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);
                  const adjustment = ${dType}(lengthResized) / outputWidth;
                  const center = ${dType}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
          case "half_pixel":
            return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
          default:
            throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);
        }
      })() + "}";
      getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {
        switch (nearestMode) {
          case "round_prefer_ceil":
            return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
          case "floor":
            return "return floor(xOriginal);";
          case "ceil":
            return "return ceil(xOriginal);";
          case "round_prefer_floor":
            return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
          case "simple":
          default:
            if (opsetVersion < 11) {
              return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
            }
            throw new Error(`Nearest mode ${nearestMode} is not supported`);
        }
      })() + "}";
      updateRoI = (roi, axes, rank) => {
        const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));
        const roiLocal = roi.length === 0 ? roiTmp : roi.slice();
        if (axes.length > 0) {
          axes.forEach((v, i) => {
            roiTmp[v] = roiLocal[i];
            roiTmp[i + rank] = roiLocal[axes.length + i];
          });
          return roiTmp;
        }
        return roiLocal;
      };
      initOutputShape = (inputShape, scales, sizes, axes) => {
        let outputShape = [];
        if (sizes.length > 0) {
          if (axes.length > 0) {
            inputShape.forEach((v) => outputShape.push(v));
            if (Math.max(...axes) > inputShape.length) {
              throw new Error("axes is out of bound");
            }
            axes.forEach((v, i) => outputShape[v] = sizes[i]);
          } else {
            sizes.forEach((v) => outputShape.push(v));
          }
        } else {
          if (scales.length === 0) {
            throw new Error("Resize requires either scales or sizes.");
          } else {
            outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));
          }
        }
        return outputShape;
      };
      adjustOutputShape = (inputShape, scales, attributes) => {
        const scaleInPolicy = (() => {
          switch (attributes.keepAspectRatioPolicy) {
            case "not_larger":
              return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);
            case "not_smaller":
              return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);
            default:
              throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);
          }
        })();
        scales.fill(1, 0, scales.length);
        const adjustedOutputShape = inputShape.slice();
        if (attributes.axes.length > 0) {
          attributes.axes.forEach((v) => scales[v] = scaleInPolicy);
          attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));
        } else {
          scales.fill(scaleInPolicy, 0, scales.length);
          adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));
        }
        return adjustedOutputShape;
      };
      calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {
      var original_indices: array<${output.type.value}, ${outputShape.length}>;
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
        if (scale == 1.0) {
          original_indices[i] = ${output.type.value}(output_index);
        } else {
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`;
      calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
      var input_indices: ${input.type.indices};
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${input.indicesSet("input_indices", "i", " input_index")}
      }
      return input_indices;
    }`;
      checkInputIndices = (input, inputShape) => `
    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${inputShape.length}; i++) {
        var input_index = ${input.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {
          return false;
        }
      }
      return true;
    }`;
      setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `
    ${input.indicesSet("input_indices", channelIdx, "channel")};
    ${input.indicesSet("input_indices", batchIdx, "batch")};
` : "";
      bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
        const isNchw = true;
        const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];
        const dType = input.type.value;
        return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}
      return ${input.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${dType} = originalIndices[${heightIdx}];
      var col:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {
        return ${extrapolationValue};
      }` : ""};
      row = max(0, min(row, ${inputShape[heightIdx]} - 1));
      col = max(0, min(col, ${inputShape[widthIdx]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};
      var x11: ${dType} = getInputValue(batch, channel, row1, col1);
      var x12: ${dType} = getInputValue(batch, channel, row1, col2);
      var x21: ${dType} = getInputValue(batch, channel, row2, col1);
      var x22: ${dType} = getInputValue(batch, channel, row2, col2);
      var dx1: ${dType} = abs(row - ${dType}(row1));
      var dx2: ${dType} = abs(${dType}(row2) - row);
      var dy1: ${dType} = abs(col - ${dType}(col1));
      var dy2: ${dType} = abs(${dType}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
      };
      bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {
        const is2D = inputShape.length === 2;
        const isNchw = true;
        const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];
        const dType = input.type.value;
        const createCubicInterpolationFunction = (idx) => {
          const direction = idx === heightIdx ? "row" : "col";
          return `
      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {
        var output_index = ${output.indicesGet("output_indices", idx)};
        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},
        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});
        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {
          return ${extrapolationValue};
        }
        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${direction}: ${dType} = originalIdx + ${dType}(i);
          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {
            ${(() => {
            if (excludeOutside) {
              return `coefs[i + 1] = 0.0;
                        continue;`;
            } else if (useExtrapolation) {
              return `return ${extrapolationValue};`;
            } else {
              return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;
            }
          })()};
          }
        var input_indices_copy: ${input.type.indices} = input_indices;
          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};
          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
        };
        return `
    ${createCubicInterpolationFunction(heightIdx)};
    ${createCubicInterpolationFunction(widthIdx)};
  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {
    var absS = abs(s);
    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${dType} = 1.0 - absS;
    var twoMinusAbsS: ${dType} = 2.0 - absS;
    var onePlusAbsS: ${dType} = 1.0 + absS;
    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};
    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;
    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {
    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
    var input_indices: ${input.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
      };
      trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
        const isNchw = true;
        const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];
        const dType = input.type.value;
        return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}
      return ${input.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${dType} = originalIndices[${depthIdx}];
      var height:${dType} = originalIndices[${heightIdx}];
      var width:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {
      return ${extrapolationValue};
        }` : ""};

    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));
      height = max(0, min(height, ${inputShape[heightIdx]} - 1));
      width = max(0, min(width, ${inputShape[widthIdx]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};

      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${dType} = abs(depth - ${dType}(depth1));
      var dx2: ${dType} = abs(${dType}(depth2) - depth);
      var dy1: ${dType} = abs(height - ${dType}(height1));
      var dy2: ${dType} = abs(${dType}(height2) - height);
      var dz1: ${dType} = abs(width - ${dType}(width1));
      var dz2: ${dType} = abs(${dType}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
      };
      createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {
        const inputShape = inputTensor.dims;
        const roi = updateRoI(roiInput, attributes.axes, inputShape.length);
        let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);
        let scales = scalesInput.slice();
        if (scalesInput.length === 0) {
          scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);
          if (attributes.keepAspectRatioPolicy !== "stretch") {
            outputShape = adjustOutputShape(inputShape, scales, attributes);
          }
        }
        const output = outputVariable("output", inputTensor.dataType, outputShape.length);
        const input = inputVariable("input", inputTensor.dataType, inputShape.length);
        const outputSize = ShapeUtil.size(outputShape);
        const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);
        const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";
        const extrapolationValue = attributes.extrapolationValue;
        const dataType = input.type.value;
        const getShaderSource = (shaderHelper) => `
      ${noScale ? "" : `
      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};
      ${(() => {
          switch (attributes.mode) {
            case "nearest":
              return `
              ${checkInputIndices(input, inputShape)};
              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};
              ${calculateInputIndicesFromOutputIndices(
                input,
                output,
                inputShape,
                outputShape,
                scales.length,
                roi.length,
                useExtrapolation
              )};
              `;
            case "linear":
              return `
              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};
              ${(() => {
                if (inputShape.length === 2 || inputShape.length === 4) {
                  return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
                } else if (inputShape.length === 3 || inputShape.length === 5) {
                  return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
                } else {
                  throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
                }
              })()};
            `;
            case "cubic":
              return `
            ${(() => {
                if (inputShape.length === 2 || inputShape.length === 4) {
                  return `${bicubicInterpolation(
                    input,
                    output,
                    inputShape,
                    outputShape,
                    scales,
                    roi,
                    attributes.cubicCoeffA,
                    useExtrapolation,
                    attributes.extrapolationValue,
                    attributes.excludeOutside
                  )}`;
                } else {
                  throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
                }
              })()};
            `;
            default:
              throw Error("Invalid resize mode");
          }
        })()};
      `}
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${noScale ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${output.offsetToIndices("global_idx")};
        var input_indices: ${input.type.indices};
        ${(() => {
          switch (attributes.mode) {
            case "nearest":
              return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${input.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${attributes.extrapolationValue};
                }`;
            case "linear":
              return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
            case "cubic":
              return "output[global_idx] = bicubicInterpolation(output_indices);";
            default:
              throw Error(`Unsupported resize mode: ${attributes.mode}`);
          }
        })()};
`}
      }`;
        return {
          name: "Resize",
          shaderCache: {
            hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? scales : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${inputShape}`,
            inputDependencies: ["rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              { type: 1 /* float */, data: scales },
              { type: 1 /* float */, data: roi },
              ...createTensorShapeVariables(inputShape, outputShape)
            ]
          })
        };
      };
      getOpsetVersionFromCustomDataBuffer = (context) => {
        const customDataBuffer = context.customDataBuffer;
        const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);
        const opsetVersion = customDataBuffer32[0];
        return opsetVersion;
      };
      resize = (context, attributes) => {
        const scales = [];
        const sizes = [];
        const roi = [];
        const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);
        if (attributes.antialias !== 0) {
          throw Error("Only default value (0) for Antialias attribute is supported");
        }
        validateInputs23(context.inputs, attributes, opsetVersion, scales, sizes, roi);
        context.compute(
          createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi),
          { inputs: [0] }
        );
      };
      parseResizeAttributes = (attributes) => {
        const antialias = attributes.antialias;
        const axes = attributes.axes;
        const coordinateTransformMode = attributes.coordinateTransformMode;
        const cubicCoeffA = attributes.cubicCoeffA;
        const excludeOutside = attributes.excludeOutside !== 0;
        const extrapolationValue = attributes.extrapolationValue;
        const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;
        const mode = attributes.mode;
        const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;
        return createAttributeWithCacheKey({
          antialias,
          axes,
          coordinateTransformMode,
          cubicCoeffA,
          excludeOutside,
          extrapolationValue,
          keepAspectRatioPolicy,
          mode,
          nearestMode
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts
  var validateInputs24, createRotaryEmbeddingProgramInfo, rotaryEmbedding;
  var init_rotary_embedding = __esm({
    "web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs24 = (inputs, attributes) => {
        const [input, positionIds, cosCache, sinCache] = inputs;
        const { numHeads, rotaryEmbeddingDim } = attributes;
        if (input.dims.length !== 3 && input.dims.length !== 4) {
          throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${input.dims.length}`);
        }
        if (!ShapeUtil.areEqual(positionIds.dims, []) && !ShapeUtil.areEqual(positionIds.dims, [1]) && positionIds.dims.length !== 2) {
          throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${positionIds.dims.length}`);
        }
        if (cosCache.dims.length !== 2) {
          throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${cosCache.dims.length}`);
        }
        if (sinCache.dims.length !== 2) {
          throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${sinCache.dims.length}`);
        }
        if (!ShapeUtil.areEqual(cosCache.dims, sinCache.dims)) {
          throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
        }
        if (rotaryEmbeddingDim > 0 && numHeads === 0) {
          throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
        }
        const batchSize = input.dims[0];
        const sequenceLength = input.dims[input.dims.length - 2];
        const maxSequenceLength = cosCache.dims[0];
        const hiddenSize = ShapeUtil.sizeFromDimension(input.dims, 1) / sequenceLength;
        const headSize = rotaryEmbeddingDim === 0 ? cosCache.dims[1] * 2 : hiddenSize / numHeads;
        if (rotaryEmbeddingDim > headSize) {
          throw new Error("rotary_embedding_dim must be less than or equal to head_size");
        }
        if (positionIds.dims.length === 2) {
          if (batchSize !== positionIds.dims[0]) {
            throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${positionIds.dims[0]}`);
          }
          if (sequenceLength !== positionIds.dims[1]) {
            throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${positionIds.dims[1]}`);
          }
        }
        if (headSize / 2 !== cosCache.dims[1] && rotaryEmbeddingDim / 2 !== cosCache.dims[1]) {
          throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${cosCache.dims[1]}`);
        }
        if (sequenceLength > maxSequenceLength) {
          throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
        }
      };
      createRotaryEmbeddingProgramInfo = (inputs, attributes) => {
        const { interleaved, numHeads, rotaryEmbeddingDim, scale } = attributes;
        const batchSize = inputs[0].dims[0];
        const batchStride = ShapeUtil.sizeFromDimension(inputs[0].dims, 1);
        const sequenceLength = inputs[0].dims[inputs[0].dims.length - 2];
        const hiddenSize = batchStride / sequenceLength;
        const halfRotaryEmbeddingDim = inputs[2].dims[1];
        const headSize = rotaryEmbeddingDim === 0 ? halfRotaryEmbeddingDim * 2 : hiddenSize / numHeads;
        const globalShape = new Array(batchSize, sequenceLength, hiddenSize / headSize, headSize - halfRotaryEmbeddingDim);
        const globalStrides = ShapeUtil.computeStrides(globalShape);
        const programUniforms = [
          { type: 1 /* float */, data: scale },
          { type: 12 /* uint32 */, data: globalShape },
          { type: 12 /* uint32 */, data: globalStrides },
          // strides for addressing the input/output tensor, in permutated order to align with the unfolded global index,
          // i.e. BSNH
          ...inputs[0].dims.length === 3 ? new Array({ type: 12 /* uint32 */, data: [batchStride, hiddenSize, headSize, 1] }) : [],
          ...inputs[0].dims.length === 4 ? new Array(
            { type: 12 /* uint32 */, data: [batchStride, headSize, sequenceLength * headSize, 1] }
          ) : [],
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, inputs[2].dims, inputs[3].dims, inputs[0].dims)
        ];
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
          const positionIds = inputVariable("position_ids", inputs[1].dataType, inputs[1].dims.length);
          const cosCache = inputVariable("cos_cache", inputs[2].dataType, inputs[2].dims.length);
          const sinCache = inputVariable("sin_cache", inputs[3].dataType, inputs[3].dims.length);
          const output = outputVariable("output", inputs[0].dataType, inputs[0].dims.length);
          shaderHelper.registerUniforms([
            { name: "scale", type: "f32" },
            { name: "global_shape", type: "u32", length: globalShape.length },
            { name: "global_strides", type: "u32", length: globalStrides.length },
            { name: "input_output_strides", type: "u32", length: globalStrides.length }
          ]);
          return `
        ${shaderHelper.declareVariables(input, positionIds, cosCache, sinCache, output)}

        ${shaderHelper.mainStart(WORKGROUP_SIZE)}
          let half_rotary_emb_dim = uniforms.${cosCache.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${positionIds.broadcastedIndicesToOffset("bsnh.xy", outputVariable("", positionIds.type.tensor, 2))};
            let position_id =
                u32(${positionIds.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${interleaved});
            let j = i + select(half_rotary_emb_dim, 1, ${interleaved});
            let re = ${input.getByOffset("i")} * ${cosCache.get("position_id", "bsnh[3]")} -
                ${input.getByOffset("j")} * ${sinCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("i", "re")}
            let im = ${input.getByOffset("i")} * ${sinCache.get("position_id", "bsnh[3]")} +
                ${input.getByOffset("j")} * ${cosCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${output.setByOffset("k", input.getByOffset("k"))}
          }
        }`;
        };
        return {
          name: "RotaryEmbedding",
          shaderCache: {
            hint: createAttributeWithCacheKey({
              interleaved
            }).cacheKey,
            inputDependencies: ["rank", "rank", "rank", "rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(ShapeUtil.size(globalShape) / WORKGROUP_SIZE) },
            programUniforms
          })
        };
      };
      rotaryEmbedding = (context, attributes) => {
        validateInputs24(context.inputs, attributes);
        context.compute(createRotaryEmbeddingProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts
  var validateInputs25, createSkipLayerNormProgramInfo, skipLayerNorm;
  var init_skip_layer_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs25 = (inputs) => {
        if (!inputs || inputs.length < 3) {
          throw new Error("layerNorm requires at least 3 inputs.");
        }
        const input = inputs[0];
        const skip = inputs[1];
        const gamma = inputs[2];
        if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {
          throw new Error("All inputs must have the same data type");
        }
        if (input.dims.length !== 3 && input.dims.length !== 2) {
          throw new Error("Input must be 2D or 3D");
        }
        if (skip.dims.length !== 3 && skip.dims.length !== 2) {
          throw new Error("Skip must be 2D or 3D");
        }
        const hiddenSize = input.dims[input.dims.length - 1];
        const sequenceLength = input.dims[input.dims.length - 2];
        if (skip.dims[skip.dims.length - 1] !== hiddenSize) {
          throw new Error("Skip must have the same hidden size as input");
        }
        if (skip.dims[skip.dims.length - 2] !== sequenceLength) {
          throw new Error("Skip must have the same sequence length as input");
        }
        if (gamma.dims.length !== 1) {
          throw new Error("Gamma must be 1D");
        }
        if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {
          throw new Error("Gamma must have the same hidden size as input");
        }
        if (inputs.length > 3) {
          const beta = inputs[3];
          if (beta.dims.length !== 1) {
            throw new Error("Beta must be 1D");
          }
          if (beta.dims[beta.dims.length - 1] !== hiddenSize) {
            throw new Error("Beta must have the same hidden size as input");
          }
        }
        if (inputs.length > 4) {
          const bias = inputs[4];
          if (bias.dims.length !== 1) {
            throw new Error("Bias must be 1D");
          }
          if (bias.dims[bias.dims.length - 1] !== hiddenSize) {
            throw new Error("Bias must have the same hidden size as input");
          }
        }
      };
      createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {
        const simplified = attributes.simplified;
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const outputShape = inputShape;
        const outputSize = inputSize;
        const hiddenSize = inputShape.slice(-1)[0];
        const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];
        const hasBetaInput = !simplified && inputs.length > 3;
        const hasBiasInput = inputs.length > 4;
        const hasMeanOutput = isTraining && outputCount > 1;
        const hasInvStdDevOutput = isTraining && outputCount > 2;
        const hasInputSkipBiasSumOutput = outputCount > 3;
        const workgroupSize = 64;
        const components = getMaxComponents(hiddenSize);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: components },
          { type: 12 /* uint32 */, data: hiddenSize },
          { type: 1 /* float */, data: attributes.epsilon }
        ];
        const getShaderSource = (shaderHelper) => {
          const uniformsArray = [
            { name: "output_size", type: "u32" },
            { name: "components", type: "u32" },
            { name: "hidden_size", type: "u32" },
            { name: "epsilon", type: "f32" }
          ];
          const variables = [
            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
            inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),
            inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)
          ];
          if (hasBetaInput) {
            variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));
          }
          if (hasBiasInput) {
            variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));
          }
          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
          if (hasMeanOutput) {
            variables.push(outputVariable("mean_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInvStdDevOutput) {
            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInputSkipBiasSumOutput) {
            variables.push(outputVariable("input_skip_bias_sum", inputs[0].dataType, outputShape, components));
          }
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const vecDataType = tensorTypeToWsglStorageType(1 /* float */, components);
          return `

      ${shaderHelper.registerUniforms(uniformsArray).declareVariables(...variables)}
      var<workgroup> sum_shared : array<${vecDataType}, ${workgroupSize}>;
      var<workgroup> sum_squared_shared : array<${vecDataType}, ${workgroupSize}>;

      ${shaderHelper.mainStart([
            workgroupSize,
            1,
            1
          ])}
        let ix = local_id.x;
        let iy = global_id.x / ${workgroupSize};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${workgroupSize};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${workgroupSize - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${hasBiasInput ? "bias[offset1d + i]" : dataType + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${hasInputSkipBiasSumOutput ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${castToF32(dataType, components, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${workgroupSize};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${sumVector("sum", components)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${sumVector("square_sum", components)} / f32(uniforms.hidden_size) ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);
        ${hasMeanOutput ? "mean_output[global_idx] = mean;" : ""}
        ${hasInvStdDevOutput ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${simplified ? "" : `- ${dataType}(mean)`}) *
            ${dataType}(inv_std_dev) * gamma[offset1d + i]
            ${hasBetaInput ? "+ beta[offset1d + i]" : ""};
        }
      }`;
        };
        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
        if (outputCount > 1) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (outputCount > 2) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (outputCount > 3) {
          outputs.push({ dims: inputShape, dataType: inputs[0].dataType });
        }
        return {
          name: "SkipLayerNormalization",
          shaderCache: {
            hint: `${components};${hasMeanOutput};${hasInvStdDevOutput};${hasInputSkipBiasSumOutput}`,
            inputDependencies: inputs.map((_input, _index) => "type")
          },
          getShaderSource,
          getRunData: () => ({
            outputs,
            dispatchGroup: {
              x: Math.ceil(outputSize / hiddenSize)
            },
            programUniforms
          })
        };
      };
      skipLayerNorm = (context, attributes) => {
        const isTraining = false;
        validateInputs25(context.inputs);
        const outputs = [0];
        if (context.outputCount > 1) {
          outputs.push(isTraining ? 1 : -3);
        }
        if (context.outputCount > 2) {
          outputs.push(isTraining ? 2 : -3);
        }
        if (context.outputCount > 3) {
          outputs.push(3);
        }
        context.compute(
          createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining),
          { outputs }
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/slice.ts
  var validateInputs26, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;
  var init_slice = __esm({
    "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs26 = (inputs, attributes) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        if (attributes.axes.length !== 0) {
          if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {
            throw new Error("axes, starts and ends must have the same length");
          }
        } else if (attributes.starts.length !== attributes.ends.length) {
          throw new Error("starts and ends must have the same length");
        }
        inputs.slice(1).forEach((_, idx) => {
          if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {
            throw new Error(`Input ${idx} must be an array of int32 or int64`);
          }
        });
      };
      readInput = (inputs, idx) => {
        const input = [];
        if (inputs.length > idx) {
          if (inputs[idx].dataType === 7 /* int64 */) {
            inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));
          } else if (inputs[idx].dataType === 6 /* int32 */) {
            inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));
          } else {
            throw new Error(`Input ${idx} must be an array of int32 or int64`);
          }
        }
        return input;
      };
      createSliceAttributesFromInputs = (inputs, attributes) => {
        if (inputs.length > 1) {
          const starts = readInput(inputs, 1);
          const ends = readInput(inputs, 2);
          let axes = readInput(inputs, 3);
          if (axes.length === 0) {
            axes = [...Array(inputs[0].dims.length).keys()];
          }
          return createAttributeWithCacheKey({ starts, ends, axes });
        } else {
          return attributes;
        }
      };
      fixStartEndValues = (value, index, inputShape, axes, steps) => {
        let newValue = value;
        if (value < 0) {
          newValue += inputShape[axes[index]];
        }
        if (steps[index] < 0) {
          return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));
        } else {
          return Math.max(0, Math.min(newValue, inputShape[axes[index]]));
        }
      };
      calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
          var input_indices: ${input.type.indices};
          var carry = 0u;
          for (var i = ${inputShape.length}; i >= 0; i--) {
            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};
            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};
            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};
            var output_index = ${output.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${input.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`;
      createSliceProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];
        let steps = readInput(inputs, 4);
        steps.forEach((step) => step !== 0 || (() => {
          throw new Error("step cannot be 0");
        }));
        if (steps.length === 0) {
          steps = Array(axes.length).fill(1);
        }
        const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));
        const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));
        if (axes.length !== starts.length || axes.length !== ends.length) {
          throw new Error("start, ends and axes should have the same number of elements");
        }
        if (axes.length !== inputShape.length) {
          for (let i = 0; i < inputShape.length; ++i) {
            if (!axes.includes(i)) {
              starts.splice(i, 0, 0);
              ends.splice(i, 0, inputShape[i]);
              steps.splice(i, 0, 1);
            }
          }
        }
        const signs = steps.map((step) => Math.sign(step));
        steps.forEach((step, i, array) => {
          if (step < 0) {
            const numSteps = (ends[i] - starts[i]) / step;
            const newEnd = starts[i];
            const newStart = newEnd + numSteps * steps[i];
            starts[i] = newStart;
            ends[i] = newEnd;
            array[i] = -step;
          }
        });
        const outputShape = inputShape.slice(0);
        axes.forEach((axis, _) => {
          outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);
        });
        const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
        const outputSize = ShapeUtil.size(outputShape);
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "starts", type: "u32", length: starts.length },
          { name: "signs", type: "i32", length: signs.length },
          { name: "steps", type: "u32", length: steps.length }
        ];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: starts },
          { type: 6 /* int32 */, data: signs },
          { type: 12 /* uint32 */, data: steps },
          ...createTensorShapeVariables(inputs[0].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
        ${calculateInputIndicesImpl(input, output, inputShape)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${output.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
      }`;
        return {
          name: "Slice",
          shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [outputTensorInfo],
            dispatchGroup: { x: Math.ceil(
              inputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      slice = (context, attributes) => {
        validateInputs26(context.inputs, attributes);
        const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);
        context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
      parseSliceAttributes = (attributes) => {
        const starts = attributes.starts;
        const ends = attributes.ends;
        const axes = attributes.axes;
        return createAttributeWithCacheKey({ starts, ends, axes });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/softmax.ts
  var validateInputs27, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;
  var init_softmax = __esm({
    "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs27 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Softmax op requires 1 input.");
        }
      };
      createSoftmaxProgramInfo = (input, attributes) => {
        const shape = input.dims;
        const outputSize = ShapeUtil.size(shape);
        const WG = 64;
        let axis = attributes.axis;
        if (axis < 0) {
          axis = shape.length + axis;
        }
        if (axis < shape.length - 1) {
          throw new Error("softmax only supports last axis for now.");
        }
        const cols = shape[axis];
        const rows = outputSize / cols;
        const components = getMaxComponents(cols);
        const packedCols = cols / components;
        const maxVector = (name, components2) => {
          if (components2 === 4) {
            return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;
          } else if (components2 === 2) {
            return `max(${name}.x, ${name}.y)`;
          } else if (components2 === 3) {
            return `max(max(${name}.x, ${name}.y), ${name}.z)`;
          }
          return name;
        };
        const x = inputVariable("x", input.dataType, input.dims, components);
        const output = outputVariable("result", input.dataType, input.dims, components);
        const valueType = x.type.value;
        const threadMaxDecl = tensorTypeToWsglStorageType(input.dataType) === "f32" ? `var threadMax = ${valueType}(-3.402823e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;
        const getShaderSource = (shaderHelper) => `
      var<workgroup> rowMaxShared : ${valueType};
      var<workgroup> rowSumShared : ${valueType};
      var<workgroup> threadShared : array<${valueType}, ${WG}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}
      ${shaderHelper.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${WG};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${threadMaxDecl}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${valueType}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;
        return {
          name: "Softmax",
          shaderCache: { hint: `${components}`, inputDependencies: ["type"] },
          getRunData: () => ({
            outputs: [{ dims: shape, dataType: input.dataType }],
            dispatchGroup: { x: rows },
            programUniforms: [{ type: 6 /* int32 */, data: packedCols }]
          }),
          getShaderSource
        };
      };
      softmax = (context, attributes) => {
        validateInputs27(context.inputs);
        context.compute(createSoftmaxProgramInfo(context.inputs[0], attributes));
      };
      parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/split.ts
  var validateInputs28, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;
  var init_split = __esm({
    "web/lib/wasm/jsep/webgpu/ops/split.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs28 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
      };
      createSplitAttributesFromInputs = (inputs, attributes) => {
        const splitSizes = [];
        let numOutputs = attributes.numOutputs;
        if (inputs[1].dims[0] > 0) {
          inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));
          numOutputs = splitSizes.length;
        }
        return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });
      };
      calculateOutputIndexImpl = (numberOfTensors) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {
    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {
        return i;
    }
    }
    return ${numberOfTensors}u;
}`;
      writeBufferDataImpl = (outputs) => {
        const numberOfTensors = outputs.length;
        const codeLines = [];
        for (let i = 0; i < numberOfTensors; ++i) {
          const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");
          if (numberOfTensors === 1) {
            codeLines.push(returnSnippet);
          } else if (i === 0) {
            codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`else { ${returnSnippet} }`);
          } else {
            codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);
          }
        }
        return `
      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {
        ${codeLines.join("\n")}
      }`;
      };
      createSplitProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const dataType = inputs[0].dataType;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        const outputs = new Array(attributes.numOutputs);
        const input = inputVariable("input", dataType, inputShape.length);
        const sizeInSplitAxis = new Array(attributes.numOutputs);
        const outputsTensorInfo = [];
        const outputShapes = [];
        let previousSum = 0;
        const programUniforms = [{ type: 12 /* uint32 */, data: inputSize }];
        for (let i = 0; i < attributes.numOutputs; i++) {
          previousSum += attributes.splitSizes[i];
          sizeInSplitAxis[i] = previousSum;
          const outputShape = inputShape.slice();
          outputShape[attributes.axis] = attributes.splitSizes[i];
          outputShapes.push(outputShape);
          outputs[i] = outputVariable(`output${i}`, dataType, outputShape.length);
          outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });
        }
        programUniforms.push(
          { type: 12 /* uint32 */, data: sizeInSplitAxis },
          ...createTensorShapeVariables(inputShape, ...outputShapes)
        );
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}
  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}
  ${writeBufferDataImpl(outputs)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${input.offsetToIndices("global_idx")};
    var index = ${input.indicesGet("indices", axis)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};
      ${input.indicesSet("indices", axis, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
        return {
          name: "Split",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: outputsTensorInfo,
            dispatchGroup: { x: Math.ceil(
              inputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      split = (context, attributes) => {
        validateInputs28(context.inputs);
        const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);
        context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
      parseSplitAttributes = (attributes) => {
        const axis = attributes.axis;
        const splitSizes = attributes.splitSizes;
        const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;
        if (numOutputs !== splitSizes.length) {
          throw new Error("numOutputs and splitSizes lengh must be equal");
        }
        return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/where.ts
  var createWhereOpProgramShader, createWhereOpProgramInfo, where;
  var init_where = __esm({
    "web/lib/wasm/jsep/webgpu/ops/where.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {
        const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);
        const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);
        const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);
        const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);
        let assignment;
        const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;
        if (!isBroadcast) {
          assignment = output.setByOffset(
            "global_idx",
            expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))
          );
        } else {
          const singleAssignment = (resStr, x, typeCast = "") => {
            const expressionA = `a_data[index_a${x}][component_a${x}]`;
            const expressionB = `b_data[index_b${x}][component_b${x}]`;
            const expressionC = `bool(c_data[index_c${x}] & (0xffu << (component_c${x} * 8)))`;
            return `
            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let index_a${x} = offset_a${x} / 4u;
            let index_b${x} = offset_b${x} / 4u;
            let index_c${x} = offset_c${x} / 4u;
            let component_a${x} = offset_a${x} % 4u;
            let component_b${x} = offset_b${x} % 4u;
            let component_c${x} = offset_c${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});
          `;
          };
          if (typeOutput === 9 /* bool */) {
            assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
          } else {
            assignment = `
            ${singleAssignment("output_data[global_idx]", 0)}
            ${singleAssignment("output_data[global_idx]", 1)}
            ${singleAssignment("output_data[global_idx]", 2)}
            ${singleAssignment("output_data[global_idx]", 3)}
          `;
          }
        }
        return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
      };
      createWhereOpProgramInfo = (inputs) => {
        const dimsA = inputs[1].dims;
        const dimsB = inputs[2].dims;
        const dimsC = inputs[0].dims;
        const outputDataType = inputs[1].dataType;
        const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));
        let outputShape = dimsA;
        let outputSize = ShapeUtil.size(dimsA);
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);
          if (!calculatedShape) {
            throw new Error("Can't perform where op on the given tensors");
          }
          outputShape = calculatedShape;
          outputSize = ShapeUtil.size(outputShape);
        }
        const vecSize = Math.ceil(outputSize / 4);
        return {
          name: "Where",
          shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
          getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64 / 4
              /* vec size */
            ) },
            programUniforms: [{ type: 12 /* uint32 */, data: vecSize }, ...createTensorShapeVariables(dimsC, dimsA, dimsB, outputShape)]
          })
        };
      };
      where = (context) => {
        context.compute(createWhereOpProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/op-resolve-rules.ts
  var WEBGPU_OP_RESOLVE_RULES;
  var init_op_resolve_rules = __esm({
    "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {
      "use strict";
      init_argminmax();
      init_attention();
      init_batch_norm();
      init_bias_add();
      init_bias_split_gelu();
      init_binary_op();
      init_concat();
      init_conv();
      init_conv_transpose();
      init_cumsum();
      init_depth_to_space();
      init_einsum();
      init_expand();
      init_fast_gelu();
      init_gather();
      init_gather_elements();
      init_gemm();
      init_group_query_attention();
      init_instance_norm();
      init_layer_norm();
      init_matmul();
      init_matmulnbits();
      init_multihead_attention();
      init_pad();
      init_pool();
      init_range();
      init_reduce();
      init_resize();
      init_rotary_embedding();
      init_skip_layer_norm();
      init_slice();
      init_softmax();
      init_split();
      init_tile();
      init_transpose();
      init_unary_op();
      init_where();
      WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([
        ["Abs", [abs]],
        ["Acos", [acos]],
        ["Acosh", [acosh]],
        ["Add", [add]],
        ["ArgMax", [argMax, parseArgMinMaxAttributes]],
        ["ArgMin", [argMin, parseArgMinMaxAttributes]],
        ["Asin", [asin]],
        ["Asinh", [asinh]],
        ["Atan", [atan]],
        ["Atanh", [atanh]],
        ["Attention", [attention]],
        // TODO: support new attributes for AveragePool-10
        ["AveragePool", [averagePool, parseAveragePoolAttributes]],
        ["BatchNormalization", [batchNorm]],
        ["BiasAdd", [biasAdd]],
        ["BiasSplitGelu", [biasSplitGelu]],
        ["Cast", [cast, parseCastAttributes]],
        ["Ceil", [ceil]],
        ["Clip", [clip]],
        ["Concat", [concat, parseConcatAttributes]],
        ["Conv", [conv, parseConvAttributes]],
        ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],
        ["Cos", [cos]],
        ["Cosh", [cosh]],
        ["CumSum", [cumsum, parseCumSumAttributes]],
        ["DepthToSpace", [depthToSpace, parseDepthToSpaceAttributes]],
        ["Div", [div]],
        ["Einsum", [einsum, parseEinsumAttributes]],
        ["Elu", [elu, parseAlphaAttributes]],
        ["Equal", [equal]],
        ["Erf", [erf]],
        ["Exp", [exp]],
        ["Expand", [expand]],
        ["FastGelu", [fastGelu2]],
        ["Floor", [floor]],
        ["FusedConv", [conv, parseConvAttributes]],
        ["Gather", [gather, parseGatherAttributes]],
        ["GatherElements", [gatherElements, parseGatherElementsAttributes]],
        ["Gelu", [gelu]],
        ["Gemm", [gemm, parseGemmAttributes]],
        ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],
        ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],
        ["Greater", [greater]],
        ["GreaterOrEqual", [greaterOrEqual]],
        ["GroupQueryAttention", [groupQueryAttention, parseGroupQueryAttentionAttributes]],
        ["HardSigmoid", [hardSigmoid, parseHardSigmoidAttributes]],
        ["InstanceNormalization", [instanceNorm]],
        ["LayerNormalization", [layerNorm]],
        ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],
        ["Less", [less]],
        ["LessOrEqual", [lessOrEqual]],
        ["Log", [log]],
        ["MatMul", [matMul]],
        ["MatMulNBits", [matMulNBits, parseMatMulNBitsAttributes]],
        // TODO: support new attributes for MaxPool-8 and MaxPool-10
        ["MaxPool", [maxPool, parseMaxPoolAttributes]],
        ["Mul", [mul]],
        ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],
        ["Neg", [neg]],
        ["Not", [not]],
        ["Pad", [pad]],
        ["Pow", [pow]],
        ["QuickGelu", [quickgelu, parseAlphaAttributes]],
        ["Range", [range]],
        ["Reciprocal", [reciprocal]],
        ["ReduceMin", [reduceMin]],
        ["ReduceMean", [reduceMean]],
        ["ReduceMax", [reduceMax]],
        ["ReduceSum", [reduceSum]],
        ["ReduceProd", [reduceProd]],
        ["ReduceL1", [reduceL1]],
        ["ReduceL2", [reduceL2]],
        ["ReduceLogSum", [reduceLogSum]],
        ["ReduceLogSumExp", [reduceLogSumExp]],
        ["ReduceSumSquare", [reduceSumSquare]],
        ["Relu", [relu]],
        ["Resize", [resize, parseResizeAttributes]],
        ["RotaryEmbedding", [rotaryEmbedding]],
        ["Sigmoid", [sigmoid]],
        ["Sin", [sin]],
        ["Sinh", [sinh]],
        ["Slice", [slice, parseSliceAttributes]],
        ["SkipLayerNormalization", [skipLayerNorm]],
        ["Split", [split, parseSplitAttributes]],
        ["Sqrt", [sqrt]],
        ["Softmax", [softmax, parseSoftmaxAttributes]],
        ["Sub", [sub]],
        ["Tan", [tan]],
        ["Tanh", [tanh]],
        ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],
        ["Tile", [tile]],
        ["Transpose", [transpose, parseTransposeAttributes]],
        ["Where", [where]]
      ]);
    }
  });

  // web/lib/wasm/jsep/webgpu/program-manager.ts
  var ProgramManager;
  var init_program_manager = __esm({
    "web/lib/wasm/jsep/webgpu/program-manager.ts"() {
      "use strict";
      init_esm();
      init_log();
      init_common();
      ProgramManager = class {
        constructor(backend) {
          this.backend = backend;
          this.repo = /* @__PURE__ */ new Map();
          this.attributesBound = false;
        }
        getArtifact(key) {
          return this.repo.get(key);
        }
        setArtifact(key, artifact) {
          this.repo.set(key, artifact);
        }
        run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {
          TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);
          const device = this.backend.device;
          const computePassEncoder = this.backend.getComputePassEncoder();
          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
          const entries = [];
          for (const input of inputs) {
            entries.push({ binding: entries.length, resource: { buffer: input.buffer } });
          }
          for (const output of outputs) {
            entries.push({ binding: entries.length, resource: { buffer: output.buffer } });
          }
          if (uniformBufferBinding) {
            entries.push({ binding: entries.length, resource: uniformBufferBinding });
          }
          const bindGroup = device.createBindGroup(
            { layout: buildArtifact.computePipeline.getBindGroupLayout(0), entries, label: buildArtifact.programInfo.name }
          );
          if (this.backend.sessionStatus === "capturing") {
            const commandInfo = {
              kernelId: this.backend.currentKernelId,
              computePipeline: buildArtifact.computePipeline,
              bindGroup,
              dispatchGroup
            };
            const sessionCommandList = this.backend.capturedCommandList.get(this.backend.currentSessionId);
            sessionCommandList.push(commandInfo);
          }
          computePassEncoder.setPipeline(buildArtifact.computePipeline);
          computePassEncoder.setBindGroup(0, bindGroup);
          computePassEncoder.dispatchWorkgroups(...dispatchGroup);
          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);
          this.backend.pendingDispatchNumber++;
          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {
            this.backend.endComputePass();
          }
          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {
            this.backend.flush();
          }
          TRACE_FUNC_END(buildArtifact.programInfo.name);
        }
        dispose() {
        }
        build(programInfo, normalizedDispatchGroupSize) {
          TRACE_FUNC_BEGIN(programInfo.name);
          const device = this.backend.device;
          const extensions = [];
          if (device.features.has("shader-f16")) {
            extensions.push("enable f16;");
          }
          const shaderHelper = createShaderHelper(normalizedDispatchGroupSize, this.backend.device.limits);
          const userCode = programInfo.getShaderSource(shaderHelper);
          const code = `${extensions.join("\n")}
${shaderHelper.additionalImplementations}
${userCode}`;
          const shaderModule = device.createShaderModule({ code, label: programInfo.name });
          LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);
          const computePipeline = device.createComputePipeline(
            { compute: { module: shaderModule, entryPoint: "main" }, layout: "auto", label: programInfo.name }
          );
          TRACE_FUNC_END(programInfo.name);
          return { programInfo, computePipeline, uniformVariablesInfo: shaderHelper.variablesInfo };
        }
        normalizeDispatchGroupSize(dispatchGroup) {
          const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;
          const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;
          const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;
          const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
          if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {
            return [x, y, z];
          }
          const size = x * y * z;
          let dispatchAverage = Math.ceil(Math.sqrt(size));
          if (dispatchAverage > limitPerDimension) {
            dispatchAverage = Math.ceil(Math.cbrt(size));
            if (dispatchAverage > limitPerDimension) {
              throw new Error("Total dispatch size exceeds WebGPU maximum.");
            }
            return [dispatchAverage, dispatchAverage, dispatchAverage];
          } else {
            return [dispatchAverage, dispatchAverage, 1];
          }
        }
      };
    }
  });

  // web/lib/wasm/jsep/backend-webgpu.ts
  var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, AdapterInfoImpl, WebGpuBackend;
  var init_backend_webgpu = __esm({
    "web/lib/wasm/jsep/backend-webgpu.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_log();
      init_tensor_view();
      init_gpu_data_manager();
      init_op_resolve_rules();
      init_program_manager();
      getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {
        if (inputDependencies.length !== inputTensors.length) {
          throw new Error(`inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`);
        }
        const inputInfos = [];
        for (let i = 0; i < inputTensors.length; ++i) {
          const type = inputTensors[i].dataType;
          switch (inputDependencies[i]) {
            case "none": {
              inputInfos.push("");
              break;
            }
            case "type": {
              inputInfos.push(`${type}`);
              break;
            }
            case "rank": {
              const rank = inputTensors[i].dims.length;
              inputInfos.push(`${type};${rank}`);
              break;
            }
            case "dims": {
              const dims = inputTensors[i].dims.join(",");
              inputInfos.push(`${type};${dims}`);
              break;
            }
            default:
              throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);
          }
        }
        return inputInfos.join("|");
      };
      getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {
        let key = programInfo.name;
        if (programInfo.shaderCache?.hint) {
          key += "[" + programInfo.shaderCache.hint + "]";
        }
        key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(
          inputTensors,
          programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")
        )}`;
        return key;
      };
      AdapterInfoImpl = class {
        constructor(adapterInfo) {
          if (adapterInfo) {
            this.architecture = adapterInfo.architecture;
            this.vendor = adapterInfo.vendor;
          }
        }
        isArchitecture(architecture) {
          return this.architecture === architecture;
        }
        isVendor(vendor) {
          return this.vendor === vendor;
        }
      };
      WebGpuBackend = class {
        constructor() {
          /**
           * representing the session ID of which is currently being run.
           * `null` means no session is being run.
           * only valid when session.run is executed.
           */
          this.currentSessionId = null;
          /**
           * representing the kernel ID of which is currently being computed (CPU code perspective).
           * `null` means no kernel is being computed.
           * only one kernel can be computed at a moment.
           */
          this.currentKernelId = null;
          this.commandEncoder = null;
          this.computePassEncoder = null;
          this.maxDispatchNumber = 16;
          this.pendingDispatchNumber = 0;
          // info of kernels pending submission for a single batch
          this.pendingKernels = [];
          // queryReadBuffer -> pendingKernels mapping for all the batches
          this.pendingQueries = /* @__PURE__ */ new Map();
          this.sessionStatus = "default";
          /**
           * a SessionID -> CommandInfo[] mapping. It's used to record all GPU commands for corresponding session.
           */
          this.capturedCommandList = /* @__PURE__ */ new Map();
          /**
           * a SessionID -> PendingKernelInfo[] mapping for profiling.
           */
          this.capturedPendingKernels = /* @__PURE__ */ new Map();
          /**
           * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.
           */
          this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
        }
        /**
         * get the custom data of the current kernel
         */
        get currentKernelCustomData() {
          if (this.currentKernelId === null) {
            throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
          }
          let data = this.kernelCustomData.get(this.currentKernelId);
          if (!data) {
            data = {};
            this.kernelCustomData.set(this.currentKernelId, data);
          }
          return data;
        }
        async initialize(env3, adapter) {
          this.env = env3;
          const requiredFeatures = [];
          const deviceDescriptor = {
            requiredLimits: {
              maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,
              maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,
              maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
              maxBufferSize: adapter.limits.maxBufferSize,
              maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,
              maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,
              maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,
              maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ
            },
            requiredFeatures
          };
          if (adapter.features.has("chromium-experimental-timestamp-query-inside-passes")) {
            requiredFeatures.push("chromium-experimental-timestamp-query-inside-passes");
          } else if (adapter.features.has("timestamp-query")) {
            requiredFeatures.push("timestamp-query");
          }
          if (adapter.features.has("shader-f16")) {
            requiredFeatures.push("shader-f16");
          }
          this.device = await adapter.requestDevice(deviceDescriptor);
          this.adapterInfo = new AdapterInfoImpl(adapter.info || await adapter.requestAdapterInfo());
          this.gpuDataManager = createGpuDataManager(this);
          this.programManager = new ProgramManager(this);
          this.kernels = /* @__PURE__ */ new Map();
          this.kernelPersistentData = /* @__PURE__ */ new Map();
          this.kernelCustomData = /* @__PURE__ */ new Map();
          configureLogger(env3.logLevel, !!env3.debug);
          this.device.onuncapturederror = (ev) => {
            if (ev.error instanceof GPUValidationError) {
              console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);
            }
          };
          Object.defineProperty(
            this.env.webgpu,
            "device",
            { value: this.device, writable: false, enumerable: true, configurable: false }
          );
          Object.defineProperty(
            this.env.webgpu,
            "adapter",
            { value: adapter, writable: false, enumerable: true, configurable: false }
          );
          this.setQueryType();
        }
        dispose() {
          if (typeof this.querySet !== "undefined") {
            this.querySet.destroy();
          }
          this.gpuDataManager.dispose();
        }
        getCommandEncoder() {
          if (!this.commandEncoder) {
            this.commandEncoder = this.device.createCommandEncoder();
          }
          return this.commandEncoder;
        }
        getComputePassEncoder() {
          if (!this.computePassEncoder) {
            const commandEncoder = this.getCommandEncoder();
            const computePassDescriptor = {};
            if (this.queryType === "at-passes") {
              computePassDescriptor.timestampWrites = {
                querySet: this.querySet,
                beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
                endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
              };
            }
            this.computePassEncoder = commandEncoder.beginComputePass(computePassDescriptor);
          }
          return this.computePassEncoder;
        }
        endComputePass() {
          if (this.computePassEncoder) {
            this.computePassEncoder.end();
            this.computePassEncoder = null;
          }
        }
        flush() {
          if (!this.commandEncoder) {
            return;
          }
          TRACE_FUNC_BEGIN();
          this.endComputePass();
          let queryReadBuffer;
          if (this.queryType !== "none") {
            this.commandEncoder.resolveQuerySet(
              this.querySet,
              0,
              this.pendingDispatchNumber * 2,
              this.queryResolveBuffer,
              0
            );
            queryReadBuffer = this.device.createBuffer(
              // eslint-disable-next-line no-bitwise
              { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }
            );
            this.pendingQueries.set(queryReadBuffer, this.pendingKernels);
            this.pendingKernels = [];
            this.commandEncoder.copyBufferToBuffer(
              this.queryResolveBuffer,
              0,
              queryReadBuffer,
              0,
              this.pendingDispatchNumber * 2 * 8
            );
          }
          this.device.queue.submit([this.commandEncoder.finish()]);
          this.gpuDataManager.refreshPendingBuffers();
          this.commandEncoder = null;
          this.pendingDispatchNumber = 0;
          if (this.queryType !== "none") {
            void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
              const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());
              const pendingKernels = this.pendingQueries.get(queryReadBuffer);
              for (let i = 0; i < mappedData.length / 2; i++) {
                const pendingKernelInfo = pendingKernels[i];
                const kernelId = pendingKernelInfo.kernelId;
                const kernelInfo = this.kernels.get(kernelId);
                const kernelType = kernelInfo.kernelType;
                const kernelName = kernelInfo.kernelName;
                const programName = pendingKernelInfo.programName;
                const inputTensorViews = pendingKernelInfo.inputTensorViews;
                const outputTensorViews = pendingKernelInfo.outputTensorViews;
                const startTimeU64 = mappedData[i * 2];
                const endTimeU64 = mappedData[i * 2 + 1];
                if (typeof this.queryTimeBase === "undefined") {
                  this.queryTimeBase = startTimeU64;
                }
                const startTime = Number(startTimeU64 - this.queryTimeBase);
                const endTime = Number(endTimeU64 - this.queryTimeBase);
                if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {
                  throw new RangeError("incorrect timestamp range");
                }
                if (this.env.webgpu.profiling?.ondata) {
                  this.env.webgpu.profiling.ondata({
                    version: 1,
                    inputsMetadata: inputTensorViews.map(
                      (value) => ({ dims: value.dims, dataType: tensorDataTypeEnumToString(value.dataType) })
                    ),
                    outputsMetadata: outputTensorViews.map(
                      (value) => ({ dims: value.dims, dataType: tensorDataTypeEnumToString(value.dataType) })
                    ),
                    kernelId,
                    kernelType,
                    kernelName,
                    programName,
                    startTime,
                    endTime
                  });
                } else {
                  let inputShapes = "";
                  inputTensorViews.forEach((value, i2) => {
                    inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                  });
                  let outputShapes = "";
                  outputTensorViews.forEach((value, i2) => {
                    outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                  });
                  console.log(`[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}execution time: ${endTime - startTime} ns`);
                }
                TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);
              }
              queryReadBuffer.unmap();
              this.pendingQueries.delete(queryReadBuffer);
            });
          }
          TRACE_FUNC_END();
        }
        /**
         * run a WebGPU program.
         * @param program a ProgramInfo instance
         * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.
         * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an
         * index to the kernel's output.
         * @param createKernelOutput a callback function that create a value to kernel's output with the given index
         * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary
         * or persistent (owned by the current kernel)
         * @returns a TensorView array representing the result.
         */
        run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput, outputCount) {
          TRACE_FUNC_BEGIN(program.name);
          const inputDatas = [];
          for (let i = 0; i < inputTensorViews.length; ++i) {
            const data = inputTensorViews[i].data;
            if (data === 0) {
              continue;
            }
            const gpuData = this.gpuDataManager.get(data);
            if (!gpuData) {
              throw new Error(`no GPU data for input: ${data}`);
            }
            inputDatas.push(gpuData);
          }
          const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);
          const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;
          if (validatedOutputIndices.length !== outputs.length) {
            throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);
          }
          const outputTensorViews = [];
          const outputDatas = [];
          for (let i = 0; i < outputs.length; ++i) {
            if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputCount) {
              throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);
            }
            if (validatedOutputIndices[i] === -3) {
              continue;
            }
            const isTemporary = validatedOutputIndices[i] === -1;
            const isPersistent = validatedOutputIndices[i] === -2;
            const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);
            outputTensorViews.push(tensorView);
            if (tensorView.data === 0) {
              continue;
            }
            const gpuData = this.gpuDataManager.get(tensorView.data);
            if (!gpuData) {
              throw new Error(`no GPU data for output: ${tensorView.data}`);
            }
            if (isTemporary) {
              this.temporaryData.push(gpuData);
            }
            if (isPersistent) {
              let persistentData = this.kernelPersistentData.get(this.currentKernelId);
              if (!persistentData) {
                persistentData = [];
                this.kernelPersistentData.set(this.currentKernelId, persistentData);
              }
              persistentData.push(gpuData);
            }
            outputDatas.push(gpuData);
          }
          if (inputDatas.length !== inputTensorViews.length || outputDatas.length !== outputTensorViews.length) {
            if (outputDatas.length === 0) {
              TRACE_FUNC_END(program.name);
              return outputTensorViews;
            }
            throw new Error(
              `Program ${program.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
            );
          }
          let uniformBufferBinding;
          if (programUniforms) {
            let currentOffset = 0;
            const offsets = [];
            programUniforms.forEach((v) => {
              const data = typeof v.data === "number" ? [v.data] : v.data;
              if (data.length === 0) {
                return;
              }
              const sizeOfElement = v.type === 10 /* float16 */ ? 2 : 4;
              let sizeOfVecOrMat;
              let baseAlignment;
              if (v.type === 10 /* float16 */) {
                baseAlignment = data.length > 4 ? 16 : data.length > 2 ? 8 : data.length * sizeOfElement;
                sizeOfVecOrMat = data.length > 4 ? 16 : sizeOfElement * data.length;
              } else {
                baseAlignment = data.length <= 2 ? data.length * sizeOfElement : 16;
                sizeOfVecOrMat = 16;
              }
              currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
              offsets.push(currentOffset);
              const elementPerVecOrMat = v.type === 10 /* float16 */ ? 8 : 4;
              currentOffset += data.length > 4 ? Math.ceil(data.length / elementPerVecOrMat) * sizeOfVecOrMat : data.length * sizeOfElement;
            });
            const maxAlignmentOfField = 16;
            currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
            const arrayBuffer = new ArrayBuffer(currentOffset);
            programUniforms.forEach((v, i) => {
              const offset = offsets[i];
              const data = typeof v.data === "number" ? [v.data] : v.data;
              if (v.type === 6 /* int32 */) {
                new Int32Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 12 /* uint32 */) {
                new Uint32Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 10 /* float16 */) {
                new Uint16Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 1 /* float */) {
                new Float32Array(arrayBuffer, offset, data.length).set(data);
              } else {
                throw new Error(`Unsupported uniform type: ${tensorDataTypeEnumToString(v.type)}`);
              }
            });
            const uniformBufferData = (
              // eslint-disable-next-line no-bitwise
              this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)
            );
            this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);
            this.gpuDataManager.release(uniformBufferData.id);
            uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };
          }
          const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);
          const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;
          const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);
          let artifact = this.programManager.getArtifact(key);
          if (!artifact) {
            artifact = this.programManager.build(program, normalizedDispatchGroup);
            this.programManager.setArtifact(key, artifact);
            LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);
          }
          if (programUniforms && artifact.uniformVariablesInfo) {
            if (programUniforms.length !== artifact.uniformVariablesInfo.length) {
              throw new Error(`Uniform variables count mismatch: expect ${artifact.uniformVariablesInfo.length}, got ${programUniforms.length} in program "${artifact.programInfo.name}".`);
            }
            for (let i = 0; i < programUniforms.length; i++) {
              const uniform = programUniforms[i];
              const actualType = uniform.type;
              const actualLength = typeof uniform.data === "number" ? 1 : uniform.data.length;
              const [type, length] = artifact.uniformVariablesInfo[i];
              if (actualType !== type || actualLength !== length) {
                throw new Error(`Uniform variable ${i} mismatch: expect type ${type} with size ${length}, got type ${actualType} with size ${actualLength} in program "${artifact.programInfo.name}".`);
              }
            }
          }
          LOG_DEBUG(
            "info",
            () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`
          );
          if (this.queryType !== "none" || this.sessionStatus === "capturing") {
            const pendingKernelInfo = {
              kernelId: this.currentKernelId,
              programName: artifact.programInfo.name,
              inputTensorViews,
              outputTensorViews
            };
            this.pendingKernels.push(pendingKernelInfo);
            if (this.sessionStatus === "capturing") {
              const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
              sessionPendingKernels.push(pendingKernelInfo);
            }
          }
          this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);
          TRACE_FUNC_END(program.name);
          return outputTensorViews;
        }
        upload(gpuDataId, data) {
          this.gpuDataManager.upload(gpuDataId, data);
        }
        memcpy(src, dst) {
          this.gpuDataManager.memcpy(src, dst);
        }
        async download(gpuDataId, getTargetBuffer) {
          await this.gpuDataManager.download(gpuDataId, getTargetBuffer);
        }
        alloc(size) {
          return this.gpuDataManager.create(size).id;
        }
        free(ptr) {
          return this.gpuDataManager.release(ptr);
        }
        createKernel(kernelType, kernelId, attribute, kernelName) {
          const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);
          if (!op) {
            throw new Error(`kernel not implemented: ${kernelType}`);
          }
          const kernelInfo = {
            kernelType,
            kernelName,
            kernelEntry: op[0],
            attributes: [op[1], attribute]
          };
          this.kernels.set(kernelId, kernelInfo);
        }
        releaseKernel(kernelId) {
          const persistentData = this.kernelPersistentData.get(kernelId);
          if (persistentData) {
            for (const data of persistentData) {
              this.gpuDataManager.release(data.id);
            }
            this.kernelPersistentData.delete(kernelId);
          }
          this.kernelCustomData.delete(kernelId);
          this.kernels.delete(kernelId);
        }
        computeKernel(kernelId, context, errors) {
          const kernel = this.kernels.get(kernelId);
          if (!kernel) {
            throw new Error(`kernel not created: ${kernelId}`);
          }
          const kernelType = kernel.kernelType;
          const kernelName = kernel.kernelName;
          const kernelEntry = kernel.kernelEntry;
          const attributes = kernel.attributes;
          if (this.currentKernelId !== null) {
            throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);
          }
          this.currentKernelId = kernelId;
          if (attributes[0]) {
            attributes[1] = attributes[0](attributes[1]);
            attributes[0] = void 0;
          }
          LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);
          const useErrorScope = this.env.debug;
          this.temporaryData = [];
          try {
            if (useErrorScope) {
              this.device.pushErrorScope("validation");
            }
            kernelEntry(context, attributes[1]);
            return 0;
          } catch (e) {
            errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));
            return 1;
          } finally {
            if (useErrorScope) {
              errors.push(this.device.popErrorScope().then(
                (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null
              ));
            }
            for (const data of this.temporaryData) {
              this.gpuDataManager.release(data.id);
            }
            this.temporaryData = [];
            this.currentKernelId = null;
          }
        }
        // #region external buffer
        registerBuffer(sessionId, index, buffer, size) {
          let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
          if (!sessionInputOutputMapping) {
            sessionInputOutputMapping = /* @__PURE__ */ new Map();
            this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);
          }
          const previousBuffer = sessionInputOutputMapping.get(index);
          const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer?.[1]);
          sessionInputOutputMapping.set(index, [id, buffer]);
          return id;
        }
        unregisterBuffers(sessionId) {
          const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
          if (sessionInputOutputMapping) {
            sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[1]));
            this.sessionExternalDataMapping.delete(sessionId);
          }
        }
        getBuffer(gpuDataId) {
          const gpuData = this.gpuDataManager.get(gpuDataId);
          if (!gpuData) {
            throw new Error(`no GPU data for buffer: ${gpuDataId}`);
          }
          return gpuData.buffer;
        }
        createDownloader(gpuBuffer, size, type) {
          return async () => {
            const data = await downloadGpuData(this, gpuBuffer, size);
            return createView(data.buffer, type);
          };
        }
        // #endregion
        writeTimestamp(index) {
          if (this.queryType !== "inside-passes") {
            return;
          }
          this.computePassEncoder.writeTimestamp(this.querySet, index);
        }
        setQueryType() {
          this.queryType = "none";
          if (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace === "undefined" ? this.env.wasm.trace : this.env.trace)) {
            if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {
              this.queryType = "inside-passes";
            } else if (this.device.features.has("timestamp-query")) {
              this.queryType = "at-passes";
            }
            if (this.queryType !== "none" && typeof this.querySet === "undefined") {
              this.querySet = this.device.createQuerySet({
                type: "timestamp",
                count: this.maxDispatchNumber * 2
              });
              this.queryResolveBuffer = this.device.createBuffer(
                // eslint-disable-next-line no-bitwise
                { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }
              );
            }
          }
        }
        captureBegin() {
          LOG_DEBUG("info", "captureBegin");
          if (!this.capturedCommandList.get(this.currentSessionId)) {
            this.capturedCommandList.set(this.currentSessionId, []);
          }
          if (!this.capturedPendingKernels.get(this.currentSessionId)) {
            this.capturedPendingKernels.set(this.currentSessionId, []);
          }
          this.flush();
          this.sessionStatus = "capturing";
        }
        captureEnd() {
          LOG_DEBUG("info", "captureEnd");
          this.flush();
          this.sessionStatus = "default";
        }
        replay() {
          LOG_DEBUG("info", "replay");
          this.sessionStatus = "replaying";
          const sessionCommandList = this.capturedCommandList.get(this.currentSessionId);
          const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
          const length = sessionCommandList.length;
          this.pendingKernels = [];
          for (let i = 0; i < length; i++) {
            const computePassEncoder = this.getComputePassEncoder();
            const command = sessionCommandList[i];
            this.writeTimestamp(this.pendingDispatchNumber * 2);
            computePassEncoder.setPipeline(command.computePipeline);
            computePassEncoder.setBindGroup(0, command.bindGroup);
            computePassEncoder.dispatchWorkgroups(...command.dispatchGroup);
            this.writeTimestamp(this.pendingDispatchNumber * 2 + 1);
            this.pendingDispatchNumber++;
            if (this.queryType !== "none") {
              this.pendingKernels.push(sessionPendingKernels[i]);
            }
            if (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") {
              this.endComputePass();
            }
            if (this.pendingDispatchNumber >= this.maxDispatchNumber) {
              this.flush();
            }
          }
          this.flush();
          this.sessionStatus = "default";
        }
        onReleaseSession(sessionId) {
          this.unregisterBuffers(sessionId);
          if (this.capturedCommandList.has(sessionId)) {
            this.capturedCommandList.delete(sessionId);
          }
          if (this.capturedPendingKernels.has(sessionId)) {
            this.capturedPendingKernels.delete(sessionId);
          }
          this.gpuDataManager.onReleaseSession(sessionId);
        }
        onRunStart(sessionId) {
          this.currentSessionId = sessionId;
          this.setQueryType();
        }
      };
    }
  });

  // web/lib/wasm/jsep/init.ts
  var init_exports = {};
  __export(init_exports, {
    init: () => init
  });
  var TensorViewImpl, ComputeContextImpl, init;
  var init_init = __esm({
    "web/lib/wasm/jsep/init.ts"() {
      "use strict";
      init_wasm_common();
      init_backend_webgpu();
      init_log();
      init_util();
      TensorViewImpl = class _TensorViewImpl {
        constructor(module, dataType, data, dims) {
          this.module = module;
          this.dataType = dataType;
          this.data = data;
          this.dims = dims;
        }
        getFloat32Array() {
          if (this.dataType !== 1 /* float */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getBigInt64Array() {
          if (this.dataType !== 7 /* int64 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getInt32Array() {
          if (this.dataType !== 6 /* int32 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        reshape(newDims) {
          if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {
            throw new Error("Invalid new shape");
          }
          return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);
        }
      };
      ComputeContextImpl = class {
        constructor(module, backend, contextDataOffset) {
          this.module = module;
          this.backend = backend;
          this.customDataOffset = 0;
          this.customDataSize = 0;
          this.adapterInfo = backend.adapterInfo;
          const heapU32 = module.HEAPU32;
          let dataIndex = contextDataOffset >>> 2;
          this.opKernelContext = heapU32[dataIndex++];
          const inputCount = heapU32[dataIndex++];
          this.outputCount = heapU32[dataIndex++];
          this.customDataOffset = heapU32[dataIndex++];
          this.customDataSize = heapU32[dataIndex++];
          const inputs = [];
          for (let i = 0; i < inputCount; i++) {
            const dataType = heapU32[dataIndex++];
            const data = heapU32[dataIndex++];
            const dim = heapU32[dataIndex++];
            const dims = [];
            for (let d = 0; d < dim; d++) {
              dims.push(heapU32[dataIndex++]);
            }
            inputs.push(new TensorViewImpl(module, dataType, data, dims));
          }
          this.inputs = inputs;
        }
        get kernelCustomData() {
          return this.backend.currentKernelCustomData;
        }
        get customDataBuffer() {
          return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
        }
        getMaxComputeWorkgroupSizes() {
          return [
            this.backend.device.limits.maxComputeWorkgroupSizeX,
            this.backend.device.limits.maxComputeWorkgroupSizeY,
            this.backend.device.limits.maxComputeWorkgroupSizeZ
          ];
        }
        getMaxComputeWorkgroupStoragesize() {
          return this.backend.device.limits.maxComputeWorkgroupStorageSize;
        }
        compute(program, inputsOutputsMapping) {
          const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;
          const outputIndices = inputsOutputsMapping?.outputs ?? [];
          const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);
          const createTemporaryOutput = (dataType, dims) => {
            const elementSize = getTensorElementSize(dataType);
            if (!elementSize) {
              throw new Error(`Unsupported data type: ${dataType}`);
            }
            const bufferSize = elementSize * ShapeUtil.size(dims);
            const gpuDataId = bufferSize > 0 ? this.backend.gpuDataManager.create(bufferSize).id : 0;
            return new TensorViewImpl(this.module, dataType, gpuDataId, dims);
          };
          return this.backend.run(
            program,
            mappedInputs,
            outputIndices,
            createKernelOutput,
            createTemporaryOutput,
            this.outputCount
          );
        }
        output(index, dims) {
          const stack = this.module.stackSave();
          try {
            const data = this.module.stackAlloc(
              (1 + dims.length) * 4
              /* sizeof(size_t) */
            );
            let offset = data >> 2;
            this.module.HEAPU32[offset++] = dims.length;
            for (let i = 0; i < dims.length; i++) {
              this.module.HEAPU32[offset++] = dims[i];
            }
            return this.module._JsepOutput(this.opKernelContext, index, data);
          } catch (e) {
            throw new Error(
              `Failed to generate kernel's output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`
            );
          } finally {
            this.module.stackRestore(stack);
          }
        }
      };
      init = async (name, module, env3, gpuAdapter) => {
        const jsepInit = module.jsepInit;
        if (!jsepInit) {
          throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
        }
        if (name === "webgpu") {
          const backend = new WebGpuBackend();
          await backend.initialize(env3, gpuAdapter);
          jsepInit("webgpu", [
            // backend
            backend,
            // jsepAlloc()
            (size) => backend.alloc(size),
            // jsepFree()
            (ptr) => backend.free(ptr),
            // jsepCopy(src, dst, size, isSourceGpu)
            (src, dst, size, isSourceGpu = false) => {
              if (isSourceGpu) {
                LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${src}, dst=${dst}, size=${size}`);
                backend.memcpy(src, dst);
              } else {
                LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${src}, gpuDataId=${dst}, size=${size}`);
                const data = module.HEAPU8.subarray(src >>> 0, (src >>> 0) + size);
                backend.upload(dst, data);
              }
            },
            // jsepCopyAsync(src, dst, size)
            async (gpuDataId, dataOffset, size) => {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`
              );
              await backend.download(
                gpuDataId,
                () => module.HEAPU8.subarray(dataOffset >>> 0, (dataOffset >>> 0) + size)
              );
            },
            // jsepCreateKernel
            (kernelType, kernelId, attribute) => backend.createKernel(
              kernelType,
              kernelId,
              attribute,
              module.UTF8ToString(module._JsepGetNodeName(kernelId))
            ),
            // jsepReleaseKernel
            (kernel) => backend.releaseKernel(kernel),
            // jsepRun
            (kernel, contextDataOffset, sessionHandle, errors) => {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`
              );
              const context = new ComputeContextImpl(module, backend, contextDataOffset);
              return backend.computeKernel(kernel, context, errors);
            },
            // jsepCaptureBegin
            () => backend.captureBegin(),
            // jsepCaptureEnd
            () => backend.captureEnd(),
            // jsepReplay
            () => backend.replay()
          ]);
        } else {
          jsepInit("webnn");
        }
      };
    }
  });

  // web/lib/wasm/wasm-core-impl.ts
  var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
  var init_wasm_core_impl = __esm({
    "web/lib/wasm/wasm-core-impl.ts"() {
      "use strict";
      init_run_options();
      init_session_options();
      init_wasm_common();
      init_wasm_factory();
      init_wasm_utils();
      init_wasm_utils_load_file();
      initOrt = (numThreads, loggingLevel) => {
        const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
        if (errorCode !== 0) {
          checkLastError("Can't initialize onnxruntime.");
        }
      };
      initRuntime = async (env3) => {
        initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
      };
      initEp = async (env3, epName) => {
        if (true) {
          const initJsep = (init_init(), __toCommonJS(init_exports)).init;
          if (epName === "webgpu") {
            if (typeof navigator === "undefined" || !navigator.gpu) {
              throw new Error("WebGPU is not supported in current environment");
            }
            let adapter = env3.webgpu.adapter;
            if (!adapter) {
              const powerPreference = env3.webgpu.powerPreference;
              if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
                throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
              }
              const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
              if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
                throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
              }
              adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
              if (!adapter) {
                throw new Error(
                  'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
                );
              }
            } else {
              if (typeof adapter.limits !== "object" || typeof adapter.features !== "object" || typeof adapter.requestDevice !== "function") {
                throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
              }
            }
            await initJsep("webgpu", getInstance(), env3, adapter);
          }
          if (epName === "webnn") {
            if (typeof navigator === "undefined" || !navigator.ml) {
              throw new Error("WebNN is not supported in current environment");
            }
            await initJsep("webnn", getInstance(), env3);
          }
        }
      };
      activeSessions = /* @__PURE__ */ new Map();
      getSessionInputOutputCount = (sessionHandle) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        try {
          const dataOffset = wasm2.stackAlloc(8);
          const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);
          if (errorCode !== 0) {
            checkLastError("Can't get session input/output count.");
          }
          return [wasm2.HEAP32[dataOffset / 4], wasm2.HEAP32[dataOffset / 4 + 1]];
        } finally {
          wasm2.stackRestore(stack);
        }
      };
      copyFromExternalBuffer = (model) => {
        const wasm2 = getInstance();
        const modelDataOffset = wasm2._malloc(model.byteLength);
        if (modelDataOffset === 0) {
          throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
        }
        wasm2.HEAPU8.set(model, modelDataOffset);
        return [modelDataOffset, model.byteLength];
      };
      createSession = async (modelData, options) => {
        let modelDataOffset, modelDataLength;
        const wasm2 = getInstance();
        if (Array.isArray(modelData)) {
          [modelDataOffset, modelDataLength] = modelData;
        } else if (modelData.buffer === wasm2.HEAPU8.buffer) {
          [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
        } else {
          [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
        }
        let sessionHandle = 0;
        let sessionOptionsHandle = 0;
        let ioBindingHandle = 0;
        let allocs = [];
        const inputNamesUTF8Encoded = [];
        const outputNamesUTF8Encoded = [];
        try {
          [sessionOptionsHandle, allocs] = setSessionOptions(options);
          if (options?.externalData && wasm2.mountExternalData) {
            const loadingPromises = [];
            for (const file of options.externalData) {
              const path = typeof file === "string" ? file : file.path;
              loadingPromises.push(loadFile(typeof file === "string" ? file : file.data).then((data) => {
                wasm2.mountExternalData(path, data);
              }));
            }
            await Promise.all(loadingPromises);
          }
          for (const provider of options?.executionProviders ?? []) {
            const providerName = typeof provider === "string" ? provider : provider.name;
            if (providerName === "webnn") {
              if (wasm2.currentContext) {
                throw new Error("WebNN execution provider is already set.");
              }
              if (typeof provider !== "string") {
                const webnnOptions = provider;
                const context = webnnOptions?.context;
                const gpuDevice = webnnOptions?.gpuDevice;
                const deviceType = webnnOptions?.deviceType;
                const numThreads = webnnOptions?.numThreads;
                const powerPreference = webnnOptions?.powerPreference;
                if (context) {
                  wasm2.currentContext = context;
                } else if (gpuDevice) {
                  wasm2.currentContext = await navigator.ml.createContext(gpuDevice);
                } else {
                  wasm2.currentContext = await navigator.ml.createContext({ deviceType, numThreads, powerPreference });
                }
              } else {
                wasm2.currentContext = await navigator.ml.createContext();
              }
              break;
            }
          }
          sessionHandle = await wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
          if (sessionHandle === 0) {
            checkLastError("Can't create a session.");
          }
          if (wasm2.currentContext) {
            wasm2.currentContext = void 0;
          }
          const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
          const enableGraphCapture = !!options?.enableGraphCapture;
          const inputNames = [];
          const outputNames = [];
          const outputPreferredLocations = [];
          for (let i = 0; i < inputCount; i++) {
            const name = wasm2._OrtGetInputName(sessionHandle, i);
            if (name === 0) {
              checkLastError("Can't get an input name.");
            }
            inputNamesUTF8Encoded.push(name);
            inputNames.push(wasm2.UTF8ToString(name));
          }
          for (let i = 0; i < outputCount; i++) {
            const name = wasm2._OrtGetOutputName(sessionHandle, i);
            if (name === 0) {
              checkLastError("Can't get an output name.");
            }
            outputNamesUTF8Encoded.push(name);
            const nameString = wasm2.UTF8ToString(name);
            outputNames.push(nameString);
            if (true) {
              if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
                outputPreferredLocations.push("gpu-buffer");
                continue;
              }
              const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
              if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer") {
                throw new Error(`Not supported preferred output location: ${location2}.`);
              }
              if (enableGraphCapture && location2 !== "gpu-buffer") {
                throw new Error(`Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);
              }
              outputPreferredLocations.push(location2);
            }
          }
          let bindingState = null;
          if (outputPreferredLocations.some((l) => l === "gpu-buffer")) {
            ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);
            if (ioBindingHandle === 0) {
              checkLastError("Can't create IO binding.");
            }
            bindingState = {
              handle: ioBindingHandle,
              outputPreferredLocations,
              outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l))
            };
          }
          activeSessions.set(
            sessionHandle,
            [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, bindingState, enableGraphCapture, false]
          );
          return [sessionHandle, inputNames, outputNames];
        } catch (e) {
          inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
          outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
          if (ioBindingHandle !== 0) {
            wasm2._OrtReleaseBinding(ioBindingHandle);
          }
          if (sessionHandle !== 0) {
            wasm2._OrtReleaseSession(sessionHandle);
          }
          throw e;
        } finally {
          wasm2._free(modelDataOffset);
          if (sessionOptionsHandle !== 0) {
            wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          wasm2.unmountExternalData?.();
        }
      };
      releaseSession = (sessionId) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot release session. invalid session id: ${sessionId}`);
        }
        const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
        if (ioBindingState) {
          if (enableGraphCapture) {
            wasm2._OrtClearBoundOutputs(ioBindingState.handle);
          }
          wasm2._OrtReleaseBinding(ioBindingState.handle);
        }
        wasm2.jsepOnReleaseSession?.(sessionId);
        inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        wasm2._OrtReleaseSession(sessionHandle);
        activeSessions.delete(sessionId);
      };
      prepareInputOutputTensor = (tensor, tensorHandles, allocs, sessionId, index, enableGraphCapture = false) => {
        if (!tensor) {
          tensorHandles.push(0);
          return;
        }
        const wasm2 = getInstance();
        const dataType = tensor[0];
        const dims = tensor[1];
        const location2 = tensor[3];
        let rawData;
        let dataByteLength;
        if (dataType === "string" && location2 === "gpu-buffer") {
          throw new Error("String tensor is not supported on GPU.");
        }
        if (enableGraphCapture && location2 !== "gpu-buffer") {
          throw new Error(
            `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
          );
        }
        if (location2 === "gpu-buffer") {
          const gpuBuffer = tensor[2].gpuBuffer;
          const elementSizeInBytes = getTensorElementSize(tensorDataTypeStringToEnum(dataType));
          dataByteLength = dims.reduce((a, b) => a * b, 1) * elementSizeInBytes;
          const registerBuffer = wasm2.jsepRegisterBuffer;
          if (!registerBuffer) {
            throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
          }
          rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
        } else {
          const data = tensor[2];
          if (Array.isArray(data)) {
            dataByteLength = 4 * data.length;
            rawData = wasm2._malloc(dataByteLength);
            allocs.push(rawData);
            let dataIndex = rawData / 4;
            for (let i = 0; i < data.length; i++) {
              if (typeof data[i] !== "string") {
                throw new TypeError(`tensor data at index ${i} is not a string`);
              }
              wasm2.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);
            }
          } else {
            dataByteLength = data.byteLength;
            rawData = wasm2._malloc(dataByteLength);
            allocs.push(rawData);
            wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
          }
        }
        const stack = wasm2.stackSave();
        const dimsOffset = wasm2.stackAlloc(4 * dims.length);
        try {
          let dimIndex = dimsOffset / 4;
          dims.forEach((d) => wasm2.HEAP32[dimIndex++] = d);
          const tensor2 = wasm2._OrtCreateTensor(
            tensorDataTypeStringToEnum(dataType),
            rawData,
            dataByteLength,
            dimsOffset,
            dims.length,
            dataLocationStringToEnum(location2)
          );
          if (tensor2 === 0) {
            checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
          }
          tensorHandles.push(tensor2);
        } finally {
          wasm2.stackRestore(stack);
        }
      };
      run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
        }
        const sessionHandle = session[0];
        const inputNamesUTF8Encoded = session[1];
        const outputNamesUTF8Encoded = session[2];
        const ioBindingState = session[3];
        const enableGraphCapture = session[4];
        const inputOutputBound = session[5];
        const inputCount = inputIndices.length;
        const outputCount = outputIndices.length;
        let runOptionsHandle = 0;
        let runOptionsAllocs = [];
        const inputTensorHandles = [];
        const outputTensorHandles = [];
        const inputOutputAllocs = [];
        const beforeRunStack = wasm2.stackSave();
        const inputValuesOffset = wasm2.stackAlloc(inputCount * 4);
        const inputNamesOffset = wasm2.stackAlloc(inputCount * 4);
        const outputValuesOffset = wasm2.stackAlloc(outputCount * 4);
        const outputNamesOffset = wasm2.stackAlloc(outputCount * 4);
        try {
          [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
          for (let i = 0; i < inputCount; i++) {
            prepareInputOutputTensor(
              inputTensors[i],
              inputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputIndices[i],
              enableGraphCapture
            );
          }
          for (let i = 0; i < outputCount; i++) {
            prepareInputOutputTensor(
              outputTensors[i],
              outputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputCount + outputIndices[i],
              enableGraphCapture
            );
          }
          let inputValuesIndex = inputValuesOffset / 4;
          let inputNamesIndex = inputNamesOffset / 4;
          let outputValuesIndex = outputValuesOffset / 4;
          let outputNamesIndex = outputNamesOffset / 4;
          for (let i = 0; i < inputCount; i++) {
            wasm2.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];
            wasm2.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];
          }
          for (let i = 0; i < outputCount; i++) {
            wasm2.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];
            wasm2.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];
          }
          if (ioBindingState && !inputOutputBound) {
            const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
            if (inputNamesUTF8Encoded.length !== inputCount) {
              throw new Error(`input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`);
            }
            for (let i = 0; i < inputCount; i++) {
              const index = inputIndices[i];
              const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
              }
            }
            for (let i = 0; i < outputCount; i++) {
              const index = outputIndices[i];
              const location2 = outputTensors[i]?.[3];
              if (location2) {
                const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
                }
              } else {
                const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], 0, outputPreferredLocationsEncoded[index]);
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
                }
              }
            }
            activeSessions.set(
              sessionId,
              [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture, true]
            );
          }
          wasm2.jsepOnRunStart?.(sessionHandle);
          let errorCode;
          if (ioBindingState) {
            errorCode = await wasm2._OrtRunWithBinding(
              sessionHandle,
              ioBindingState.handle,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          } else {
            errorCode = await wasm2._OrtRun(
              sessionHandle,
              inputNamesOffset,
              inputValuesOffset,
              inputCount,
              outputNamesOffset,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          }
          if (errorCode !== 0) {
            checkLastError("failed to call OrtRun().");
          }
          const output = [];
          for (let i = 0; i < outputCount; i++) {
            const tensor = wasm2.HEAPU32[outputValuesOffset / 4 + i];
            if (tensor === outputTensorHandles[i]) {
              output.push(outputTensors[i]);
              continue;
            }
            const beforeGetTensorDataStack = wasm2.stackSave();
            const tensorDataOffset = wasm2.stackAlloc(4 * 4);
            let keepOutputTensor = false;
            let type, dataOffset = 0;
            try {
              const errorCode2 = wasm2._OrtGetTensorData(
                tensor,
                tensorDataOffset,
                tensorDataOffset + 4,
                tensorDataOffset + 8,
                tensorDataOffset + 12
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't access output tensor data on index ${i}.`);
              }
              let tensorDataIndex = tensorDataOffset / 4;
              const dataType = wasm2.HEAPU32[tensorDataIndex++];
              dataOffset = wasm2.HEAPU32[tensorDataIndex++];
              const dimsOffset = wasm2.HEAPU32[tensorDataIndex++];
              const dimsLength = wasm2.HEAPU32[tensorDataIndex++];
              const dims = [];
              for (let i2 = 0; i2 < dimsLength; i2++) {
                dims.push(wasm2.HEAPU32[dimsOffset / 4 + i2]);
              }
              wasm2._OrtFree(dimsOffset);
              const size = dims.reduce((a, b) => a * b, 1);
              type = tensorDataTypeEnumToString(dataType);
              const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
              if (type === "string") {
                if (preferredLocation === "gpu-buffer") {
                  throw new Error("String tensor is not supported on GPU.");
                }
                const stringData = [];
                let dataIndex = dataOffset / 4;
                for (let i2 = 0; i2 < size; i2++) {
                  const offset = wasm2.HEAPU32[dataIndex++];
                  const maxBytesToRead = i2 === size - 1 ? void 0 : wasm2.HEAPU32[dataIndex] - offset;
                  stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));
                }
                output.push([type, dims, stringData, "cpu"]);
              } else {
                if (preferredLocation === "gpu-buffer" && size > 0) {
                  const getBuffer = wasm2.jsepGetBuffer;
                  if (!getBuffer) {
                    throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                  }
                  const gpuBuffer = getBuffer(dataOffset);
                  const elementSize = getTensorElementSize(dataType);
                  if (elementSize === void 0 || !isGpuBufferSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  keepOutputTensor = true;
                  output.push([
                    type,
                    dims,
                    {
                      gpuBuffer,
                      download: wasm2.jsepCreateDownloader(gpuBuffer, size * elementSize, type),
                      dispose: () => {
                        wasm2._OrtReleaseTensor(tensor);
                      }
                    },
                    "gpu-buffer"
                  ]);
                } else {
                  const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                  const data = new typedArrayConstructor(size);
                  new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength));
                  output.push([type, dims, data, "cpu"]);
                }
              }
            } finally {
              wasm2.stackRestore(beforeGetTensorDataStack);
              if (type === "string" && dataOffset) {
                wasm2._free(dataOffset);
              }
              if (!keepOutputTensor) {
                wasm2._OrtReleaseTensor(tensor);
              }
            }
          }
          if (ioBindingState && !enableGraphCapture) {
            wasm2._OrtClearBoundOutputs(ioBindingState.handle);
            activeSessions.set(
              sessionId,
              [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture, false]
            );
          }
          return output;
        } finally {
          wasm2.stackRestore(beforeRunStack);
          inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
          outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
          inputOutputAllocs.forEach((p) => wasm2._free(p));
          if (runOptionsHandle !== 0) {
            wasm2._OrtReleaseRunOptions(runOptionsHandle);
          }
          runOptionsAllocs.forEach((p) => wasm2._free(p));
        }
      };
      endProfiling = (sessionId) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error("invalid session id");
        }
        const sessionHandle = session[0];
        const profileFileName = wasm2._OrtEndProfiling(sessionHandle);
        if (profileFileName === 0) {
          checkLastError("Can't get an profile file name.");
        }
        wasm2._OrtFree(profileFileName);
      };
      extractTransferableBuffers = (tensors) => {
        const buffers = [];
        for (const tensor of tensors) {
          const data = tensor[2];
          if (!Array.isArray(data) && "buffer" in data) {
            buffers.push(data.buffer);
          }
        }
        return buffers;
      };
    }
  });

  // web/lib/wasm/proxy-wrapper.ts
  var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
  var init_proxy_wrapper = __esm({
    "web/lib/wasm/proxy-wrapper.ts"() {
      "use strict";
      init_esm();
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
      initializing2 = false;
      initialized2 = false;
      aborted2 = false;
      queuedCallbacks = /* @__PURE__ */ new Map();
      enqueueCallbacks = (type, callbacks) => {
        const queue = queuedCallbacks.get(type);
        if (queue) {
          queue.push(callbacks);
        } else {
          queuedCallbacks.set(type, [callbacks]);
        }
      };
      ensureWorker = () => {
        if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
          throw new Error("worker not ready");
        }
      };
      onProxyWorkerMessage = (ev) => {
        switch (ev.data.type) {
          case "init-wasm":
            initializing2 = false;
            if (ev.data.err) {
              aborted2 = true;
              initWasmCallbacks[1](ev.data.err);
            } else {
              initialized2 = true;
              initWasmCallbacks[0]();
            }
            if (temporaryObjectUrl) {
              URL.revokeObjectURL(temporaryObjectUrl);
              temporaryObjectUrl = void 0;
            }
            break;
          case "init-ep":
          case "copy-from":
          case "create":
          case "release":
          case "run":
          case "end-profiling": {
            const callbacks = queuedCallbacks.get(ev.data.type);
            if (ev.data.err) {
              callbacks.shift()[1](ev.data.err);
            } else {
              callbacks.shift()[0](ev.data.out);
            }
            break;
          }
          default:
        }
      };
      initializeWebAssemblyAndOrtRuntime = async () => {
        if (initialized2) {
          return;
        }
        if (initializing2) {
          throw new Error("multiple calls to 'initWasm()' detected.");
        }
        if (aborted2) {
          throw new Error("previous call to 'initWasm()' failed.");
        }
        initializing2 = true;
        if (isProxy()) {
          return new Promise((resolve, reject) => {
            proxyWorker?.terminate();
            void importProxyWorker().then(([objectUrl, worker]) => {
              try {
                proxyWorker = worker;
                proxyWorker.onerror = (ev) => reject(ev);
                proxyWorker.onmessage = onProxyWorkerMessage;
                initWasmCallbacks = [resolve, reject];
                const message = { type: "init-wasm", in: env2 };
                proxyWorker.postMessage(message);
                temporaryObjectUrl = objectUrl;
              } catch (e) {
                reject(e);
              }
            }, reject);
          });
        } else {
          try {
            await initializeWebAssembly(env2.wasm);
            await initRuntime(env2);
            initialized2 = true;
          } catch (e) {
            aborted2 = true;
            throw e;
          } finally {
            initializing2 = false;
          }
        }
      };
      initializeOrtEp = async (epName) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("init-ep", [resolve, reject]);
            const message = { type: "init-ep", in: { epName, env: env2 } };
            proxyWorker.postMessage(message);
          });
        } else {
          await initEp(env2, epName);
        }
      };
      copyFromExternalBuffer2 = async (buffer) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("copy-from", [resolve, reject]);
            const message = { type: "copy-from", in: { buffer } };
            proxyWorker.postMessage(message, [buffer.buffer]);
          });
        } else {
          return copyFromExternalBuffer(buffer);
        }
      };
      createSession2 = async (model, options) => {
        if (isProxy()) {
          if (options?.preferredOutputLocation) {
            throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("create", [resolve, reject]);
            const message = { type: "create", in: { model, options: { ...options } } };
            const transferable = [];
            if (model instanceof Uint8Array) {
              transferable.push(model.buffer);
            }
            proxyWorker.postMessage(message, transferable);
          });
        } else {
          return createSession(model, options);
        }
      };
      releaseSession2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("release", [resolve, reject]);
            const message = { type: "release", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          releaseSession(sessionId);
        }
      };
      run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
        if (isProxy()) {
          if (inputs.some((t) => t[3] !== "cpu")) {
            throw new Error("input tensor on GPU is not supported for proxy.");
          }
          if (outputs.some((t) => t)) {
            throw new Error("pre-allocated output tensor is not supported for proxy.");
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("run", [resolve, reject]);
            const serializableInputs = inputs;
            const message = { type: "run", in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options } };
            proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
          });
        } else {
          return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
        }
      };
      endProfiling2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("end-profiling", [resolve, reject]);
            const message = { type: "end-profiling", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          endProfiling(sessionId);
        }
      };
    }
  });

  // web/lib/wasm/session-handler-inference.ts
  var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
  var init_session_handler_inference = __esm({
    "web/lib/wasm/session-handler-inference.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_wasm_common();
      init_wasm_utils_env();
      init_wasm_utils_load_file();
      encodeTensorMetadata = (tensor, getName) => {
        switch (tensor.location) {
          case "cpu":
            return [tensor.type, tensor.dims, tensor.data, "cpu"];
          case "gpu-buffer":
            return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
          default:
            throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
        }
      };
      decodeTensorMetadata = (tensor) => {
        switch (tensor[3]) {
          case "cpu":
            return new Tensor2(tensor[0], tensor[2], tensor[1]);
          case "gpu-buffer": {
            const dataType = tensor[0];
            if (!isGpuBufferSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
            }
            const { gpuBuffer, download, dispose } = tensor[2];
            return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
          }
          default:
            throw new Error(`invalid data location: ${tensor[3]}`);
        }
      };
      OnnxruntimeWebAssemblySessionHandler = class {
        async fetchModelAndCopyToWasmMemory(path) {
          return copyFromExternalBuffer2(await loadFile(path));
        }
        async loadModel(pathOrBuffer, options) {
          TRACE_FUNC_BEGIN();
          let model;
          if (typeof pathOrBuffer === "string") {
            if (isNode) {
              model = await loadFile(pathOrBuffer);
            } else {
              model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
            }
          } else {
            model = pathOrBuffer;
          }
          [this.sessionId, this.inputNames, this.outputNames] = await createSession2(model, options);
          TRACE_FUNC_END();
        }
        async dispose() {
          return releaseSession2(this.sessionId);
        }
        async run(feeds, fetches, options) {
          TRACE_FUNC_BEGIN();
          const inputArray = [];
          const inputIndices = [];
          Object.entries(feeds).forEach((kvp) => {
            const name = kvp[0];
            const tensor = kvp[1];
            const index = this.inputNames.indexOf(name);
            if (index === -1) {
              throw new Error(`invalid input '${name}'`);
            }
            inputArray.push(tensor);
            inputIndices.push(index);
          });
          const outputArray = [];
          const outputIndices = [];
          Object.entries(fetches).forEach((kvp) => {
            const name = kvp[0];
            const tensor = kvp[1];
            const index = this.outputNames.indexOf(name);
            if (index === -1) {
              throw new Error(`invalid output '${name}'`);
            }
            outputArray.push(tensor);
            outputIndices.push(index);
          });
          const inputs = inputArray.map((t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`));
          const outputs = outputArray.map(
            (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
          );
          const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
          const resultMap = {};
          for (let i = 0; i < results.length; i++) {
            resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
          }
          TRACE_FUNC_END();
          return resultMap;
        }
        startProfiling() {
        }
        endProfiling() {
          void endProfiling2(this.sessionId);
        }
      };
    }
  });

  // web/lib/backend-wasm.ts
  var initializeFlags, OnnxruntimeWebAssemblyBackend;
  var init_backend_wasm = __esm({
    "web/lib/backend-wasm.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_session_handler_inference();
      init_wasm_utils_import();
      initializeFlags = () => {
        if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
          env2.wasm.initTimeout = 0;
        }
        if (env2.wasm.simd === false) {
          console.warn(
            'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'
          );
        }
        if (typeof env2.wasm.proxy !== "boolean") {
          env2.wasm.proxy = false;
        }
        if (typeof env2.wasm.trace !== "boolean") {
          env2.wasm.trace = false;
        }
        if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            env2.wasm.numThreads = 1;
          } else {
            const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
            env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
          }
        }
        if (true) {
          if (env2.wasm.wasmPaths === void 0 && scriptSrc && scriptSrc.indexOf("blob:") !== 0) {
            env2.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
          }
        }
      };
      OnnxruntimeWebAssemblyBackend = class {
        /**
         * This function initializes the WebAssembly backend.
         *
         * This function will be called only once for each backend name. It will be called the first time when
         * `ort.InferenceSession.create()` is called with a registered backend name.
         *
         * @param backendName - the registered backend name.
         */
        async init(backendName) {
          initializeFlags();
          await initializeWebAssemblyAndOrtRuntime();
          await initializeOrtEp(backendName);
        }
        async createInferenceSessionHandler(pathOrBuffer, options) {
          const handler = new OnnxruntimeWebAssemblySessionHandler();
          await handler.loadModel(pathOrBuffer, options);
          return Promise.resolve(handler);
        }
      };
    }
  });

  // web/lib/backend-wasm-inference.ts
  var backend_wasm_inference_exports = {};
  __export(backend_wasm_inference_exports, {
    wasmBackend: () => wasmBackend
  });
  var wasmBackend;
  var init_backend_wasm_inference = __esm({
    "web/lib/backend-wasm-inference.ts"() {
      "use strict";
      init_backend_wasm();
      wasmBackend = new OnnxruntimeWebAssemblyBackend();
    }
  });

  // web/lib/index.ts
  var lib_exports = {};
  __export(lib_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    TrainingSession: () => TrainingSession2,
    default: () => lib_default,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  init_esm();
  init_esm();
  init_esm();

  // web/lib/version.ts
  var version2 = "1.19.0";

  // web/lib/index.ts
  var lib_default = esm_exports;
  if (false) {
    const onnxjsBackend = null.onnxjsBackend;
    registerBackend("webgl", onnxjsBackend, -10);
  }
  if (true) {
    const wasmBackend2 = true ? (init_backend_wasm_inference(), __toCommonJS(backend_wasm_inference_exports)).wasmBackend : null.wasmBackend;
    if (true) {
      registerBackend("webgpu", wasmBackend2, 5);
      registerBackend("webnn", wasmBackend2, 5);
    }
    registerBackend("cpu", wasmBackend2, 10);
    registerBackend("wasm", wasmBackend2, 10);
  }
  Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
  return __toCommonJS(lib_exports);
})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5kZXgudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1lbnYudHMiLCAiLi4vbGliL3dhc20vcHJveHktd29ya2VyL21haW4udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHMiLCAiLi4vbGliL3dhc20vd2FzbS1mYWN0b3J5LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tdXRpbHMudHMiLCAiLi4vbGliL3dhc20vcnVuLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1vcHRpb25zLnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29tbW9uLnRzIiwgIi4uL2xpYi93YXNtL3dhc20tdXRpbHMtbG9hZC1maWxlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvbG9nLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvdGVuc29yLXZpZXcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvdHlwZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXkudHMiLCAiLi4vbGliL3dhc20vanNlcC91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb21tb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RyYW5zcG9zZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVkdWNlLXNoYXJlZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVkdWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9hcmdtaW5tYXgudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2F0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmF0Y2gtbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmlhcy1hZGQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3VuYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLXNwbGl0LWdlbHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpbmFyeS1vcC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29uY2F0LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9mdXNlLXV0aWxzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvYWN0aXZhdGlvbl91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udjNkX25haXZlX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tYXRtdWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X2JhY2twcm9wX21tX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvM3JkLXBhcnR5L2NvbnZfYmFja3Byb3Bfd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LXRyYW5zcG9zZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY3Vtc3VtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9kZXB0aC10by1zcGFjZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZWluc3VtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9leHBhbmQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2Zhc3QtZ2VsdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXItZWxlbWVudHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dlbW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL211bHRpaGVhZC1hdHRlbnRpb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvaW5zdGFuY2Utbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbWF0bXVsbmJpdHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3BhZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcG9vbC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmFuZ2UudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3Jlc2l6ZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcm90YXJ5LWVtYmVkZGluZy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc2tpcC1sYXllci1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zbGljZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc29mdG1heC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvc3BsaXQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3doZXJlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvcHJvZ3JhbS1tYW5hZ2VyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvYmFja2VuZC13ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC9pbml0LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29yZS1pbXBsLnRzIiwgIi4uL2xpYi93YXNtL3Byb3h5LXdyYXBwZXIudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZS50cyIsICIuLi9saWIvYmFja2VuZC13YXNtLnRzIiwgIi4uL2xpYi9iYWNrZW5kLXdhc20taW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9pbmRleC50cyIsICIuLi9saWIvdmVyc2lvbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QmFja2VuZH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5cbmludGVyZmFjZSBCYWNrZW5kSW5mbyB7XG4gIGJhY2tlbmQ6IEJhY2tlbmQ7XG4gIHByaW9yaXR5OiBudW1iZXI7XG5cbiAgaW5pdFByb21pc2U/OiBQcm9taXNlPHZvaWQ+O1xuICBpbml0aWFsaXplZD86IGJvb2xlYW47XG4gIGFib3J0ZWQ/OiBib29sZWFuO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuY29uc3QgYmFja2VuZHM6IE1hcDxzdHJpbmcsIEJhY2tlbmRJbmZvPiA9IG5ldyBNYXAoKTtcbmNvbnN0IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eTogc3RyaW5nW10gPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJhY2tlbmQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgYmFja2VuZCBvYmplY3QuXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSBiYWNrZW5kLiBIaWdoZXIgbnVtYmVyIG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gaWYgcHJpb3JpdHlcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJCYWNrZW5kID0gKG5hbWU6IHN0cmluZywgYmFja2VuZDogQmFja2VuZCwgcHJpb3JpdHk6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kcy5nZXQobmFtZSk7XG4gICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tlbmRzLnNldChuYW1lLCB7YmFja2VuZCwgcHJpb3JpdHl9KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRCYWNrZW5kLnByaW9yaXR5ID4gcHJpb3JpdHkpIHtcbiAgICAgIC8vIHNhbWUgbmFtZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4gc2tpcCByZWdpc3RlcmF0aW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPT09IHByaW9yaXR5KSB7XG4gICAgICBpZiAoY3VycmVudEJhY2tlbmQuYmFja2VuZCAhPT0gYmFja2VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWdpc3RlciBiYWNrZW5kIFwiJHtuYW1lfVwiIHVzaW5nIHByaW9yaXR5ICR7cHJpb3JpdHl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByaW9yaXR5ID49IDApIHtcbiAgICAgIGNvbnN0IGkgPSBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYmFja2VuZHMuZ2V0KGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eVtpXSkhLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAwLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSB2YWxpZCBiYWNrZW5kJyk7XG59O1xuXG4vKipcbiAqIFRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYmFja2VuZC5cbiAqIEByZXR1cm5zIHRoZSBiYWNrZW5kIGluc3RhbmNlIGlmIHJlc29sdmVkIGFuZCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHksIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgZmFpbGVkLlxuICovXG5jb25zdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQgPSBhc3luYyhiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTxCYWNrZW5kfHN0cmluZz4gPT4ge1xuICBjb25zdCBiYWNrZW5kSW5mbyA9IGJhY2tlbmRzLmdldChiYWNrZW5kTmFtZSk7XG4gIGlmICghYmFja2VuZEluZm8pIHtcbiAgICByZXR1cm4gJ2JhY2tlbmQgbm90IGZvdW5kLic7XG4gIH1cblxuICBpZiAoYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgfSBlbHNlIGlmIChiYWNrZW5kSW5mby5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc0luaXRpYWxpemluZyA9ICEhYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uaW5pdFByb21pc2UgPSBiYWNrZW5kSW5mby5iYWNrZW5kLmluaXQoYmFja2VuZE5hbWUpO1xuICAgICAgfVxuICAgICAgYXdhaXQgYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWlzSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgIGJhY2tlbmRJbmZvLmVycm9yID0gYCR7ZX1gO1xuICAgICAgICBiYWNrZW5kSW5mby5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5lcnJvciE7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVzb2x2ZSBleGVjdXRpb24gcHJvdmlkZXJzIGZyb20gdGhlIHNwZWNpZmljIHNlc3Npb24gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBzZXNzaW9uIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiBhbiBpbml0aWFsaXplZCBiYWNrZW5kIGluc3RhbmNlIGFuZCBhIHNlc3Npb24gb3B0aW9ucyBvYmplY3Qgd2l0aFxuICogZmlsdGVyZWQgRVAgbGlzdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyA9IGFzeW5jKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgIFByb21pc2U8W2JhY2tlbmQ6IEJhY2tlbmQsIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnNdPiA9PiB7XG4gICAgICAvLyBleHRyYWN0IGJhY2tlbmQgaGludHMgZnJvbSBzZXNzaW9uIG9wdGlvbnNcbiAgICAgIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICAgICAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcChpID0+IHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpO1xuICAgICAgY29uc3QgYmFja2VuZE5hbWVzID0gYmFja2VuZEhpbnRzLmxlbmd0aCA9PT0gMCA/IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eSA6IGJhY2tlbmRIaW50cztcblxuICAgICAgLy8gdHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYWxsIHJlcXVlc3RlZCBiYWNrZW5kc1xuICAgICAgbGV0IGJhY2tlbmQ6IEJhY2tlbmR8dW5kZWZpbmVkO1xuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBjb25zdCBhdmFpbGFibGVCYWNrZW5kTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIGZvciAoY29uc3QgYmFja2VuZE5hbWUgb2YgYmFja2VuZE5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVSZXN1bHQgPSBhd2FpdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQoYmFja2VuZE5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmVSZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goe25hbWU6IGJhY2tlbmROYW1lLCBlcnI6IHJlc29sdmVSZXN1bHR9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWJhY2tlbmQpIHtcbiAgICAgICAgICAgIGJhY2tlbmQgPSByZXNvbHZlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmFja2VuZCA9PT0gcmVzb2x2ZVJlc3VsdCkge1xuICAgICAgICAgICAgYXZhaWxhYmxlQmFja2VuZE5hbWVzLmFkZChiYWNrZW5kTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIG5vIGJhY2tlbmQgaXMgYXZhaWxhYmxlLCB0aHJvdyBlcnJvci5cbiAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcChlID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGZvciBlYWNoIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJhY2tlbmQsIGlmIGl0J3Mgbm90IGF2YWlsYWJsZSwgb3V0cHV0IHdhcm5pbmcgbWVzc2FnZS5cbiAgICAgIGZvciAoY29uc3Qge25hbWUsIGVycn0gb2YgZXJyb3JzKSB7XG4gICAgICAgIGlmIChiYWNrZW5kSGludHMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybihgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7XG4gICAgICAgICAgICAgIG5hbWV9XCIgZnJvbSBzZXNzaW9uIG9wdGlvbnMgYmVjYXVzZSBpdCBpcyBub3QgYXZhaWxhYmxlOiAke2Vycn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWx0ZXJlZEVwcyA9IGVwcy5maWx0ZXIoaSA9PiBhdmFpbGFibGVCYWNrZW5kTmFtZXMuaGFzKHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYmFja2VuZCwgbmV3IFByb3h5KG9wdGlvbnMsIHtcbiAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZXhlY3V0aW9uUHJvdmlkZXJzJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRFcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdO1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5pbXBvcnQge09ubnhWYWx1ZX0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7VHJhaW5pbmdTZXNzaW9ufSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgdHlwZSBGZWVkc1R5cGUgPSB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZX07XG4gIHR5cGUgRmV0Y2hlc1R5cGUgPSB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGx9O1xuICB0eXBlIFJldHVyblR5cGUgPSB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZX07XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuaW50ZXJmYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgaGFuZGxlciBpbnN0YW5jZSBvZiBhbiBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIHJ1bihmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLCBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT47XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgaGFuZGxlciBpbnN0YW5jZSBvZiBhIHRyYWluaW5nIGluZmVyZW5jZSBzZXNzaW9uLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyIGV4dGVuZHMgU2Vzc2lvbkhhbmRsZXIge1xuICByZWFkb25seSBldmFsSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIHJlYWRvbmx5IGV2YWxPdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgbGF6eVJlc2V0R3JhZCgpOiBQcm9taXNlPHZvaWQ+O1xuICBydW5UcmFpblN0ZXAoXG4gICAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLCBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT47XG4gIHJ1bk9wdGltaXplclN0ZXAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcbiAgcnVuRXZhbFN0ZXAoXG4gICAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLCBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT47XG5cbiAgZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8bnVtYmVyPjtcbiAgbG9hZFBhcmFtZXRlcnNCdWZmZXIoYnVmZmVyOiBVaW50OEFycmF5LCB0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcbiAgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8T25ueFZhbHVlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBiYWNrZW5kIHRoYXQgcHJvdmlkZXMgaW1wbGVtZW50YXRpb24gb2YgbW9kZWwgaW5mZXJlbmNpbmcuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tlbmQge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgYmFja2VuZCBhc3luY2hyb25vdXNseS4gU2hvdWxkIHRocm93IHdoZW4gZmFpbGVkLlxuICAgKi9cbiAgaW5pdChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblxuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcih1cmlPckJ1ZmZlcjogc3RyaW5nfFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+O1xuXG4gIGNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXI/XG4gICAgICAoY2hlY2twb2ludFN0YXRlVXJpT3JCdWZmZXI6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlciwgdHJhaW5Nb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXIsXG4gICAgICAgZXZhbE1vZGVsVXJpT3JCdWZmZXI6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlciwgb3B0aW1pemVyTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPFRyYWluaW5nU2Vzc2lvbkhhbmRsZXI+O1xufVxuXG5leHBvcnQge3JlZ2lzdGVyQmFja2VuZH0gZnJvbSAnLi9iYWNrZW5kLWltcGwuanMnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXG4vLyBEbyBub3QgbW9kaWZ5IGZpbGUgY29udGVudCBtYW51YWxseS5cblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS4xOS4wJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnZ9IGZyb20gJy4vZW52LmpzJztcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi92ZXJzaW9uLmpzJztcblxudHlwZSBMb2dMZXZlbFR5cGUgPSBFbnZbJ2xvZ0xldmVsJ107XG5cbmxldCBsb2dMZXZlbFZhbHVlOiBSZXF1aXJlZDxMb2dMZXZlbFR5cGU+ID0gJ3dhcm5pbmcnO1xuXG5leHBvcnQgY29uc3QgZW52OiBFbnYgPSB7XG4gIHdhc206IHt9IGFzIEVudi5XZWJBc3NlbWJseUZsYWdzLFxuICB3ZWJnbDoge30gYXMgRW52LldlYkdMRmxhZ3MsXG4gIHdlYmdwdToge30gYXMgRW52LldlYkdwdUZsYWdzLFxuICB2ZXJzaW9uczoge2NvbW1vbjogdmVyc2lvbn0sXG5cbiAgc2V0IGxvZ0xldmVsKHZhbHVlOiBMb2dMZXZlbFR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBbJ3ZlcmJvc2UnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2ZhdGFsJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIGxvZ0xldmVsVmFsdWUgPSB2YWx1ZTtcbiAgfSxcbiAgZ2V0IGxvZ0xldmVsKCk6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4ge1xuICAgIHJldHVybiBsb2dMZXZlbFZhbHVlO1xuICB9LFxufTtcblxuLy8gc2V0IHByb3BlcnR5ICdsb2dMZXZlbCcgc28gdGhhdCB0aGV5IGNhbiBiZSBjb3JyZWN0bHkgdHJhbnNmZXJyZWQgdG8gd29ya2VyIGJ5IGBwb3N0TWVzc2FnZSgpYC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnYsICdsb2dMZXZlbCcsIHtlbnVtZXJhYmxlOiB0cnVlfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52IGFzIGVudkltcGx9IGZyb20gJy4vZW52LWltcGwuanMnO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRW52IHtcbiAgZXhwb3J0IHR5cGUgV2FzbVBhdGhQcmVmaXggPSBzdHJpbmc7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2FzbUZpbGVQYXRocyB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgb3ZlcnJpZGUgcGF0aCBmb3IgdGhlIG1haW4gLndhc20gZmlsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgcGF0aCBzaG91bGQgYmUgYW4gYWJzb2x1dGUgcGF0aC5cbiAgICAgKlxuICAgICAqIElmIG5vdCBtb2RpZmllZCwgdGhlIGZpbGVuYW1lIG9mIHRoZSAud2FzbSBmaWxlIGlzOlxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbWAgZm9yIGRlZmF1bHQgYnVpbGRcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbWAgZm9yIEpTRVAgYnVpbGQgKHdpdGggV2ViR1BVIGFuZCBXZWJOTilcbiAgICAgKiAtIGBvcnQtdHJhaW5pbmctd2FzbS1zaW1kLXRocmVhZGVkLndhc21gIGZvciB0cmFpbmluZyBidWlsZFxuICAgICAqL1xuICAgIHdhc20/OiBVUkx8c3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIG92ZXJyaWRlIHBhdGggZm9yIHRoZSBtYWluIC5tanMgZmlsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgcGF0aCBzaG91bGQgYmUgYW4gYWJzb2x1dGUgcGF0aC5cbiAgICAgKlxuICAgICAqIElmIG5vdCBtb2RpZmllZCwgdGhlIGZpbGVuYW1lIG9mIHRoZSAubWpzIGZpbGUgaXM6XG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanNgIGZvciBkZWZhdWx0IGJ1aWxkXG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qc2AgZm9yIEpTRVAgYnVpbGQgKHdpdGggV2ViR1BVIGFuZCBXZWJOTilcbiAgICAgKiAtIGBvcnQtdHJhaW5pbmctd2FzbS1zaW1kLXRocmVhZGVkLm1qc2AgZm9yIHRyYWluaW5nIGJ1aWxkXG4gICAgICovXG4gICAgbWpzPzogVVJMfHN0cmluZztcbiAgfVxuICBleHBvcnQgdHlwZSBXYXNtUHJlZml4T3JGaWxlUGF0aHMgPSBXYXNtUGF0aFByZWZpeHxXYXNtRmlsZVBhdGhzO1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RmxhZ3Mge1xuICAgIC8qKlxuICAgICAqIHNldCBvciBnZXQgbnVtYmVyIG9mIHRocmVhZChzKS4gSWYgb21pdHRlZCBvciBzZXQgdG8gMCwgbnVtYmVyIG9mIHRocmVhZChzKSB3aWxsIGJlIGRldGVybWluZWQgYnkgc3lzdGVtLiBJZiBzZXRcbiAgICAgKiB0byAxLCBubyB3b3JrZXIgdGhyZWFkIHdpbGwgYmUgc3Bhd25lZC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSB3aGVuIFdlYkFzc2VtYmx5IG11bHRpdGhyZWFkIGZlYXR1cmUgaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgY29udGV4dC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYDBgXG4gICAgICovXG4gICAgbnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIHNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBlbmFibGUgU0lNRC4gSWYgc2V0IHRvIGZhbHNlLCBTSU1EIHdpbGwgYmUgZm9yY2VseSBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSB3aGVuIFdlYkFzc2VtYmx5IFNJTUQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLiBTaW5jZSBTSU1EIGlzIHN1cHBvcnRlZCBieSBhbGwgbWFqb3IgSmF2YVNjcmlwdCBlbmdpbmVzLCBub24tU0lNRFxuICAgICAqIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZC4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2UuXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgdHJ1ZWBcbiAgICAgKi9cbiAgICBzaW1kPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIHNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBlbmFibGUgdHJhY2UuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVudi50cmFjZWAgaW5zdGVhZC4gSWYgYGVudi50cmFjZWAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICB0cmFjZT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IGEgbnVtYmVyIHNwZWNpZnlpbmcgdGhlIHRpbWVvdXQgZm9yIGluaXRpYWxpemF0aW9uIG9mIFdlYkFzc2VtYmx5IGJhY2tlbmQsIGluIG1pbGxpc2Vjb25kcy4gQSB6ZXJvXG4gICAgICogdmFsdWUgaW5kaWNhdGVzIG5vIHRpbWVvdXQgaXMgc2V0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBpbml0VGltZW91dD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGN1c3RvbSBVUkwgcHJlZml4IHRvIHRoZSAud2FzbS8ubWpzIGZpbGVzLCBvciBhbiBvYmplY3Qgb2Ygb3ZlcnJpZGVzIGZvciBib3RoIC53YXNtLy5tanMgZmlsZS4gVGhlIG92ZXJyaWRlXG4gICAgICogcGF0aCBzaG91bGQgYmUgYW4gYWJzb2x1dGUgcGF0aC5cbiAgICAgKi9cbiAgICB3YXNtUGF0aHM/OiBXYXNtUHJlZml4T3JGaWxlUGF0aHM7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gcHJveHkgdGhlIGV4ZWN1dGlvbiBvZiBtYWluIHRocmVhZCB0byBhIHdvcmtlciB0aHJlYWQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBwcm94eT86IGJvb2xlYW47XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdMRmxhZ3Mge1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIFdlYkdMIENvbnRleHQgSUQgKHdlYmdsIG9yIHdlYmdsMikuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAnd2ViZ2wyJ2BcbiAgICAgKi9cbiAgICBjb250ZXh0SWQ/OiAnd2ViZ2wnfCd3ZWJnbDInO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGV4dDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIG1heGltdW0gYmF0Y2ggc2l6ZSBmb3IgbWF0bXVsLiAwIG1lYW5zIHRvIGRpc2FibGUgYmF0Y2hpbmcuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIG1hdG11bE1heEJhdGNoU2l6ZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSB0ZXh0dXJlIGNhY2hlIG1vZGUuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAnZnVsbCdgXG4gICAgICovXG4gICAgdGV4dHVyZUNhY2hlTW9kZT86ICdpbml0aWFsaXplck9ubHknfCdmdWxsJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwYWNrZWQgdGV4dHVyZSBtb2RlXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBwYWNrPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgZW5hYmxlIGFzeW5jIGRvd25sb2FkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgYXN5bmM/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YSB7XG4gICAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gICAgZGF0YVR5cGU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMSB7XG4gICAgdmVyc2lvbjogMTtcbiAgICBpbnB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBvdXRwdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XG4gICAga2VybmVsSWQ6IG51bWJlcjtcbiAgICBrZXJuZWxUeXBlOiBzdHJpbmc7XG4gICAga2VybmVsTmFtZTogc3RyaW5nO1xuICAgIHByb2dyYW1OYW1lOiBzdHJpbmc7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZW5kVGltZTogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgV2ViR3B1UHJvZmlsaW5nRGF0YSA9IFdlYkdwdVByb2ZpbGluZ0RhdGFWMTtcblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUZsYWdzIHtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaW5zdGVhZC4gSWYgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG4gICAgICogaWdub3JlZC5cbiAgICAgKi9cbiAgICBwcm9maWxpbmdNb2RlPzogJ29mZid8J2RlZmF1bHQnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBjb25maWd1cmF0aW9uLlxuICAgICAqL1xuICAgIHByb2ZpbGluZz86IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIG1vZGUuXG4gICAgICAgKlxuICAgICAgICogQGRlZmF1bHRWYWx1ZSBgJ29mZidgXG4gICAgICAgKi9cbiAgICAgIG1vZGU/OiAnb2ZmJ3wnZGVmYXVsdCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IG9yIGdldCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYSBwcm9maWxpbmcgZGF0YSBpcyByZWNlaXZlZC4gSWYgbm90IHNldCwgdGhlIHByb2ZpbGluZyBkYXRhIHdpbGwgYmVcbiAgICAgICAqIHByaW50ZWQgdG8gY29uc29sZS5cbiAgICAgICAqL1xuICAgICAgb25kYXRhPzogKGRhdGE6IFdlYkdwdVByb2ZpbGluZ0RhdGEpID0+IHZvaWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwb3dlciBwcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IG9ubHkgaGFzIGVmZmVjdCBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgb3B0aW9ucyBmb3IgYG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoKWAuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vZ3B1d2ViLmdpdGh1Yi5pby9ncHV3ZWIvI2RpY3RkZWYtZ3B1cmVxdWVzdGFkYXB0ZXJvcHRpb25zfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgdW5kZWZpbmVkYFxuICAgICAqL1xuICAgIHBvd2VyUHJlZmVyZW5jZT86ICdsb3ctcG93ZXInfCdoaWdoLXBlcmZvcm1hbmNlJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBmb3JjZSBmYWxsYmFjayBhZGFwdGVyIGZsYWcuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICovXG4gICAgZm9yY2VGYWxsYmFja0FkYXB0ZXI/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGFkYXB0ZXIgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBHUFUgYWRhcHRlciBmb3IgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQgdG8gY3JlYXRlIEdQVSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIG5vdCBzZXQsIGl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIGdldCBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZVxuICAgICAqIHZhbHVlIHdpbGwgYmUgdGhlIEdQVSBhZGFwdGVyIHRoYXQgY3JlYXRlZCBieSB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIFdoZW4gdXNlIHdpdGggVHlwZVNjcmlwdCwgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBgR1BVQWRhcHRlcmAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKiBVc2UgYGNvbnN0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlcjtgIGluIFR5cGVTY3JpcHQgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkgd2l0aCBjb3JyZWN0IHR5cGUuXG4gICAgICpcbiAgICAgKiBzZWUgY29tbWVudHMgb24ge0BsaW5rIFRlbnNvci5HcHVCdWZmZXJUeXBlfVxuICAgICAqL1xuICAgIGFkYXB0ZXI6IHVua25vd247XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZXZpY2UgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogV2hlbiB1c2Ugd2l0aCBUeXBlU2NyaXB0LCB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IGlzIGBHUFVEZXZpY2VgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICogVXNlIGBjb25zdCBkZXZpY2UgPSBlbnYud2ViZ3B1LmRldmljZSBhcyBHUFVEZXZpY2U7YCBpbiBUeXBlU2NyaXB0IHRvIGFjY2VzcyB0aGlzIHByb3BlcnR5IHdpdGggY29ycmVjdCB0eXBlLlxuICAgICAqXG4gICAgICogc2VlIGNvbW1lbnRzIG9uIHtAbGluayBUZW5zb3IuR3B1QnVmZmVyVHlwZX0gZm9yIG1vcmUgZGV0YWlscyBhYm91dCB3aHkgbm90IHVzZSB0eXBlcyBkZWZpbmVkIGluIFwiQHdlYmdwdS90eXBlc1wiLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGRldmljZTogdW5rbm93bjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgdmFsaWRhdGUgaW5wdXQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHZhbGlkYXRlSW5wdXRDb250ZW50PzogYm9vbGVhbjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVudiB7XG4gIC8qKlxuICAgKiBzZXQgdGhlIHNldmVyaXR5IGxldmVsIGZvciBsb2dnaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGAnd2FybmluZydgXG4gICAqL1xuICBsb2dMZXZlbD86ICd2ZXJib3NlJ3wnaW5mbyd8J3dhcm5pbmcnfCdlcnJvcid8J2ZhdGFsJztcblxuICAvKipcbiAgICogSW5kaWNhdGUgd2hldGhlciBydW4gaW4gZGVidWcgbW9kZS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICBkZWJ1Zz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBlbmFibGUgdHJhY2UuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgKi9cbiAgdHJhY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBHZXQgdmVyc2lvbiBvZiB0aGUgY3VycmVudCBwYWNrYWdlLlxuICAgKi9cbiAgcmVhZG9ubHkgdmVyc2lvbnM6IHtcbiAgICByZWFkb25seSBjb21tb246IHN0cmluZztcbiAgICByZWFkb25seSB3ZWI/OiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgbm9kZT86IHN0cmluZztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgcmVhZG9ubHkgJ3JlYWN0LW5hdGl2ZSc/OiBzdHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViQXNzZW1ibHlcbiAgICovXG4gIHJlYWRvbmx5IHdhc206IEVudi5XZWJBc3NlbWJseUZsYWdzO1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgZm9yIFdlYkdMXG4gICAqL1xuICByZWFkb25seSB3ZWJnbDogRW52LldlYkdMRmxhZ3M7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR1BVXG4gICAqL1xuICByZWFkb25seSB3ZWJncHU6IEVudi5XZWJHcHVGbGFncztcblxuICBbbmFtZTogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgYXMgYSBnbG9iYWwgc2luZ2xldG9uLlxuICovXG5leHBvcnQgY29uc3QgZW52OiBFbnYgPSBlbnZJbXBsO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvclRvRGF0YVVybE9wdGlvbnMsIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9uc30gZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0RhdGFVUkwoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9EYXRhVVJMID0gKHRlbnNvcjogVGVuc29yLCBvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IChuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpKTtcbiAgY2FudmFzLndpZHRoID0gdGVuc29yLmRpbXNbM107XG4gIGNhbnZhcy5oZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcbiAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID1cbiAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIChDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfCBudWxsKTtcblxuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7ICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiAobm9ybS5tZWFuKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhblswXSwgbm9ybS5tZWFuWzFdLCBub3JtLm1lYW5bMl0sIDBdO1xuICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiAobm9ybS5iaWFzKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLCBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG5cbiAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IFIgPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgIC8vIFIgdmFsdWVcbiAgICAgICAgY29uc3QgRyA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAgLy8gRyB2YWx1ZVxuICAgICAgICBjb25zdCBCID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07ICAvLyBCIHZhbHVlXG4gICAgICAgIGNvbnN0IEEgPSBhVGVuc29yUG9pbnRlciA9PT0gLTEgP1xuICAgICAgICAgICAgMjU1IDpcbiAgICAgICAgICAgICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAgLy8gQSB2YWx1ZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHNcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBSICsgJywnICsgRyArICcsJyArIEIgKyAnLCcgKyBBICsgJyknO1xuICAgICAgICBwaXhlbHMyRENvbnRleHQuZmlsbFJlY3QoaiwgaSwgMSwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgndG9EYXRhVVJMJyBpbiBjYW52YXMpIHtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndG9EYXRhVVJMIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gIH1cbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnRvSW1hZ2VEYXRhKClcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclRvSW1hZ2VEYXRhID0gKHRlbnNvcjogVGVuc29yLCBvcHRpb25zPzogVGVuc29yVG9JbWFnZURhdGFPcHRpb25zKTogSW1hZ2VEYXRhID0+IHtcbiAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpIDpcbiAgICAgIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSkuZ2V0Q29udGV4dCgnMmQnKSBhcyBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gIGxldCBpbWFnZTogSW1hZ2VEYXRhO1xuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgY2hhbm5lbHM6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzFdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1szXTtcbiAgICB9IGVsc2UgeyAgLy8gRGVmYXVsdCBsYXlvdXQgaXMgTkNXSFxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1sxXTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiAobm9ybS5tZWFuKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhblswXSwgbm9ybS5tZWFuWzFdLCBub3JtLm1lYW5bMl0sIDI1NV07XG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1NZWFuWzNdID0gbm9ybS5tZWFuWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIChub3JtLmJpYXMpID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzWzBdLCBub3JtLmJpYXNbMV0sIG5vcm0uYmlhc1syXSwgMF07XG4gICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgKGNoYW5uZWxzID09PSA0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCQScpIHx8XG4gICAgICAgICAgKGNoYW5uZWxzID09PSAzICYmIChvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQicgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdCR1InKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgZm9ybWF0IGRvZXNuXFwndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltcycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgIGNvbnN0IHN0ZXAgPSA0O1xuICAgIGxldCBySW1hZ2VQb2ludGVyID0gMCwgZ0ltYWdlUG9pbnRlciA9IDEsIGJJbWFnZVBvaW50ZXIgPSAyLCBhSW1hZ2VQb2ludGVyID0gMztcbiAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLCBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSwgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLCBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH1cblxuICAgIGltYWdlID0gcGl4ZWxzMkRDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgICBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGkrKykge1xuICAgICAgaW1hZ2UuZGF0YVtySW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAgLy8gUiB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVtnSW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAgLy8gRyB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVtiSW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbYlRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAgLy8gQiB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVthSW1hZ2VQb2ludGVyXSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/XG4gICAgICAgICAgMjU1IDpcbiAgICAgICAgICAoKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1szXSkgKiBub3JtTWVhblszXTsgIC8vIEEgdmFsdWVcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge09wdGlvbnNEaW1lbnNpb25zLCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsIE9wdGlvbnNUZW5zb3JGb3JtYXQsIE9wdGlvbnNUZW5zb3JMYXlvdXQsIFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucywgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMsIFRlbnNvckZyb21UZXh0dXJlT3B0aW9ucywgVGVuc29yRnJvbVVybE9wdGlvbnN9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHtUZW5zb3IgYXMgVGVuc29ySW50ZXJmYWNlfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmludGVyZmFjZSBCdWZmZXJUb1RlbnNvck9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zRGltZW5zaW9ucywgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNUZW5zb3JGb3JtYXQge31cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIGltYWdlIG9iamVjdFxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBFeHRyYWN0ZWQgaW1hZ2UgYnVmZmVyIGRhdGEgLSBhc3N1bWluZyBSR0JBIGZvcm1hdFxuICogQHBhcmFtIGltYWdlRm9ybWF0IC0gaW5wdXQgaW1hZ2UgY29uZmlndXJhdGlvbiAtIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb25zIGhlaWdodCwgd2lkdGgsIGZvcm1hdFxuICogQHBhcmFtIHRlbnNvckZvcm1hdCAtIG91dHB1dCB0ZW5zb3IgY29uZmlndXJhdGlvbiAtIERlZmF1bHQgaXMgUkdCIGZvcm1hdFxuICovXG5leHBvcnQgY29uc3QgYnVmZmVyVG9UZW5zb3IgPSAoYnVmZmVyOiBVaW50OENsYW1wZWRBcnJheXx1bmRlZmluZWQsIG9wdGlvbnM6IEJ1ZmZlclRvVGVuc29yT3B0aW9ucyk6IFRlbnNvciA9PiB7XG4gIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIGlmIChvcHRpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgIHRocm93IG5ldyBFcnJvcignTkhXQyBUZW5zb3IgbGF5b3V0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gIH1cblxuICBjb25zdCB7aGVpZ2h0LCB3aWR0aH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IG5vcm0gPSBvcHRpb25zLm5vcm0gPz8ge21lYW46IDI1NSwgYmlhczogMH07XG4gIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbiAgaWYgKHR5cGVvZiAobm9ybS5tZWFuKSA9PT0gJ251bWJlcicpIHtcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICB9IGVsc2Uge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiFbMF0sIG5vcm0ubWVhbiFbMV0sIG5vcm0ubWVhbiFbMl0sIG5vcm0ubWVhbiFbM10gPz8gMjU1XTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgKG5vcm0uYmlhcykgPT09ICdudW1iZXInKSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgfSBlbHNlIHtcbiAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMhWzBdLCBub3JtLmJpYXMhWzFdLCBub3JtLmJpYXMhWzJdLCBub3JtLmJpYXMhWzNdID8/IDBdO1xuICB9XG5cbiAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCQSc7XG4gIC8vIGRlZmF1bHQgdmFsdWUgaXMgUkdCQSBzaW5jZSBpbWFnZWRhdGEgYW5kIEhUTUxJbWFnZUVsZW1lbnQgdXNlcyBpdFxuXG4gIGNvbnN0IG91dHB1dGZvcm1hdCA9XG4gICAgICBvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkID8gKG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRlbnNvckZvcm1hdCA6ICdSR0InKSA6ICdSR0InO1xuICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgY29uc3QgZmxvYXQzMkRhdGEgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJyA/IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogNCkgOiBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDMpO1xuXG4gIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICBsZXQgc3RlcCA9IDQsIHJJbWFnZVBvaW50ZXIgPSAwLCBnSW1hZ2VQb2ludGVyID0gMSwgYkltYWdlUG9pbnRlciA9IDIsIGFJbWFnZVBvaW50ZXIgPSAzO1xuICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLCBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSwgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLCBhVGVuc29yUG9pbnRlciA9IC0xO1xuXG4gIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgIHN0ZXAgPSAzO1xuICAgIHJJbWFnZVBvaW50ZXIgPSAwO1xuICAgIGdJbWFnZVBvaW50ZXIgPSAxO1xuICAgIGJJbWFnZVBvaW50ZXIgPSAyO1xuICAgIGFJbWFnZVBvaW50ZXIgPSAtMTtcbiAgfVxuXG4gIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBvdXRwdXQgdGVuc29yIGZvcm1hdFxuICBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gIH0gZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gIH0gZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnQkdSJykge1xuICAgIGJUZW5zb3JQb2ludGVyID0gMDtcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICByVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTtcbiAgICAgICBpKyssIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcCkge1xuICAgIGZsb2F0MzJEYXRhW3JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltySW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzBdKSAvIG5vcm1NZWFuWzBdO1xuICAgIGZsb2F0MzJEYXRhW2dUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltnSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzFdKSAvIG5vcm1NZWFuWzFdO1xuICAgIGZsb2F0MzJEYXRhW2JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltiSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzJdKSAvIG5vcm1NZWFuWzJdO1xuICAgIGlmIChhVGVuc29yUG9pbnRlciAhPT0gLTEgJiYgYUltYWdlUG9pbnRlciAhPT0gLTEpIHtcbiAgICAgIGZsb2F0MzJEYXRhW2FUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlclthSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzNdKSAvIG5vcm1NZWFuWzNdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZsb2F0MzJBcnJheSAtPiBvcnQuVGVuc29yXG4gIGNvbnN0IG91dHB1dFRlbnNvciA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IFRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgNCwgaGVpZ2h0LCB3aWR0aF0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCAzLCBoZWlnaHQsIHdpZHRoXSk7XG4gIHJldHVybiBvdXRwdXRUZW5zb3I7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tSW1hZ2UoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21JbWFnZSA9IGFzeW5jKFxuICAgIGltYWdlOiBJbWFnZURhdGF8SFRNTEltYWdlRWxlbWVudHxJbWFnZUJpdG1hcHxzdHJpbmcsXG4gICAgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zfFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zfFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnN8XG4gICAgVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFRlbnNvcj4gPT4ge1xuICAvLyBjaGVja2luZyB0aGUgdHlwZSBvZiBpbWFnZSBvYmplY3RcbiAgY29uc3QgaXNIVE1MSW1hZ2VFbGUgPSB0eXBlb2YgKEhUTUxJbWFnZUVsZW1lbnQpICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ7XG4gIGNvbnN0IGlzSW1hZ2VEYXRhRWxlID0gdHlwZW9mIChJbWFnZURhdGEpICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YTtcbiAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiAoSW1hZ2VCaXRtYXApICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwO1xuICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZyc7XG5cbiAgbGV0IGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5fHVuZGVmaW5lZDtcbiAgbGV0IGJ1ZmZlclRvVGVuc29yT3B0aW9uczogQnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcblxuICBjb25zdCBjcmVhdGVDYW52YXMgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY3JlYXRlQ2FudmFzQ29udGV4dCA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50fE9mZnNjcmVlbkNhbnZhcykgPT4ge1xuICAgIGlmIChjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0gZWxzZSBpZiAoY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgT2Zmc2NyZWVuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIC8vIGZpbGxpbmcgYW5kIGNoZWNraW5nIGltYWdlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICBpZiAoaXNIVE1MSW1hZ2VFbGUpIHtcbiAgICAvLyBIVE1MSW1hZ2VFbGVtZW50IC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IGlzIFJHQkEgYnkgZGVmYXVsdFxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBsZXQgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgbGV0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZURhdGFFbGUpIHtcbiAgICBsZXQgaGVpZ2h0OiBudW1iZXI7XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmZvcm1hdCA9ICdSR0JBJztcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuXG4gICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dCh0ZW1wQ2FudmFzKTtcblxuICAgICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBpbWFnZS5kYXRhO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ltYWdlQml0bWFwKSB7XG4gICAgLy8gSW1hZ2VCaXRtYXAgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBieSB1c2VyXG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG5cbiAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICByZXR1cm4gYnVmZmVyVG9UZW5zb3IoZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcbiAgICAgIGlmICghaW1hZ2UgfHwgIWNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIG5ld0ltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICBuZXdJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgIG5ld0ltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gbmV3SW1hZ2Uud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdJbWFnZS5oZWlnaHQ7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG5ld0ltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBpbWcgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgIHJlc29sdmUoYnVmZmVyVG9UZW5zb3IoaW1nLmRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gIH1cblxuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tVGV4dHVyZSgpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbVRleHR1cmUgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5UZXh0dXJlRGF0YVR5cGVzPihcbiAgICB0ZXh0dXJlOiBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZVR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBkb3dubG9hZCwgZGlzcG9zZX0gPSBvcHRpb25zO1xuICAvLyBBbHdheXMgYXNzdW1lIFJHQkFGMzIuIFRPRE86IHN1cHBvcnQgZGlmZmVyZW50IHRleHR1cmUgZm9ybWF0XG4gIGNvbnN0IGRpbXMgPSBbMSwgaGVpZ2h0LCB3aWR0aCwgNF07XG4gIHJldHVybiBuZXcgVGVuc29yKHtsb2NhdGlvbjogJ3RleHR1cmUnLCB0eXBlOiAnZmxvYXQzMicsIHRleHR1cmUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tR3B1QnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tR3B1QnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgICBncHVCdWZmZXI6IFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJUeXBlLCBvcHRpb25zOiBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUPik6IFRlbnNvciA9PiB7XG4gIGNvbnN0IHtkYXRhVHlwZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2V9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBUZW5zb3Ioe2xvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsIHR5cGU6IGRhdGFUeXBlID8/ICdmbG9hdDMyJywgZ3B1QnVmZmVyLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZX0pO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVBpbm5lZEJ1ZmZlcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbVBpbm5lZEJ1ZmZlciA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkNwdVBpbm5lZERhdGFUeXBlcz4oXG4gICAgdHlwZTogVCwgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PlxuICAgIG5ldyBUZW5zb3Ioe2xvY2F0aW9uOiAnY3B1LXBpbm5lZCcsIHR5cGUsIGRhdGE6IGJ1ZmZlciwgZGltczogZGltcyA/PyBbYnVmZmVyLmxlbmd0aF19KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IEZsb2F0MzJBcnJheUNvbnN0cnVjdG9yfFVpbnQ4QXJyYXlDb25zdHJ1Y3RvcnxJbnQ4QXJyYXlDb25zdHJ1Y3RvcnxcbiAgICBVaW50MTZBcnJheUNvbnN0cnVjdG9yfEludDE2QXJyYXlDb25zdHJ1Y3RvcnxJbnQzMkFycmF5Q29uc3RydWN0b3J8QmlnSW50NjRBcnJheUNvbnN0cnVjdG9yfFVpbnQ4QXJyYXlDb25zdHJ1Y3RvcnxcbiAgICBGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvcnxVaW50MzJBcnJheUNvbnN0cnVjdG9yfEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3I7XG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5ID0gSW5zdGFuY2VUeXBlPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+O1xuXG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgPSBuZXcgTWFwPHN0cmluZywgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycz4oW1xuICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxuICBbJ3VpbnQ4JywgVWludDhBcnJheV0sXG4gIFsnaW50OCcsIEludDhBcnJheV0sXG4gIFsndWludDE2JywgVWludDE2QXJyYXldLFxuICBbJ2ludDE2JywgSW50MTZBcnJheV0sXG4gIFsnaW50MzInLCBJbnQzMkFycmF5XSxcbiAgWydib29sJywgVWludDhBcnJheV0sXG4gIFsnZmxvYXQ2NCcsIEZsb2F0NjRBcnJheV0sXG4gIFsndWludDMyJywgVWludDMyQXJyYXldLFxuXSk7XG5cbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5leHBvcnQgY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCA9IG5ldyBNYXA8U3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycywgVGVuc29yLlR5cGU+KFtcbiAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcbiAgW1VpbnQ4QXJyYXksICd1aW50OCddLFxuICBbSW50OEFycmF5LCAnaW50OCddLFxuICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcbiAgW0ludDE2QXJyYXksICdpbnQxNiddLFxuICBbSW50MzJBcnJheSwgJ2ludDMyJ10sXG4gIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXG4gIFtVaW50MzJBcnJheSwgJ3VpbnQzMiddLFxuXSk7XG5cbi8vIGEgZHVtbXkgdHlwZSBkZWNsYXJhdGlvbiBmb3IgRmxvYXQxNkFycmF5IGluIGNhc2UgYW55IHBvbHlmaWxsIGlzIGF2YWlsYWJsZS5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBGbG9hdDE2QXJyYXk6IGFueTtcbn1cblxuLy8gdGhlIGZvbGxvd2luZyBjb2RlIGFsbG93cyBkZWxheWluZyBleGVjdXRpb24gb2YgQmlnSW50L0Zsb2F0MTZBcnJheSBjaGVja2luZy4gVGhpcyBhbGxvd3MgbGF6eSBpbml0aWFsaXphdGlvbiBmb3Jcbi8vIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgYW5kIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsIHdoaWNoIGFsbG93cyBCaWdJbnQvRmxvYXQxNkFycmF5XG4vLyBwb2x5ZmlsbCBpZiBhdmFpbGFibGUuXG5sZXQgaXNUeXBlZEFycmF5Q2hlY2tlZCA9IGZhbHNlO1xuZXhwb3J0IGNvbnN0IGNoZWNrVHlwZWRBcnJheSA9ICgpID0+IHtcbiAgaWYgKCFpc1R5cGVkQXJyYXlDaGVja2VkKSB7XG4gICAgaXNUeXBlZEFycmF5Q2hlY2tlZCA9IHRydWU7XG4gICAgY29uc3QgaXNCaWdJbnQ2NEFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEJpZ0ludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEJpZ0ludDY0QXJyYXkuZnJvbTtcbiAgICBjb25zdCBpc0JpZ1VpbnQ2NEFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdVaW50NjRBcnJheS5mcm9tO1xuICAgIGNvbnN0IGlzRmxvYXQxNkFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb207XG5cbiAgICBpZiAoaXNCaWdJbnQ2NEFycmF5QXZhaWxhYmxlKSB7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnaW50NjQnLCBCaWdJbnQ2NEFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ0ludDY0QXJyYXksICdpbnQ2NCcpO1xuICAgIH1cbiAgICBpZiAoaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ3VpbnQ2NCcsIEJpZ1VpbnQ2NEFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ1VpbnQ2NEFycmF5LCAndWludDY0Jyk7XG4gICAgfVxuICAgIGlmIChpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2Zsb2F0MTYnLCBGbG9hdDE2QXJyYXkpO1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoRmxvYXQxNkFycmF5LCAnZmxvYXQxNicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBGbG9hdDE2QXJyYXkgaXMgbm90IGF2YWlsYWJsZSwgdXNlICdVaW50MTZBcnJheScgdG8gc3RvcmUgdGhlIGRhdGEuXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnZmxvYXQxNicsIFVpbnQxNkFycmF5KTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7Q3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzLCBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnMsIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnN9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuXG4vKipcbiAqIGNhbGN1bGF0ZSBzaXplIGZyb20gZGltcy5cbiAqXG4gKiBAcGFyYW0gZGltcyB0aGUgZGltcyBhcnJheS4gTWF5IGJlIGFuIGlsbGVnYWwgaW5wdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVTaXplID0gKGRpbXM6IHJlYWRvbmx5IHVua25vd25bXSk6IG51bWJlciA9PiB7XG4gIGxldCBzaXplID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGltID0gZGltc1tpXTtcbiAgICBpZiAodHlwZW9mIGRpbSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpbSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgIH1cbiAgICBpZiAoZGltIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgIH1cbiAgICBzaXplICo9IGRpbTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnJlc2hhcGUoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yUmVzaGFwZSA9ICh0ZW5zb3I6IFRlbnNvciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3IgPT4ge1xuICBzd2l0Y2ggKHRlbnNvci5sb2NhdGlvbikge1xuICAgIGNhc2UgJ2NwdSc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih0ZW5zb3IudHlwZSwgdGVuc29yLmRhdGEsIGRpbXMpO1xuICAgIGNhc2UgJ2NwdS1waW5uZWQnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ2NwdS1waW5uZWQnLFxuICAgICAgICBkYXRhOiB0ZW5zb3IuZGF0YSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ2RhdGEnXSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcbiAgICAgICAgbG9jYXRpb246ICd0ZXh0dXJlJyxcbiAgICAgICAgdGV4dHVyZTogdGVuc29yLnRleHR1cmUsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ2dwdS1idWZmZXInLFxuICAgICAgICBncHVCdWZmZXI6IHRlbnNvci5ncHVCdWZmZXIsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdGVuc29yUmVzaGFwZTogdGVuc29yIGxvY2F0aW9uICR7dGVuc29yLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7dGVuc29yVG9EYXRhVVJMLCB0ZW5zb3JUb0ltYWdlRGF0YX0gZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi1pbXBsLmpzJztcbmltcG9ydCB7VGVuc29yVG9EYXRhVXJsT3B0aW9ucywgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7dGVuc29yRnJvbUdwdUJ1ZmZlciwgdGVuc29yRnJvbUltYWdlLCB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLCB0ZW5zb3JGcm9tVGV4dHVyZX0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS1pbXBsLmpzJztcbmltcG9ydCB7Q3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzLCBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnMsIFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucywgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMsIFRlbnNvckZyb21UZXh0dXJlT3B0aW9ucywgVGVuc29yRnJvbVVybE9wdGlvbnMsIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnN9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHtjaGVja1R5cGVkQXJyYXksIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAsIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsIFN1cHBvcnRlZFR5cGVkQXJyYXksIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnN9IGZyb20gJy4vdGVuc29yLWltcGwtdHlwZS1tYXBwaW5nLmpzJztcbmltcG9ydCB7Y2FsY3VsYXRlU2l6ZSwgdGVuc29yUmVzaGFwZX0gZnJvbSAnLi90ZW5zb3ItdXRpbHMtaW1wbC5qcyc7XG5pbXBvcnQge1RlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2V9IGZyb20gJy4vdGVuc29yLmpzJztcblxuLy8gdHlwZSBhbGlhc2VzIGZvciB0aG9zZSBleHBvcnRlZCBmcm9tIFRlbnNvciBpbnRlcmZhY2VcblxudHlwZSBUZW5zb3JUeXBlID0gVGVuc29ySW50ZXJmYWNlLlR5cGU7XG50eXBlIFRlbnNvckRhdGFUeXBlID0gVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlO1xudHlwZSBUZW5zb3JEYXRhTG9jYXRpb24gPSBUZW5zb3JJbnRlcmZhY2UuRGF0YUxvY2F0aW9uO1xudHlwZSBUZW5zb3JUZXh0dXJlVHlwZSA9IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZTtcbnR5cGUgVGVuc29yR3B1QnVmZmVyVHlwZSA9IFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJUeXBlO1xuXG4vKipcbiAqIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IgaW50ZXJmYWNlLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNsYXNzIFRlbnNvciBpbXBsZW1lbnRzIFRlbnNvckludGVyZmFjZSB7XG4gIC8vICNyZWdpb24gY29uc3RydWN0b3JzXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBDUFUgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICB0eXBlOiBUZW5zb3JUeXBlLCBkYXRhOiBUZW5zb3JEYXRhVHlwZXxyZWFkb25seSBzdHJpbmdbXXxyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBib29sZWFuW10sXG4gICAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuIFR5cGUgaXMgaW5mZXJyZWQgZnJvbSBkYXRhLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YTogVGVuc29yRGF0YVR5cGV8cmVhZG9ubHkgc3RyaW5nW118cmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgcGlubmVkIENQVSBkYXRhIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGRpbXMuXG4gICAqXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdjcHUtcGlubmVkJy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIFNwZWNpZnkgdGhlIHBhcmFtZXRlcnMgdG8gY29uc3RydWN0IHRoZSB0ZW5zb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBXZWJHTCB0ZXh0dXJlIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGRpbXMuXG4gICAqXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICd0ZXh0dXJlJy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIFNwZWNpZnkgdGhlIHBhcmFtZXRlcnMgdG8gY29uc3RydWN0IHRoZSB0ZW5zb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgV2ViR1BVIGJ1ZmZlciB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCBkaW1zLlxuICAgKlxuICAgKiBUZW5zb3IncyBsb2NhdGlvbiB3aWxsIGJlIHNldCB0byAnZ3B1LWJ1ZmZlcicuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTcGVjaWZ5IHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnN0cnVjdCB0aGUgdGVuc29yLlxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyYW1zOiBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnMpO1xuXG4gIC8qKlxuICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgYXJnMDogVGVuc29yVHlwZXxUZW5zb3JEYXRhVHlwZXxyZWFkb25seSBzdHJpbmdbXXxyZWFkb25seSBib29sZWFuW118Q3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzfFxuICAgICAgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc3xHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gICAgICBhcmcxPzogVGVuc29yRGF0YVR5cGV8cmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgc3RyaW5nW118cmVhZG9ubHkgYm9vbGVhbltdLCBhcmcyPzogcmVhZG9ubHkgbnVtYmVyW10pIHtcbiAgICAvLyBwZXJmb3JtIG9uZS10aW1lIGNoZWNrIGZvciBCaWdJbnQvRmxvYXQxNkFycmF5IHN1cHBvcnRcbiAgICBjaGVja1R5cGVkQXJyYXkoKTtcblxuICAgIGxldCB0eXBlOiBUZW5zb3JUeXBlO1xuICAgIGxldCBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcgJiYgJ2xvY2F0aW9uJyBpbiBhcmcwKSB7XG4gICAgICAvL1xuICAgICAgLy8gY29uc3RydWN0aW5nIHRlbnNvciBmcm9tIHNwZWNpZmljIGxvY2F0aW9uXG4gICAgICAvL1xuICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSBhcmcwLmxvY2F0aW9uO1xuICAgICAgdHlwZSA9IGFyZzAudHlwZTtcbiAgICAgIGRpbXMgPSBhcmcwLmRpbXM7XG4gICAgICBzd2l0Y2ggKGFyZzAubG9jYXRpb24pIHtcbiAgICAgICAgY2FzZSAnY3B1LXBpbm5lZCc6IHtcbiAgICAgICAgICBjb25zdCBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KHR5cGUpO1xuICAgICAgICAgIGlmICghZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHBpbm5lZCBidWZmZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoYXJnMC5kYXRhIGluc3RhbmNlb2YgZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBidWZmZXIgc2hvdWxkIGJlIG9mIHR5cGUgJHtleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBhcmcwLmRhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndGV4dHVyZSc6IHtcbiAgICAgICAgICBpZiAodHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSB0ZXh0dXJlYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1VGV4dHVyZURhdGEgPSBhcmcwLnRleHR1cmU7XG4gICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gYXJnMC5kb3dubG9hZDtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gYXJnMC5kaXNwb3NlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICAgICAgaWYgKCh0eXBlICE9PSAnZmxvYXQzMicgJiYgdHlwZSAhPT0gJ2Zsb2F0MTYnICYmIHR5cGUgIT09ICdpbnQzMicgJiYgdHlwZSAhPT0gJ2ludDY0JyAmJiB0eXBlICE9PSAndWludDMyJyAmJlxuICAgICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ4JyAmJiB0eXBlICE9PSAnYm9vbCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IGFyZzAuZ3B1QnVmZmVyO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIG9mIGxvY2F0aW9uICdjcHUnXG4gICAgICAvL1xuICAgICAgbGV0IGRhdGE6IFRlbnNvckRhdGFUeXBlO1xuICAgICAgbGV0IG1heWJlRGltczogdHlwZW9mIGFyZzF8dHlwZW9mIGFyZzI7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIGFyZzAgaXMgdHlwZSBvciBkYXRhXG4gICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3Rvcih0eXBlLCBkYXRhLCAuLi4pXG4gICAgICAgIC8vXG4gICAgICAgIHR5cGUgPSBhcmcwO1xuICAgICAgICBtYXliZURpbXMgPSBhcmcyO1xuICAgICAgICBpZiAoYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHN0cmluZyB0ZW5zb3JcXCdzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgZG9uJ3QgY2hlY2sgd2hldGhlciBldmVyeSBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBzdHJpbmc7IHRoaXMgaXMgdG9vIHNsb3cuIHdlIGFzc3VtZSBpdCdzIGNvcnJlY3QgYW5kXG4gICAgICAgICAgLy8gZXJyb3Igd2lsbCBiZSBwb3B1bGF0ZWQgYXQgaW5mZXJlbmNlXG4gICAgICAgICAgZGF0YSA9IGFyZzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbnVtZXJpYyB0ZW5zb3JcbiAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcbiAgICAgICAgICBpZiAodHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke2FyZzB9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgaWYgKGFyZzAgPT09ICdmbG9hdDE2JyAmJiB0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IFVpbnQxNkFycmF5KSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gbm8gRmxvYXQxNkFycmF5IHBvbHlmaWxsIGlzIHVzZWQsIHdlIGNhbm5vdCBjcmVhdGUgJ2Zsb2F0MTYnIHRlbnNvciBmcm9tIG51bWJlciBhcnJheS5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3IgaGVyZSBiZWNhdXNlIHdoZW4gdXNlciB0cnkgdG8gdXNlIG51bWJlciBhcnJheSBhcyBkYXRhLFxuICAgICAgICAgICAgICAvLyBlLmcuIG5ldyBUZW5zb3IoJ2Zsb2F0MTYnLCBbMSwgMiwgMywgNF0sIGRpbXMpKSwgaXQgd2lsbCBhY3R1YWxseSBjYWxsXG4gICAgICAgICAgICAgIC8vIFVpbnQxNkFycmF5LmZyb20oYXJnMSkgd2hpY2ggZ2VuZXJhdGVzIHdyb25nIGRhdGEuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnQ3JlYXRpbmcgYSBmbG9hdDE2IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIFVpbnQxNkFycmF5IGFzIGRhdGEuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZzAgPT09ICd1aW50NjQnIHx8IGFyZzAgPT09ICdpbnQ2NCcpIHtcbiAgICAgICAgICAgICAgLy8gdXNlICdhcyBhbnknIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgICAgICAgLy8gMS4gVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHR5cGUgb2YgJ0FycmF5LmlzQXJyYXkoKScgZG9lcyBub3Qgd29yayB3aXRoIHJlYWRvbmx5IGFycmF5cy5cbiAgICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTcwMDJcbiAgICAgICAgICAgICAgLy8gMi4gVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHVuaW9uIHR5cGUgb2YgJyhCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcikuZnJvbSgpJ1xuICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBhY2NlcHQgcGFyYW1ldGVyIG1hcEZuLlxuICAgICAgICAgICAgICAvLyAzLiBwYXJhbWV0ZXJzIG9mICdTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLmZyb20oKScgZG9lcyBub3QgbWF0Y2ggdGhlIHJlcXVpcmVtZW50IG9mIHRoZSB1bmlvblxuICAgICAgICAgICAgICAvLyB0eXBlLlxuXG4gICAgICAgICAgICAgIC8vIGFzc3VtZSAnYXJnMScgaXMgb2YgdHlwZSBcInJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IGJpZ2ludFtdXCIgaGVyZS5cblxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICBkYXRhID0gKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciBhcyBhbnkpLmZyb20oYXJnMSwgQmlnSW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGFzc3VtZSAnYXJnMScgaXMgb2YgdHlwZSBcInJlYWRvbmx5IG51bWJlcltdXCIgaGVyZS5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMSBpbnN0YW5jZW9mIHR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgZGF0YSA9IGFyZzE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHt0eXBlfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3RvcihkYXRhLCAuLi4pXG4gICAgICAgIC8vXG4gICAgICAgIG1heWJlRGltcyA9IGFyZzE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgLy8gb25seSBib29sZWFuW10gYW5kIHN0cmluZ1tdIGlzIHN1cHBvcnRlZFxuICAgICAgICAgIGlmIChhcmcwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudFR5cGUgPSB0eXBlb2YgYXJnMFswXTtcbiAgICAgICAgICBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RFbGVtZW50VHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2Jvb2wnO1xuICAgICAgICAgICAgLy8gJ2FyZzAnIGlzIG9mIHR5cGUgJ2Jvb2xlYW5bXScuIFVpbnQ4QXJyYXkuZnJvbShib29sZWFuW10pIGFjdHVhbGx5IHdvcmtzLCBidXQgdHlwZXNjcmlwdCB0aGlua3MgdGhpcyBpc1xuICAgICAgICAgICAgLy8gd3JvbmcgdHlwZS4gV2UgdXNlICdhcyBhbnknIHRvIG1ha2UgaXQgaGFwcHkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcwIGFzIGFueVtdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHtmaXJzdEVsZW1lbnRUeXBlfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0IHRlbnNvciB0eXBlIGZyb20gVHlwZWRBcnJheVxuICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPVxuICAgICAgICAgICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChhcmcwLmNvbnN0cnVjdG9yIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMpO1xuICAgICAgICAgIGlmIChtYXBwZWRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke2FyZzAuY29uc3RydWN0b3J9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlID0gbWFwcGVkVHlwZTtcbiAgICAgICAgICBkYXRhID0gYXJnMCBhcyBTdXBwb3J0ZWRUeXBlZEFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHR5cGUgYW5kIGRhdGEgaXMgcHJvY2Vzc2VkLCBub3cgcHJvY2Vzc2luZyBkaW1zXG4gICAgICBpZiAobWF5YmVEaW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYXNzdW1lIDEtRCB0ZW5zb3IgaWYgZGltcyBvbWl0dGVkXG4gICAgICAgIG1heWJlRGltcyA9IFtkYXRhLmxlbmd0aF07XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1heWJlRGltcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSB0ZW5zb3JcXCdzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheScpO1xuICAgICAgfVxuICAgICAgZGltcyA9IG1heWJlRGltcyBhcyByZWFkb25seSBudW1iZXJbXTtcblxuICAgICAgdGhpcy5jcHVEYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ2NwdSc7XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBjaGVjayBvbiBkaW1zXG4gICAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVNpemUoZGltcyk7XG4gICAgLy8gaWYgZGF0YSBpcyBvbiBDUFUsIGNoZWNrIHdoZXRoZXIgZGF0YSBsZW5ndGggbWF0Y2hlcyB0ZW5zb3Igc2l6ZVxuICAgIGlmICh0aGlzLmNwdURhdGEgJiYgc2l6ZSAhPT0gdGhpcy5jcHVEYXRhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7c2l6ZX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kaW1zID0gZGltcztcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGZhY3RvcnlcbiAgc3RhdGljIGFzeW5jIGZyb21JbWFnZShcbiAgICAgIGltYWdlOiBJbWFnZURhdGF8SFRNTEltYWdlRWxlbWVudHxJbWFnZUJpdG1hcHxzdHJpbmcsXG4gICAgICBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnN8VGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnN8VGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc3xcbiAgICAgIFRlbnNvckZyb21VcmxPcHRpb25zKTogUHJvbWlzZTxUZW5zb3JJbnRlcmZhY2U+IHtcbiAgICByZXR1cm4gdGVuc29yRnJvbUltYWdlKGltYWdlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLlRleHR1cmVEYXRhVHlwZXM+KFxuICAgICAgdGV4dHVyZTogVGVuc29yVGV4dHVyZVR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUPik6IFRlbnNvckludGVyZmFjZSB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21UZXh0dXJlKHRleHR1cmUsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21HcHVCdWZmZXI8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgICAgZ3B1QnVmZmVyOiBUZW5zb3JHcHVCdWZmZXJUeXBlLCBvcHRpb25zOiBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUPik6IFRlbnNvckludGVyZmFjZSB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21HcHVCdWZmZXIoZ3B1QnVmZmVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgICAgIHR5cGU6IFQsIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3Ige1xuICAgIHJldHVybiB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyKHR5cGUsIGJ1ZmZlciwgZGltcyk7XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBjb252ZXJzaW9uc1xuICB0b0RhdGFVUkwob3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiB0ZW5zb3JUb0RhdGFVUkwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICB0b0ltYWdlRGF0YShvcHRpb25zPzogVGVuc29yVG9JbWFnZURhdGFPcHRpb25zKTogSW1hZ2VEYXRhIHtcbiAgICByZXR1cm4gdGVuc29yVG9JbWFnZURhdGEodGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHVibGljIGZpZWxkc1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgdHlwZTogVGVuc29yVHlwZTtcbiAgcmVhZG9ubHkgc2l6ZTogbnVtYmVyO1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwcml2YXRlIGZpZWxkc1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgcHJpdmF0ZSBkYXRhTG9jYXRpb246IFRlbnNvckRhdGFMb2NhdGlvbjtcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSBkYXRhIG9uIENQVSwgaWYgbG9jYXRpb24gaXMgJ2NwdScgb3IgJ2NwdS1waW5uZWQnLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGNwdURhdGE/OiBUZW5zb3JEYXRhVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSB1bmRlcmx5aW5nIHRleHR1cmUgd2hlbiBsb2NhdGlvbiBpcyAndGV4dHVyZScuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgZ3B1VGV4dHVyZURhdGE/OiBUZW5zb3JUZXh0dXJlVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSB1bmRlcmx5aW5nIEdQVSBidWZmZXIgd2hlbiBsb2NhdGlvbiBpcyAnZ3B1LWJ1ZmZlcicuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgZ3B1QnVmZmVyRGF0YT86IFRlbnNvckdwdUJ1ZmZlclR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyBhbiBvcHRpb25hbCBkb3dubG9hZGVyIGZ1bmN0aW9uIHRvIGRvd25sb2FkIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgcHJpdmF0ZSBkb3dubG9hZGVyPygpOiBQcm9taXNlPFRlbnNvckRhdGFUeXBlPjtcblxuICAvKipcbiAgICogYSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGF0YSBpcyBiZWluZyBkb3dubG9hZGVkIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIHByaXZhdGUgaXNEb3dubG9hZGluZz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHN0b3JlcyBhbiBvcHRpb25hbCBkaXNwb3NlciBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGRpc3Bvc2VyPygpOiB2b2lkO1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwcm9wZXJ0aWVzXG4gIGdldCBkYXRhKCk6IFRlbnNvckRhdGFUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmNwdURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIGRhdGEgaXMgbm90IG9uIENQVS4gVXNlIGBnZXREYXRhKClgIHRvIGRvd25sb2FkIEdQVSBkYXRhIHRvIENQVSwgJyArXG4gICAgICAgICAgJ29yIHVzZSBgdGV4dHVyZWAgb3IgYGdwdUJ1ZmZlcmAgcHJvcGVydHkgdG8gYWNjZXNzIHRoZSBHUFUgZGF0YSBkaXJlY3RseS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3B1RGF0YTtcbiAgfVxuXG4gIGdldCBsb2NhdGlvbigpOiBUZW5zb3JEYXRhTG9jYXRpb24ge1xuICAgIHJldHVybiB0aGlzLmRhdGFMb2NhdGlvbjtcbiAgfVxuXG4gIGdldCB0ZXh0dXJlKCk6IFRlbnNvclRleHR1cmVUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmdwdVRleHR1cmVEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIGdldCBncHVCdWZmZXIoKTogVGVuc29yR3B1QnVmZmVyVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5ncHVCdWZmZXJEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHUFUgYnVmZmVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ncHVCdWZmZXJEYXRhO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIG1ldGhvZHNcblxuICBhc3luYyBnZXREYXRhKHJlbGVhc2VEYXRhPzogYm9vbGVhbik6IFByb21pc2U8VGVuc29yRGF0YVR5cGU+IHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgc3dpdGNoICh0aGlzLmRhdGFMb2NhdGlvbikge1xuICAgICAgY2FzZSAnY3B1JzpcbiAgICAgIGNhc2UgJ2NwdS1waW5uZWQnOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgICAgY2FzZSAndGV4dHVyZSc6XG4gICAgICBjYXNlICdncHUtYnVmZmVyJzoge1xuICAgICAgICBpZiAoIXRoaXMuZG93bmxvYWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7XG4gICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ2NwdSc7XG4gICAgICAgICAgdGhpcy5jcHVEYXRhID0gZGF0YTtcblxuICAgICAgICAgIGlmIChyZWxlYXNlRGF0YSAmJiB0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VyKCk7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VyKCk7XG4gICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmNwdURhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdUJ1ZmZlckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ25vbmUnO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gdGVuc29yIHV0aWxpdGllc1xuICBwcml2YXRlIGVuc3VyZVZhbGlkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRhdGFMb2NhdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcmVzaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICh0aGlzLmRvd25sb2FkZXIgfHwgdGhpcy5kaXNwb3Nlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzaGFwZSBhIHRlbnNvciB0aGF0IG93bnMgR1BVIHJlc291cmNlLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGVuc29yUmVzaGFwZSh0aGlzLCBkaW1zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yRmFjdG9yeX0gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1RlbnNvciBhcyBUZW5zb3JJbXBsfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcbmltcG9ydCB7VHlwZWRUZW5zb3JVdGlsc30gZnJvbSAnLi90ZW5zb3ItdXRpbHMuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbi8qKlxuICogcmVwcmVzZW50IGEgYmFzaWMgdGVuc29yIHdpdGggc3BlY2lmaWVkIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZS5cbiAqL1xuaW50ZXJmYWNlIFR5cGVkVGVuc29yQmFzZTxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogVDtcbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIENQVSAoZWcuIGl0J3MgaW4gdGhlIGZvcm0gb2YgV2ViR0wgdGV4dHVyZSBvciBXZWJHUFUgYnVmZmVyKSwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF07XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb247XG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkdMIHRleHR1cmUgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR0wgdGV4dHVyZSwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR1BVIGJ1ZmZlciwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBkYXRhIG9mIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIENQVSwgcmV0dXJucyB0aGUgZGF0YSBpbW1lZGlhdGVseS5cbiAgICogSWYgdGhlIGRhdGEgaXMgb24gR1BVLCBkb3dubG9hZHMgdGhlIGRhdGEgYW5kIHJldHVybnMgdGhlIHByb21pc2UuXG4gICAqXG4gICAqIEBwYXJhbSByZWxlYXNlRGF0YSAtIHdoZXRoZXIgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuIElnbm9yZSBpZiBkYXRhIGlzIGFscmVhZHkgb24gQ1BVLlxuICAgKi9cbiAgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBDUFUsIHJlbW92ZSBpdHMgaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuXG4gICAqXG4gICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgdGhlIHRlbnNvciBpcyBjb25zaWRlcmVkIG5vIGxvbmdlciB2YWxpZC4gSXRzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdub25lJy5cbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRlbnNvciB7XG4gIGludGVyZmFjZSBEYXRhVHlwZU1hcCB7XG4gICAgZmxvYXQzMjogRmxvYXQzMkFycmF5O1xuICAgIHVpbnQ4OiBVaW50OEFycmF5O1xuICAgIGludDg6IEludDhBcnJheTtcbiAgICB1aW50MTY6IFVpbnQxNkFycmF5O1xuICAgIGludDE2OiBJbnQxNkFycmF5O1xuICAgIGludDMyOiBJbnQzMkFycmF5O1xuICAgIGludDY0OiBCaWdJbnQ2NEFycmF5O1xuICAgIHN0cmluZzogc3RyaW5nW107XG4gICAgYm9vbDogVWludDhBcnJheTtcbiAgICBmbG9hdDE2OiBVaW50MTZBcnJheTsgIC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBGbG9hdDY0QXJyYXk7XG4gICAgdWludDMyOiBVaW50MzJBcnJheTtcbiAgICB1aW50NjQ6IEJpZ1VpbnQ2NEFycmF5O1xuICAgIC8vIGNvbXBsZXg2NDogbmV2ZXI7XG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XG4gICAgLy8gYmZsb2F0MTY6IG5ldmVyO1xuICB9XG5cbiAgaW50ZXJmYWNlIEVsZW1lbnRUeXBlTWFwIHtcbiAgICBmbG9hdDMyOiBudW1iZXI7XG4gICAgdWludDg6IG51bWJlcjtcbiAgICBpbnQ4OiBudW1iZXI7XG4gICAgdWludDE2OiBudW1iZXI7XG4gICAgaW50MTY6IG51bWJlcjtcbiAgICBpbnQzMjogbnVtYmVyO1xuICAgIGludDY0OiBiaWdpbnQ7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgYm9vbDogYm9vbGVhbjtcbiAgICBmbG9hdDE2OiBudW1iZXI7ICAvLyBLZWVwIHVzaW5nIFVpbnQxNkFycmF5IHVudGlsIHdlIGhhdmUgYSBjb25jcmV0ZSBzb2x1dGlvbiBmb3IgZmxvYXQgMTYuXG4gICAgZmxvYXQ2NDogbnVtYmVyO1xuICAgIHVpbnQzMjogbnVtYmVyO1xuICAgIHVpbnQ2NDogYmlnaW50O1xuICAgIC8vIGNvbXBsZXg2NDogbmV2ZXI7XG4gICAgLy8gY29tcGxleDEyODogbmV2ZXI7XG4gICAgLy8gYmZsb2F0MTY6IG5ldmVyO1xuICB9XG5cbiAgdHlwZSBEYXRhVHlwZSA9IERhdGFUeXBlTWFwW1R5cGVdO1xuICB0eXBlIEVsZW1lbnRUeXBlID0gRWxlbWVudFR5cGVNYXBbVHlwZV07XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHBpbm5lZCBDUFUgYnVmZmVyXG4gICAqL1xuICBleHBvcnQgdHlwZSBDcHVQaW5uZWREYXRhVHlwZXMgPSBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz47XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVUeXBlID0gV2ViR0xUZXh0dXJlO1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXG4gICAqL1xuICBleHBvcnQgdHlwZSBUZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInO1xuXG4gIC8qKlxuICAgKiB0eXBlIGFsaWFzIGZvciBXZWJHUFUgYnVmZmVyXG4gICAqXG4gICAqIFRoZSByZWFzb24gd2h5IHdlIGRvbid0IHVzZSB0eXBlIFwiR1BVQnVmZmVyXCIgZGVmaW5lZCBpbiB3ZWJncHUuZC50cyBmcm9tIEB3ZWJncHUvdHlwZXMgaXMgYmVjYXVzZSBcIkB3ZWJncHUvdHlwZXNcIlxuICAgKiByZXF1aXJlcyBcIkB0eXBlcy9kb20td2ViY29kZWNzXCIgYXMgcGVlciBkZXBlbmRlbmN5IHdoZW4gdXNpbmcgVHlwZVNjcmlwdCA8IHY1LjEgYW5kIGl0cyB2ZXJzaW9uIG5lZWQgdG8gYmUgY2hvc2VuXG4gICAqIGNhcmVmdWxseSBhY2NvcmRpbmcgdG8gdGhlIFR5cGVTY3JpcHQgdmVyc2lvbiBiZWluZyB1c2VkLiBUaGlzIG1lYW5zIHNvIGZhciB0aGVyZSBpcyBub3QgYSB3YXkgdG8ga2VlcCBldmVyeVxuICAgKiBUeXBlU2NyaXB0IHZlcnNpb24gaGFwcHkuIEl0IHR1cm5zIG91dCB0aGF0IHdlIHdpbGwgZWFzaWx5IGJyb2tlIHVzZXJzIG9uIHNvbWUgVHlwZVNjcmlwdCB2ZXJzaW9uLlxuICAgKlxuICAgKiBmb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3B1d2ViL3R5cGVzL2lzc3Vlcy8xMjdcbiAgICovXG4gIGV4cG9ydCB0eXBlIEdwdUJ1ZmZlclR5cGUgPSB7c2l6ZTogbnVtYmVyOyBtYXBTdGF0ZTogJ3VubWFwcGVkJyB8ICdwZW5kaW5nJyB8ICdtYXBwZWQnfTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyRGF0YVR5cGVzID0gJ2Zsb2F0MzInfCdmbG9hdDE2J3wnaW50MzInfCdpbnQ2NCd8J3VpbnQzMid8J3VpbnQ4J3wnYm9vbCc7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudCB3aGVyZSB0aGUgdGVuc29yIGRhdGEgaXMgc3RvcmVkXG4gICAqL1xuICBleHBvcnQgdHlwZSBEYXRhTG9jYXRpb24gPSAnbm9uZSd8J2NwdSd8J2NwdS1waW5uZWQnfCd0ZXh0dXJlJ3wnZ3B1LWJ1ZmZlcic7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudCB0aGUgZGF0YSB0eXBlIG9mIGEgdGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5UeXBlPiBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUPiwgVHlwZWRUZW5zb3JVdGlsczxUPiB7fVxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3IgZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VGVuc29yLlR5cGU+LCBUeXBlZFRlbnNvclV0aWxzPFRlbnNvci5UeXBlPiB7fVxuXG4vKipcbiAqIHR5cGUgVGVuc29yQ29uc3RydWN0b3IgZGVmaW5lcyB0aGUgY29uc3RydWN0b3JzIG9mICdUZW5zb3InIHRvIGNyZWF0ZSBDUFUgdGVuc29yIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JDb25zdHJ1Y3RvciBleHRlbmRzIFRlbnNvckZhY3Rvcnkge1xuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBzcGVjaWZ5IGVsZW1lbnQgdHlwZVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHN0cmluZyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcodHlwZTogJ3N0cmluZycsIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFsnc3RyaW5nJ118cmVhZG9ubHkgc3RyaW5nW10sXG4gICAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnc3RyaW5nJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBib29sIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyh0eXBlOiAnYm9vbCcsIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFsnYm9vbCddfHJlYWRvbmx5IGJvb2xlYW5bXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Jvb2wnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IDY0LWJpdCBpbnRlZ2VyIHR5cGVkIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldzxUIGV4dGVuZHMgJ3VpbnQ2NCd8J2ludDY0Jz4oXG4gICAgICB0eXBlOiBULCBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF18cmVhZG9ubHkgYmlnaW50W118cmVhZG9ubHkgbnVtYmVyW10sXG4gICAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjxUPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IG51bWVyaWMgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3PFQgZXh0ZW5kcyBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJ3wnYm9vbCd8J3VpbnQ2NCd8J2ludDY0Jz4+KFxuICAgICAgdHlwZTogVCwgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdfHJlYWRvbmx5IG51bWJlcltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjxUPjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIGluZmVyIGVsZW1lbnQgdHlwZXNcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGZsb2F0MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogRmxvYXQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBJbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ4Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBVaW50OEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQxNiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBVaW50MTZBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQxNic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50MTYgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogSW50MTZBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDE2Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBJbnQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEJpZ0ludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQ2NCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IHJlYWRvbmx5IHN0cmluZ1tdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnc3RyaW5nJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBib29sIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IHJlYWRvbmx5IGJvb2xlYW5bXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Jvb2wnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGZsb2F0NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogRmxvYXQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQ2NCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFVpbnQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogQmlnVWludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50NjQnPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gZmFsbCBiYWNrIHRvIG5vbi1nZW5lcmljIHRlbnNvciB0eXBlIGRlY2xhcmF0aW9uXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcodHlwZTogVGVuc29yLlR5cGUsIGRhdGE6IFRlbnNvci5EYXRhVHlwZXxyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBzdHJpbmdbXXxyZWFkb25seSBiaWdpbnRbXXxyZWFkb25seSBib29sZWFuW10sXG4gICAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3I7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBUZW5zb3IuRGF0YVR5cGUsIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbCBhcyBUZW5zb3JDb25zdHJ1Y3RvcjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJy4vZW52LWltcGwuanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFID0gKGRldmljZVR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZykgPT4ge1xuICBpZiAodHlwZW9mIGVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAhZW52Lndhc20udHJhY2UgOiAhZW52LnRyYWNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUudGltZVN0YW1wKGAke2RldmljZVR5cGV9OjpPUlQ6OiR7bGFiZWx9YCk7XG59O1xuXG5jb25zdCBUUkFDRV9GVU5DID0gKG1zZzogc3RyaW5nLCBleHRyYU1zZz86IHN0cmluZykgPT4ge1xuICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZykgfHwgW107XG4gIGxldCBoYXNUcmFjZUZ1bmMgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgIGlmIChoYXNUcmFjZUZ1bmMgJiYgIXN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcbiAgICAgIGxldCBsYWJlbCA9IGBGVU5DXyR7bXNnfTo6JHtzdGFja1tpXS50cmltKCkuc3BsaXQoJyAnKVsxXX1gO1xuICAgICAgaWYgKGV4dHJhTXNnKSB7XG4gICAgICAgIGxhYmVsICs9IGA6OiR7ZXh0cmFNc2d9YDtcbiAgICAgIH1cbiAgICAgIFRSQUNFKCdDUFUnLCBsYWJlbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGFja1tpXS5pbmNsdWRlcygnVFJBQ0VfRlVOQycpKSB7XG4gICAgICBoYXNUcmFjZUZ1bmMgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCBUUkFDRV9GVU5DX0JFR0lOID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVFJBQ0VfRlVOQygnQkVHSU4nLCBleHRyYU1zZyk7XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfRU5EID0gKGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVFJBQ0VfRlVOQygnRU5EJywgZXh0cmFNc2cpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtyZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVyc30gZnJvbSAnLi9iYWNrZW5kLWltcGwuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbiBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7T25ueFZhbHVlfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7VFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkR9IGZyb20gJy4vdHJhY2UuanMnO1xuXG50eXBlIFNlc3Npb25PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5TZXNzaW9uT3B0aW9ucztcbnR5cGUgUnVuT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuUnVuT3B0aW9ucztcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5GZWVkc1R5cGU7XG50eXBlIEZldGNoZXNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5GZXRjaGVzVHlwZTtcbnR5cGUgUmV0dXJuVHlwZSA9IEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2UuUmV0dXJuVHlwZTtcblxuZXhwb3J0IGNsYXNzIEluZmVyZW5jZVNlc3Npb24gaW1wbGVtZW50cyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihoYW5kbGVyOiBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcikge1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gIH1cbiAgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGZldGNoZXM6IEZldGNoZXNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIGFzeW5jIHJ1bihmZWVkczogRmVlZHNUeXBlLCBhcmcxPzogRmV0Y2hlc1R5cGV8UnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG4gICAgY29uc3QgZmV0Y2hlczoge1tuYW1lOiBzdHJpbmddOiBPbm54VmFsdWV8bnVsbH0gPSB7fTtcbiAgICBsZXQgb3B0aW9uczogUnVuT3B0aW9ucyA9IHt9O1xuICAgIC8vIGNoZWNrIGlucHV0c1xuICAgIGlmICh0eXBlb2YgZmVlZHMgIT09ICdvYmplY3QnIHx8IGZlZWRzID09PSBudWxsIHx8IGZlZWRzIGluc3RhbmNlb2YgVGVuc29yIHx8IEFycmF5LmlzQXJyYXkoZmVlZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdcXCdmZWVkc1xcJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuJyk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmV0Y2hlc0VtcHR5ID0gdHJ1ZTtcbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggb3ZlcnJpZGUgaXMgYmVpbmcgdXNlZFxuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChhcmcxID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLicpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYSBUZW5zb3InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xuICAgICAgICAvLyBpZiBhbnkgb3V0cHV0IG5hbWUgaXMgcHJlc2VudCBhbmQgaXRzIHZhbHVlIGlzIHZhbGlkIE9ubnhWYWx1ZSwgd2UgY29uc2lkZXIgaXQgZmV0Y2hlc1xuICAgICAgICBsZXQgaXNGZXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgICAgaWYgKGFyZzFLZXlzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGFyZzEgYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5OdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUpW25hbWVdO1xuICAgICAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdiBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgICAgICBpc0ZldGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlIFxcJ2ZldGNoZXNcXCcgb3IgXFwnb3B0aW9uc1xcJy4nKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuaW5wdXROYW1lcykge1xuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZX0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBuZXcgVGVuc29yKHJlc3VsdC50eXBlLCByZXN1bHQuZGF0YSwgcmVzdWx0LmRpbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgYXN5bmMgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGUocGF0aDogc3RyaW5nLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBieXRlT2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg/OiBudW1iZXIsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShcbiAgICAgIGFyZzA6IHN0cmluZ3xBcnJheUJ1ZmZlckxpa2V8VWludDhBcnJheSwgYXJnMT86IFNlc3Npb25PcHRpb25zfG51bWJlciwgYXJnMj86IG51bWJlcixcbiAgICAgIGFyZzM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICAvLyBlaXRoZXIgbG9hZCBmcm9tIGEgZmlsZSBvciBidWZmZXJcbiAgICBsZXQgZmlsZVBhdGhPclVpbnQ4QXJyYXk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIGxldCBvcHRpb25zOiBTZXNzaW9uT3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBhcmcwO1xuICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGFyZzAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICBieXRlT2Zmc2V0ID0gYXJnMTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlT2Zmc2V0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdieXRlT2Zmc2V0XFwnIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke2J1ZmZlci5ieXRlTGVuZ3RofSkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMjtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlTGVuZ3RoJyBpcyBvdXQgb2YgcmFuZ2UgKDAsICR7YnVmZmVyLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0fV0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gJ29iamVjdCcgJiYgYXJnMyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzM7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2J5dGVMZW5ndGhcXCcgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFswXTogbXVzdCBiZSBcXCdwYXRoXFwnIG9yIFxcJ2J1ZmZlclxcJy4nKTtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIGJhY2tlbmQsIHVwZGF0ZSBzZXNzaW9uIG9wdGlvbnMgd2l0aCB2YWxpZGF0ZWQgRVBzLCBhbmQgY3JlYXRlIHNlc3Npb24gaGFuZGxlclxuICAgIGNvbnN0IFtiYWNrZW5kLCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQc10gPSBhd2FpdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyhvcHRpb25zKTtcbiAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgYmFja2VuZC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihmaWxlUGF0aE9yVWludDhBcnJheSwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHMpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgcmV0dXJuIG5ldyBJbmZlcmVuY2VTZXNzaW9uKGhhbmRsZXIpO1xuICB9XG5cbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCk7XG4gIH1cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKTtcbiAgfVxuXG4gIGdldCBpbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gIH1cbiAgZ2V0IG91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVyOiBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcjtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbXBsfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xuaW1wb3J0IHtPbm54TW9kZWxPcHRpb25zfSBmcm9tICcuL29ubngtbW9kZWwuanMnO1xuaW1wb3J0IHtPbm54VmFsdWUsIE9ubnhWYWx1ZURhdGFMb2NhdGlvbn0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gaW5wdXQvb3V0cHV0IHR5cGVzXG5cbiAgdHlwZSBPbm54VmFsdWVNYXBUeXBlID0ge3JlYWRvbmx5IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWV9O1xuICB0eXBlIE51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSA9IHtyZWFkb25seSBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbH07XG5cbiAgLyoqXG4gICAqIEEgZmVlZHMgKG1vZGVsIGlucHV0cykgaXMgYW4gb2JqZWN0IHRoYXQgdXNlcyBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICB0eXBlIEZlZWRzVHlwZSA9IE9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLyoqXG4gICAqIEEgZmV0Y2hlcyAobW9kZWwgb3V0cHV0cykgY291bGQgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqXG4gICAqIC0gT21pdHRlZC4gVXNlIG1vZGVsJ3Mgb3V0cHV0IG5hbWVzIGRlZmluaXRpb24uXG4gICAqIC0gQW4gYXJyYXkgb2Ygc3RyaW5nIGluZGljYXRpbmcgdGhlIG91dHB1dCBuYW1lcy5cbiAgICogLSBBbiBvYmplY3QgdGhhdCB1c2Ugb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBvciBudWxsIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBAcmVtYXJrXG4gICAqIGRpZmZlcmVudCBmcm9tIGlucHV0IGFyZ3VtZW50LCBpbiBvdXRwdXQsIE9ubnhWYWx1ZSBpcyBvcHRpb25hbC4gSWYgYW4gT25ueFZhbHVlIGlzIHByZXNlbnQgaXQgd2lsbCBiZVxuICAgKiB1c2VkIGFzIGEgcHJlLWFsbG9jYXRlZCB2YWx1ZSBieSB0aGUgaW5mZXJlbmNlIGVuZ2luZTsgaWYgb21pdHRlZCwgaW5mZXJlbmNlIGVuZ2luZSB3aWxsIGFsbG9jYXRlIGJ1ZmZlclxuICAgKiBpbnRlcm5hbGx5LlxuICAgKi9cbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHJlYWRvbmx5IHN0cmluZ1tdfE51bGxhYmxlT25ueFZhbHVlTWFwVHlwZTtcblxuICAvKipcbiAgICogQSBpbmZlcmVuY2luZyByZXR1cm4gdHlwZSBpcyBhbiBvYmplY3QgdGhhdCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICB0eXBlIFJldHVyblR5cGUgPSBPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHNlc3Npb24gb3B0aW9uc1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBjb25maWd1cmF0aW9ucyBmb3Igc2Vzc2lvbiBiZWhhdmlvci5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbk9wdGlvbnMgZXh0ZW5kcyBPbm54TW9kZWxPcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBleGVjdXRpb24gcHJvdmlkZXIgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEFuIGV4ZWN1dGlvbiBwcm92aWRlciBvcHRpb24gY2FuIGJlIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIG5hbWUgb2YgdGhlIGV4ZWN1dGlvbiBwcm92aWRlcixcbiAgICAgKiBvciBhbiBvYmplY3Qgb2YgY29ycmVzcG9uZGluZyB0eXBlLlxuICAgICAqL1xuICAgIGV4ZWN1dGlvblByb3ZpZGVycz86IHJlYWRvbmx5IEV4ZWN1dGlvblByb3ZpZGVyQ29uZmlnW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50cmEgT1AgdGhyZWFkcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBpbnRyYU9wTnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlciBPUCB0aHJlYWRzIG51bWJlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGludGVyT3BOdW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGZyZWVEaW1lbnNpb25PdmVycmlkZXM/OiB7cmVhZG9ubHkgW2RpbWVuc2lvbk5hbWU6IHN0cmluZ106IG51bWJlcn07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW1pemF0aW9uIGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/OiAnZGlzYWJsZWQnfCdiYXNpYyd8J2V4dGVuZGVkJ3wnYWxsJztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIENQVSBtZW1vcnkgYXJlbmEuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZW5hYmxlQ3B1TWVtQXJlbmE/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgbWVtb3J5IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZW5hYmxlTWVtUGF0dGVybj86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBleGVjdXRpb25Nb2RlPzogJ3NlcXVlbnRpYWwnfCdwYXJhbGxlbCc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgbW9kZWwgZmlsZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzZXR0aW5nIGlzIHNwZWNpZmllZCwgdGhlIG9wdGltaXplZCBtb2RlbCB3aWxsIGJlIGR1bXBlZC4gSW4gYnJvd3NlciwgYSBibG9iIHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIHdpdGggYSBwb3AtdXAgd2luZG93LlxuICAgICAqL1xuICAgIG9wdGltaXplZE1vZGVsRmlsZVBhdGg/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIGVuYWJsZVByb2ZpbGluZz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBGaWxlIHByZWZpeCBmb3IgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgZnV0dXJlIHVzZS5cbiAgICAgKi9cbiAgICBwcm9maWxlRmlsZVByZWZpeD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBJRC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dJZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMHwxfDJ8M3w0O1xuXG4gICAgLyoqXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICBsb2dWZXJib3NpdHlMZXZlbD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgc3RyaW5nIGFzIGEgcHJlZmVycmVkIGRhdGEgbG9jYXRpb24gZm9yIGFsbCBvdXRwdXRzLCBvciBhbiBvYmplY3QgdGhhdCB1c2Ugb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIGFcbiAgICAgKiBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdMIGFuZCBXZWJHUFUgRVAuXG4gICAgICovXG4gICAgcHJlZmVycmVkT3V0cHV0TG9jYXRpb24/OiBPbm54VmFsdWVEYXRhTG9jYXRpb258e3JlYWRvbmx5IFtvdXRwdXROYW1lOiBzdHJpbmddOiBPbm54VmFsdWVEYXRhTG9jYXRpb259O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgZ3JhcGggY2FwdHVyZS5cbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHUFUgRVAuXG4gICAgICovXG4gICAgZW5hYmxlR3JhcGhDYXB0dXJlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIGNvbmZpZ3VyYXRpb25zIGZvciBhIHNlc3Npb24uIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9zZXNzaW9uL1xuICAgICAqIG9ubnhydW50aW1lX3Nlc3Npb25fb3B0aW9uc19jb25maWdfa2V5cy5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIHNlc3Npb246IHtcbiAgICAgKiAgICAgc2V0X2Rlbm9ybWFsX2FzX3plcm86IFwiMVwiLFxuICAgICAqICAgICBkaXNhYmxlX3ByZXBhY2tpbmc6IFwiMVwiXG4gICAgICogICB9LFxuICAgICAqICAgb3B0aW1pemF0aW9uOiB7XG4gICAgICogICAgIGVuYWJsZV9nZWx1X2FwcHJveGltYXRpb246IFwiMVwiXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjcmVnaW9uIGV4ZWN1dGlvbiBwcm92aWRlcnNcblxuICAvLyBDdXJyZW50bHksIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBiYWNrZW5kcyB0byBzdXBwb3J0IGV4ZWN1dGlvbiBwcm92aWRlcnM6XG4gIC8vIEJhY2tlbmQgTm9kZS5qcyBiaW5kaW5nOiBzdXBwb3J0cyAnY3B1JywgJ2RtbCcgKHdpbjMyKSwgJ2NvcmVtbCcgKG1hY09TKSBhbmQgJ2N1ZGEnIChsaW51eCkuXG4gIC8vIEJhY2tlbmQgV2ViQXNzZW1ibHk6IHN1cHBvcnRzICdjcHUnLCAnd2FzbScsICd3ZWJncHUnIGFuZCAnd2Vibm4nLlxuICAvLyBCYWNrZW5kIE9OTlguanM6IHN1cHBvcnRzICd3ZWJnbCcuXG4gIC8vIEJhY2tlbmQgUmVhY3QgTmF0aXZlOiBzdXBwb3J0cyAnY3B1JywgJ3hubnBhY2snLCAnY29yZW1sJyAoaU9TKSwgJ25uYXBpJyAoQW5kcm9pZCkuXG4gIGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcCB7XG4gICAgY29yZW1sOiBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBjcHU6IENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGN1ZGE6IEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBkbWw6IERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIG5uYXBpOiBObmFwaUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHRlbnNvcnJ0OiBUZW5zb3JSdEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdhc206IFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ2w6IFdlYkdMRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2ViZ3B1OiBXZWJHcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJubjogV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICBxbm46IFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHhubnBhY2s6IFhubnBhY2tFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgfVxuXG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJOYW1lID0ga2V5b2YgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXA7XG4gIHR5cGUgRXhlY3V0aW9uUHJvdmlkZXJDb25maWcgPVxuICAgICAgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb25NYXBbRXhlY3V0aW9uUHJvdmlkZXJOYW1lXXxFeGVjdXRpb25Qcm92aWRlck9wdGlvbnxFeGVjdXRpb25Qcm92aWRlck5hbWV8c3RyaW5nO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjcHUnO1xuICAgIHVzZUFyZW5hPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIEN1ZGFFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY3VkYSc7XG4gICAgZGV2aWNlSWQ/OiBudW1iZXI7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBEbWxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnZG1sJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3RlbnNvcnJ0JztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkFzc2VtYmx5RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dhc20nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2ViZ2wnO1xuICAgIC8vIFRPRE86IGFkZCBmbGFnc1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd4bm5wYWNrJztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJncHUnO1xuICAgIHByZWZlcnJlZExheW91dD86ICdOQ0hXJ3wnTkhXQyc7XG4gIH1cblxuICAvLyAjcmVnaW9uIFdlYk5OIG9wdGlvbnNcblxuICBpbnRlcmZhY2UgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUgZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYm5uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgV2ViTk4gTUxDb250ZXh0LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJubi8jZGljdGRlZi1tbGNvbnRleHRvcHRpb25zXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OQ29udGV4dE9wdGlvbnMge1xuICAgIGRldmljZVR5cGU/OiAnY3B1J3wnZ3B1J3wnbnB1JztcbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuICAgIHBvd2VyUHJlZmVyZW5jZT86ICdkZWZhdWx0J3wnbG93LXBvd2VyJ3wnaGlnaC1wZXJmb3JtYW5jZSc7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aG91dCBNTENvbnRleHQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dpdGhvdXRNTENvbnRleHQgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSwgV2ViTk5Db250ZXh0T3B0aW9ucyB7XG4gICAgY29udGV4dD86IG5ldmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGggTUxDb250ZXh0LlxuICAgKlxuICAgKiBXaGVuIE1MQ29udGV4dCBpcyBwcm92aWRlZCwgdGhlIGRldmljZVR5cGUgaXMgYWxzbyByZXF1aXJlZCBzbyB0aGF0IHRoZSBXZWJOTiBFUCBjYW4gZGV0ZXJtaW5lIHRoZSBwcmVmZXJyZWRcbiAgICogY2hhbm5lbCBsYXlvdXQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0IGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9taXQ8V2ViTk5Db250ZXh0T3B0aW9ucywgJ2RldmljZVR5cGUnPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVxdWlyZWQ8UGljazxXZWJOTkNvbnRleHRPcHRpb25zLCAnZGV2aWNlVHlwZSc+PiB7XG4gICAgY29udGV4dDogdW5rbm93biAvKiBNTENvbnRleHQgKi87XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQgd2hpY2ggaXMgY3JlYXRlZCBmcm9tIEdQVURldmljZS5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RvbS1tbC1jcmVhdGVjb250ZXh0LWdwdWRldmljZVxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXZWJHcHUgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSB7XG4gICAgY29udGV4dDogdW5rbm93biAvKiBNTENvbnRleHQgKi87XG4gICAgZ3B1RGV2aWNlOiB1bmtub3duIC8qIEdQVURldmljZSAqLztcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIuXG4gICAqL1xuICBleHBvcnQgdHlwZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uID0gV2ViTk5PcHRpb25zV2l0aG91dE1MQ29udGV4dHxXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0fFdlYk5OT3B0aW9uc1dlYkdwdTtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgZXhwb3J0IGludGVyZmFjZSBRbm5FeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAncW5uJztcbiAgICAvLyBUT0RPIGFkZCBmbGFnc1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29yZU1MRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NvcmVtbCc7XG4gICAgLyoqXG4gICAgICogVGhlIGJpdCBmbGFncyBmb3IgQ29yZU1MIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIENPUkVNTF9GTEFHX1VTRV9DUFVfT05MWSA9IDB4MDAxXG4gICAgICogQ09SRU1MX0ZMQUdfRU5BQkxFX09OX1NVQkdSQVBIID0gMHgwMDJcbiAgICAgKiBDT1JFTUxfRkxBR19PTkxZX0VOQUJMRV9ERVZJQ0VfV0lUSF9BTkUgPSAweDAwNFxuICAgICAqIENPUkVNTF9GTEFHX09OTFlfQUxMT1dfU1RBVElDX0lOUFVUX1NIQVBFUyA9IDB4MDA4XG4gICAgICogQ09SRU1MX0ZMQUdfQ1JFQVRFX01MUFJPR1JBTSA9IDB4MDEwXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBTZWUgaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Byb3ZpZGVycy9jb3JlbWwvY29yZW1sX3Byb3ZpZGVyX2ZhY3RvcnkuaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhpcyBmbGFnIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcpLlxuICAgICAqL1xuICAgIGNvcmVNbEZsYWdzPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byB1c2UgQ1BVIG9ubHkgaW4gQ29yZU1MIEVQLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIHVzZUNQVU9ubHk/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBlbmFibGUgQ29yZU1MIEVQIG9uIHN1YmdyYXBoLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGVuYWJsZU9uU3ViZ3JhcGg/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgd2hldGhlciB0byBvbmx5IGVuYWJsZSBDb3JlTUwgRVAgZm9yIEFwcGxlIGRldmljZXMgd2l0aCBBTkUgKEFwcGxlIE5ldXJhbCBFbmdpbmUpLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChyZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIG9ubHlFbmFibGVEZXZpY2VXaXRoQU5FPzogYm9vbGVhbjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ25uYXBpJztcbiAgICB1c2VGUDE2PzogYm9vbGVhbjtcbiAgICB1c2VOQ0hXPzogYm9vbGVhbjtcbiAgICBjcHVEaXNhYmxlZD86IGJvb2xlYW47XG4gICAgY3B1T25seT86IGJvb2xlYW47XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJ1biBvcHRpb25zXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBpbmZlcmVuY2UgcnVuIGJlaGF2aW9yXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFJ1bk9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIExvZyBzZXZlcml0eSBsZXZlbC4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL2NvbW1vbi9sb2dnaW5nL3NldmVyaXR5LmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBsb2dTZXZlcml0eUxldmVsPzogMHwxfDJ8M3w0O1xuXG4gICAgLyoqXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICBsb2dWZXJib3NpdHlMZXZlbD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZSBhbGwgaW5jb21wbGV0ZSBPcnRSdW4gY2FsbHMgYXMgc29vbiBhcyBwb3NzaWJsZSBpZiB0cnVlXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgdGVybWluYXRlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEEgdGFnIGZvciB0aGUgUnVuKCkgY2FsbHMgdXNpbmcgdGhpc1xuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIHRhZz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIHNpbmdsZSBydW4gY29uZmlndXJhdGlvbiBlbnRyeS4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfcnVuX29wdGlvbnNfY29uZmlnX2tleXMuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIG1lbW9yeToge1xuICAgICAqICAgICBlbmFibGVfbWVtb3J5X2FyZW5hX3Nocmlua2FnZTogXCIxXCIsXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB2YWx1ZSBtZXRhZGF0YVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlXG4gIGludGVyZmFjZSBWYWx1ZU1ldGFkYXRhIHtcbiAgICAvLyBUQkRcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBydW50aW1lIGluc3RhbmNlIG9mIGFuIE9OTlggbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gcnVuKClcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5PdXRwdXRUeXBlYCBmb3JcbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb2ZpbGluZ1xuXG4gIC8qKlxuICAgKiBTdGFydCBwcm9maWxpbmcuXG4gICAqL1xuICBzdGFydFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBFbmQgcHJvZmlsaW5nLlxuICAgKi9cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBpbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8vIC8qKlxuICAvLyAgKiBHZXQgaW5wdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IGlucHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBvdXRwdXQgbWV0YWRhdGEgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgLy8gICovXG4gIC8vIHJlYWRvbmx5IG91dHB1dE1ldGFkYXRhOiBSZWFkb25seUFycmF5PFJlYWRvbmx5PEluZmVyZW5jZVNlc3Npb24uVmFsdWVNZXRhZGF0YT4+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gT05OWCBtb2RlbCBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVGhlIFVSSSBvciBmaWxlIHBhdGggb2YgdGhlIG1vZGVsIHRvIGxvYWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUodXJpOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIHNlZ21lbnQgb2YgYW4gYXJyYXkgYnVmZXIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBbiBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gYnl0ZU9mZnNldCAtIFRoZSBiZWdpbm5pbmcgb2YgdGhlIHNwZWNpZmllZCBwb3J0aW9uIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBieXRlTGVuZ3RoIC0gVGhlIGxlbmd0aCBpbiBieXRlcyBvZiB0aGUgYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogQXJyYXlCdWZmZXJMaWtlLCBieXRlT2Zmc2V0OiBudW1iZXIsIGJ5dGVMZW5ndGg/OiBudW1iZXIsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGEgVWludDhBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEEgVWludDhBcnJheSByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IEluZmVyZW5jZVNlc3Npb246IEluZmVyZW5jZVNlc3Npb25GYWN0b3J5ID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7T3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLCBPcHRpb25zVGVuc29yTGF5b3V0fSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0RhdGFVcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIGV4dGVuZHMgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2lvblV0aWxzIHtcbiAgLyoqXG4gICAqIGNyZWF0ZXMgYSBEYXRhVVJMIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGEgRGF0YVVSTCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBjcmVhdGVzIGFuIEltYWdlRGF0YSBpbnN0YW5jZSBmcm9tIHRlbnNvclxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGhlIHRlbnNvci5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgZm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiBAcmV0dXJucyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBpbWFnZSBjb252ZXJ0ZWQgZnJvbSB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3IsIFR5cGVkVGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIEltYWdlRm9ybWF0ID0gJ1JHQid8J1JHQkEnfCdCR1InfCdSQkcnO1xuZXhwb3J0IHR5cGUgSW1hZ2VUZW5zb3JMYXlvdXQgPSAnTkhXQyd8J05DSFcnO1xuXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cblxuLy8gI3JlZ2lvbiB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvblxuXG4vKipcbiAqIHJlcHJlc2VudCBjb21tb24gcHJvcGVydGllcyBvZiB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICovXG5pbnRlcmZhY2UgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIEdQVSByZXNvdXJjZS5cbiAqL1xuaW50ZXJmYWNlIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZG93bmxvYWQgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXG4gICAqL1xuICBkb3dubG9hZD8oKTogUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGVNYXBbVF0+O1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgdGVuc29yIHRyZWF0IHRoZSBHUFUgZGF0YSBhcyBleHRlcm5hbCByZXNvdXJjZS5cbiAgICovXG4gIGRpc3Bvc2U/KCk6IHZvaWQ7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXMgPSBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzPiBleHRlbmRzXG4gICAgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdjcHUtcGlubmVkJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCc7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBDUFUgcGlubmVkIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHTCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXMgPSBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcz4gZXh0ZW5kc1xuICAgIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiwgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ3RleHR1cmUnLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICd0ZXh0dXJlJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYkdMIHRleHR1cmUgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9IFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+IGV4dGVuZHNcbiAgICBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4sIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICdncHUtYnVmZmVyJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcic7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBXZWJHUFUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgZ3B1QnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIG9mIGVhY2ggaW5kaXZpZHVhbCBvcHRpb25zLlxuLy8gdGhlIHRlbnNvciBmYWN0b3J5IGZ1bmN0aW9ucyB1c2UgYSBjb21wb3NpdGlvbiBvZiB0aG9zZSBvcHRpb25zIGFzIHRoZSBwYXJhbWV0ZXIgdHlwZS5cblxuLy8gI3JlZ2lvbiBPcHRpb25zIGZpZWxkc1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNGb3JtYXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBmb3JtYXQgcmVwcmVzZW50ZWQgaW4gUkdCQSBjb2xvciBzcGFjZS5cbiAgICovXG4gIGZvcm1hdD86IEltYWdlRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JGb3JtYXQge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBmb3JtYXQgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogTk9URTogdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBvcHRpb24gJ2Zvcm1hdCcuIFdoaWxlIG9wdGlvbiAnZm9ybWF0JyByZXByZXNlbnRzIHRoZSBvcmlnaW5hbCBpbWFnZSwgJ3RlbnNvckZvcm1hdCdcbiAgICogcmVwcmVzZW50cyB0aGUgdGFyZ2V0IGZvcm1hdCBvZiB0aGUgdGVuc29yLiBBIHRyYW5zcG9zZSB3aWxsIGJlIHBlcmZvcm1lZCBpZiB0aGV5IGFyZSBkaWZmZXJlbnQuXG4gICAqL1xuICB0ZW5zb3JGb3JtYXQ/OiBJbWFnZUZvcm1hdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRGF0YVR5cGUge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGRhdGFUeXBlPzogJ2Zsb2F0MzInfCd1aW50OCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckxheW91dCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHRlbnNvciBsYXlvdXQgd2hlbiByZXByZXNlbnRpbmcgZGF0YSBvZiBvbmUgb3IgbW9yZSBpbWFnZShzKS5cbiAgICovXG4gIHRlbnNvckxheW91dD86IEltYWdlVGVuc29yTGF5b3V0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNEaW1lbnNpb25zIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2UgaGVpZ2h0IGluIHBpeGVsXG4gICAqL1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIHdpZHRoIGluIHBpeGVsXG4gICAqL1xuICB3aWR0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25SZXNpemVkRGltZW5zaW9ucyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHJlc2l6ZWQgaGVpZ2h0LiBJZiBvbWl0dGVkLCBvcmlnaW5hbCBoZWlnaHQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcmVzaXplZEhlaWdodD86IG51bWJlcjtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyByZXNpemVkIHdpZHRoIC0gY2FuIGJlIGFjY2Vzc2VkIHZpYSB0ZW5zb3IgZGltZW5zaW9ucyBhcyB3ZWxsXG4gICAqL1xuICByZXNpemVkV2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyBub3JtYWxpemF0aW9uIHBhcmFtZXRlcnMgd2hlbiBwcmVwcm9jZXNzaW5nIHRoZSBpbWFnZSBhcyBtb2RlbCBpbnB1dC5cbiAgICpcbiAgICogRGF0YSBlbGVtZW50IGFyZSByYW5nZWQgZnJvbSAwIHRvIDI1NS5cbiAgICovXG4gIG5vcm0/OiB7XG4gICAgLyoqXG4gICAgICogVGhlICdiaWFzJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiAtIElmIG9taXR0ZWQsIHVzZSBkZWZhdWx0IHZhbHVlIDAuXG4gICAgICogLSBJZiBpdCdzIGEgc2luZ2xlIG51bWJlciwgYXBwbHkgdG8gZWFjaCBjaGFubmVsXG4gICAgICogLSBJZiBpdCdzIGFuIGFycmF5IG9mIDMgb3IgNCBudW1iZXJzLCBhcHBseSBlbGVtZW50LXdpc2UuIE51bWJlciBvZiBlbGVtZW50cyBuZWVkIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgKiBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZm9ybWF0XG4gICAgICovXG4gICAgYmlhcz86IG51bWJlcnxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl18W251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgLyoqXG4gICAgICogVGhlICdtZWFuJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiAtIElmIG9taXR0ZWQsIHVzZSBkZWZhdWx0IHZhbHVlIDI1NS5cbiAgICAgKiAtIElmIGl0J3MgYSBzaW5nbGUgbnVtYmVyLCBhcHBseSB0byBlYWNoIGNoYW5uZWxcbiAgICAgKiAtIElmIGl0J3MgYW4gYXJyYXkgb2YgMyBvciA0IG51bWJlcnMsIGFwcGx5IGVsZW1lbnQtd2lzZS4gTnVtYmVyIG9mIGVsZW1lbnRzIG5lZWQgdG8gbWF0Y2ggdGhlIG51bWJlciBvZiBjaGFubmVsc1xuICAgICAqIGZvciB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBmb3JtYXRcbiAgICAgKi9cbiAgICBtZWFuPzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIH07XG59XG5cbi8vICNlbmRyZWdpb25cblxuLy8gI3JlZ2lvbiBPcHRpb25zIGNvbXBvc2l0aW9uXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucywgT3B0aW9uc1RlbnNvckZvcm1hdCwgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21VcmxPcHRpb25zIGV4dGVuZHMgT3B0aW9uc0RpbWVuc2lvbnMsIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLCBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsIE9wdGlvbnNUZW5zb3JGb3JtYXQsIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+IGV4dGVuZHNcbiAgICBSZXF1aXJlZDxPcHRpb25zRGltZW5zaW9ucz4sIE9wdGlvbnNGb3JtYXQsIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LyogVE9ETzogYWRkIG1vcmUgKi8ge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz4gZXh0ZW5kc1xuICAgIFBpY2s8VGVuc29yLCAnZGltcyc+LCBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiBUO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8qKlxuICogdHlwZSBUZW5zb3JGYWN0b3J5IGRlZmluZXMgdGhlIGZhY3RvcnkgZnVuY3Rpb25zIG9mICdUZW5zb3InIHRvIGNyZWF0ZSB0ZW5zb3IgaW5zdGFuY2VzIGZyb20gZXhpc3RpbmcgZGF0YSBvclxuICogcmVzb3VyY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZhY3Rvcnkge1xuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYW4gSW1hZ2VEYXRhIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gaW1hZ2VEYXRhIC0gdGhlIEltYWdlRGF0YSBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBJbWFnZURhdGEuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShpbWFnZURhdGE6IEltYWdlRGF0YSwgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zKTpcbiAgICAgIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPnxUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgSFRNTEltYWdlRWxlbWVudCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGltYWdlRWxlbWVudCAtIHRoZSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEhUTUxJbWFnZUVsZW1lbnQuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz58VHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBVUkxcbiAgICpcbiAgICogQHBhcmFtIHVybFNvdXJjZSAtIGEgc3RyaW5nIGFzIGEgVVJMIHRvIHRoZSBpbWFnZSBvciBhIGRhdGEgVVJMIGNvbnRhaW5pbmcgdGhlIGltYWdlIGRhdGEuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBVUkwuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZSh1cmxTb3VyY2U6IHN0cmluZywgb3B0aW9ucz86IFRlbnNvckZyb21VcmxPcHRpb25zKTogUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+fFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYW4gSW1hZ2VCaXRtYXAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBiaXRtYXAgLSB0aGUgSW1hZ2VCaXRtYXAgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gVVJMLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UoYml0bWFwOiBJbWFnZUJpdG1hcCwgb3B0aW9uczogVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz58VHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICpcbiAgICogQHBhcmFtIHRleHR1cmUgLSB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFdlYkdMIHRleHR1cmUuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYHdpZHRoYDogdGhlIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgaGVpZ2h0YDogdGhlIGhlaWdodCBvZiB0aGUgdGV4dHVyZS4gUmVxdWlyZWQuXG4gICAqIC0gYGZvcm1hdGA6IHRoZSBmb3JtYXQgb2YgdGhlIHRleHR1cmUuIElmIG9taXR0ZWQsIGFzc3VtZSAnUkdCQScuXG4gICAqIC0gYGRvd25sb2FkYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIHRlbnNvciBkYXRhIGZyb20gR1BVIHRvIENQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhXG4gICAqIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndFxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICogLSBgZGlzcG9zZWA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHRlbnNvciBkYXRhIG9uIEdQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhIHdpbGwgbm90IGJlIGRpc3Bvc2VkLlxuICAgKiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbVRleHR1cmU8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gJ2Zsb2F0MzInPihcbiAgICAgIHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+KTogVHlwZWRUZW5zb3I8J2Zsb2F0MzInPjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSB0aGUgR1BVQnVmZmVyIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFdlYkdQVSBidWZmZXIuXG4gICAqXG4gICAqIFRoZSBvcHRpb25zIGluY2x1ZGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIC0gYGRhdGFUeXBlYDogdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhc3N1bWUgJ2Zsb2F0MzInLlxuICAgKiAtIGBkaW1zYDogdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBSZXF1aXJlZC5cbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcbiAgICogd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0XG4gICAqIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXG4gICAqIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tR3B1QnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgICAgIGJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+KTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgcHJlLWFsbG9jYXRlZCBidWZmZXIuIFRoZSBidWZmZXIgd2lsbCBiZSB1c2VkIGFzIGEgcGlubmVkIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIGEgVHlwZWRBcnJheSBjb3JyZXNwb25kaW5nIHRvIHRoZSB0eXBlLlxuICAgKiBAcGFyYW0gZGltcyAtIHNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz4+KFxuICAgICAgdHlwZTogVCwgYnVmZmVyOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPFQ+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKipcbiAqIEEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZpbGUncyBVUkwgb3IgcGF0aC5cbiAqXG4gKiBQYXRoIGlzIHZhaWxhYmxlIG9ubHkgaW4gb25ueHJ1bnRpbWUtbm9kZSBvciBvbm54cnVudGltZS13ZWIgcnVubmluZyBpbiBOb2RlLmpzLlxuICovXG5leHBvcnQgdHlwZSBGaWxlVXJsT3JQYXRoID0gc3RyaW5nO1xuXG4vKipcbiAqIEEgQmxvYiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZUJsb2IgPSBCbG9iO1xuXG4vKipcbiAqIEEgVWludDhBcnJheSwgQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXIgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGZpbGUgY29udGVudC5cbiAqXG4gKiBXaGVuIGl0IGlzIGFuIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyLCB0aGUgd2hvbGUgYnVmZmVyIGlzIGFzc3VtZWQgdG8gYmUgdGhlIGZpbGUgY29udGVudC5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZURhdGEgPSBVaW50OEFycmF5fEFycmF5QnVmZmVyTGlrZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZmlsZSB0aGF0IGNhbiBiZSBsb2FkZWQgYnkgdGhlIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZVR5cGUgPSBGaWxlVXJsT3JQYXRofEZpbGVCbG9ifEZpbGVEYXRhO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybmFsRGF0YUZpbGVEZXNjcmlwdGlvbiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBleHRlcm5hbCBkYXRhIGZpbGUuXG4gICAqL1xuICBkYXRhOiBGaWxlVHlwZTtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGZpbGUgcGF0aC5cbiAgICovXG4gIHBhdGg6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAqXG4gKiBXaGVuIHVzaW5nIGEgc3RyaW5nLCBpdCBzaG91bGQgYmUgYSBmaWxlIFVSTCBvciBwYXRoIHRoYXQgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoZSBtb2RlbCBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBFeHRlcm5hbERhdGFGaWxlVHlwZSA9IEV4dGVybmFsRGF0YUZpbGVEZXNjcmlwdGlvbnxGaWxlVXJsT3JQYXRoO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIG1vZGVsIGxvYWRpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT25ueE1vZGVsT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5aW5nIGEgbGlzdCBvZiBmaWxlcyB0aGF0IHJlcHJlc2VudHMgdGhlIGV4dGVybmFsIGRhdGEuXG4gICAqL1xuICBleHRlcm5hbERhdGE/OiByZWFkb25seSBFeHRlcm5hbERhdGFGaWxlVHlwZVtdO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBOb25UZW5zb3JUeXBlID0gbmV2ZXI7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWUgUmVwcmVzZW50cyBib3RoIHRlbnNvcnMgYW5kIG5vbi10ZW5zb3JzIHZhbHVlIGZvciBtb2RlbCdzIGlucHV0cy9vdXRwdXRzLlxuICpcbiAqIE5PVEU6IGN1cnJlbnRseSBub3Qgc3VwcG9ydCBub24tdGVuc29yXG4gKi9cbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZSA9IFRlbnNvcnxOb25UZW5zb3JUeXBlO1xuXG4vKipcbiAqIFR5cGUgT25ueFZhbHVlRGF0YUxvY2F0aW9uIHJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIG9mIGFuIE9ubnhWYWx1ZS5cbiAqL1xuZXhwb3J0IHR5cGUgT25ueFZhbHVlRGF0YUxvY2F0aW9uID0gVGVuc29yLkRhdGFMb2NhdGlvbjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtyZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVyc30gZnJvbSAnLi9iYWNrZW5kLWltcGwuanMnO1xuaW1wb3J0IHtTZXNzaW9uSGFuZGxlciwgVHJhaW5pbmdTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbiBhcyBJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7T25ueFZhbHVlfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7VHJhaW5pbmdTZXNzaW9uIGFzIFRyYWluaW5nU2Vzc2lvbkludGVyZmFjZSwgVHJhaW5pbmdTZXNzaW9uQ3JlYXRlT3B0aW9uc30gZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcblxudHlwZSBTZXNzaW9uT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnM7XG50eXBlIEZlZWRzVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlO1xudHlwZSBGZXRjaGVzVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGU7XG50eXBlIFJldHVyblR5cGUgPSBJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU7XG50eXBlIFJ1bk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnM7XG5cbmNvbnN0IG5vQmFja2VuZEVyck1zZzogc3RyaW5nID0gJ1RyYWluaW5nIGJhY2tlbmQgY291bGQgbm90IGJlIHJlc29sdmVkLiAnICtcbiAgICAnTWFrZSBzdXJlIHlvdVxcJ3JlIHVzaW5nIHRoZSBjb3JyZWN0IGNvbmZpZ3VyYXRpb24gJiBXZWJBc3NlbWJseSBmaWxlcy4nO1xuXG5leHBvcnQgY2xhc3MgVHJhaW5pbmdTZXNzaW9uIGltcGxlbWVudHMgVHJhaW5pbmdTZXNzaW9uSW50ZXJmYWNlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyLCBoYXNPcHRpbWl6ZXJNb2RlbDogYm9vbGVhbiwgaGFzRXZhbE1vZGVsOiBib29sZWFuKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmhhc09wdGltaXplck1vZGVsID0gaGFzT3B0aW1pemVyTW9kZWw7XG4gICAgdGhpcy5oYXNFdmFsTW9kZWwgPSBoYXNFdmFsTW9kZWw7XG4gIH1cbiAgcHJpdmF0ZSBoYW5kbGVyOiBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyO1xuICBwcml2YXRlIGhhc09wdGltaXplck1vZGVsOiBib29sZWFuO1xuICBwcml2YXRlIGhhc0V2YWxNb2RlbDogYm9vbGVhbjtcblxuICBnZXQgdHJhaW5pbmdJbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gIH1cbiAgZ2V0IHRyYWluaW5nT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXQgZXZhbElucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsSW5wdXROYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG4gIGdldCBldmFsT3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5ldmFsT3V0cHV0TmFtZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB0cmFpbmluZyBzZXNzaW9uIGhhcyBubyBldmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUodHJhaW5pbmdPcHRpb25zOiBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zLCBzZXNzaW9uT3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8VHJhaW5pbmdTZXNzaW9uPiB7XG4gICAgY29uc3QgZXZhbE1vZGVsOiBzdHJpbmd8VWludDhBcnJheSA9IHRyYWluaW5nT3B0aW9ucy5ldmFsTW9kZWwgfHwgJyc7XG4gICAgY29uc3Qgb3B0aW1pemVyTW9kZWw6IHN0cmluZ3xVaW50OEFycmF5ID0gdHJhaW5pbmdPcHRpb25zLm9wdGltaXplck1vZGVsIHx8ICcnO1xuICAgIGNvbnN0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0gc2Vzc2lvbk9wdGlvbnMgfHwge307XG5cbiAgICAvLyByZXNvbHZlIGJhY2tlbmQsIHVwZGF0ZSBzZXNzaW9uIG9wdGlvbnMgd2l0aCB2YWxpZGF0ZWQgRVBzLCBhbmQgY3JlYXRlIHNlc3Npb24gaGFuZGxlclxuICAgIGNvbnN0IFtiYWNrZW5kLCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQc10gPSBhd2FpdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyhvcHRpb25zKTtcbiAgICBpZiAoYmFja2VuZC5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgYmFja2VuZC5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKFxuICAgICAgICAgIHRyYWluaW5nT3B0aW9ucy5jaGVja3BvaW50U3RhdGUsIHRyYWluaW5nT3B0aW9ucy50cmFpbk1vZGVsLCBldmFsTW9kZWwsIG9wdGltaXplck1vZGVsLFxuICAgICAgICAgIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzKTtcbiAgICAgIHJldHVybiBuZXcgVHJhaW5pbmdTZXNzaW9uKGhhbmRsZXIsICEhdHJhaW5pbmdPcHRpb25zLm9wdGltaXplck1vZGVsLCAhIXRyYWluaW5nT3B0aW9ucy5ldmFsTW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iobm9CYWNrZW5kRXJyTXNnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBydW5UcmFpblN0ZXAgYW5kIGZ1dHVyZSBydW5TdGVwIG1ldGhvZHMgdGhhdCBoYW5kbGVzIHRoZSB0eXBlLW5hcnJvd2luZyBjb252ZXJzaW9uIGZyb21cbiAgICogdGhlIGdpdmVuIHBhcmFtZXRlcnMgdG8gU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgYW5kIFJ1bk9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dE5hbWVzIHRoZSBmZWVkcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZXkgY29udGFpbiBhbGwgaW5wdXQgbmFtZXMgaW4gdGhlIHByb3ZpZGVkIGxpc3Qgb2YgaW5wdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBvdXRwdXROYW1lcyB0aGUgZmV0Y2hlcyBvYmplY3QgaXMgY2hlY2tlZCB0aGF0IHRoZWlyIGtleXMgbWF0Y2ggdXAgd2l0aCB2YWxpZCBuYW1lcyBpbiB0aGUgbGlzdCBvZiBvdXRwdXRcbiAgICogbmFtZXMuXG4gICAqIEBwYXJhbSBmZWVkcyB0aGUgcmVxdWlyZWQgaW5wdXRcbiAgICogQHBhcmFtIGFyZzEgbmFycm93ZWQgJiBjb252ZXJ0ZWQgaW50byB0aGUgU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUgb3IgUnVuT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIGFyZzIgb3B0aW9uYWwgUnVuT3B0aW9ucyBvYmplY3QuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICB0eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICAgIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdLCBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW10sIGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZXxSdW5PcHRpb25zLFxuICAgICAgYXJnMj86IFJ1bk9wdGlvbnMpOiBbU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsIFJ1bk9wdGlvbnNdIHtcbiAgICBjb25zdCBmZXRjaGVzOiB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZXxudWxsfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1xcJ2ZlZWRzXFwnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy4nKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhIFRlbnNvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAvLyBvdXRwdXQgbmFtZXNcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtuYW1lfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xuICAgICAgICAvLyBpZiBhbnkgb3V0cHV0IG5hbWUgaXMgcHJlc2VudCBhbmQgaXRzIHZhbHVlIGlzIHZhbGlkIE9ubnhWYWx1ZSwgd2UgY29uc2lkZXIgaXQgZmV0Y2hlc1xuICAgICAgICBsZXQgaXNGZXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBvdXRwdXROYW1lcykge1xuICAgICAgICAgIGlmIChhcmcxS2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IChhcmcxIGFzIEluZmVyZW5jZVNlc3Npb24uTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlKVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2ID09PSBudWxsIHx8IHYgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgaXNGZXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmV0Y2hlcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcxIGFzIFJ1bk9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSBcXCdmZXRjaGVzXFwnIG9yIFxcJ29wdGlvbnNcXCcuJyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgYWxsIGlucHV0cyBhcmUgaW4gZmVlZFxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBpbnB1dE5hbWVzKSB7XG4gICAgICBpZiAodHlwZW9mIGZlZWRzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gZmV0Y2hlcyBpcyBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZnVsbCBvdXRwdXQgbmFtZXMgbGlzdFxuICAgIGlmIChpc0ZldGNoZXNFbXB0eSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG91dHB1dE5hbWVzKSB7XG4gICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbZmV0Y2hlcywgb3B0aW9uc107XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCBmb3IgcnVuVHJhaW5TdGVwIGFuZCBhbnkgb3RoZXIgcnVuU3RlcCBtZXRob2RzLiBUYWtlcyB0aGUgUmV0dXJuVHlwZSByZXN1bHQgZnJvbSB0aGUgU2Vzc2lvbkhhbmRsZXJcbiAgICogYW5kIGNoYW5nZXMgaXQgaW50byBhIG1hcCBvZiBUZW5zb3JzLlxuICAgKlxuICAgKiBAcGFyYW0gcmVzdWx0c1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnMocmVzdWx0czogU2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZSk6IFJldHVyblR5cGUge1xuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZX0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBuZXcgVGVuc29yKHJlc3VsdC50eXBlLCByZXN1bHQuZGF0YSwgcmVzdWx0LmRpbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG4gIGFzeW5jIGxhenlSZXNldEdyYWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5oYW5kbGVyLmxhenlSZXNldEdyYWQoKTtcbiAgfVxuXG4gIHJ1blRyYWluU3RlcChmZWVkczogRmVlZHNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIHJ1blRyYWluU3RlcChmZWVkczogRmVlZHNUeXBlLCBmZXRjaGVzOiBGZXRjaGVzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBhc3luYyBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlfFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgY29uc3QgW2ZldGNoZXMsIG9wdGlvbnNdID1cbiAgICAgICAgdGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0aGlzLnRyYWluaW5nSW5wdXROYW1lcywgdGhpcy50cmFpbmluZ091dHB1dE5hbWVzLCBmZWVkcywgYXJnMSwgYXJnMik7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW5UcmFpblN0ZXAoZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHMpO1xuICB9XG5cbiAgYXN5bmMgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zfHVuZGVmaW5lZCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmhhc09wdGltaXplck1vZGVsKSB7XG4gICAgICBhd2FpdCB0aGlzLmhhbmRsZXIucnVuT3B0aW1pemVyU3RlcChvcHRpb25zIHx8IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gT3B0aW1pemVyTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zfHVuZGVmaW5lZCk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGZldGNoZXM6IEZldGNoZXNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9uc3x1bmRlZmluZWQpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBhc3luYyBydW5FdmFsU3RlcChmZWVkczogRmVlZHNUeXBlLCBhcmcxPzogRmV0Y2hlc1R5cGV8UnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBpZiAodGhpcy5oYXNFdmFsTW9kZWwpIHtcbiAgICAgIGNvbnN0IFtmZXRjaGVzLCBvcHRpb25zXSA9XG4gICAgICAgICAgdGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcCh0aGlzLmV2YWxJbnB1dE5hbWVzLCB0aGlzLmV2YWxPdXRwdXROYW1lcywgZmVlZHMsIGFyZzEsIGFyZzIpO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW5FdmFsU3RlcChmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5jb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRyYWluaW5nU2Vzc2lvbiBoYXMgbm8gRXZhbE1vZGVsIGxvYWRlZC4nKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5ID0gdHJ1ZSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5nZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5KTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRQYXJhbWV0ZXJzQnVmZmVyKGFycmF5OiBVaW50OEFycmF5LCB0cmFpbmFibGVPbmx5ID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHBhcmFtc1NpemUgPSBhd2FpdCB0aGlzLmdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkpO1xuICAgIC8vIGNoZWNraW5nIHRoYXQgdGhlIHNpemUgb2YgdGhlIFVpbnQ4QXJyYXkgaXMgZXF1aXZhbGVudCB0byB0aGUgYnl0ZSBsZW5ndGggb2YgYSBGbG9hdDMyQXJyYXkgb2YgdGhlIG51bWJlclxuICAgIC8vIG9mIHBhcmFtZXRlcnNcbiAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSA0ICogcGFyYW1zU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTaXplIG9mIHRoZSBidWZmZXIgcGFzc2VkIGludG8gbG9hZFBhcmFtZXRlcnNCdWZmZXIgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgaW4gJyArXG4gICAgICAgICAgJ3RoZSBtb2RlbC4gUGxlYXNlIHVzZSBnZXRQYXJhbWV0ZXJzU2l6ZSBtZXRob2QgdG8gY2hlY2suJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhbmRsZXIubG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXksIHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPE9ubnhWYWx1ZT4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5pbXBvcnQge09ubnhWYWx1ZX0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7VHJhaW5pbmdTZXNzaW9uIGFzIFRyYWluaW5nU2Vzc2lvbkltcGx9IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi1pbXBsLmpzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSAqL1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVHJhaW5pbmdTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEVpdGhlciBVUkkgZmlsZSBwYXRoIChzdHJpbmcpIG9yIFVpbnQ4QXJyYXkgY29udGFpbmluZyBtb2RlbCBvciBjaGVja3BvaW50IGluZm9ybWF0aW9uLlxuICAgKi9cbiAgdHlwZSBVcmlPckJ1ZmZlciA9IHN0cmluZ3xVaW50OEFycmF5O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHJ1bnRpbWUgaW5zdGFuY2Ugb2YgYW4gT05OWCB0cmFpbmluZyBzZXNzaW9uLFxuICogd2hpY2ggY29udGFpbnMgYSBtb2RlbCB0aGF0IGNhbiBiZSB0cmFpbmVkLCBhbmQsIG9wdGlvbmFsbHksXG4gKiBhbiBldmFsIGFuZCBvcHRpbWl6ZXIgbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uIHtcbiAgLy8gI3JlZ2lvbiBydW4oKVxuXG4gIC8qKlxuICAgKiBMYXppbHkgcmVzZXRzIHRoZSBncmFkaWVudHMgb2YgYWxsIHRyYWluYWJsZSBwYXJhbWV0ZXJzIHRvIHplcm8uIFNob3VsZCBoYXBwZW4gYWZ0ZXIgdGhlIGludm9jYXRpb24gb2ZcbiAgICogcnVuT3B0aW1pemVyU3RlcC5cbiAgICovXG4gIGxhenlSZXNldEdyYWQoKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogUnVuIFRyYWluU3RlcCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5JbnB1dFR5cGVgIGZvclxuICAgZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIHRyYWluaW5nLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgcnVuVHJhaW5TdGVwKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1biBhIHNpbmdsZSB0cmFpbiBzdGVwIHdpdGggdGhlIGdpdmVuIGlucHV0cyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LlxuICAgKiBAcGFyYW0gZmV0Y2hlcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQuXG4gICAqIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCB0cmFpbmluZy5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nXG4gICB2YWx1ZXMuXG4gICAqL1xuICBydW5UcmFpblN0ZXAoXG4gICAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBSdW5zIGEgc2luZ2xlIG9wdGltaXplciBzdGVwLCB3aGljaCBwZXJmb3JtcyB3ZWlnaHQgdXBkYXRlcyBmb3IgdGhlIHRyYWluYWJsZSBwYXJhbWV0ZXJzIHVzaW5nIHRoZSBvcHRpbWl6ZXIgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgb3B0aW1pemluZy5cbiAgICovXG4gIHJ1bk9wdGltaXplclN0ZXAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFJ1biBhIHNpbmdsZSBldmFsIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zIHVzaW5nIHRoZSBldmFsIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgZXZhbCBzdGVwLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1bkV2YWxTdGVwKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1biBhIHNpbmdsZSBldmFsIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zIHVzaW5nIHRoZSBldmFsIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC5cbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGV2YWwgc3RlcC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nXG4gICB2YWx1ZXMuXG4gICAqL1xuICBydW5FdmFsU3RlcChcbiAgICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gY29weSBwYXJhbWV0ZXJzXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhbGwgcGFyYW1ldGVycyBmb3IgdGhlIHRyYWluaW5nIHN0YXRlLiBDYWxjdWxhdGVzIHRoZSB0b3RhbCBudW1iZXIgb2YgcHJpbWl0aXZlIChkYXRhdHlwZSBvZlxuICAgKiB0aGUgcGFyYW1ldGVycykgZWxlbWVudHMgb2YgYWxsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSB0cmFpbmluZyBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRyYWluYWJsZU9ubHkgLSBXaGVuIHNldCB0byB0cnVlLCB0aGUgc2l6ZSBpcyBjYWxjdWxhdGVkIGZvciB0cmFpbmFibGUgcGFyYW1zIG9ubHkuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICovXG4gIGdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPG51bWJlcj47XG5cbiAgLyoqXG4gICAqIENvcGllcyBwYXJhbWV0ZXIgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGJ1ZmZlciB0byB0aGUgdHJhaW5pbmcgc3RhdGUuIEN1cnJlbnRseSwgb25seSBzdXBwb3J0aW5nIG1vZGVscyB3aXRoXG4gICAqIHBhcmFtZXRlcnMgb2YgdHlwZSBGbG9hdDMyLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIEZsb2F0MzIgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHRyYWluYWJsZU9ubHkgLSBUcnVlIGlmIHRyYWluYWJsZSBwYXJhbWV0ZXJzIG9ubHkgdG8gYmUgbW9kaWZpZWQsIGZhbHNlIG90aGVyd2lzZS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKi9cbiAgbG9hZFBhcmFtZXRlcnNCdWZmZXIoYnVmZmVyOiBVaW50OEFycmF5LCB0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ29waWVzIHRoZSBtb2RlbCBwYXJhbWV0ZXJzIHRvIGEgY29udGlndW91cyBidWZmZXIuIFVzdWFsbHkgdXNlZCBpbiB0aGUgY29udGV4dCBvZiBGZWRlcmF0ZWQgTGVhcm5pbmcuXG4gICAqIEN1cnJlbnRseSwgb25seSBzdXBwb3J0aW5nIG1vZGVscyB3aXRoIHBhcmFtZXRlcnMgb2YgdHlwZSBGbG9hdDMyLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFdoZW4gc2V0IHRvIHRydWUsIG9ubHkgdHJhaW5hYmxlIHBhcmFtZXRlcnMgYXJlIGNvcGllZC4gVHJhaW5hYmxlIHBhcmFtZXRlcnMgYXJlIHBhcmFtZXRlcnNcbiAgICogZm9yIHdoaWNoIHJlcXVpcmVzX2dyYWQgaXMgc2V0IHRvIHRydWUuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGbG9hdDMyIE9ubnhWYWx1ZSBvZiB0aGUgcmVxdWVzdGVkIHBhcmFtZXRlcnMuXG4gICAqL1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiByZWxlYXNlKClcblxuICAvKipcbiAgICogUmVsZWFzZSB0aGUgaW5mZXJlbmNlIHNlc3Npb24gYW5kIHRoZSB1bmRlcmx5aW5nIHJlc291cmNlcy5cbiAgICovXG4gIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0YWRhdGFcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSB0cmFpbmluZ0lucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSB0cmFpbmluZ091dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IGlucHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgZXZhbCBtb2RlbC4gSXMgYW4gZW1wdHkgYXJyYXkgaWYgbm8gZXZhbCBtb2RlbCBpcyBsb2FkZWQuXG4gICAqL1xuICByZWFkb25seSBldmFsSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBldmFsIG1vZGVsLiBJcyBhbiBlbXB0eSBhcnJheSBpZiBubyBldmFsIG1vZGVsIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGV2YWxPdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIG9wdGlvbmFsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmUgcGFzc2VkIGludG8gdGhlIFRyYWluaW5nU2Vzc2lvbkZhY3RvcnkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uQ3JlYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBVUkkgb3IgYnVmZmVyIGZvciBhIC5ja3B0IGZpbGUgdGhhdCBjb250YWlucyB0aGUgY2hlY2twb2ludCBmb3IgdGhlIHRyYWluaW5nIG1vZGVsLlxuICAgKi9cbiAgY2hlY2twb2ludFN0YXRlOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG4gIC8qKlxuICAgKiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggdHJhaW5pbmcgZmlsZS5cbiAgICovXG4gIHRyYWluTW9kZWw6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIE9wdGlvbmFsLiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggb3B0aW1pemVyIG1vZGVsIGZpbGUuXG4gICAqL1xuICBvcHRpbWl6ZXJNb2RlbD86IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIE9wdGlvbmFsLiBVUkkgb3IgYnVmZmVyIGZvciB0aGUgLm9ubnggZXZhbCBtb2RlbCBmaWxlLlxuICAgKi9cbiAgZXZhbE1vZGVsPzogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xufVxuXG4vKipcbiAqIERlZmluZXMgbWV0aG9kIG92ZXJsb2FkIHBvc3NpYmlsaXRpZXMgZm9yIGNyZWF0aW5nIGEgVHJhaW5pbmdTZXNzaW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkZhY3Rvcnkge1xuICAvLyAjcmVnaW9uIGNyZWF0ZSgpXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVHJhaW5pbmdTZXNzaW9uIGFuZCBhc3luY2hyb25vdXNseSBsb2FkcyBhbnkgbW9kZWxzIHBhc3NlZCBpbiB0aHJvdWdoIHRyYWluaW5nT3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5pbmdPcHRpb25zIHNwZWNpZnkgbW9kZWxzIGFuZCBjaGVja3BvaW50cyB0byBsb2FkIGludG8gdGhlIFRyYWluaW5nIFNlc3Npb25cbiAgICogQHBhcmFtIHNlc3Npb25PcHRpb25zIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgdHJhaW5pbmcgc2Vzc2lvbiBiZWhhdmlvclxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBUcmFpbmluZ1Nlc3Npb24gb2JqZWN0XG4gICAqL1xuICBjcmVhdGUodHJhaW5pbmdPcHRpb25zOiBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zLCBzZXNzaW9uT3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxUcmFpbmluZ1Nlc3Npb24+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IFRyYWluaW5nU2Vzc2lvbjogVHJhaW5pbmdTZXNzaW9uRmFjdG9yeSA9IFRyYWluaW5nU2Vzc2lvbkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogIyBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUElcbiAqXG4gKiBPTk5YIFJ1bnRpbWUgSmF2YVNjcmlwdCBBUEkgaXMgYSB1bmlmaWVkIEFQSSBmb3IgYWxsIEphdmFTY3JpcHQgdXNhZ2VzLCBpbmNsdWRpbmcgdGhlIGZvbGxvd2luZyBOUE0gcGFja2FnZXM6XG4gKlxuICogLSBbb25ueHJ1bnRpbWUtbm9kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtbm9kZSlcbiAqIC0gW29ubnhydW50aW1lLXdlYl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtd2ViKVxuICogLSBbb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1yZWFjdC1uYXRpdmUpXG4gKlxuICogU2VlIGFsc286XG4gKiAtIFtHZXQgU3RhcnRlZF0oaHR0cHM6Ly9vbm54cnVudGltZS5haS9kb2NzL2dldC1zdGFydGVkL3dpdGgtamF2YXNjcmlwdC8pXG4gKiAtIFtJbmZlcmVuY2UgZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUtaW5mZXJlbmNlLWV4YW1wbGVzL3RyZWUvbWFpbi9qcylcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuXG5leHBvcnQgKiBmcm9tICcuL2JhY2tlbmQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnYuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFjZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtbW9kZWwuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi5qcyc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAhISh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJ3ZWJ3b3JrZXJcIiAvPlxuXG4vL1xuLy8gKiB0eXBlIGhhY2sgZm9yIFwiSFRNTEltYWdlRWxlbWVudFwiXG4vL1xuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJIVE1MSW1hZ2VFbGVtZW50XCIgaXMgZGVmaW5lZCBpbiBsaWIuZG9tLmQudHMsIHdoaWNoIGlzIGNvbmZsaWN0IHdpdGggbGliLndlYndvcmtlci5kLnRzLlxuLy8gd2hlbiB3ZSB1c2Ugd2Vid29ya2VyLCB0aGUgbGliLndlYndvcmtlci5kLnRzIHdpbGwgYmUgdXNlZCwgd2hpY2ggZG9lcyBub3QgaGF2ZSBIVE1MSW1hZ2VFbGVtZW50IGRlZmluZWQuXG4vL1xuLy8gd2Ugd2lsbCBnZXQgdGhlIGZvbGxvd2luZyBlcnJvcnMgY29tcGxhaW5pbmcgdGhhdCBIVE1MSW1hZ2VFbGVtZW50IGlzIG5vdCBkZWZpbmVkOlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gLi4vY29tbW9uL2Rpc3QvY2pzL3RlbnNvci1mYWN0b3J5LmQudHM6MTg3OjI5IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MSW1hZ2VFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gMTg3ICAgICBmcm9tSW1hZ2UoaW1hZ2VFbGVtZW50OiBIVE1MSW1hZ2VFbGVtZW50LCBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMpOlxuLy8gUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+IHwgVHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XG4vL1xuLy8gbm9kZV9tb2R1bGVzL0B3ZWJncHUvdHlwZXMvZGlzdC9pbmRleC5kLnRzOjgzOjcgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyA4MyAgICAgfCBIVE1MSW1hZ2VFbGVtZW50XG4vLyAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBgSFRNTEltYWdlRWxlbWVudGAgaXMgb25seSB1c2VkIGluIHR5cGUgZGVjbGFyYXRpb24gYW5kIG5vdCBpbiByZWFsIGNvZGUuIFNvIHdlIGRlZmluZSBpdCBhcyBgdW5rbm93bmAgaGVyZSB0b1xuLy8gYnlwYXNzIHRoZSB0eXBlIGNoZWNrLlxuXG4vL1xuLy8gKiB0eXBlIGhhY2sgZm9yIFwiZG9jdW1lbnRcIlxuLy9cbi8vIGluIHR5cGVzY3JpcHQsIHRoZSB0eXBlIG9mIFwiZG9jdW1lbnRcIiBpcyBkZWZpbmVkIGluIGxpYi5kb20uZC50cywgc28gaXQncyBub3QgYXZhaWxhYmxlIGluIHdlYndvcmtlci5cbi8vXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IGRvY3VtZW50IGlzIG5vdCBkZWZpbmVkOlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6NzozMyAtIGVycm9yIFRTMjU4NDogQ2Fubm90IGZpbmQgbmFtZSAnZG9jdW1lbnQnLiBEbyB5b3UgbmVlZCB0byBjaGFuZ2UgeW91ciB0YXJnZXRcbi8vIGxpYnJhcnk/IFRyeSBjaGFuZ2luZyB0aGUgJ2xpYicgY29tcGlsZXIgb3B0aW9uIHRvIGluY2x1ZGUgJ2RvbScuXG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3OjYxIC0gZXJyb3IgVFMyNTg0OiBDYW5ub3QgZmluZCBuYW1lICdkb2N1bWVudCcuIERvIHlvdSBuZWVkIHRvIGNoYW5nZSB5b3VyIHRhcmdldFxuLy8gbGlicmFyeT8gVHJ5IGNoYW5naW5nIHRoZSAnbGliJyBjb21waWxlciBvcHRpb24gdG8gaW5jbHVkZSAnZG9tJy5cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3Ojg4IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MU2NyaXB0RWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+fn5+fn5+fn5+flxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBgZG9jdW1lbnRgIGlzIHVzZWQgdG8gZ2V0IHRoZSBjdXJyZW50IHNjcmlwdCBVUkwsIHdoaWNoIGlzIG5vdCBhdmFpbGFibGUgaW4gd2Vid29ya2VyLiBUaGlzIGZpbGUgaXMgc2VydmVkIGFzIGFcbi8vIFwiZHVhbFwiIGZpbGUgZm9yIGVudHJpZXMgb2YgYm90aCB3ZWJ3b3JrZXIgYW5kIHRoZSBlc20gbW9kdWxlLlxuLy9cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgdHlwZSBIVE1MSW1hZ2VFbGVtZW50ID0gdW5rbm93bjtcbiAgdHlwZSBIVE1MU2NyaXB0RWxlbWVudCA9IHtzcmM/OiBzdHJpbmd9O1xuICBjb25zdCBkb2N1bWVudDogdW5kZWZpbmVkfHtjdXJyZW50U2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnR9O1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5XG4gKlxuICogVGhpcyBmaWxlIGlzIHNlcnZlZCBhcyBhIFwiZHVhbFwiIGZpbGUgZm9yIGJvdGggZW50cmllcyBvZiB0aGUgZm9sbG93aW5nOlxuICogLSBUaGUgcHJveHkgd29ya2VyIGl0c2VsZi5cbiAqICAgLSBXaGVuIHVzZWQgYXMgYSB3b3JrZXIsIGl0IGxpc3RlbnMgdG8gdGhlIG1lc3NhZ2VzIGZyb20gdGhlIG1haW4gdGhyZWFkIGFuZCBwZXJmb3JtcyB0aGUgY29ycmVzcG9uZGluZyBvcGVyYXRpb25zLlxuICogICAtIFNob3VsZCBiZSBpbXBvcnRlZCBkaXJlY3RseSB1c2luZyBgbmV3IFdvcmtlcigpYCBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogLSBUaGUgRVNNIG1vZHVsZSB0aGF0IGNyZWF0ZXMgdGhlIHByb3h5IHdvcmtlciAoYXMgYSB3b3JrZXIgbGF1bmNoZXIpLlxuICogICAtIFdoZW4gdXNlZCBhcyBhIHdvcmtlciBsYXVuY2hlciwgaXQgY3JlYXRlcyB0aGUgcHJveHkgd29ya2VyIGFuZCByZXR1cm5zIGl0LlxuICogICAtIFNob3VsZCBiZSBpbXBvcnRlZCB1c2luZyBgaW1wb3J0KClgIGluIHRoZSBtYWluIHRocmVhZCwgd2l0aCB0aGUgcXVlcnkgcGFyYW1ldGVyIGBpbXBvcnQ9MWAuXG4gKlxuICogVGhpcyBmaWxlIHdpbGwgYmUgYWx3YXlzIGNvbXBpbGluZyBpbnRvIEVTTSBmb3JtYXQuXG4gKi9cblxuaW1wb3J0IHR5cGUge09ydFdhc21NZXNzYWdlLCBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YX0gZnJvbSAnLi4vcHJveHktbWVzc2FnZXMuanMnO1xuaW1wb3J0IHtjcmVhdGVTZXNzaW9uLCBjb3B5RnJvbUV4dGVybmFsQnVmZmVyLCBlbmRQcm9maWxpbmcsIGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzLCBpbml0RXAsIGluaXRSdW50aW1lLCByZWxlYXNlU2Vzc2lvbiwgcnVufSBmcm9tICcuLi93YXNtLWNvcmUtaW1wbC5qcyc7XG5pbXBvcnQge2luaXRpYWxpemVXZWJBc3NlbWJseX0gZnJvbSAnLi4vd2FzbS1mYWN0b3J5LmpzJztcbmltcG9ydCB7c2NyaXB0U3JjfSBmcm9tICcuLi93YXNtLXV0aWxzLWltcG9ydC5qcyc7XG5cbmNvbnN0IFdPUktFUl9OQU1FID0gJ29ydC13YXNtLXByb3h5LXdvcmtlcic7XG5jb25zdCBpc1Byb3h5V29ya2VyID0gZ2xvYmFsVGhpcy5zZWxmPy5uYW1lID09PSBXT1JLRVJfTkFNRTtcblxuaWYgKGlzUHJveHlXb3JrZXIpIHtcbiAgLy8gV29ya2VyIHRocmVhZFxuICBzZWxmLm9ubWVzc2FnZSA9IChldjogTWVzc2FnZUV2ZW50PE9ydFdhc21NZXNzYWdlPik6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHt0eXBlLCBpbiA6IG1lc3NhZ2V9ID0gZXYuZGF0YTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luaXQtd2FzbSc6XG4gICAgICAgICAgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KG1lc3NhZ2UhLndhc20pXG4gICAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbml0UnVudGltZShtZXNzYWdlISkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5pdC1lcCc6IHtcbiAgICAgICAgICBjb25zdCB7ZXBOYW1lLCBlbnZ9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgaW5pdEVwKGVudiwgZXBOYW1lKVxuICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGV9KTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb3B5LWZyb20nOiB7XG4gICAgICAgICAgY29uc3Qge2J1ZmZlcn0gPSBtZXNzYWdlITtcbiAgICAgICAgICBjb25zdCBidWZmZXJEYXRhID0gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBvdXQ6IGJ1ZmZlckRhdGF9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjcmVhdGUnOiB7XG4gICAgICAgICAgY29uc3Qge21vZGVsLCBvcHRpb25zfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbk1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIG91dDogc2Vzc2lvbk1ldGFkYXRhfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIGVycn0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVsZWFzZSc6XG4gICAgICAgICAgcmVsZWFzZVNlc3Npb24obWVzc2FnZSEpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J1bic6IHtcbiAgICAgICAgICBjb25zdCB7c2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9uc30gPSBtZXNzYWdlITtcbiAgICAgICAgICBydW4oc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgbmV3IEFycmF5KG91dHB1dEluZGljZXMubGVuZ3RoKS5maWxsKG51bGwpLCBvcHRpb25zKVxuICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgIG91dHB1dHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy5zb21lKG8gPT4gb1szXSAhPT0gJ2NwdScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIGVycjogJ1Byb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uJ30pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZSwgb3V0OiBvdXRwdXRzfSBhcyBPcnRXYXNtTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMoWy4uLmlucHV0cywgLi4ub3V0cHV0c10gYXMgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIGVycn0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6XG4gICAgICAgICAgZW5kUHJvZmlsaW5nKG1lc3NhZ2UhKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZX0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIGVycn0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm94eVdvcmtlciA/XG4gICAgbnVsbCA6XG4gICAgKHVybE92ZXJyaWRlPzogc3RyaW5nKSA9PlxuICAgICAgICBuZXcgV29ya2VyKHVybE92ZXJyaWRlID8/IHNjcmlwdFNyYyEsIHt0eXBlOiBCVUlMRF9ERUZTLklTX0VTTSA/ICdtb2R1bGUnIDogJ2NsYXNzaWMnLCBuYW1lOiBXT1JLRVJfTkFNRX0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgdHlwZSB7T3J0V2FzbU1vZHVsZX0gZnJvbSAnLi93YXNtLXR5cGVzJztcbmltcG9ydCB7aXNOb2RlfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcblxuLyoqXG4gKiBUaGUgY2xhc3NpYyBzY3JpcHQgc291cmNlIFVSTC4gVGhpcyBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZSBpbiBub24gRVNNb2R1bGUgZW52aXJvbm1lbnRzLlxuICpcbiAqIEluIE5vZGUuanMsIHRoaXMgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc2NyaXB0U3JjID1cbiAgICAvLyBpZiBOb2RlanMsIHJldHVybiB1bmRlZmluZWRcbiAgICBpc05vZGUgPyB1bmRlZmluZWQgOlxuICAgICAgICAgICAgIC8vIGlmIEl0J3MgRVNNLCB1c2UgaW1wb3J0Lm1ldGEudXJsXG4gICAgICAgICAgICAgQlVJTERfREVGUy5FU01fSU1QT1JUX01FVEFfVVJMID8/XG4gICAgICAgIC8vIHVzZSBgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNgIGlmIGF2YWlsYWJsZVxuICAgICAgICAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudC5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgYHNlbGYubG9jYXRpb24uaHJlZmAgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYubG9jYXRpb24/LmhyZWYgOiB1bmRlZmluZWQpKTtcblxuLyoqXG4gKiBUaGUgb3JpZ2luIG9mIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEluIE5vZGUuanMsIHRoaXMgaXMgdW5kZWZpbmVkLlxuICovXG5jb25zdCBvcmlnaW4gPSBpc05vZGUgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uLm9yaWdpbjtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZmlsZW5hbWUgd2l0aCBwcmVmaXggaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4uXG4gKi9cbmNvbnN0IGlzU2FtZU9yaWdpbiA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJhc2VVcmwgPSBwcmVmaXhPdmVycmlkZSA/PyBzY3JpcHRTcmM7XG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHVybC5vcmlnaW4gPT09IG9yaWdpbjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXRzIHRvIGFuIGFic29sdXRlIFVSTCB3aXRoIHRoZSBnaXZlbiBwcmVmaXggb3ZlcnJpZGUuIElmIGZhaWxlZCwgcmV0dXJuIHVuZGVmaW5lZC5cbiAqL1xuY29uc3Qgbm9ybWFsaXplVXJsID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGJhc2VVcmwgPSBwcmVmaXhPdmVycmlkZSA/PyBzY3JpcHRTcmM7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYmFzZVVybCA/IG5ldyBVUkwoZmlsZW5hbWUsIGJhc2VVcmwpIDogbmV3IFVSTChmaWxlbmFtZSk7XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhbGxiYWNrIFVSTCBpZiBhbiBhYnNvbHV0ZSBVUkwgY2Fubm90IGJlIGNyZWF0ZWQgYnkgdGhlIG5vcm1hbGl6ZVVybCBmdW5jdGlvbi5cbiAqL1xuY29uc3QgZmFsbGJhY2tVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IGAke3ByZWZpeE92ZXJyaWRlID8/ICcuLyd9JHtmaWxlbmFtZX1gO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcHJlbG9hZCBhIG1vZHVsZSBmcm9tIGEgVVJMLlxuICpcbiAqIElmIHRoZSBvcmlnaW4gb2YgdGhlIHdvcmtlciBVUkwgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb3JpZ2luLCB0aGUgd29ya2VyIGNhbm5vdCBiZSBsb2FkZWQgZGlyZWN0bHkuXG4gKiBTZWUgZGlzY3Vzc2lvbnMgaW4gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi93b3JrZXItbG9hZGVyL2lzc3Vlcy8xNTRcbiAqXG4gKiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgZmV0Y2ggdGhlIHdvcmtlciBVUkwgYW5kIGNyZWF0ZSBhIG5ldyBCbG9iIFVSTCB3aXRoIHRoZSBzYW1lIG9yaWdpbiBhcyBhIHdvcmthcm91bmQuXG4gKlxuICogQHBhcmFtIGFic29sdXRlVXJsIC0gVGhlIGFic29sdXRlIFVSTCB0byBwcmVsb2FkLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBuZXcgQmxvYiBVUkxcbiAqL1xuY29uc3QgcHJlbG9hZCA9IGFzeW5jKGFic29sdXRlVXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFic29sdXRlVXJsLCB7Y3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbid9KTtcbiAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59O1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZHluYW1pY2FsbHkgaW1wb3J0IGEgbW9kdWxlIGZyb20gYSBVUkwuXG4gKlxuICogVGhlIGJ1aWxkIHNjcmlwdCBoYXMgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhpcyBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCB0aGUgVVJMIGlzIG5vdCBidW5kbGVkIGludG8gdGhlIGZpbmFsIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBpbXBvcnQuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVmYXVsdCBleHBvcnQgb2YgdGhlIG1vZHVsZS5cbiAqL1xuY29uc3QgZHluYW1pY0ltcG9ydERlZmF1bHQgPSBhc3luYzxUPih1cmw6IHN0cmluZyk6IFByb21pc2U8VD4gPT4gKGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIHVybCkpLmRlZmF1bHQ7XG5cbi8qKlxuICogVGhlIHByb3h5IHdvcmtlciBmYWN0b3J5IGltcG9ydGVkIGZyb20gdGhlIHByb3h5IHdvcmtlciBtb2R1bGUuXG4gKlxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIHRoZSBXZWJBc3NlbWJseSBwcm94eSBpcyBub3QgZGlzYWJsZWQuXG4gKi9cbmNvbnN0IGNyZWF0ZVByb3h5V29ya2VyOiAoKHVybE92ZXJyaWRlPzogc3RyaW5nKSA9PiBXb3JrZXIpfHVuZGVmaW5lZCA9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICBCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSA/IHVuZGVmaW5lZCA6IHJlcXVpcmUoJy4vcHJveHktd29ya2VyL21haW4nKS5kZWZhdWx0O1xuXG4vKipcbiAqIEltcG9ydCB0aGUgcHJveHkgd29ya2VyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwZXJmb3JtIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gKiAxLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxuICogMi4gVXNlIHRoZSBwcm94eSB3b3JrZXIgZmFjdG9yeSB0byBjcmVhdGUgdGhlIHByb3h5IHdvcmtlci5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgMiBlbGVtZW50czpcbiAqICAgICAgICAgICAgLSBUaGUgb2JqZWN0IFVSTCBvZiB0aGUgcHJlbG9hZGVkIG1vZHVsZSwgb3IgdW5kZWZpbmVkIGlmIG5vIHByZWxvYWQgaXMgbmVlZGVkLlxuICogICAgICAgICAgICAtIFRoZSBwcm94eSB3b3JrZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBpbXBvcnRQcm94eVdvcmtlciA9IGFzeW5jKCk6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgV29ya2VyXT4gPT4ge1xuICBpZiAoIXNjcmlwdFNyYykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgcHJveHkgd29ya2VyOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC4nKTtcbiAgfVxuXG4gIC8vIElmIHRoZSBzY3JpcHQgc291cmNlIGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLCB3ZSBjYW4gdXNlIHRoZSBlbWJlZGRlZCBwcm94eSBtb2R1bGUgZGlyZWN0bHkuXG4gIGlmIChpc1NhbWVPcmlnaW4oc2NyaXB0U3JjKSkge1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCBjcmVhdGVQcm94eVdvcmtlciEoKV07XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG5lZWQgdG8gcHJlbG9hZFxuICBjb25zdCB1cmwgPSBhd2FpdCBwcmVsb2FkKHNjcmlwdFNyYyk7XG4gIHJldHVybiBbdXJsLCBjcmVhdGVQcm94eVdvcmtlciEodXJsKV07XG59O1xuXG4vKipcbiAqIFRoZSBlbWJlZGRlZCBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKlxuICogVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBFU00gYW5kIHdoZW4gZW1iZWRkaW5nIGlzIG5vdCBkaXNhYmxlZC5cbiAqL1xuY29uc3QgZW1iZWRkZWRXYXNtTW9kdWxlOiBFbXNjcmlwdGVuTW9kdWxlRmFjdG9yeTxPcnRXYXNtTW9kdWxlPnx1bmRlZmluZWQgPVxuICAgIEJVSUxEX0RFRlMuSVNfRVNNICYmIEJVSUxEX0RFRlMuRElTQUJMRV9EWU5BTUlDX0lNUE9SVCA/XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICByZXF1aXJlKFxuICAgICAgICAhQlVJTERfREVGUy5ESVNBQkxFX1RSQUlOSU5HID8gJy4uLy4uL2Rpc3Qvb3J0LXRyYWluaW5nLXdhc20tc2ltZC10aHJlYWRlZC5tanMnIDpcbiAgICAgICAgICAgICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCA/ICcuLi8uLi9kaXN0L29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuLi8uLi9kaXN0L29ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzJylcbiAgICAgICAgLmRlZmF1bHQgOlxuICAgIHVuZGVmaW5lZDtcblxuLyoqXG4gKiBJbXBvcnQgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICogMS4gSWYgQlVJTERfREVGUy5ESVNBQkxFX0RZTkFNSUNfSU1QT1JUIGlzIHRydWUsIHVzZSB0aGUgZW1iZWRkZWQgbW9kdWxlLlxuICogMi4gSWYgYSBwcmVsb2FkIGlzIG5lZWRlZCwgaXQgd2lsbCBwcmVsb2FkIHRoZSBtb2R1bGUgYW5kIHJldHVybiB0aGUgb2JqZWN0IFVSTC5cbiAqIDMuIE90aGVyd2lzZSwgaXQgd2lsbCBwZXJmb3JtIGEgZHluYW1pYyBpbXBvcnQgb2YgdGhlIG1vZHVsZS5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgMiBlbGVtZW50czpcbiAqICAgICAgICAgICAgLSBUaGUgb2JqZWN0IFVSTCBvZiB0aGUgcHJlbG9hZGVkIG1vZHVsZSwgb3IgdW5kZWZpbmVkIGlmIG5vIHByZWxvYWQgaXMgbmVlZGVkLlxuICogICAgICAgICAgICAtIFRoZSBkZWZhdWx0IGV4cG9ydCBvZiB0aGUgbW9kdWxlLCB3aGljaCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbXBvcnRXYXNtTW9kdWxlID0gYXN5bmMoXG4gICAgdXJsT3ZlcnJpZGU6IHN0cmluZ3x1bmRlZmluZWQsIHByZWZpeE92ZXJyaWRlOiBzdHJpbmd8dW5kZWZpbmVkLFxuICAgIGlzTXVsdGlUaHJlYWRlZDogYm9vbGVhbik6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT5dPiA9PiB7XG4gIGlmIChCVUlMRF9ERUZTLkRJU0FCTEVfRFlOQU1JQ19JTVBPUlQpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgZW1iZWRkZWRXYXNtTW9kdWxlIV07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgd2FzbU1vZHVsZUZpbGVuYW1lID0gIUJVSUxEX0RFRlMuRElTQUJMRV9UUkFJTklORyA/ICdvcnQtdHJhaW5pbmctd2FzbS1zaW1kLXRocmVhZGVkLm1qcycgOlxuICAgICAgICAhQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnO1xuICAgIGNvbnN0IHdhc21Nb2R1bGVVcmwgPSB1cmxPdmVycmlkZSA/PyBub3JtYWxpemVVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSk7XG4gICAgLy8gbmVlZCB0byBwcmVsb2FkIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgICAvLyAxLiBub3QgaW4gTm9kZS5qcy5cbiAgICAvLyAgICAtIE5vZGUuanMgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBvcmlnaW4gcG9saWN5IGZvciBjcmVhdGluZyB3b3JrZXJzLlxuICAgIC8vIDIuIG11bHRpLXRocmVhZGVkIGlzIGVuYWJsZWQuXG4gICAgLy8gICAgLSBJZiBtdWx0aS10aHJlYWRlZCBpcyBkaXNhYmxlZCwgbm8gd29ya2VyIHdpbGwgYmUgY3JlYXRlZC4gU28gd2UgZG9uJ3QgbmVlZCB0byBwcmVsb2FkIHRoZSBtb2R1bGUuXG4gICAgLy8gMy4gdGhlIGFic29sdXRlIFVSTCBpcyBhdmFpbGFibGUuXG4gICAgLy8gICAgLSBJZiB0aGUgYWJzb2x1dGUgVVJMIGlzIGZhaWxlZCB0byBiZSBjcmVhdGVkLCB0aGUgb3JpZ2luIGNhbm5vdCBiZSBkZXRlcm1pbmVkLiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgbm90XG4gICAgLy8gICAgcHJlbG9hZCB0aGUgbW9kdWxlLlxuICAgIC8vIDQuIHRoZSB3b3JrZXIgVVJMIGlzIG5vdCBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAgICAvLyAgICAtIElmIHRoZSB3b3JrZXIgVVJMIGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLCB3ZSBjYW4gY3JlYXRlIHRoZSB3b3JrZXIgZGlyZWN0bHkuXG4gICAgY29uc3QgbmVlZFByZWxvYWQgPSAhaXNOb2RlICYmIGlzTXVsdGlUaHJlYWRlZCAmJiB3YXNtTW9kdWxlVXJsICYmICFpc1NhbWVPcmlnaW4od2FzbU1vZHVsZVVybCwgcHJlZml4T3ZlcnJpZGUpO1xuICAgIGNvbnN0IHVybCA9IG5lZWRQcmVsb2FkID8gKGF3YWl0IHByZWxvYWQod2FzbU1vZHVsZVVybCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3YXNtTW9kdWxlVXJsID8/IGZhbGxiYWNrVXJsKHdhc21Nb2R1bGVGaWxlbmFtZSwgcHJlZml4T3ZlcnJpZGUpKTtcbiAgICByZXR1cm4gW25lZWRQcmVsb2FkID8gdXJsIDogdW5kZWZpbmVkLCBhd2FpdCBkeW5hbWljSW1wb3J0RGVmYXVsdDxFbXNjcmlwdGVuTW9kdWxlRmFjdG9yeTxPcnRXYXNtTW9kdWxlPj4odXJsKV07XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgdHlwZSB7T3J0V2FzbU1vZHVsZX0gZnJvbSAnLi93YXNtLXR5cGVzJztcbmltcG9ydCB7aW1wb3J0V2FzbU1vZHVsZX0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XG5cbmxldCB3YXNtOiBPcnRXYXNtTW9kdWxlfHVuZGVmaW5lZDtcbmxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGFib3J0ZWQgPSBmYWxzZTtcblxuY29uc3QgaXNNdWx0aVRocmVhZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgLy8gSWYgJ1NoYXJlZEFycmF5QnVmZmVyJyBpcyBub3QgYXZhaWxhYmxlLCBXZWJBc3NlbWJseSB0aHJlYWRzIHdpbGwgbm90IHdvcmsuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciB0cmFuc2ZlcmFiaWxpdHkgb2YgU0FCcyAoZm9yIGJyb3dzZXJzLiBuZWVkZWQgZm9yIEZpcmVmb3gpXG4gICAgLy8gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIW1zZy9tb3ppbGxhLmRldi5wbGF0Zm9ybS9JSGtCWmxIRVRwQS9kd3NNTmNoV0VRQUpcbiAgICBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKTtcbiAgICB9XG5cbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSB0aHJlYWRzIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgdGhyZWFkZWQgaW5zdHJ1Y3Rpb25zLlxuICAgIHJldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbXG4gICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsICAwLCAgMCwgMSwgNCwgMSwgIDk2LCAwLCAgIDAsICAzLCAyLCAxLCAgMCwgNSxcbiAgICAgIDQsIDEsICAzLCAgIDEsICAgMSwgMTAsIDExLCAxLCA5LCAwLCA2NSwgMCwgIDI1NCwgMTYsIDIsIDAsIDI2LCAxMVxuICAgIF0pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuY29uc3QgaXNTaW1kU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xuICB0cnkge1xuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyBTSU1EIGluc3RydWN0aW9ucy5cblxuICAgIC8vIFRoZSBiaW5hcnkgZGF0YSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgZm9sbG93aW5nIGNvZGUgYnkgd2F0Mndhc206XG4gICAgLy9cbiAgICAvLyAobW9kdWxlXG4gICAgLy8gICAodHlwZSAkdDAgKGZ1bmMpKVxuICAgIC8vICAgKGZ1bmMgJGYwICh0eXBlICR0MClcbiAgICAvLyAgICAgKGRyb3BcbiAgICAvLyAgICAgICAoaTMyeDQuZG90X2kxNng4X3NcbiAgICAvLyAgICAgICAgIChpOHgxNi5zcGxhdFxuICAgIC8vICAgICAgICAgICAoaTMyLmNvbnN0IDApKVxuICAgIC8vICAgICAgICAgKHYxMjguY29uc3QgaTMyeDQgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDAgMHgwMDAwMDAwMCkpKSkpXG5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCwgICA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCAxMCwgMzAsIDEsICAgMjgsICAwLCA2NSwgMCxcbiAgICAgIDI1MywgMTUsIDI1MywgMTIsICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgIDAsICAyNTMsIDE4NiwgMSwgMjYsIDExXG4gICAgXSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5ID0gYXN5bmMoZmxhZ3M6IEVudi5XZWJBc3NlbWJseUZsYWdzKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aXBsZSBjYWxscyB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBkZXRlY3RlZC4nKTtcbiAgfVxuICBpZiAoYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJldmlvdXMgY2FsbCB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBmYWlsZWQuJyk7XG4gIH1cblxuICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gIC8vIHdhc20gZmxhZ3MgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgY29uc3QgdGltZW91dCA9IGZsYWdzLmluaXRUaW1lb3V0ITtcbiAgbGV0IG51bVRocmVhZHMgPSBmbGFncy5udW1UaHJlYWRzITtcblxuICAvLyBlbnN1cmUgU0lNRCBpcyBzdXBwb3J0ZWRcbiAgaWYgKCFpc1NpbWRTdXBwb3J0ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LicpO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgbXVsdGktdGhyZWFkaW5nIGlzIHN1cHBvcnRlZFxuICBjb25zdCBtdWx0aVRocmVhZFN1cHBvcnRlZCA9IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQoKTtcbiAgaWYgKG51bVRocmVhZHMgPiAxICYmICFtdWx0aVRocmVhZFN1cHBvcnRlZCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gJyArIG51bVRocmVhZHMgK1xuICAgICAgICAgICcsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiAnICtcbiAgICAgICAgICAnU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICcgK1xuICAgICAgICAnRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuJyk7XG5cbiAgICAvLyBzZXQgZmxhZ3MubnVtVGhyZWFkcyB0byAxIHNvIHRoYXQgT3J0SW5pdCgpIHdpbGwgbm90IGNyZWF0ZSBhIGdsb2JhbCB0aHJlYWQgcG9vbC5cbiAgICBmbGFncy5udW1UaHJlYWRzID0gbnVtVGhyZWFkcyA9IDE7XG4gIH1cblxuICBjb25zdCB3YXNtUGF0aHMgPSBmbGFncy53YXNtUGF0aHM7XG4gIGNvbnN0IHdhc21QcmVmaXhPdmVycmlkZSA9IHR5cGVvZiB3YXNtUGF0aHMgPT09ICdzdHJpbmcnID8gd2FzbVBhdGhzIDogdW5kZWZpbmVkO1xuICBjb25zdCBtanNQYXRoT3ZlcnJpZGVGbGFnID0gKHdhc21QYXRocyBhcyBFbnYuV2FzbUZpbGVQYXRocyk/Lm1qcztcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlID0gKG1qc1BhdGhPdmVycmlkZUZsYWcgYXMgVVJMKT8uaHJlZiA/PyBtanNQYXRoT3ZlcnJpZGVGbGFnO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy53YXNtO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlID0gKHdhc21QYXRoT3ZlcnJpZGVGbGFnIGFzIFVSTCk/LmhyZWYgPz8gd2FzbVBhdGhPdmVycmlkZUZsYWc7XG5cbiAgY29uc3QgW29iamVjdFVybCwgb3J0V2FzbUZhY3RvcnldID0gKGF3YWl0IGltcG9ydFdhc21Nb2R1bGUobWpzUGF0aE92ZXJyaWRlLCB3YXNtUHJlZml4T3ZlcnJpZGUsIG51bVRocmVhZHMgPiAxKSk7XG5cbiAgbGV0IGlzVGltZW91dCA9IGZhbHNlO1xuXG4gIGNvbnN0IHRhc2tzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IFtdO1xuXG4gIC8vIHByb21pc2UgZm9yIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgdGFza3MucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0pKTtcbiAgfVxuXG4gIC8vIHByb21pc2UgZm9yIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICB0YXNrcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8T3J0V2FzbU1vZHVsZT4gPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBudW1iZXIgb2YgdGhyZWFkcy4gV2ViQXNzZW1ibHkgd2lsbCBjcmVhdGUgKE1vZHVsZS5udW1UaHJlYWRzIC0gMSkgd29ya2Vycy4gSWYgaXQgaXMgMSwgbm8gd29ya2VyIHdpbGwgYmVcbiAgICAgICAqIGNyZWF0ZWQuXG4gICAgICAgKi9cbiAgICAgIG51bVRocmVhZHMsXG4gICAgfTtcblxuICAgIGlmICh3YXNtUGF0aE92ZXJyaWRlIHx8IHdhc21QcmVmaXhPdmVycmlkZSkge1xuICAgICAgLyoqXG4gICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGxvY2F0ZSB0aGUgV2ViQXNzZW1ibHkgZmlsZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZS5cbiAgICAgICAqXG4gICAgICAgKiBTaW5jZSBFbXNjcmlwdGVuIDMuMS41OCwgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgdGhlIC53YXNtIGZpbGUuXG4gICAgICAgKi9cbiAgICAgIGNvbmZpZy5sb2NhdGVGaWxlID0gKGZpbGVOYW1lLCBzY3JpcHREaXJlY3RvcnkpID0+XG4gICAgICAgICAgd2FzbVBhdGhPdmVycmlkZSA/PyAod2FzbVByZWZpeE92ZXJyaWRlID8/IHNjcmlwdERpcmVjdG9yeSkgKyBmaWxlTmFtZTtcbiAgICB9XG5cbiAgICBvcnRXYXNtRmFjdG9yeShjb25maWcpLnRoZW4oXG4gICAgICAgIC8vIHdhc20gbW9kdWxlIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICBtb2R1bGUgPT4ge1xuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICB3YXNtID0gbW9kdWxlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICBpZiAob2JqZWN0VXJsKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyB3YXNtIG1vZHVsZSBmYWlsZWQgdG8gaW5pdGlhbGl6ZVxuICAgICAgICAod2hhdCkgPT4ge1xuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdCh3aGF0KTtcbiAgICAgICAgfSk7XG4gIH0pKTtcblxuICBhd2FpdCBQcm9taXNlLnJhY2UodGFza3MpO1xuXG4gIGlmIChpc1RpbWVvdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0aW1lb3V0fW1zYCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZSA9ICgpOiBPcnRXYXNtTW9kdWxlID0+IHtcbiAgaWYgKGluaXRpYWxpemVkICYmIHdhc20pIHtcbiAgICByZXR1cm4gd2FzbTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkaXNwb3NlID0gKCk6IHZvaWQgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQgJiYgIWluaXRpYWxpemluZyAmJiAhYWJvcnRlZCkge1xuICAgIC8vIFRPRE86IGN1cnJlbnRseSBcIlBUaHJlYWQudGVybWluYXRlQWxsVGhyZWFkcygpXCIgaXMgbm90IGV4cG9zZWQgaW4gdGhlIHdhc20gbW9kdWxlLlxuICAgIC8vICAgICAgIEFuZCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCB5ZXQgY2FsbGVkIGJ5IGFueSBjb2RlLlxuICAgIC8vICAgICAgIElmIGl0IGlzIG5lZWRlZCBpbiB0aGUgZnV0dXJlLCB3ZSBzaG91bGQgZXhwb3NlIGl0IGluIHRoZSB3YXNtIG1vZHVsZSBhbmQgdW5jb21tZW50IHRoZSBmb2xsb3dpbmcgbGluZS5cblxuICAgIC8vIHdhc20/LlBUaHJlYWQ/LnRlcm1pbmF0ZUFsbFRocmVhZHMoKTtcbiAgICB3YXNtID0gdW5kZWZpbmVkO1xuXG4gICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuXG5leHBvcnQgY29uc3QgYWxsb2NXYXNtU3RyaW5nID0gKGRhdGE6IHN0cmluZywgYWxsb2NzOiBudW1iZXJbXSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gIGNvbnN0IGRhdGFMZW5ndGggPSB3YXNtLmxlbmd0aEJ5dGVzVVRGOChkYXRhKSArIDE7XG4gIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLl9tYWxsb2MoZGF0YUxlbmd0aCk7XG4gIHdhc20uc3RyaW5nVG9VVEY4KGRhdGEsIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xuICBhbGxvY3MucHVzaChkYXRhT2Zmc2V0KTtcblxuICByZXR1cm4gZGF0YU9mZnNldDtcbn07XG5cbmludGVyZmFjZSBFeHRyYU9wdGlvbnNIYW5kbGVyIHtcbiAgKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBpdGVyYXRlRXh0cmFPcHRpb25zID1cbiAgICAob3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIHByZWZpeDogc3RyaW5nLCBzZWVuOiBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PixcbiAgICAgaGFuZGxlcjogRXh0cmFPcHRpb25zSGFuZGxlcik6IHZvaWQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNlZW4uaGFzKG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9ucycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW4uYWRkKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gKHByZWZpeCkgPyBwcmVmaXggKyBrZXkgOiBrZXk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyh2YWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgbmFtZSArICcuJywgc2VlbiwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGhhbmRsZXIobmFtZSwgKHZhbHVlKSA/ICcxJyA6ICcwJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4vKipcbiAqIGNoZWNrIHdlYiBhc3NlbWJseSBBUEkncyBsYXN0IGVycm9yIGFuZCB0aHJvdyBlcnJvciBpZiBhbnkgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0gbWVzc2FnZSBhIG1lc3NhZ2UgdXNlZCB3aGVuIGFuIGVycm9yIG9jY3VycmVkLlxuICovXG5leHBvcnQgY29uc3QgY2hlY2tMYXN0RXJyb3IgPSAobWVzc2FnZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJhbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoOCk7XG4gICAgd2FzbS5fT3J0R2V0TGFzdEVycm9yKHBhcmFtc09mZnNldCwgcGFyYW1zT2Zmc2V0ICsgNCk7XG4gICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5IRUFQMzJbcGFyYW1zT2Zmc2V0IC8gNF07XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlUG9pbnRlciA9IHdhc20uSEVBUFUzMltwYXJhbXNPZmZzZXQgLyA0ICsgMV07XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JNZXNzYWdlUG9pbnRlciA/IHdhc20uVVRGOFRvU3RyaW5nKGVycm9yTWVzc2FnZVBvaW50ZXIpIDogJyc7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9IEVSUk9SX0NPREU6ICR7ZXJyb3JDb2RlfSwgRVJST1JfTUVTU0FHRTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb259IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7YWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9uc30gZnJvbSAnLi93YXNtLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IHNldFJ1bk9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHJ1bk9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucz8ubG9nU2V2ZXJpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPSAyOyAgLy8gRGVmYXVsdCB0byB3YXJuaW5nXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dTZXZlcml0eUxldmVsKSB8fFxuICAgICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8IG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dTZXZlcml0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5sb2dWZXJib3NpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgIC8vIERlZmF1bHQgdG8gMFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LnRlcm1pbmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLnRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB0YWdEYXRhT2Zmc2V0ID0gMDtcbiAgICBpZiAob3B0aW9ucz8udGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhZ0RhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcob3B0aW9ucy50YWcsIGFsbG9jcyk7XG4gICAgfVxuXG4gICAgcnVuT3B0aW9uc0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZVJ1bk9wdGlvbnMoXG4gICAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsIHJ1bk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwhLCAhIXJ1bk9wdGlvbnMudGVybWluYXRlISwgdGFnRGF0YU9mZnNldCk7XG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGNyZWF0ZSBydW4gb3B0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uZXh0cmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhvcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoa2V5LCBhbGxvY3MpO1xuICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcodmFsdWUsIGFsbG9jcyk7XG5cbiAgICAgICAgaWYgKHdhc20uX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHJ1bk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtrZXl9IC0gJHt2YWx1ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbcnVuT3B0aW9uc0hhbmRsZSwgYWxsb2NzXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhydW5PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2goYWxsb2MgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHthbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yLCBpdGVyYXRlRXh0cmFPcHRpb25zfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuXG5jb25zdCBnZXRHcmFwaE9wdGltemF0aW9uTGV2ZWwgPSAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbDogc3RyaW5nfHVua25vd24pOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpIHtcbiAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICdleHRlbmRlZCc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdhbGwnOlxuICAgICAgcmV0dXJuIDk5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtncmFwaE9wdGltaXphdGlvbkxldmVsfWApO1xuICB9XG59O1xuXG5jb25zdCBnZXRFeGVjdXRpb25Nb2RlID0gKGV4ZWN1dGlvbk1vZGU6ICdzZXF1ZW50aWFsJ3wncGFyYWxsZWwnKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChleGVjdXRpb25Nb2RlKSB7XG4gICAgY2FzZSAnc2VxdWVudGlhbCc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdwYXJhbGxlbCc6XG4gICAgICByZXR1cm4gMTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtleGVjdXRpb25Nb2RlfWApO1xuICB9XG59O1xuXG5jb25zdCBhcHBlbmREZWZhdWx0T3B0aW9ucyA9IChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogdm9pZCA9PiB7XG4gIGlmICghb3B0aW9ucy5leHRyYSkge1xuICAgIG9wdGlvbnMuZXh0cmEgPSB7fTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuZXh0cmEuc2Vzc2lvbikge1xuICAgIG9wdGlvbnMuZXh0cmEuc2Vzc2lvbiA9IHt9O1xuICB9XG4gIGNvbnN0IHNlc3Npb24gPSBvcHRpb25zLmV4dHJhLnNlc3Npb24gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgaWYgKCFzZXNzaW9uLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgc2Vzc2lvbi51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5ID0gJzEnO1xuICB9XG5cbiAgLy8gaWYgdXNpbmcgSlNFUCB3aXRoIFdlYkdQVSwgYWx3YXlzIGRpc2FibGUgbWVtb3J5IHBhdHRlcm5cbiAgaWYgKG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzICYmXG4gICAgICBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKGVwID0+ICh0eXBlb2YgZXAgPT09ICdzdHJpbmcnID8gZXAgOiBlcC5uYW1lKSA9PT0gJ3dlYmdwdScpKSB7XG4gICAgb3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuID0gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IHNldEV4ZWN1dGlvblByb3ZpZGVycyA9XG4gICAgKHNlc3Npb25PcHRpb25zSGFuZGxlOiBudW1iZXIsIGV4ZWN1dGlvblByb3ZpZGVyczogcmVhZG9ubHkgSW5mZXJlbmNlU2Vzc2lvbi5FeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdLFxuICAgICBhbGxvY3M6IG51bWJlcltdKTogdm9pZCA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVwIG9mIGV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgICAgICBsZXQgZXBOYW1lID0gdHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZTtcblxuICAgICAgICAvLyBjaGVjayBFUCBuYW1lXG4gICAgICAgIHN3aXRjaCAoZXBOYW1lKSB7XG4gICAgICAgICAgY2FzZSAnd2Vibm4nOlxuICAgICAgICAgICAgZXBOYW1lID0gJ1dFQk5OJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdlYm5uT3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICAgICAgICAgICAgLy8gY29uc3QgY29udGV4dCA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0KT8uY29udGV4dDtcbiAgICAgICAgICAgICAgY29uc3QgZGV2aWNlVHlwZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8uZGV2aWNlVHlwZTtcbiAgICAgICAgICAgICAgaWYgKGRldmljZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdkZXZpY2VUeXBlJywgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZGV2aWNlVHlwZSwgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PVxuICAgICAgICAgICAgICAgICAgICAwKSB7XG4gICAgICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdkZXZpY2VUeXBlJyAtICR7ZGV2aWNlVHlwZX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd3ZWJncHUnOlxuICAgICAgICAgICAgZXBOYW1lID0gJ0pTJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdlYmdwdU9wdGlvbnMgPSBlcCBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucz8ucHJlZmVycmVkTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0ICE9PSAnTkNIVycgJiYgd2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOSFdDJykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHt3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygncHJlZmVycmVkTGF5b3V0JywgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT1cbiAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncHJlZmVycmVkTGF5b3V0JyAtICR7d2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXR9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnd2FzbSc6XG4gICAgICAgICAgY2FzZSAnY3B1JzpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke2VwTmFtZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVwTmFtZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZXBOYW1lLCBhbGxvY3MpO1xuICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGVwTmFtZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbmV4cG9ydCBjb25zdCBzZXRTZXNzaW9uT3B0aW9ucyA9IChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFtudW1iZXIsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICBjb25zdCBhbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3Qgc2Vzc2lvbk9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBhcHBlbmREZWZhdWx0T3B0aW9ucyhzZXNzaW9uT3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBncmFwaE9wdGltaXphdGlvbkxldmVsID0gZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsKHNlc3Npb25PcHRpb25zLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPz8gJ2FsbCcpO1xuICAgIGNvbnN0IGV4ZWN1dGlvbk1vZGUgPSBnZXRFeGVjdXRpb25Nb2RlKHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvbk1vZGUgPz8gJ3NlcXVlbnRpYWwnKTtcbiAgICBjb25zdCBsb2dJZERhdGFPZmZzZXQgPVxuICAgICAgICB0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMubG9nSWQgPT09ICdzdHJpbmcnID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLmxvZ0lkLCBhbGxvY3MpIDogMDtcblxuICAgIGNvbnN0IGxvZ1NldmVyaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID8/IDI7ICAvLyBEZWZhdWx0IHRvIDIgLSB3YXJuaW5nXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1NldmVyaXR5TGV2ZWwpIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nVmVyYm9zaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCA/PyAwOyAgLy8gRGVmYXVsdCB0byAwIC0gdmVyYm9zZVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsb2dWZXJib3NpdHlMZXZlbCkgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPCAwIHx8IGxvZ1ZlcmJvc2l0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoT2Zmc2V0ID0gdHlwZW9mIHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGggPT09ICdzdHJpbmcnID9cbiAgICAgICAgYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsIGFsbG9jcykgOlxuICAgICAgICAwO1xuXG4gICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhcbiAgICAgICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCwgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVDcHVNZW1BcmVuYSwgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuLCBleGVjdXRpb25Nb2RlLFxuICAgICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZVByb2ZpbGluZywgMCwgbG9nSWREYXRhT2Zmc2V0LCBsb2dTZXZlcml0eUxldmVsLCBsb2dWZXJib3NpdHlMZXZlbCxcbiAgICAgICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCk7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLicpO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMpIHtcbiAgICAgIHNldEV4ZWN1dGlvblByb3ZpZGVycyhzZXNzaW9uT3B0aW9uc0hhbmRsZSwgc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLCBhbGxvY3MpO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVuYWJsZUdyYXBoQ2FwdHVyZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZTogJHtzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdlbmFibGVHcmFwaENhcHR1cmUnLCBhbGxvY3MpO1xuICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZS50b1N0cmluZygpLCBhbGxvY3MpO1xuICAgICAgaWYgKHdhc20uX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcbiAgICAgICAgICAgIGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2VuYWJsZUdyYXBoQ2FwdHVyZScgLSAke3Nlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZX0uYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSBuYW1lIG11c3QgYmUgYSBzdHJpbmc6ICR7bmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhuYW1lLCBhbGxvY3MpO1xuICAgICAgICBpZiAod2FzbS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKHNlc3Npb25PcHRpb25zSGFuZGxlLCBuYW1lT2Zmc2V0LCB2YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7bmFtZX0gLSAke3ZhbHVlfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5leHRyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHNlc3Npb25PcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoa2V5LCBhbGxvY3MpO1xuICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcodmFsdWUsIGFsbG9jcyk7XG5cbiAgICAgICAgaWYgKHdhc20uX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHtrZXl9IC0gJHt2YWx1ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKGFsbG9jID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuLy8gYSBkdW1teSB0eXBlIGRlY2xhcmF0aW9uIGZvciBGbG9hdDE2QXJyYXkgaW4gY2FzZSBhbnkgcG9seWZpbGwgaXMgYXZhaWxhYmxlLlxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IEZsb2F0MTZBcnJheTogYW55O1xufVxuXG4vLyBUaGlzIGZpbGUgaW5jbHVkZXMgY29tbW9uIGRlZmluaXRpb25zLiBUaGV5IGRvIE5PVCBoYXZlIGRlcGVuZGVuY3kgb24gdGhlIFdlYkFzc2VtYmx5IGluc3RhbmNlLlxuXG4vKipcbiAqIENvcGllZCBmcm9tIE9OTlggZGVmaW5pdGlvbi4gVXNlIHRoaXMgdG8gZHJvcCBkZXBlbmRlbmN5ICdvbm54X3Byb3RvJyB0byBkZWNyZWFzZSBjb21waWxlZCAuanMgZmlsZSBzaXplLlxuICovXG5leHBvcnQgY29uc3QgZW51bSBEYXRhVHlwZSB7XG4gIHVuZGVmaW5lZCA9IDAsXG4gIGZsb2F0ID0gMSxcbiAgdWludDggPSAyLFxuICBpbnQ4ID0gMyxcbiAgdWludDE2ID0gNCxcbiAgaW50MTYgPSA1LFxuICBpbnQzMiA9IDYsXG4gIGludDY0ID0gNyxcbiAgc3RyaW5nID0gOCxcbiAgYm9vbCA9IDksXG4gIGZsb2F0MTYgPSAxMCxcbiAgZG91YmxlID0gMTEsXG4gIHVpbnQzMiA9IDEyLFxuICB1aW50NjQgPSAxMyxcbiAgY29tcGxleDY0ID0gMTQsXG4gIGNvbXBsZXgxMjggPSAxNSxcbiAgYmZsb2F0MTYgPSAxNlxufVxuXG4vKipcbiAqIE1hcCBzdHJpbmcgdGVuc29yIGRhdGEgdG8gZW51bSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0gPSAodHlwZTogc3RyaW5nKTogRGF0YVR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ4O1xuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50ODtcbiAgICBjYXNlICdib29sJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5ib29sO1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQxNjtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQxNjtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50MzI7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50MzI7XG4gICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQxNjtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5mbG9hdDtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5kb3VibGU7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5zdHJpbmc7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDY0O1xuICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDY0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGVudW0gdmFsdWUgdG8gc3RyaW5nIHRlbnNvciBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyA9ICh0eXBlUHJvdG86IERhdGFUeXBlKTogVGVuc29yLlR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGVQcm90bykge1xuICAgIGNhc2UgRGF0YVR5cGUuaW50ODpcbiAgICAgIHJldHVybiAnaW50OCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50ODpcbiAgICAgIHJldHVybiAndWludDgnO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQxNjpcbiAgICAgIHJldHVybiAnaW50MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDE2OlxuICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XG4gICAgICByZXR1cm4gJ2ludDMyJztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQzMjpcbiAgICAgIHJldHVybiAndWludDMyJztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICByZXR1cm4gJ2Zsb2F0MTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuZG91YmxlOlxuICAgICAgcmV0dXJuICdmbG9hdDY0JztcbiAgICBjYXNlIERhdGFUeXBlLnN0cmluZzpcbiAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxuICAgICAgcmV0dXJuICdpbnQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NjQ6XG4gICAgICByZXR1cm4gJ3VpbnQ2NCc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZVByb3RvfWApO1xuICB9XG59O1xuXG4vKipcbiAqIGdldCB0ZW5zb3IgZWxlbWVudCBzaXplIGluIGJ5dGVzIGJ5IHRoZSBnaXZlbiBkYXRhIHR5cGVcbiAqIEByZXR1cm5zIHNpemUgaW4gaW50ZWdlciBvciB1bmRlZmluZWQgaWYgdGhlIGRhdGEgdHlwZSBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUZW5zb3JFbGVtZW50U2l6ZSA9IChkYXRlVHlwZTogbnVtYmVyKTogbnVtYmVyfFxuICAgIHVuZGVmaW5lZCA9PiBbdW5kZWZpbmVkLCA0LCAxLCAxLCAyLCAyLCA0LCA4LCB1bmRlZmluZWQsIDEsIDIsIDgsIDQsIDgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdW2RhdGVUeXBlXTtcblxuLyoqXG4gKiBnZXQgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IgYnkgdGhlIGdpdmVuIHRlbnNvciB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IgPSAodHlwZTogVGVuc29yLlR5cGUpOiBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvcnxVaW50OEFycmF5Q29uc3RydWN0b3J8XG4gICAgSW50OEFycmF5Q29uc3RydWN0b3J8VWludDE2QXJyYXlDb25zdHJ1Y3RvcnxJbnQxNkFycmF5Q29uc3RydWN0b3J8SW50MzJBcnJheUNvbnN0cnVjdG9yfEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvcnxcbiAgICBVaW50OEFycmF5Q29uc3RydWN0b3J8RmxvYXQ2NEFycmF5Q29uc3RydWN0b3J8VWludDMyQXJyYXlDb25zdHJ1Y3RvcnxCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yID0+IHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdmbG9hdDE2JzpcbiAgICAgICAgICAvLyBhbGxvdyBGbG9hdDE2QXJyYXkgcG9seWZpbGwuXG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tID8gRmxvYXQxNkFycmF5IDogVWludDE2QXJyYXk7XG4gICAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gICAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgICAgcmV0dXJuIEludDhBcnJheTtcbiAgICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gICAgICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgICAgICByZXR1cm4gQmlnSW50NjRBcnJheTtcbiAgICAgICAgY2FzZSAndWludDY0JzpcbiAgICAgICAgICByZXR1cm4gQmlnVWludDY0QXJyYXk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfTtcblxuLyoqXG4gKiBNYXAgc3RyaW5nIGxvZyBsZXZlbCB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dMZXZlbFN0cmluZ1RvRW51bSA9IChsb2dMZXZlbD86ICd2ZXJib3NlJ3wnaW5mbyd8J3dhcm5pbmcnfCdlcnJvcid8J2ZhdGFsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAobG9nTGV2ZWwpIHtcbiAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2luZm8nOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnd2FybmluZyc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlICdmYXRhbCc6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2xvZ0xldmVsfWApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRlbnNvciB0eXBlIGlzIHN1cHBvcnRlZCBieSBHUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUgPSAodHlwZTogVGVuc29yLlR5cGUpOiB0eXBlIGlzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXMgPT4gdHlwZSA9PT0gJ2Zsb2F0MzInIHx8XG4gICAgdHlwZSA9PT0gJ2Zsb2F0MTYnIHx8IHR5cGUgPT09ICdpbnQzMicgfHwgdHlwZSA9PT0gJ2ludDY0JyB8fCB0eXBlID09PSAndWludDMyJyB8fCB0eXBlID09PSAndWludDgnIHx8XG4gICAgdHlwZSA9PT0gJ2Jvb2wnO1xuXG4vKipcbiAqIE1hcCBzdHJpbmcgZGF0YSBsb2NhdGlvbiB0byBpbnRlZ2VyIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0gPSAobG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb24pOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGxvY2F0aW9uKSB7XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsb2NhdGlvbjogJHtsb2NhdGlvbn1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgaW50ZWdlciBkYXRhIGxvY2F0aW9uIHRvIHN0cmluZyB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZGF0YUxvY2F0aW9uRW51bVRvU3RyaW5nID0gKGxvY2F0aW9uOiBudW1iZXIpOiBUZW5zb3IuRGF0YUxvY2F0aW9ufHVuZGVmaW5lZCA9PlxuICAgIChbJ25vbmUnLCAnY3B1JywgJ2NwdS1waW5uZWQnLCAndGV4dHVyZScsICdncHUtYnVmZmVyJ10gYXMgY29uc3QpW2xvY2F0aW9uXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtpc05vZGV9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xuXG4vKipcbiAqIExvYWQgYSBmaWxlIGludG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBmaWxlIC0gdGhlIGZpbGUgdG8gbG9hZC4gQ2FuIGJlIGEgVVJML3BhdGgsIGEgQmxvYiwgYW4gQXJyYXlCdWZmZXIsIG9yIGEgVWludDhBcnJheS5cbiAqIEByZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBmaWxlIGRhdGEuXG4gKi9cbmV4cG9ydCBjb25zdCBsb2FkRmlsZSA9IGFzeW5jKGZpbGU6IHN0cmluZ3xCbG9ifEFycmF5QnVmZmVyTGlrZXxVaW50OEFycmF5KTogUHJvbWlzZTxVaW50OEFycmF5PiA9PiB7XG4gIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBOb2RlLmpzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7cmVhZEZpbGV9ID0gcmVxdWlyZSgnbm9kZTpmcy9wcm9taXNlcycpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVhZEZpbGUoZmlsZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlID09PSAnRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFJykge1xuICAgICAgICAgIC8vIGZpbGUgaXMgdG9vIGxhcmdlLCB1c2UgZnMuY3JlYXRlUmVhZFN0cmVhbSBpbnN0ZWFkXG4gICAgICAgICAgY29uc3Qge2NyZWF0ZVJlYWRTdHJlYW19ID0gcmVxdWlyZSgnbm9kZTpmcycpO1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNyZWF0ZVJlYWRTdHJlYW0oZmlsZSk7XG4gICAgICAgICAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBicm93c2Vyc1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZmlsZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgICAgIGNvbnN0IGZpbGVTaXplID0gY29udGVudExlbmd0aEhlYWRlciA/IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZWFkZXIsIDEwKSA6IDA7XG4gICAgICBpZiAoZmlsZVNpemUgPCAxMDczNzQxODI0IC8qIDFHQiAqLykge1xuICAgICAgICAvLyB3aGVuIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBpcyBub3Qgc2V0LCB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBmaWxlIHNpemUuIFdlIGFzc3VtZSBpdCBpcyBzbWFsbCBlbm91Z2ggdG9cbiAgICAgICAgLy8gbG9hZCBpbnRvIG1lbW9yeS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBzdHJlYW0gaW5zdGVhZFxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtmaWxlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihmaWxlU2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHVzZSBXZWJBc3NlbWJseSBNZW1vcnkgdG8gYWxsb2NhdGUgbGFyZ2VyIEFycmF5QnVmZmVyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIDY1NTM2KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6IHBhZ2VzLCBtYXhpbXVtOiBwYWdlc30pLmJ1ZmZlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBjaHVua1NpemUpO1xuICAgICAgICAgIGNodW5rLnNldCh2YWx1ZSk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCBmaWxlU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpKTtcbiAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShmaWxlKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7bG9nTGV2ZWxTdHJpbmdUb0VudW19IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxudHlwZSBMb2dMZXZlbCA9IE5vbk51bGxhYmxlPEVudlsnbG9nTGV2ZWwnXT47XG50eXBlIE1lc3NhZ2VTdHJpbmcgPSBzdHJpbmc7XG50eXBlIE1lc3NhZ2VGdW5jdGlvbiA9ICgpID0+IHN0cmluZztcbnR5cGUgTWVzc2FnZSA9IE1lc3NhZ2VTdHJpbmd8TWVzc2FnZUZ1bmN0aW9uO1xuXG5jb25zdCBsb2dMZXZlbFByZWZpeCA9IFsnVicsICdJJywgJ1cnLCAnRScsICdGJ107XG5cbmNvbnN0IGRvTG9nID0gKGxldmVsOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmxvZyhgWyR7bG9nTGV2ZWxQcmVmaXhbbGV2ZWxdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHttZXNzYWdlfWApO1xufTtcblxubGV0IGNvbmZpZ0xvZ0xldmVsOiBMb2dMZXZlbHx1bmRlZmluZWQ7XG5sZXQgZGVidWc6IGJvb2xlYW58dW5kZWZpbmVkO1xuXG5leHBvcnQgY29uc3QgY29uZmlndXJlTG9nZ2VyID0gKCRjb25maWdMb2dMZXZlbDogTG9nTGV2ZWwsICRkZWJ1ZzogYm9vbGVhbik6IHZvaWQgPT4ge1xuICBjb25maWdMb2dMZXZlbCA9ICRjb25maWdMb2dMZXZlbDtcbiAgZGVidWcgPSAkZGVidWc7XG59O1xuXG4vKipcbiAqIEEgc2ltcGxlIGxvZ2dpbmcgdXRpbGl0eSB0byBsb2cgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBjb25zdCBMT0cgPSAobG9nTGV2ZWw6IExvZ0xldmVsLCBtc2c6IE1lc3NhZ2UpOiB2b2lkID0+IHtcbiAgY29uc3QgbWVzc2FnZUxldmVsID0gbG9nTGV2ZWxTdHJpbmdUb0VudW0obG9nTGV2ZWwpO1xuICBjb25zdCBjb25maWdMZXZlbCA9IGxvZ0xldmVsU3RyaW5nVG9FbnVtKGNvbmZpZ0xvZ0xldmVsKTtcbiAgaWYgKG1lc3NhZ2VMZXZlbCA+PSBjb25maWdMZXZlbCkge1xuICAgIGRvTG9nKG1lc3NhZ2VMZXZlbCwgdHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJyA/IG1zZygpIDogbXNnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIHNpbXBsZSBsb2dnaW5nIHV0aWxpdHkgdG8gbG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLiBPbmx5IGxvZ3Mgd2hlbiBkZWJ1ZyBpcyBlbmFibGVkLlxuICovXG5leHBvcnQgY29uc3QgTE9HX0RFQlVHOiB0eXBlb2YgTE9HID0gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIExPRz4pID0+IHtcbiAgaWYgKGRlYnVnKSB7XG4gICAgTE9HKC4uLmFyZ3MpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHt0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3J9IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoZGF0YUJ1ZmZlcjogQXJyYXlCdWZmZXIsIHR5cGU6IFRlbnNvci5UeXBlKTogSW50MzJBcnJheXxVaW50MzJBcnJheXxCaWdJbnQ2NEFycmF5fFxuICAgIEJpZ1VpbnQ2NEFycmF5fFVpbnQ4QXJyYXl8RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheXxJbnQ4QXJyYXl8SW50MTZBcnJheXxVaW50MTZBcnJheSA9PlxuICAgICAgICBuZXcgKHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlKSkoZGF0YUJ1ZmZlcik7XG5cbi8qKlxuICogYSBUZW5zb3JWaWV3IGRvZXMgbm90IG93biB0aGUgZGF0YS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JWaWV3IHtcbiAgcmVhZG9ubHkgZGF0YTogbnVtYmVyO1xuICByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyO1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcblxuICAvKipcbiAgICogZ2V0IGEgRmxvYXQzMkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0RmxvYXQzMkFycmF5KCk6IEZsb2F0MzJBcnJheTtcblxuICAvKipcbiAgICogZ2V0IGEgQmlnSW50NjRBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldEJpZ0ludDY0QXJyYXkoKTogQmlnSW50NjRBcnJheTtcblxuICAvKipcbiAgICogZ2V0IGEgSW50MzJBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldEludDMyQXJyYXkoKTogSW50MzJBcnJheTtcblxuICAvKipcbiAgICogY3JlYXRlIGEgbmV3IHRlbnNvciB2aWV3IHdpdGggdGhlIHNhbWUgZGF0YSBidXQgZGlmZmVyZW50IGRpbWVuc2lvbnMuXG4gICAqL1xuICByZXNoYXBlKG5ld0RpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldztcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi90ZW5zb3Itdmlldyc7XG5cbmltcG9ydCB7U2hhZGVySGVscGVyfSBmcm9tICcuL29wcy9jb21tb24nO1xuXG5leHBvcnQgdHlwZSBTZXNzaW9uU3RhdGUgPSAnZGVmYXVsdCd8J2NhcHR1cmluZyd8J3JlcGxheWluZyc7XG5cbmV4cG9ydCBlbnVtIEdwdURhdGFUeXBlIHtcbiAgZGVmYXVsdCA9IDAsXG4gIHVwbG9hZCA9IDEsXG4gIHByb2ZpbGUgPSAyXG59XG5leHBvcnQgdHlwZSBHcHVEYXRhSWQgPSBudW1iZXI7XG5cbmV4cG9ydCB0eXBlIEdwdUFyY2hpdGVjdHVyZSA9ICdhbXBlcmUnO1xuZXhwb3J0IHR5cGUgR3B1VmVuZG9yID0gJ2FtZCd8J2ludGVsJ3wnbnZpZGlhJztcbmV4cG9ydCBpbnRlcmZhY2UgQWRhcHRlckluZm8ge1xuICBpc0FyY2hpdGVjdHVyZTogKGFyY2hpdGVjdHVyZTogR3B1QXJjaGl0ZWN0dXJlKSA9PiBib29sZWFuO1xuICBpc1ZlbmRvcjogKHZlbmRvcjogR3B1VmVuZG9yKSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdwdURhdGEge1xuICB0eXBlOiBHcHVEYXRhVHlwZTtcbiAgaWQ6IEdwdURhdGFJZDtcbiAgYnVmZmVyOiBHUFVCdWZmZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29ySW5mbyB7XG4gIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICBkYXRhVHlwZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1Vbmlmb3JtIHtcbiAgdHlwZTogRGF0YVR5cGU7XG4gIGRhdGE6IG51bWJlcnxyZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm8gPSBbdHlwZTogRGF0YVR5cGUsIGxlbmd0aDogbnVtYmVyXTtcblxuLyoqXG4gKiBSZXByZXNlbnQgdGhlIGRlcGVuZGVuY3kgb2YgYSBwcm9ncmFtIG9uIGEgc3BlY2lmaWMgaW5wdXQgdGVuc29yLlxuICpcbiAqIC0gJ25vbmUnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZG9lcyBub3QgZGVwZW5kIG9uIHRoaXMgaW5wdXQncyBpbmZvXG4gKiAtICd0eXBlJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ3JhbmsnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgYW5kIHRoZSByYW5rIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ2RpbXMnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgYW5kIHRoZSBkaW1zIG9mIHRoaXMgaW5wdXRcbiAqIC0gJ2RhdGEnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUsIHRoZSBkaW1zIGFuZCB0aGUgZGF0YSBvZiB0aGlzIGlucHV0XG4gKi9cbmV4cG9ydCB0eXBlIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5ID0gJ25vbmUnfCd0eXBlJ3wncmFuayd8J2RpbXMnfCdkYXRhJztcblxuLyoqXG4gKiBSZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBwcm9ncmFtJ3MgY2FjaGUgZm9yIHNoYWRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvIHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIHN0cmluZyBhcyBhIGNhY2hlIGhpbnQgaW4gdGhlIGFydGlmYWN0IGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgaW5pdGlhbGl6aW5nLXRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIGF0dHJpYnV0ZXMgb3IgYW55IGluZm9ybWF0aW9uIG9mXG4gICAqIGluaXRpYWxpemVycy4gSXQgc2hvdWxkIE5PVCBjb250YWluIGFueSBydW50aW1lIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBzaGFwZSBvZiBpbnB1dHMuXG4gICAqL1xuICBoaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBsaXN0IG9mIGRlcGVuZGVuY2llcyBvZiB0aGUgcHJvZ3JhbSBvbiB0aGUgaW5wdXQgdGVuc29ycy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvZ3JhbSBkZXBlbmRzXG4gICAqIG9uICdkaW1zJyBvZiBhbGwgaW5wdXRzLlxuICAgKi9cbiAgaW5wdXREZXBlbmRlbmNpZXM/OiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIHByb2dyYW0ncyBjYWNoZSBmb3IgdW5pZm9ybS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtVW5pZm9ybUNhY2hlSW5mbyB7XG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBzdHJpbmcgYXMgYSBjYWNoZSBoaW50IGluIHRoZSB1bmlmb3JtIGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgcnVudGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgc2hhcGUgb2YgaW5wdXRzLlxuICAgKi9cbiAgaGludD86IHN0cmluZztcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgbGlzdCBvZiBkZXBlbmRlbmNpZXMgb2YgdGhlIHByb2dyYW0gb24gdGhlIGlucHV0IHRlbnNvcnMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIHByb2dyYW0gZGVwZW5kc1xuICAgKiBvbiAnbm9uZScgb2YgYWxsIGlucHV0cy5cbiAgICovXG4gIGlucHV0RGVwZW5kZW5jaWVzPzogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXTtcbn1cblxuXG4vKipcbiAqIEEgc2V0IG9mIGRhdGEgdGhhdCByZXByZXNlbnQgYSBzaGFkZXIgcHJvZ3JhbVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1JbmZvIHtcbiAgLyoqXG4gICAqIHRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtLiB1c2VkIGZvciBkZWJ1Z2dpbmcgYW5kIHByb2ZpbGluZ1xuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBvYmplY3QgZGVzY3JpYmluZyB0aGUgY2FjaGUgaW5mb3JtYXRpb24gb2YgdGhlIHByb2dyYW0gc2hhZGVyLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBoaW50IGlzIGVtcHR5IGFuZCBpbnB1dERlcGVuZGVuY2llcyBhcmUgWydkaW1zJ10gZm9yIGFsbCBpbnB1dHMuXG4gICAqL1xuICBzaGFkZXJDYWNoZT86IFByb2dyYW1TaGFkZXJDYWNoZUluZm87XG5cbiAgLyoqXG4gICAqIHRoZSBzaGFkZXIncyBwcm9jZXNzaW5nIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gc2hhZGVyIGNhY2hlIG1pc3NlZC5cbiAgICovXG4gIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gZ2V0IHJ1biBkYXRhIHJlcXVpcmVkIHRvIHJ1biB0aGUgcHJvZ3JhbS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBwcm9ncmFtIGlzIGV4ZWN1dGVkLiBTaG91bGQga2VlcCB0aGlzIGZ1bmN0aW9uIGFzIHNpbXBsZSBhcyBwb3NzaWJsZS5cbiAgICovXG4gIGdldFJ1bkRhdGE6IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSkgPT4ge1xuICAgIG91dHB1dHM6IHJlYWRvbmx5IFRlbnNvckluZm9bXTtcbiAgICBkaXNwYXRjaEdyb3VwOiB7eDogbnVtYmVyOyB5PzogbnVtYmVyOyB6PzogbnVtYmVyfTtcbiAgICBwcm9ncmFtVW5pZm9ybXM/OiByZWFkb25seSBQcm9ncmFtVW5pZm9ybVtdO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0IHtcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvO1xuICBjb21wdXRlUGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcbiAgdW5pZm9ybVZhcmlhYmxlc0luZm86IHJlYWRvbmx5IFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvW118dW5kZWZpbmVkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcge1xuICAvKipcbiAgICogc3BlY2lmeSB0aGUgbWFwcGluZyB0byB0aGUgcHJvZ3JhbSdzIGlucHV0cy4gdGhlIHZhbHVlIGNhbiBiZSBhIG51bWJlciBvciBhIHRlbnNvciB2aWV3LlxuICAgKiAtIGlmIGl0J3MgYSBudW1iZXIsIGl0J3MgdGhlIGluZGV4IG9mIHRoZSBrZXJuZWwncyBpbnB1dFxuICAgKiAtIGlmIGl0J3MgYSB0ZW5zb3IgdmlldywgaXQncyBhbiBleGlzdGluZyB0ZW5zb3IgdmlldyB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5wdXRcbiAgICpcbiAgICogaWYgaW5wdXRzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtYXBwaW5nIHdpbGwgYmUgdGhlIGtlcm5lbCdzIGlucHV0cyBpbiBvcmRlci5cbiAgICovXG4gIHJlYWRvbmx5IGlucHV0cz86IFJlYWRvbmx5QXJyYXk8VGVuc29yVmlld3xudW1iZXI+O1xuICAvKipcbiAgICogc3BlY2lmeSB0aGUgbWFwcGluZyB0byB0aGUgcHJvZ3JhbSdzIG91dHB1dHMuIHRoZSB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLlxuICAgKiAtIGlmIGl0J3MgYSBub24tbmVnYXRpdmUgbnVtYmVyLCBpdCdzIHRoZSBpbmRleCBvZiB0aGUga2VybmVsJ3Mgb3V0cHV0XG4gICAqIC0gaWYgaXQncyAtMSwgaXQncyBhbiBvdXRwdXQgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgYXMgYSB0ZW1wb3JhcnkgdmFsdWUuIHRoaXMgdmFsdWUgd2lsbCBiZSByZWxlYXNlZCBhZnRlclxuICAgKiB0aGUga2VybmVsIGlzIGV4ZWN1dGVkLlxuICAgKiAtIGlmIGl0J3MgLTIsIGl0J3MgYW4gb3V0cHV0IHRoYXQgd2lsbCBiZSBjcmVhdGVkIGFzIGEgcGVyc2lzdGVudCB2YWx1ZS4gdGhpcyB2YWx1ZSB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdGhlXG4gICAqIGtlcm5lbCBpcyByZWxlYXNlZC5cbiAgICpcbiAgICogaWYgb3V0cHV0cyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbWFwcGluZyB3aWxsIGJlIHRoZSBrZXJuZWwncyBvdXRwdXRzIGluIG9yZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0cz86IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG4vKipcbiAqIEEgQ29tcHV0ZUNvbnRleHQgaW5zdGFuY2UgY2FycmllcyB0aGUgc3RhdGVzIHRoYXQgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJ1bm5pbmcgb2YgYSBrZXJuZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZUNvbnRleHQge1xuICAvKipcbiAgICogZ3B1IGFkYXB0ZXIgaW5mb1xuICAgKi9cbiAgcmVhZG9ubHkgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHBvaW50ZXIgdG8gT3BLZXJuZWxDb250ZXh0XG4gICAqL1xuICByZWFkb25seSBvcEtlcm5lbENvbnRleHQ6IG51bWJlcjtcblxuICAvKipcbiAgICogYSBsaXN0IG9mIGlucHV0cywgZWFjaCBpbnB1dCBpcyBhbiBpbnN0YW5jZSBvZiBUZW5zb3JWaWV3XG4gICAqL1xuICByZWFkb25seSBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcblxuICAvKipcbiAgICogYSBjdXN0b20gZGF0YSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhbnkgZGF0YSB0aGF0IGlzIG5lZWRlZCBieSB0aGUga2VybmVsXG4gICAqL1xuICByZWFkb25seSBrZXJuZWxDdXN0b21EYXRhOiB7W2tleTogc3RyaW5nXTogdW5rbm93bn07XG5cbiAgLyoqXG4gICAqIGEgYnVmZmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWNjZXNzIGN1c3RvbSBkYXRhIGNyZWF0ZWQgZWFjaCB0aW1lIHRoZSBrZXJuZWwgaXMgZXhlY3V0ZWRcbiAgICovXG4gIHJlYWRvbmx5IGN1c3RvbURhdGFCdWZmZXI6IFVpbnQ4QXJyYXk7XG5cbiAgLyoqXG4gICAqIGEgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoZSBub2RlXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xuXG4gIGNvbXB1dGUocHJvZ3JhbTogUHJvZ3JhbUluZm8sIGlucHV0c091dHB1dHNNYXBwaW5nPzogQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyk6IFRlbnNvclZpZXdbXTtcbiAgb3V0cHV0KGluZGV4OiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyO1xuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU2l6ZXMoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZXNpemUoKTogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBUaW1lc3RhbXBRdWVyeSA9ICdub25lJ3wnaW5zaWRlLXBhc3Nlcyd8J2F0LXBhc3Nlcyc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7V2ViR3B1QmFja2VuZH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xuaW1wb3J0IHtMT0dfREVCVUd9IGZyb20gJy4uL2xvZyc7XG5cbmltcG9ydCB7R3B1RGF0YSwgR3B1RGF0YUlkLCBHcHVEYXRhVHlwZX0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogbWFuYWdlcyBHcHVEYXRhSWQgLT4gR3B1QnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3B1RGF0YU1hbmFnZXIge1xuICAvKipcbiAgICogY29weSBkYXRhIGZyb20gQ1BVIHRvIEdQVS5cbiAgICovXG4gIHVwbG9hZChpZDogR3B1RGF0YUlkLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZDtcbiAgLyoqXG4gICAqIGNvcHkgZGF0YSBmcm9tIEdQVSB0byBHUFUuXG4gICAqL1xuICBtZW1jcHkoc291cmNlSWQ6IEdwdURhdGFJZCwgZGVzdGluYXRpb25JZDogR3B1RGF0YUlkKTogdm9pZDtcbiAgLyoqXG4gICAqIGNyZWF0ZSBuZXcgZGF0YSBvbiBHUFUuXG4gICAqL1xuICBjcmVhdGUoc2l6ZTogbnVtYmVyLCB1c2FnZT86IG51bWJlcik6IEdwdURhdGE7XG4gIC8qKlxuICAgKiBnZXQgR1BVIGRhdGEgYnkgSUQuXG4gICAqL1xuICBnZXQoaWQ6IEdwdURhdGFJZCk6IEdwdURhdGF8dW5kZWZpbmVkO1xuICAvKipcbiAgICogcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUgYnkgSUQuXG4gICAqXG4gICAqIEByZXR1cm4gc2l6ZSBvZiB0aGUgZGF0YSByZWxlYXNlZFxuICAgKi9cbiAgcmVsZWFzZShpZDogR3B1RGF0YUlkKTogbnVtYmVyO1xuICAvKipcbiAgICogY29weSBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIGRvd25sb2FkKGlkOiBHcHVEYXRhSWQsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIHJlZnJlc2ggdGhlIGJ1ZmZlcnMgdGhhdCBtYXJrZWQgZm9yIHJlbGVhc2UuXG4gICAqXG4gICAqIHdoZW4gcmVsZWFzZSgpIGlzIGNhbGxlZCwgdGhlIGJ1ZmZlciBpcyBub3QgcmVsZWFzZWQgaW1tZWRpYXRlbHkuIHRoaXMgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjb21tYW5kc1xuICAgKiB0byBiZSBzdWJtaXR0ZWQgdG8gdGhlIEdQVS4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbW1hbmRzIGFyZSBzdWJtaXR0ZWQgc28gdGhhdCB0aGUgYnVmZmVycyBjYW4gYmVcbiAgICogYWN0dWFsbHkgcmVsZWFzZWQuXG4gICAqL1xuICByZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKTogdm9pZDtcblxuICAvKipcbiAgICogcmVnaXN0ZXIgYW4gZXh0ZXJuYWwgYnVmZmVyIGZvciBJTyBCaW5kaW5nLiBJZiB0aGUgYnVmZmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCwgcmV0dXJuIHRoZSBleGlzdGluZyBHUFUgZGF0YSBJRC5cbiAgICpcbiAgICogR1BVIGRhdGEgbWFuYWdlciBvbmx5IG1hbmFnZXMgYSBtYXBwaW5nIGJldHdlZW4gdGhlIGJ1ZmZlciBhbmQgdGhlIEdQVSBkYXRhIElELiBJdCB3aWxsIG5vdCBtYW5hZ2UgdGhlIGxpZmVjeWNsZSBvZlxuICAgKiB0aGUgZXh0ZXJuYWwgYnVmZmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlciwgb3JpZ2luYWxTaXplOiBudW1iZXIsIHByZXZpb3VzQnVmZmVyPzogR1BVQnVmZmVyKTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB1bnJlZ2lzdGVyIGFuIGV4dGVybmFsIGJ1ZmZlciBmb3IgSU8gQmluZGluZy5cbiAgICovXG4gIHVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlcik6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIGRlc3Ryb3kgYWxsIGdwdSBidWZmZXJzLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiByZWxlYXNlIHNlc3Npb24gcmVsYXRlZCBkYXRhLlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIC0gc3BlY2lmeSB0aGUgc2Vzc2lvbiBJRC5cbiAgICovXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgU3RvcmFnZUNhY2hlVmFsdWUge1xuICBncHVEYXRhOiBHcHVEYXRhO1xuICBvcmlnaW5hbFNpemU6IG51bWJlcjtcbn1cblxuY29uc3QgYnVja2V0RnJlZWxpc3Q6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwKFtcbiAgWzY0LCAyNTBdLFxuICBbMTI4LCAyMDBdLFxuICBbMjU2LCAyMDBdLFxuICBbNTEyLCAyMDBdLFxuICBbMjA0OCwgMjMwXSxcbiAgWzQwOTYsIDIwMF0sXG4gIFs4MTkyLCA1MF0sXG4gIFsxNjM4NCwgNTBdLFxuICBbMzI3NjgsIDUwXSxcbiAgWzY1NTM2LCA1MF0sXG4gIFsxMzEwNzIsIDUwXSxcbiAgWzI2MjE0NCwgNTBdLFxuICBbNTI0Mjg4LCA1MF0sXG4gIFsxMDQ4NTc2LCA1MF0sXG4gIFsyMDk3MTUyLCAzMF0sXG4gIFs0MTk0MzA0LCAyMF0sXG4gIFs4Mzg4NjA4LCAxMF0sXG4gIFsxMjU4MjkxMiwgMTBdLFxuICBbMTY3NzcyMTYsIDEwXSxcbiAgWzI2MjE0NDAwLCAxNV0sXG4gIFszMzU1NDQzMiwgMjJdLFxuICBbNDQyMzY4MDAsIDJdLFxuICBbNTg5ODI0MDAsIDZdLFxuICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIHRoZSBidWNrZXQgc2l6ZXMgYmVsb3cgYnV0IG5vdCBjYWNoaW5nIHRoZW1cbiAgLy8gcmVzdWx0cyBpbiBzb21lIG1ham9yIHBlcmZvcm1hbmNlIGhpdHMgZm9yIG1vZGVscyBsaWtlIHNkLXR1cmJvLlxuICBbNjcxMDg4NjQsIDZdLFxuICBbMTM0MjE3NzI4LCA2XSxcbiAgWzE2Nzc3MjE2MCwgNl0sXG5dKTtcblxuY29uc3QgYnVja2V0QXJyOiBudW1iZXJbXSA9IFtdO1xuXG4vKipcbiAqIG5vcm1hbGl6ZSB0aGUgYnVmZmVyIHNpemUgc28gdGhhdCBpdCBmaXRzIHRoZSAxMjgtYml0cyAoMTYgYnl0ZXMpIGFsaWdubWVudC5cbiAqL1xuY29uc3QgY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplID0gKHNpemU6IG51bWJlcikgPT4gTWF0aC5jZWlsKHNpemUgLyAxNikgKiAxNjtcblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGJ1ZmZlciBzaXplIHNvIHRoYXQgaXQgZml0cyBpbnRvIGJ1Y2tldHMuXG4gKi9cbmNvbnN0IGNhbGNCdWNrZXRCdWZmZXJTaXplID0gKHNpemU6IG51bWJlcikgPT4ge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBidWNrZXRBcnIubGVuZ3RoOyBpZHgrKykge1xuICAgIGNvbnN0IHNpemVGb3JCdWNrZXQgPSBidWNrZXRBcnJbaWR4XTtcbiAgICBpZiAoc2l6ZSA8PSBzaXplRm9yQnVja2V0KSB7XG4gICAgICByZXR1cm4gc2l6ZUZvckJ1Y2tldDtcbiAgICB9XG4gIH1cbiAgLy8gbm90IGluIGJ1Y2tldCBsaXN0IC0+IGNhbGxlciB3aWxsIG5vdCBjYWNoZSwgcm91bmQgdXAgdG8gMTYuXG4gIHJldHVybiBNYXRoLmNlaWwoc2l6ZSAvIDE2KSAqIDE2O1xufTtcblxubGV0IGd1aWQgPSAxO1xuY29uc3QgY3JlYXRlTmV3R3B1RGF0YUlkID0gKCkgPT4gZ3VpZCsrO1xuXG4vKipcbiAqIGV4cG9ydGVkIHN0YW5kYXJkIGRvd25sb2FkIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgdGhlIHNlc3Npb24gdG8gZG93bmxvYWQgdGhlIGRhdGEgZnJvbSBHUFUsIGFuZCBhbHNvIGJ5XG4gKiBmYWN0b3J5IHRvIGNyZWF0ZSBHUFUgdGVuc29ycyB3aXRoIHRoZSBjYXBhY2l0eSBvZiBkb3dubG9hZGluZyBkYXRhIGZyb20gR1BVLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kIC0gdGhlIFdlYkdQVSBiYWNrZW5kXG4gKiBAcGFyYW0gZ3B1QnVmZmVyIC0gdGhlIEdQVSBidWZmZXIgdG8gZG93bmxvYWRcbiAqIEBwYXJhbSBvcmlnaW5hbFNpemUgLSB0aGUgb3JpZ2luYWwgc2l6ZSBvZiB0aGUgZGF0YVxuICogQHBhcmFtIGdldFRhcmdldEJ1ZmZlciAtIG9wdGlvbmFsLiBJZiBwcm92aWRlZCwgdGhlIGRhdGEgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIHRhcmdldCBidWZmZXIuIE90aGVyd2lzZSwgYSBuZXcgYnVmZmVyXG4gKiB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICovXG5leHBvcnQgY29uc3QgZG93bmxvYWRHcHVEYXRhID1cbiAgICBhc3luYyhiYWNrZW5kOiBXZWJHcHVCYWNrZW5kLCBncHVCdWZmZXI6IEdQVUJ1ZmZlciwgb3JpZ2luYWxTaXplOiBudW1iZXIsIGdldFRhcmdldEJ1ZmZlcj86ICgpID0+IFVpbnQ4QXJyYXkpOlxuICAgICAgICBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgICAgICAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKG9yaWdpbmFsU2l6ZSk7XG4gICAgICAgICAgY29uc3QgZ3B1UmVhZEJ1ZmZlciA9IGJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgICAge3NpemU6IGJ1ZmZlclNpemUsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgICAgICAgICAgYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgICAgICAgICAgY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKFxuICAgICAgICAgICAgICAgIGdwdUJ1ZmZlciAvKiBzb3VyY2UgYnVmZmVyICovLCAwIC8qIHNvdXJjZSBvZmZzZXQgKi8sIGdwdVJlYWRCdWZmZXIgLyogZGVzdGluYXRpb24gYnVmZmVyICovLFxuICAgICAgICAgICAgICAgIDAgLyogZGVzdGluYXRpb24gb2Zmc2V0ICovLCBidWZmZXJTaXplIC8qIHNpemUgKi9cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBiYWNrZW5kLmZsdXNoKCk7XG5cbiAgICAgICAgICAgIGF3YWl0IGdwdVJlYWRCdWZmZXIubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtcblxuICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBncHVSZWFkQnVmZmVyLmdldE1hcHBlZFJhbmdlKCk7XG4gICAgICAgICAgICBpZiAoZ2V0VGFyZ2V0QnVmZmVyKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIENQVSBidWZmZXIgdG8gYWNjZXB0IHRoZSBkYXRhLCBubyBuZWVkIHRvIGNsb25lIHRoZSBBcnJheUJ1ZmZlci5cbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyID0gZ2V0VGFyZ2V0QnVmZmVyKCk7XG4gICAgICAgICAgICAgIHRhcmdldEJ1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIDAsIG9yaWdpbmFsU2l6ZSkpO1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0QnVmZmVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdGhlIG1hcHBlZCBBcnJheUJ1ZmZlciB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdGhlIEdQVSBidWZmZXIgaXMgZGVzdHJveWVkLiBOZWVkIHRvIGNsb25lIHRoZVxuICAgICAgICAgICAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLnNsaWNlKDAsIG9yaWdpbmFsU2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBncHVSZWFkQnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbmNsYXNzIEdwdURhdGFNYW5hZ2VySW1wbCBpbXBsZW1lbnRzIEdwdURhdGFNYW5hZ2VyIHtcbiAgLy8gR1BVIERhdGEgSUQgPT4gR1BVIERhdGEgKCBzdG9yYWdlIGJ1ZmZlciApXG4gIHByaXZhdGUgc3RvcmFnZUNhY2hlOiBNYXA8R3B1RGF0YUlkLCBTdG9yYWdlQ2FjaGVWYWx1ZT47XG5cbiAgLy8gcGVuZGluZyBidWZmZXJzIGZvciB1cGxvYWRpbmcgKCBkYXRhIGlzIHVubWFwcGVkIClcbiAgcHJpdmF0ZSBidWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZzogR1BVQnVmZmVyW107XG4gIC8vIHBlbmRpbmcgYnVmZmVycyBmb3IgY29tcHV0aW5nXG4gIHByaXZhdGUgYnVmZmVyc1BlbmRpbmc6IEdQVUJ1ZmZlcltdO1xuXG4gIC8vIFRoZSByZXVzYWJsZSBzdG9yYWdlIGJ1ZmZlcnMgZm9yIGNvbXB1dGluZy5cbiAgcHJpdmF0ZSBmcmVlQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xuICAvLyBUaGUgcmV1c2FibGUgdW5pZm9ybSBidWZmZXJzXG4gIHByaXZhdGUgZnJlZVVuaWZvcm1CdWZmZXJzOiBNYXA8bnVtYmVyLCBHUFVCdWZmZXJbXT47XG5cbiAgLy8gVGhlIGV4dGVybmFsIGJ1ZmZlcnMgcmVnaXN0ZXJlZCB1c2VycyBmb3IgSU8gQmluZGluZy5cbiAgcHJpdmF0ZSBleHRlcm5hbEJ1ZmZlcnM6IE1hcDxHUFVCdWZmZXIsIEdwdURhdGFJZD47XG5cbiAgLy8gVGhlIHBlbmRpbmdCdWZmZXJzIGZvciBjYXB0dXJlIGdyYXBoLlxuICAvLyBhIFNlc3Npb25JRCAtPiBHUFVCdWZmZXJbXSBtYXBwaW5nLlxuICBwcml2YXRlIGNhcHR1cmVkUGVuZGluZ0J1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGJhY2tlbmQ6IFdlYkdwdUJhY2tlbmQpIHtcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZyZWVCdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcgPSBbXTtcbiAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nID0gW107XG4gICAgdGhpcy5leHRlcm5hbEJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBdIG9mIGJ1Y2tldEZyZWVsaXN0KSB7XG4gICAgICBidWNrZXRBcnIucHVzaChrZXkpO1xuICAgICAgdGhpcy5mcmVlQnVmZmVycy5zZXQoa2V5LCBbXSk7XG4gICAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5zZXQoa2V5LCBbXSk7XG4gICAgfVxuICB9XG5cbiAgdXBsb2FkKGlkOiBHcHVEYXRhSWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcbiAgICBjb25zdCBzcmNBcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xuICAgIGNvbnN0IHNyY09mZnNldCA9IGRhdGEuYnl0ZU9mZnNldDtcbiAgICBjb25zdCBzcmNMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgY29uc3Qgc2l6ZSA9IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZShzcmNMZW5ndGgpO1xuXG4gICAgLy8gZ2V0IGRlc3RpbmF0aW9uIGdwdSBidWZmZXJcbiAgICBjb25zdCBncHVEYXRhQ2FjaGUgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZ3B1RGF0YUNhY2hlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dwdSBkYXRhIGZvciB1cGxvYWRpbmcgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG4gICAgaWYgKGdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUgIT09IHNyY0xlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmNvbnNpc3RlbnQgZGF0YSBzaXplLiBncHUgZGF0YSBzaXplPSR7Z3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke3NyY0xlbmd0aH1gKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGdwdUJ1ZmZlckZvclVwbG9hZGluZyA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB7bWFwcGVkQXRDcmVhdGlvbjogdHJ1ZSwgc2l6ZSwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSk7XG5cbiAgICAvLyBjb3B5ICh1cGxvYWQpIGRhdGFcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGdwdUJ1ZmZlckZvclVwbG9hZGluZy5nZXRNYXBwZWRSYW5nZSgpO1xuICAgIG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkoc3JjQXJyYXlCdWZmZXIsIHNyY09mZnNldCwgc3JjTGVuZ3RoKSk7XG4gICAgZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLnVubWFwKCk7XG5cblxuICAgIC8vIEdQVSBjb3B5XG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTtcbiAgICB0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLCAwLCBncHVEYXRhQ2FjaGUuZ3B1RGF0YS5idWZmZXIsIDAsIHNpemUpO1xuXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVwbG9hZChpZD0ke2lkfSlgKTtcblxuICAgIHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcucHVzaChncHVCdWZmZXJGb3JVcGxvYWRpbmcpO1xuICB9XG5cbiAgbWVtY3B5KHNvdXJjZUlkOiBHcHVEYXRhSWQsIGRlc3RpbmF0aW9uSWQ6IEdwdURhdGFJZCk6IHZvaWQge1xuICAgIC8vIGdldCBzb3VyY2UgZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IHNvdXJjZUdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChzb3VyY2VJZCk7XG4gICAgaWYgKCFzb3VyY2VHcHVEYXRhQ2FjaGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG4gICAgLy8gZ2V0IGRlc3RpbmF0aW9uIGdwdSBidWZmZXJcbiAgICBjb25zdCBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChkZXN0aW5hdGlvbklkKTtcbiAgICBpZiAoIWRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUgIT09IGRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZShzb3VyY2VHcHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplKTtcblxuICAgIC8vIEdQVSBjb3B5XG4gICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTtcbiAgICB0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICAgIHNvdXJjZUdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlciwgMCwgZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUuZ3B1RGF0YS5idWZmZXIsIDAsIHNpemUpO1xuICB9XG5cbiAgcmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlciwgb3JpZ2luYWxTaXplOiBudW1iZXIsIHByZXZpb3VzQnVmZmVyPzogR1BVQnVmZmVyKTogbnVtYmVyIHtcbiAgICBsZXQgaWQ6IG51bWJlcnx1bmRlZmluZWQ7XG4gICAgaWYgKHByZXZpb3VzQnVmZmVyKSB7XG4gICAgICBpZCA9IHRoaXMuZXh0ZXJuYWxCdWZmZXJzLmdldChwcmV2aW91c0J1ZmZlcik7XG4gICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXZpb3VzIGJ1ZmZlciBpcyBub3QgcmVnaXN0ZXJlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKGJ1ZmZlciA9PT0gcHJldmlvdXNCdWZmZXIpIHtcbiAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICAgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke29yaWdpbmFsU2l6ZX0pID0+IGlkPSR7XG4gICAgICAgICAgICAgICAgaWR9LCBidWZmZXIgaXMgdGhlIHNhbWUsIHNraXAuYCk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWdpc3RlcmluZyBhIGRpZmZlcmVudCBleHRlcm5hbCBidWZmZXIgdW5kZXIgZ3JhcGggY2FwdHVyZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgICAgICAgIFBsZWFzZSB1c2UgdGhlIHByZXZpb3VzIGV4dGVybmFsIGJ1ZmZlciFgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXh0ZXJuYWxCdWZmZXJzLmRlbGV0ZShwcmV2aW91c0J1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gY3JlYXRlTmV3R3B1RGF0YUlkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGlkLCB7Z3B1RGF0YToge2lkLCB0eXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0LCBidWZmZXJ9LCBvcmlnaW5hbFNpemV9KTtcbiAgICB0aGlzLmV4dGVybmFsQnVmZmVycy5zZXQoYnVmZmVyLCBpZCk7XG4gICAgTE9HX0RFQlVHKFxuICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtvcmlnaW5hbFNpemV9KSA9PiBpZD0ke2lkfSwgcmVnaXN0ZXJlZC5gKTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICB1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVyOiBHUFVCdWZmZXIpOiB2b2lkIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZXh0ZXJuYWxCdWZmZXJzLmdldChidWZmZXIpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUoaWQpO1xuICAgICAgdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKGJ1ZmZlcik7XG4gICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHtpZH1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICBjcmVhdGUoc2l6ZTogbnVtYmVyLCB1c2FnZSA9IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQyB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUKTogR3B1RGF0YSB7XG4gICAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGNCdWNrZXRCdWZmZXJTaXplKHNpemUpO1xuXG4gICAgbGV0IGdwdUJ1ZmZlcjtcbiAgICAvLyBDdXJyZW50bHksIG9ubHkgc3RvcmFnZSBidWZmZXJzIGFyZSByZXVzZWQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBjb25zdCBpc1N0b3JhZ2UgPSAodXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSA9PT0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGNvbnN0IGlzVW5pZm9ybSA9ICh1c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pID09PSBHUFVCdWZmZXJVc2FnZS5VTklGT1JNO1xuICAgIGlmIChpc1N0b3JhZ2UgfHwgaXNVbmlmb3JtKSB7XG4gICAgICBjb25zdCBmcmVlQnVmZmVycyA9IGlzU3RvcmFnZSA/IHRoaXMuZnJlZUJ1ZmZlcnMgOiB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycztcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBmcmVlQnVmZmVycy5nZXQoYnVmZmVyU2l6ZSk7XG4gICAgICBpZiAoIWJ1ZmZlcnMpIHtcbiAgICAgICAgLy8gbm8gc3VjaCBidWNrZXQvZnJlZWxpc3QgLSBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgICAgICBncHVCdWZmZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2V9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBpbiBmcmVlbGlzdCwgdXNlIGl0XG4gICAgICAgICAgZ3B1QnVmZmVyID0gYnVmZmVycy5wb3AoKSBhcyBHUFVCdWZmZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnVja2V0IGVtcHR5LCBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgICAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOiBidWZmZXJTaXplLCB1c2FnZX0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgICBncHVCdWZmZXIgPSB0aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2V9KTtcbiAgICB9XG5cbiAgICBjb25zdCBncHVEYXRhID0ge2lkOiBjcmVhdGVOZXdHcHVEYXRhSWQoKSwgdHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCwgYnVmZmVyOiBncHVCdWZmZXJ9O1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlLnNldChncHVEYXRhLmlkLCB7Z3B1RGF0YSwgb3JpZ2luYWxTaXplOiBzaXplfSk7XG5cbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHtzaXplfSkgPT4gaWQ9JHtncHVEYXRhLmlkfWApO1xuICAgIHJldHVybiBncHVEYXRhO1xuICB9XG5cbiAgZ2V0KGlkOiBHcHVEYXRhSWQpOiBHcHVEYXRhfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk/LmdwdURhdGE7XG4gIH1cblxuICByZWxlYXNlKGlkOiBHcHVEYXRhSWQpOiBudW1iZXIge1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpO1xuICAgIGlmICghY2FjaGVkRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWxlYXNpbmcgZGF0YSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cblxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWxlYXNlKGlkPSR7aWR9KSwgZ3B1RGF0YUlkPSR7Y2FjaGVkRGF0YS5ncHVEYXRhLmlkfWApO1xuXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKGlkKTtcbiAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2goY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlcik7XG4gICAgLy8gY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XG5cbiAgICByZXR1cm4gY2FjaGVkRGF0YS5vcmlnaW5hbFNpemU7XG4gIH1cblxuICBhc3luYyBkb3dubG9hZChpZDogR3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXI6ICgpID0+IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWNhY2hlZERhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBhd2FpdCBkb3dubG9hZEdwdURhdGEodGhpcy5iYWNrZW5kLCBjYWNoZWREYXRhLmdwdURhdGEuYnVmZmVyLCBjYWNoZWREYXRhLm9yaWdpbmFsU2l6ZSwgZ2V0VGFyZ2V0QnVmZmVyKTtcbiAgfVxuXG4gIHJlZnJlc2hQZW5kaW5nQnVmZmVycygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nKSB7XG4gICAgICAvLyB1cGxvYWQgYnVmZmVyIGlzIG9ubHkgdXNlZnVsIGluIHRoZSBzZXNzaW9uIGNyZWF0aW9uIHRpbWUuIFNvIHdlIGRvbid0IG5lZWQgdG8gcmV1c2UgdGhlbSBpbiBzZXNzaW9uIHJ1bm5pbmcuXG4gICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nID0gW107XG5cbiAgICBpZiAodGhpcy5idWZmZXJzUGVuZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXMgPT09ICdkZWZhdWx0Jykge1xuICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgdGhpcy5idWZmZXJzUGVuZGluZykge1xuICAgICAgICBjb25zdCBtYXhJbkZyZWVMaXN0ID0gYnVja2V0RnJlZWxpc3QuZ2V0KGJ1ZmZlci5zaXplKTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICBpZiAoKGJ1ZmZlci51c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpID09PSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSB7XG4gICAgICAgICAgLy8gUHV0IHRoZSBwZW5kaW5nIGJ1ZmZlciB0byBmcmVlQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxuICAgICAgICAgIGNvbnN0IGZyZWVsaXN0ID0gdGhpcy5mcmVlQnVmZmVycy5nZXQoYnVmZmVyLnNpemUpIHx8IFtdO1xuICAgICAgICAgIGlmIChtYXhJbkZyZWVMaXN0ID09PSB1bmRlZmluZWQgfHwgZnJlZWxpc3QubGVuZ3RoID49IG1heEluRnJlZUxpc3QpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyZWVsaXN0LnB1c2goYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgfSBlbHNlIGlmICgoYnVmZmVyLnVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSkgPT09IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pIHtcbiAgICAgICAgICAvLyBQdXQgdGhlIHBlbmRpbmcgYnVmZmVyIHRvIGZyZWVVbmlmb3JtQnVmZmVycyBsaXN0IGluc3RlYWQgb2YgcmVhbGx5IGRlc3Ryb3lpbmcgaXQgZm9yIGJ1ZmZlciByZXVzaW5nLlxuICAgICAgICAgIGNvbnN0IGZyZWVsaXN0ID0gdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuZ2V0KGJ1ZmZlci5zaXplKSB8fCBbXTtcbiAgICAgICAgICBpZiAobWF4SW5GcmVlTGlzdCA9PT0gdW5kZWZpbmVkIHx8IGZyZWVsaXN0Lmxlbmd0aCA+PSBtYXhJbkZyZWVMaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmVlbGlzdC5wdXNoKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG9uJ3QgcmVsZWFzZSBpbnRlcm1lZGlhdGUgdGVuc29ycyBpbiBub24tZGVmYXVsdCBtb2RlLlxuICAgICAgLy8gVE9ETzogcmV1c2UgdGhlIHN0b3JhZ2UgYnVmZmVycyBpbiBub24tZGVmYXVsdCBtb2RlLlxuICAgICAgbGV0IGNhcHR1cmVkQnVmZmVycyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhKTtcbiAgICAgIGlmICghY2FwdHVyZWRCdWZmZXJzKSB7XG4gICAgICAgIGNhcHR1cmVkQnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuc2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISwgY2FwdHVyZWRCdWZmZXJzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpIHtcbiAgICAgICAgY2FwdHVyZWRCdWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVycykgPT4ge1xuICAgICAgYnVmZmVycy5mb3JFYWNoKGJ1ZmZlciA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XG4gICAgICBidWZmZXJzLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgICAgc3RvcmFnZS5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZm9yRWFjaCgoYnVmZmVycykgPT4ge1xuICAgICAgYnVmZmVycy5mb3JFYWNoKGJ1ZmZlciA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnN0b3JhZ2VDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZyZWVCdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpIHtcbiAgICAvLyByZWxlYXNlIHRoZSBjYXB0dXJlZCBwZW5kaW5nIGJ1ZmZlcnMuXG4gICAgY29uc3QgcGVuZGluZ0J1ZmZlcnMgPSB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKHBlbmRpbmdCdWZmZXJzKSB7XG4gICAgICBwZW5kaW5nQnVmZmVycy5mb3JFYWNoKGJ1ZmZlciA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdwdURhdGFNYW5hZ2VyID0gKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgR3B1RGF0YU1hbmFnZXJJbXBsPik6IEdwdURhdGFNYW5hZ2VyID0+XG4gICAgbmV3IEdwdURhdGFNYW5hZ2VySW1wbCguLi5hcmdzKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuY2xhc3MgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBwcml2YXRlIGtleTogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGNhY2hlS2V5KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgdGhpcy5rZXkgPVxuICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAobmFtZSA9PiBgJHsodGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbbmFtZV19YCkuam9pbignOycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjYWNoZUtleTogc3RyaW5nO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIG5ldyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gYXR0cmlidXRlLCBhbmQgYWRkIGEgY2FjaGVLZXkgcHJvcGVydHkgdG8gaXRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSA9IDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KGF0dHJpYnV0ZTogVCk6IFQmQXR0cmlidXRlV2l0aENhY2hlS2V5ID0+XG4gICAgbmV3IEF0dHJpYnV0ZVdpdGhDYWNoZUtleUltcGwoYXR0cmlidXRlKSBhcyB1bmtub3duIGFzIFQgJiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbmV4cG9ydCBjbGFzcyBNYXRNdWxVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGUgd2hlbiBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICogQHBhcmFtIGEgVGhlIHNoYXBlIG9mIHRlbnNvciBBLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNNYXRNdWxTaGFwZShhOiBbbnVtYmVyLCBudW1iZXJdLCBiOiBbbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyXXx1bmRlZmluZWQge1xuICAgIHJldHVybiAoYVsxXSAhPT0gYlswXSkgPyB1bmRlZmluZWQgOiBbYVswXSwgYlsxXV07XG4gIH1cbn1cblxuXG5leHBvcnQgY2xhc3MgQnJvYWRjYXN0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNTaGFwZShhZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGJkaW1zOiByZWFkb25seSBudW1iZXJbXSwgaXNNYXRNdWwgPSBmYWxzZSk6IHJlYWRvbmx5IG51bWJlcltdfHVuZGVmaW5lZCB7XG4gICAgY29uc3QgYXJhbmsgPSBhZGltcy5sZW5ndGg7XG4gICAgY29uc3QgYnJhbmsgPSBiZGltcy5sZW5ndGg7XG4gICAgaWYgKGFyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYmRpbXM7XG4gICAgfVxuICAgIGlmIChicmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFkaW1zO1xuICAgIH1cbiAgICBjb25zdCBjcmFuayA9IE1hdGgubWF4KGFkaW1zLmxlbmd0aCwgYmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBjZGltcyA9IG5ldyBBcnJheTxudW1iZXI+KGNyYW5rKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGFzdCAyIGRpbWVuc2lvbiBpZiBpdCBpcyBNYXRNdWxcbiAgICBpZiAoaXNNYXRNdWwpIHtcbiAgICAgIGlmIChhcmFuayA8IDIgfHwgYnJhbmsgPCAyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjU2hhcGVNYXRNdWwgPVxuICAgICAgICAgIE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFthZGltc1thcmFuayAtIDJdLCBhZGltc1thcmFuayAtIDFdXSwgW2JkaW1zW2JyYW5rIC0gMl0sIGJkaW1zW2JyYW5rIC0gMV1dKTtcbiAgICAgIGlmIChjU2hhcGVNYXRNdWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgW2NkaW1zW2NyYW5rIC0gMl0sIGNkaW1zW2NyYW5rIC0gMV1dID0gY1NoYXBlTWF0TXVsO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBpc01hdE11bCA/IDMgOiAxOyBpIDw9IGNyYW5rOyBpKyspIHtcbiAgICAgIGNvbnN0IGFMZW4gPSBhcmFuayAtIGkgPCAwID8gMSA6IGFkaW1zW2FyYW5rIC0gaV07XG4gICAgICBjb25zdCBiTGVuID0gYnJhbmsgLSBpIDwgMCA/IDEgOiBiZGltc1ticmFuayAtIGldO1xuXG4gICAgICBpZiAoYUxlbiAhPT0gYkxlbiAmJiBhTGVuID4gMSAmJiBiTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoYUxlbiwgYkxlbik7XG4gICAgICBpZiAoYUxlbiAmJiBiTGVuKSB7XG4gICAgICAgIGNkaW1zW2NyYW5rIC0gaV0gPSBNYXRoLm1heChhTGVuLCBiTGVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gZWl0aGVyIGFMZW4gb3IgYkxlbiBpcyAwLCB0aGUgb3RoZXIgc2hvdWxkIGJlIGVpdGhlciAwIG9yIDEsIG90aGVyd2lzZSBpdCBpcyBub3QgYnJvYWRjYXN0YWJsZS5cbiAgICAgICAgaWYgKG1heCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNkaW1zW2NyYW5rIC0gaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjZGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBzaGFwZSBpcyB1bmlkaXJlY3Rpb25hbCBicm9hZGNhc3RhYmxlIHRvIGFub3RoZXIgc2hhcGVcbiAgICogQHBhcmFtIHNoYXBlIFRoZSBpbnB1dCBzaGFwZVxuICAgKiBAcGFyYW0gZmluYWxTaGFwZSBUaGUgZGVzaXJlZCBzaGFwZSBhZnRlciBicm9hZGNhc3RpbmdcbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZmluYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICAvLyBhbGlnbiBzaGFwZSB0byB0aGUgcmlnaHRcbiAgICBjb25zdCBpbnB1dFJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgZmluYWxSYW5rID0gZmluYWxTaGFwZS5sZW5ndGg7XG4gICAgaWYgKGlucHV0UmFuayA+IGZpbmFsUmFuaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBpbnB1dFJhbms7IGkrKykge1xuICAgICAgaWYgKHNoYXBlW2lucHV0UmFuayAtIGldICE9PSAxICYmIHNoYXBlW2lucHV0UmFuayAtIGldICE9PSBmaW5hbFNoYXBlW2ZpbmFsUmFuayAtIGldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuXG5leHBvcnQgY2xhc3MgU2hhcGVVdGlsIHtcbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKVxuICAgKi9cbiAgc3RhdGljIHNpemUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCAwLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogY29udmVydCBkaW1zIGNvcnJlc3BvbmRpbmcgdG8gdHlwZSBjaGFuZ2UgdG8gcGFjay4gZXguIHVpbnQ4IGRhdGEgdG8gdWludDMyXG4gICAqL1xuICBzdGF0aWMgY29udmVydFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzaXplID0gNCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgbmV3RGltcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBsZXQgaSA9IHJhbmsgLSAxO1xuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIGlmIChkaW1zW2ldICUgc2l6ZSA9PT0gMCkge1xuICAgICAgICBuZXdEaW1zW2ldID0gZGltc1tpXSAvIHNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNpemUgJSBkaW1zW2ldICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNvbnZlcnQgc2hhcGUnKTtcbiAgICAgIH1cbiAgICAgIG5ld0RpbXNbaV0gPSAxO1xuICAgICAgc2l6ZSAvPSBkaW1zW2ldO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBmb3IgKGktLTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIG5ld0RpbXNbaV0gPSBkaW1zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cykgZnJvbSB0aGUgZ2l2ZW4gYXhpcyAoaW5jbHVzaXZlKVxuICAgKi9cbiAgc3RhdGljIHNpemVGcm9tRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2RpbXMubGVuZ3RofSBkaW1lbnNpb25zLmApO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgYXhpcywgZGltcy5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSB0byB0aGUgZ2l2ZW4gYXhpcyAoZXhjbHVzaXZlKVxuICAgKi9cbiAgc3RhdGljIHNpemVUb0RpbWVuc2lvbihkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IDAgfHwgYXhpcyA+IGRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7YXhpc30gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCAwLCBheGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHNpemUgKG51bWJlciBvZiBlbGVtZW50cykgZnJvbSBhbmQgdG8gdGhlIGdpdmVuIGF4aXMgW3N0YXJ0LCBlbmQpXG4gICAqL1xuICBzdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgLy8gc2FmZXR5IGNoZWNrIGFzIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBtdWx0aXBsZSBvdGhlciBtZXRob2RzIHJlcXVpcmluZyBzaXplLlxuICAgICAgLy8gc2l6ZSBjYW5ub3QgYmUgbmVnYXRpdmUuXG4gICAgICBpZiAoZGltc1tpXSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAgICdjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uJyk7XG4gICAgICB9XG4gICAgICBzaXplICo9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgc3RhdGljIGNvbXB1dGVTdHJpZGVzKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFsxXTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAxXSA9IDE7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBkaW1zW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBkaW1zW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlkZXM7XG4gIH1cblxuICAvKipcbiAgICogbm9ybWFpbHplIGF4aXMgb2YgcmFuZ2UgWy1yLCByKSBpbnRvIFswLCByKS5cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVBeGlzKGF4aXM6IG51bWJlciwgdGVuc29yUmFuazogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IC10ZW5zb3JSYW5rICYmIGF4aXMgPj0gdGVuc29yUmFuaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXMgPCAwID8gYXhpcyArIHRlbnNvclJhbmsgOiBheGlzO1xuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZUF4ZXMoYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHRlbnNvclJhbms/OiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIGF4ZXMubWFwKHggPT4gdGhpcy5ub3JtYWxpemVBeGlzKHgsIHRlbnNvclJhbmsgPz8gYXhlcy5sZW5ndGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBhIGdpdmVuIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRpY2VzIGluIHRoZSBQZXJtIGFycmF5XG4gICAqIFVzZWQgaW4gVHJhbnNwb3NlXG4gICAqIEBwYXJhbSBhIEFycmF5IHRvIGJlIHNvcnRlZCBzdWNoIGFzIGRpbXMgb3Igc3RyaWRlc1xuICAgKiBAcGFyYW0gcGVybSBQZXJtIGdpdmVuOyBpZiBudWxsIGEgd2lsbCBiZSByZXZlcnNlZFxuICAgKi9cbiAgc3RhdGljIHNvcnRCYXNlZE9uUGVybShhOiByZWFkb25seSBudW1iZXJbXSwgcGVybT86IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChwZXJtKSB7XG4gICAgICByZXR1cm4gcGVybS5tYXAoKHYpID0+IGFbdl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFkcyBhIGdpdmVuIHNoYXBlIGFjY29yZGluZyB0byB0aGUgcGFkZGluZyB2YWx1ZXNcbiAgICogQHBhcmFtIGRpbXMgc2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBwYWRkZWRcbiAgICogQHBhcmFtIHBhZCBwYWQgdmFsdWVzXG4gICAqL1xuICBzdGF0aWMgcGFkU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHBhZDogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIHJldHVybiBkaW1zLm1hcCgodiwgaSkgPT4gdiArIHBhZFtpXSArIHBhZFtpICsgcmFua10pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHR3byBzaGFwZXMgYXJlIGlkZW50aWNhbFxuICAgKiBAcGFyYW0gc2hhcGUxXG4gICAqIEBwYXJhbSBzaGFwZTJcbiAgICovXG4gIHN0YXRpYyBhcmVFcXVhbChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKHNoYXBlMS5sZW5ndGggIT09IHNoYXBlMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlMS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gc2hhcGUyW2ldKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUG9vbENvbnZVdGlsIHtcbiAgLyoqXG4gICAqIEFkanVzdCB0aGUga2VybmVsLCBzdHJpZGVzLCBwYWRzIHRvIGNvcnJlY3QgcmFuay4gU2V0IHRvIGRlZmF1bHQgdmFsdWUgaWYgbm90IHByZXNlbnRcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHBhZHMgUGFkZGluZyBmb3IgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGFsb25nIGVhY2ggYXhpcy5cbiAgICovXG4gIHN0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyhcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sXG4gICAgICBkaWxhdGlvbnM6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSk6IHZvaWQge1xuICAgIGlmICghaXNHbG9iYWxPcGVyYXRvciAmJiBrZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgLy8gYWRqdXN0IGtlcm5lbCBzaGFwZSB0byBjb3ZlciB0aGUgaW5wdXQgZGltc1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIGlmIChkaW0gPj0ga2VybmVsU2hhcGUubGVuZ3RoKSB7XG4gICAgICAgICAga2VybmVsU2hhcGUucHVzaChpbnB1dERpbXNbZGltICsgMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0gPSBpbnB1dERpbXNbZGltICsgMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3Qgc3RyaWRlcyBsZW5ndGggdG8gbWF0Y2gga2VybmVsIHNoYXBlIGxlbmd0aFxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBzdHJpZGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3RyaWRlc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaWRlcy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBkaWxhdGlvbiB2YWx1ZVxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBkaWxhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkaWxhdGlvbnNbZGltXSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlsYXRpb25zLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHBhZHMgbGVuZ3RoIHRvIG1hdGNoIDIgKiBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoICogMjsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBwYWRzLmxlbmd0aCkge1xuICAgICAgICBpZiAocGFkc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWRzLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2FuaXR5IGNoZWNrcyBmb3IgdmFsdWVzIGluIGtlcm5lbCBzaGFwZXMgYW5kIHBhZHNcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoa2VybmVsU2hhcGVbZGltXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWRzW2RpbV0gPj0ga2VybmVsU2hhcGVbZGltXSB8fCBwYWRzW2RpbSArIGtlcm5lbFNoYXBlLmxlbmd0aF0gPj0ga2VybmVsU2hhcGVbZGltXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhZGp1c3QgcGFkIHZhbHVlcyBiYXNlZCBvbiAnYXV0b1BhZCcgYXR0cmlidXRlXG4gIHN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXG4gICAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGlzQ2hhbm5lbExhc3Q6IGJvb2xlYW4sIGF1dG9QYWQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWF1dG9QYWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFkcy5sZW5ndGggIT09IDIgKiAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChzdHJpZGVzLmxlbmd0aCAhPT0gKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoICE9PSAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICAgIGlucHV0RGltc1tkaW0gKyAoaXNDaGFubmVsTGFzdCA/IDEgOiAyKV0sIHN0cmlkZXNbZGltXSwgZGlsYXRpb25zW2RpbV0sIGtlcm5lbFNoYXBlW2RpbV0sIHBhZHMsIGRpbSxcbiAgICAgICAgICBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMiwgYXV0b1BhZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3V0cHV0IHNoYXBlIGZvciBQb29sIG9wcyBiYXNlZCBvbiBpbnB1dCBhdHRyaWJ1dGVzLiAoU2hvdWxkIGJlIHVzZWQgb25seSBmb3IgUG9vbCBvcHMpXG4gICAqIEBwYXJhbSBpc0dsb2JhbE9wZXJhdG9yIElmIHRydWUsIHBlcmZvcm0gZ2xvYmFsIHBvb2xpbmcuXG4gICAqIEBwYXJhbSBpbnB1dERpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMF0uZGltcylcbiAgICogQHBhcmFtIHN0cmlkZXMgU3RyaWRlIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGRpbGF0aW9ucyBEaWxhdGlvbiBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHBhZHMgUGFkZGluZyBmb3IgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGF1dG9QYWQgREVQUkVDQVRFRCBhdHRyaWJ1dGUgc3VwcG9ydGVkIGZvciBsZWdhY3kgbW9kZWxzLiBTcGVjaWZpZXMgaG93IHRvIGltcGxpY2l0bHkgY2FsY3VsYXRlIHBhZHMgaW4gZWFjaFxuICAgKiAgICAgZGltZW5zaW9uLiBDYW4gdGFrZSB2YWx1ZXMgTk9UU0VULCBTQU1FX1VQUEVSLCBTQU1FX0xPV0VSLCBvciBWQUxJRC5cbiAgICovXG4gIHN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLCBhdXRvUGFkPzogc3RyaW5nKTogbnVtYmVyW10ge1xuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBjaGFubmVscyBvZiBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW2lucHV0RGltc1swXSwgaW5wdXREaW1zWzFdXTtcblxuICAgIFBvb2xDb252VXRpbC5jb21wdXRlU2hhcGVIZWxwZXIoXG4gICAgICAgIGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0RGltcywgb3V0cHV0RGltcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXV0b1BhZCk7XG4gICAgcmV0dXJuIG91dHB1dERpbXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIENvbnYgb3AgYmFzZWQgb24gaW5wdXQgYXR0cmlidXRlcy4gKFNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIENvbnYgb3ApXG4gICAqIEBwYXJhbSBpbnB1dERpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMF0uZGltcylcbiAgICogQHBhcmFtIGZpbHRlckRpbXMgVGhlIGZpbHRlciB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzFdLmRpbXMpXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHBhZHMgUGFkZGluZyBmb3IgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGF1dG9QYWQgREVQUkVDQVRFRCBhdHRyaWJ1dGUgc3VwcG9ydGVkIGZvciBsZWdhY3kgbW9kZWxzLiBTcGVjaWZpZXMgaG93IHRvIGltcGxpY2l0bHkgY2FsY3VsYXRlIHBhZHMgaW4gZWFjaFxuICAgKiAgICAgZGltZW5zaW9uLiBDYW4gdGFrZSB2YWx1ZXMgTk9UU0VULCBTQU1FX1VQUEVSLCBTQU1FX0xPV0VSLCBvciBWQUxJRC5cbiAgICovXG4gIHN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKFxuICAgICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwgZmlsdGVyRGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLCBkaWxhdGlvbnM6IG51bWJlcltdLFxuICAgICAga2VybmVsU2hhcGU6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSwgYXV0b1BhZD86IHN0cmluZyk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwIHx8IGZpbHRlckRpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltcycpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihmYWxzZSwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcbiAgLy8gY2FsbGVkIGJ5IGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoKSBhbmQgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSgpXG4gIC8vIGFkanVzdCBwYWRzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGUgcHJpb3IgdG8gc2hhcGUgY29tcHV0YXRpb25cbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0RGltczogbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSwgYXV0b1BhZD86IHN0cmluZykge1xuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKFBvb2xDb252VXRpbC5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgICAgICAgIGlucHV0RGltc1tkaW0gKyAyXSwgc3RyaWRlc1tkaW1dLCBkaWxhdGlvbnNbZGltXSwga2VybmVsU2hhcGVbZGltXSwgcGFkcywgZGltLCBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGF1dG9QYWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIGNvbXB1dGVTaGFwZUhlbHBlcigpIGFuZCBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoKVxuICAvLyBhZGp1c3RzIHBhZCB2YWx1ZSBmb3IgZ2l2ZW4gJ2F1dG9QYWQnIHN0cmluZyBhbmQgY29tcHV0ZXMgb3V0cHV0IHNoYXBlIGFsb25nIGEgcGFydGljdWxhciBkaW1lbnNpb25cbiAgcHJpdmF0ZSBzdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICBpblNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIGRpbGF0aW9uOiBudW1iZXIsIGtlcm5lbDogbnVtYmVyLCBwYWRzOiBudW1iZXJbXSwgcGFkSGVhZEluZGV4OiBudW1iZXIsXG4gICAgICBwYWRUYWlsSW5kZXg6IG51bWJlciwgYXV0b1BhZD86IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgZGtlcm5lbCA9IGRpbGF0aW9uICogKGtlcm5lbCAtIDEpICsgMTtcbiAgICBpZiAoYXV0b1BhZCAmJiBhdXRvUGFkICE9PSAnTk9UU0VUJykge1xuICAgICAgc3dpdGNoIChhdXRvUGFkKSB7XG4gICAgICAgIGNhc2UgJ1ZBTElEJzpcbiAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPSAwO1xuICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IDA7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKChpblNpemUgLSBka2VybmVsKSAvIHN0cmlkZSkgKyAxKTtcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XG4gICAgICAgIGNhc2UgJ1NBTUVfVVBQRVInOlxuICAgICAgICAgIGlmIChkaWxhdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVnYWN5VGFyZ2V0U2l6ZSA9IChpblNpemUgKyBzdHJpZGUgLSAxKSAvIHN0cmlkZTtcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XG4gICAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPVxuICAgICAgICAgICAgICAgIChhdXRvUGFkID09PSAnU0FNRV9MT1dFUicpID8gTWF0aC5mbG9vcigocGFkTmVlZGVkICsgMSkgLyAyKSA6IE1hdGguZmxvb3IocGFkTmVlZGVkIC8gMik7XG4gICAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSBwYWROZWVkZWQgLSBwYWRzW3BhZEhlYWRJbmRleF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoKGluU2l6ZSArIHBhZE5lZWRlZCAtIGtlcm5lbCkgLyBzdHJpZGUpICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKCgoaW5TaXplICsgcGFkc1twYWRIZWFkSW5kZXhdICsgcGFkc1twYWRUYWlsSW5kZXhdIC0gZGtlcm5lbCkgLyBzdHJpZGUpICsgMSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHZW1tVXRpbCB7XG4gIC8vIHdpbGwgbWFrZSBzdXJlIGlucHV0IHNoYXBlcyBhcmUgY29tcGF0aWJsZSBmb3IgdGhpcyBvcFxuICAvLyBhbmQgcmV0dXJuIGJhY2sgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgaW4gdGhlIGZvcm0gb2YgYSB0dXBsZVxuICAvLyB3aWxsIHRocm93IGV4Y2VwdGlvbiBpZiB0aGUgaW5wdXQgc2hhcGVzIGFyZSBub3QgY29tcGF0aWJsZVxuICBzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQoXG4gICAgICBsZWZ0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0cmFuc0xlZnQ6IGJvb2xlYW4sIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0cmFuc1JpZ2h0OiBib29sZWFuLFxuICAgICAgYmlhc1NoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKGxlZnRTaGFwZS5sZW5ndGggIT09IDIgfHwgcmlnaHRTaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDInKTtcbiAgICB9XG5cbiAgICBsZXQgTTogbnVtYmVyO1xuICAgIGxldCBLOiBudW1iZXI7XG4gICAgbGV0IE46IG51bWJlcjtcblxuICAgIGlmICh0cmFuc0xlZnQpIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMV07XG4gICAgICBLID0gbGVmdFNoYXBlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBNID0gbGVmdFNoYXBlWzBdO1xuICAgICAgSyA9IGxlZnRTaGFwZVsxXTtcbiAgICB9XG5cbiAgICBsZXQga0RpbSA9IC0xO1xuXG4gICAgaWYgKHRyYW5zUmlnaHQpIHtcbiAgICAgIE4gPSByaWdodFNoYXBlWzBdO1xuICAgICAga0RpbSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIE4gPSByaWdodFNoYXBlWzFdO1xuICAgICAga0RpbSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0U2hhcGVba0RpbV0gIT09IEspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGltZW5zaW9uIG1pc21hdGNoJyk7XG4gICAgfVxuXG4gICAgaWYgKE0gPD0gMCB8fCBOIDw9IDAgfHwgSyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2hhcGUgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgaWYgKGJpYXNTaGFwZSAmJiAhQnJvYWRjYXN0VXRpbC5pc1ZhbGlkQnJvYWRjYXN0KGJpYXNTaGFwZSwgW00sIE5dKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBbTSwgTiwgS107XG4gIH1cbn1cblxuXG5leHBvcnQgY29uc3QgTUlOX0NMSVAgPSAtMy40MDI4MjM0NjYzODUyODg2ZSszODtcbmV4cG9ydCBjb25zdCBNQVhfQ0xJUCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzg7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7UHJvZ3JhbVVuaWZvcm0sIFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogY29uc3RhbnQgdmFsdWUgZm9yIGEgd29ya2dyb3VwIHNpemUuXG4gKlxuICogV2UgZGVmaW5pdGVseSBjYW4gZG8gZnVydGhlciBvcHRpbWl6YXRpb24gaW4gZnV0dXJlLCBidXQgZm9yIG5vdyB3ZSB1c2UgNjQuXG4gKlxuICogcnVsZSBvZiB0aHVtYjogVXNlIFthIHdvcmtncm91cCBzaXplIG9mXSA2NCB1bmxlc3MgeW91IGtub3cgd2hhdCBHUFUgeW91IGFyZSB0YXJnZXRpbmcgb3IgdGhhdCB5b3VyIHdvcmtsb2FkXG4gKiAgICAgICAgICAgICAgICBuZWVkcyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICpcbiAqIGZyb206IGh0dHBzOi8vc3VybWEuZGV2L3RoaW5ncy93ZWJncHUvXG4gKiovXG5leHBvcnQgY29uc3QgV09SS0dST1VQX1NJWkUgPSA2NDtcblxuaW50ZXJmYWNlIEluZGljZXNIZWxwZXJUeXBlcyB7XG4gIC8qKlxuICAgKiBXR1NMIHR5cGUgb2YgaW5kaWNlcyBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgdHlwZSBvZiBhIHZhbHVlXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIHR5cGUgb2Ygc3RvcmFnZSB0eXBlIHJlcHJlc2VudGluZyBhIHZhbHVlXG4gICAqXG4gICAqIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSB0byBgdmFsdWVgLCBidXQgZm9yIHNvbWUgdHlwZSAoZWcuIGJvb2wpLCB3ZSBuZWVkIHRvIHVzZSBgdTMyYCBhcyBzdG9yYWdlIHR5cGUgZm9yXG4gICAqIHZhbHVlIHR5cGUgYHZlYzQ8Ym9vbD5gXG4gICAqL1xuICByZWFkb25seSBzdG9yYWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIHRlbnNvciB0eXBlIGFzIHJlcHJlc2VudGVkIGluIFRlbnNvclZpZXdcbiAgICovXG4gIHJlYWRvbmx5IHRlbnNvcjogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIGNsYXNzIGZvciBnZW5lcmF0aW5nIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEgZm9yIGEgc2hhZGVyJ3MgaW5wdXQgb3Igb3V0cHV0LlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgZGVzaWduZWQgdG8gb2ZmZXIgYSB1bmlmaWVkIHdheSB0byBnZW5lcmF0ZSBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhIGZvciBhIHNoYWRlcidzXG4gKiBpbnB1dCBvciBvdXRwdXQuXG4gKlxuICogVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2YgdGVybWlub2xvZ2llcyB1c2VkIGluIHRoaXMgY2xhc3M6XG4gKiAtIGBvZmZzZXRgOiBhIHVpbnQzMiB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBvZiBhbiBlbGVtZW50IGluIHRoZSBkYXRhIGJ1ZmZlci5cbiAqIC0gYGluZGljZXNgOiBhbiBhYnN0cmFjdGlvbiBvZiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5J3MgaW5kaWNlcyByZXByZXNlbnRpbmcgdGhlIGRhdGEncyBpbmRleCBvbiBlYWNoIGRpbWVuc2lvbi5cbiAqIC0gYHZhbHVlYDogYSB2YWx1ZSBvZiBhIGRhdGEgZWxlbWVudC5cbiAqXG4gKiBVc2VycyBhcmUgZXhwZWN0ZWQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgZm9yIGVhY2ggc2hhZGVyJ3MgaW5wdXQgb3Igb3V0cHV0LCBhbmQgdXNlIHRoZSBpbnN0YW5jZSB0b1xuICogZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBtYW5pcHVsYXRpbmcgaW5kaWNlcyBhbmQgZGF0YS4gVGhlIGZvbGxvd2luZyAyIGV4cG9ydGVkIGZ1bmN0aW9ucyBhcmUgZm9yIHVzZXJzIHRvIGNhbGwgdG9cbiAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhbiBpbmRpY2VzIGhlbHBlcjpcbiAqIC0gYGlucHV0VmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gaW5wdXQuXG4gKiAtIGBvdXRwdXRWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBvdXRwdXQuXG4gKiAtIGBpbnRlcm5hbFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIGludGVybmFsIHZhcmlhYmxlLlxuICpcbiAqIEFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGNvbnRhaW5zIGhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9uczpcbiAqIC0gYWNjZXNzIHJlYWRvbmx5IGJhc2ljIGluZm9ybWF0aW9uLCBpbmNsdWRpbmc6IGBuYW1lYCh0aGUgbmFtZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0KSwgYHVzYWdlYCh3aGV0aGVyIGl0J3MgYW5cbiAqIGlucHV0LCBhbiBvdXRwdXQgb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUpIGFuZCBgc2hhcGVgKHRoZSBwYXNzZWQgaW4gc2hhcGUpLlxuICogLSBgdHlwZWA6IGFjY2VzcyByZWFkb25seSB0eXBlIGluZm9ybWF0aW9uLCBpbmNsdWRpbmc6IGBpbmRpY2VzYCh0aGUgdHlwZSBvZiBpbmRpY2VzKSwgYHZhbHVlYCh0aGUgdHlwZSBvZiB2YWx1ZSBhdFxuICogcnVudGltZSksIGBzdG9yYWdlYCh0aGUgdHlwZSBvZiB2YWx1ZSBhdCBzdG9yYWdlKSBhbmQgYHRlbnNvcmAodGhlIHRlbnNvciB0eXBlIGFzIHJlcHJlc2VudGVkIGluIFRlbnNvclZpZXcpLlxuICogLSBnZW5lcmF0ZSBXR1NMIGNvZGUgZm9yIGdldHRpbmcgaW5kaWNlcyBmcm9tIG9mZnNldC4gVXNlIGBvZmZzZXRUb0luZGljZXMoKWAgZm9yIFdHU0wgY29kZSBzbmlwcGV0IHRvIGNhbGN1bGF0ZVxuICogaW5kaWNlcyBmcm9tIG9mZnNldCwgYW5kIHVzZSBgaW5kaWNlc1RvT2Zmc2V0KClgIGZvciBXR1NMIGNvZGUgc25pcHBldCB0byBjYWxjdWxhdGUgb2Zmc2V0IGZyb20gaW5kaWNlcy5cbiAqIC0gdG8gbWFuaXB1bGF0ZSBhbiBpbnN0YW5jZSBvZiBpbmRpY2VzLCB1c2UgYHNldEluZGljZXMoKWAgYW5kIGBnZXRJbmRpY2VzKClgIHRvIHNldCBhbmQgZ2V0IHRoZSBpbmRpY2VzIG9uIGFuXG4gKiBpbmRpY2VzIHZhcmlhYmxlLlxuICogLSB0byBtYW5pcHVsYXRlIGRhdGEsIHVzZSBgc2V0KClgL2BnZXQoKWAgdG8gYWNjZXNzIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgZnJvbSBwYXJhbWV0ZXIgbGlzdCwgdXNlXG4gKiBgc2V0QnlJbmRpY2VzKClgL2BnZXRCeUluZGljZXMoKWAgdG8gYWNjZXNzIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgZnJvbSBhbiBpbmRpY2VzIHZhcmlhYmxlLCBhbmQgdXNlXG4gKiBgc2V0QnlPZmZzZXQoKWAvYGdldEJ5T2Zmc2V0KClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKiAtIGBpbXBsYDogZ2V0IFdHU0wgY29kZSBvZiBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHV0aWwgZnVuY3Rpb25zIG1lbnRpb25lZCBhYm92ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmRpY2VzSGVscGVyIHtcbiAgLyoqXG4gICAqIGdldCBXR1NMIGNvZGUgb2YgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1dGlsIGZ1bmN0aW9ucy5cbiAgICpcbiAgICovXG4gIHJlYWRvbmx5IGltcGw6ICgpID0+IHN0cmluZztcblxuICAvKipcbiAgICogZ2V0IHR5cGUgaW5mb1xuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogSW5kaWNlc0hlbHBlclR5cGVzO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYSBleHByZXNzaW9uIGZvciBnZXR0aW5nIGluZGljZXMgZnJvbSBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJPZmZzZXQgLSBhIHUzMiBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBvZmZzZXRUb0luZGljZXM6ICh2YXJPZmZzZXQ6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYW4gYHUzMmAgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBvZmZzZXQgZnJvbSBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIGluZGljZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXNUb09mZnNldDogKHZhckluZGljZXM6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYW4gYHUzMmAgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBvcmlnaW5hbCBvZmZzZXQgZnJvbSBicm9hZGNhc3RlZCBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIG91dHB1dCBpbmRpY2VzLlxuICAgKiBAcGFyYW0gb3V0cHV0IC0gb3V0cHV0IEluZGljZXNIZWxwZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiAodmFySW5kaWNlczogc3RyaW5nLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGdlbmVyYXRpbmcgYW4gaW5kaWNlcyBsaXRlcmFsXG4gICAqXG4gICAqIEBwYXJhbSBpbml0IC0gaW5pdGlhbCB2YWx1ZS5cbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXM6ICguLi5pbml0OiBSZWFkb25seUFycmF5PG51bWJlcnxzdHJpbmc+KSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGluZGljZXMgdG8gc2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICpcbiAgICogQHJldHVybnMgYSBXR1NMIHN0YXRlbWVudFxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc1NldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXJ8c3RyaW5nLCB2YWx1ZTogbnVtYmVyfHN0cmluZykgPT4gdm9pZDtcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRpY2VzLlxuICAgKiBAcGFyYW0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBpbmRpY2VzIHRvIGdldC4gY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzR2V0OiAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlcnxzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kaWNlc0FuZFZhbHVlIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcywgZm9sbG93ZWRcbiAgICogICAgIGJ5IHRoZSB2YWx1ZSB0byBzZXQuIFRoaXMgYXJyYXkgc2hvdWxkIGhhdmUgZXhhY3RseSBgc2hhcGUubGVuZ3RoICsgMWAgZWxlbWVudHMuXG4gICAqL1xuICByZWFkb25seSBzZXQ6ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyfHN0cmluZz4pID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIHNob3VsZCBiZSBhIFdHU0wgZXhwcmVzc2lvbi5cbiAgICovXG4gIHJlYWRvbmx5IHNldEJ5SW5kaWNlczogKHZhckluZGljZXM6IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCAtIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0LlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gc2V0LiBzaG91bGQgYmUgYSBXR1NMIGV4cHJlc3Npb24uXG4gICAqL1xuICByZWFkb25seSBzZXRCeU9mZnNldDogKG9mZnNldDogbnVtYmVyfHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIGluZGljZXMgLSBhbiBhcnJheSBvZiBudW1iZXJzIG9yIHN0cmluZ3MgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgZ2V0OiAoLi4uaW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXJ8c3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRpY2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgZ2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cbiAgICovXG4gIHJlYWRvbmx5IGdldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXJ8c3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIG5hbWUgb2YgdGhlIGRhdGEgdmFyaWFibGVcbiAgICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogd2hldGhlciB0aGUgaGVscGVyIGlzIGZvciBhbiBpbnB1dCwgYW4gb3V0cHV0IG9yIGFuIGludGVybmFsIHZhcmlhYmxlLlxuICAgKi9cbiAgcmVhZG9ubHkgdXNhZ2U6ICdpbnB1dCd8J291dHB1dCd8J2ludGVybmFsJztcblxuICAvKipcbiAgICogdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHJhbms6IG51bWJlcjtcblxuICAvKipcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHNoYXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFyaWFibGUgbmFtZSBmb3IgdGhlIHN0cmlkZXMgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHN0cmlkZXM6IHN0cmluZztcbn1cblxuY29uc3QgZ2V0V2dzbE1hcHBlZFR5cGUgPSAodHlwZTogbnVtYmVyLCBjb21wb25lbnRzOiAxfDJ8M3w0KTogc3RyaW5nfFtzdHJpbmcsIHN0cmluZ10gPT4ge1xuICBpZiAoY29tcG9uZW50cyA9PT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcigndmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZCcpO1xuICB9XG5cbiAgLy8gcmV0dXJuIHR5cGUgaXMgWyBzdG9yYWdlIHR5cGUsIHJ1bnRpbWUgdHlwZSBdIG9yIGEgc2luZ2xlIHN0cmluZyBmb3IgYm90aFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxmMTY+YCA6ICdmMTYnO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQ6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxmMzI+YCA6ICdmMzInO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MzI6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTxpMzI+YCA6ICdpMzInO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMgPiAxID8gYHZlYyR7Y29tcG9uZW50c308dTMyPmAgOiAndTMyJztcbiAgICBjYXNlIERhdGFUeXBlLmludDY0OlxuICAgICAgaWYgKGNvbXBvbmVudHMgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWyd2ZWMyPHUzMj4nLCAnaTMyJ107XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NjQ6XG4gICAgICBpZiAoY29tcG9uZW50cyA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3ZlYzI8dTMyPicsICd1MzInXTtcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XG4gICAgICBpZiAoY29tcG9uZW50cyAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jvb2wgbXVzdCBiZSB2ZWM0Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gWyd1MzInLCAndmVjNDxib29sPiddO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMXwyfDN8NCA9IDEpID0+IHtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMF07XG59O1xuXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMXwyfDN8NCA9IDEpID0+IHtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMV07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMgPSAoLi4uZGltczogUmVhZG9ubHlBcnJheTxyZWFkb25seSBudW1iZXJbXT4pOiBQcm9ncmFtVW5pZm9ybVtdID0+IHtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XG4gIGRpbXMuZm9yRWFjaChkaW0gPT4ge1xuICAgIGlmIChkaW0ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkaW19LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZGltKX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm9ncmFtVW5pZm9ybXM7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBtYXhpbXVtIHZlY3RvciBzaXplIGZvciBzcGVjaWZpZWQgZGF0YSBsZW5ndGhcbiAqIEBwYXJhbSBzaXplXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRNYXhDb21wb25lbnRzID0gKHNpemU6IG51bWJlcikgPT4ge1xuICAvLyB3ZSBjYW5ub3QgdXNlIHZlYzMgdHlwZSBzaW5jZSBpdCBoYXMgYWxpZ25tZW50IG9mIDE2IGJ5dGVzXG4gIGlmIChzaXplICUgNCA9PT0gMCkge1xuICAgIHJldHVybiA0O1xuICB9IGVsc2UgaWYgKHNpemUgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIDI7XG4gIH1cblxuICByZXR1cm4gMTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB2YXJpYWJsZSBhcyBhIHNjYWxhciBvciB2ZWN0b3IuIGUuZy4gZjMyKDApIG9yIHZlYzRmKDAsMCwwLDApXG4gKiBAcGFyYW0gZGF0YVR5cGVcbiAqIEBwYXJhbSBjb21wb25lbnRzXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbGxWZWN0b3IgPSAoZGF0YVR5cGUgPSAnZjMyJywgY29tcG9uZW50cz86IG51bWJlciwgdmFsdWUgPSAnMCcpID0+IHtcbiAgaWYgKCFjb21wb25lbnRzIHx8IGNvbXBvbmVudHMgPT09IDEpIHtcbiAgICByZXR1cm4gYCR7ZGF0YVR5cGV9KCR7dmFsdWV9KWA7XG4gIH1cblxuICByZXR1cm4gYHZlYyR7Y29tcG9uZW50c308JHtkYXRhVHlwZX0+KCR7dmFsdWV9KWA7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY2FzdHMgdmFsdWUgb3IgdmVjdG9yIHRvIGYzMlxuICogQHBhcmFtIGRhdGFUeXBlXG4gKiBAcGFyYW0gY29tcG9uZW50c1xuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBjYXN0VG9GMzIgPSAoZGF0YVR5cGU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gIGlmIChkYXRhVHlwZSA9PT0gJ2YzMicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGNvbXBvbmVudHMgPT09IDEpIHtcbiAgICByZXR1cm4gYGYzMigke3ZhbHVlfSlgO1xuICB9XG5cbiAgcmV0dXJuIGB2ZWMke2NvbXBvbmVudHN9PGYzMj4oJHt2YWx1ZX0pYDtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHNjYWxhciBvciBzdW1zIGFsbCBjb21wb25lbnRzIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0gbmFtZVxuICogQHBhcmFtIGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IHN1bVZlY3RvciA9IChuYW1lOiBzdHJpbmcsIGNvbXBvbmVudHM6IG51bWJlcikgPT4ge1xuICBpZiAoY29tcG9uZW50cyA9PT0gNCkge1xuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSArICR7bmFtZX0ueiArICR7bmFtZX0udylgO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDIpIHtcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkpYDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55ICsgJHtuYW1lfS56KWA7XG4gIH1cblxuICByZXR1cm4gbmFtZTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHZhcmlhYmxlIGVsZW1lbnQgYXQgaW5kZXguXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHZhcmlhYmxlLlxuICogQHBhcmFtIGluZGV4IC0gdGhlIGluZGV4IG9mIHZhcmlhYmxlIGVsZW1lbnQuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB2YXJpYWJsZS5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHR5cGUgb2YgdmFyaWFibGUsIG9wdGlvbmFsLlxuICovXG5leHBvcnQgY29uc3QgZ2V0RWxlbWVudEF0ID1cbiAgICAobmFtZTogc3RyaW5nLCBpbmRleDogbnVtYmVyfHN0cmluZywgbGVuZ3RoOiBudW1iZXIsIHR5cGU/OiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlKTogc3RyaW5nID0+IHtcbiAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VuaWZvcm1zLicpICYmIGxlbmd0aCA+IDQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoaW5kZXgpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9Wygke2luZGV4fSkgLyA4XVsoJHtpbmRleH0pICUgOCAvIDRdWygke2luZGV4fSkgJSA4ICUgNF1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bKCR7aW5kZXh9KSAvIDRdWygke2luZGV4fSkgJSA0XWA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7TWF0aC5mbG9vcihpbmRleCAvIDgpfV1bJHtNYXRoLmZsb29yKGluZGV4ICUgOCAvIDQpfV1bJHtpbmRleCAlIDggJSA0fV1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtNYXRoLmZsb29yKGluZGV4IC8gNCl9XVske2luZGV4ICUgNH1dYDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZW5ndGggPiAxID8gYCR7bmFtZX1bJHtpbmRleH1dYCA6IG5hbWU7XG4gICAgICB9XG4gICAgfTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSBJbmRpY2VzSGVscGVyIGZvciBhIGdpdmVuIGlucHV0IG9yIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXG4gKiBAcGFyYW0gdGVuc29yVHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICogQHBhcmFtIHVzYWdlIC0gdGhlIHVzYWdlIG9mIHRoZSBpbmRpY2VzIGhlbHBlci5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiBlYWNoIGVsZW1lbnQuIDEgZm9yIHNjYWxhciwgMiBmb3IgdmVjMiwgMyBmb3IgdmVjMywgNCBmb3JcbiAqICAgIHZlYzQuXG4gKi9cbmNvbnN0IGNyZWF0ZUluZGljZXNIZWxwZXIgPVxuICAgIChuYW1lOiBzdHJpbmcsIHRlbnNvclR5cGU6IG51bWJlciwgc2hhcGVPclJhbms6IG51bWJlcnxyZWFkb25seSBudW1iZXJbXSwgdXNhZ2U6IEluZGljZXNIZWxwZXJbJ3VzYWdlJ10sXG4gICAgIGNvbXBvbmVudHM6IDF8MnwzfDQpOiBJbmRpY2VzSGVscGVyID0+IHtcbiAgICAgIGNvbnN0IHVzZVVuaWZvcm0gPSB0eXBlb2Ygc2hhcGVPclJhbmsgPT09ICdudW1iZXInO1xuICAgICAgY29uc3QgcmFuayA9IHVzZVVuaWZvcm0gPyBzaGFwZU9yUmFuayA6IHNoYXBlT3JSYW5rLmxlbmd0aDtcbiAgICAgIGNvbnN0IHJhbmtJZGVudGl0eSA9IFsuLi5uZXcgQXJyYXkocmFuaykua2V5cygpXTtcbiAgICAgIGNvbnN0IGluZGljZXNUeXBlID0gcmFuayA8IDIgPyAndTMyJyA6IHJhbmsgPD0gNCA/IGB2ZWMke3Jhbmt9PHUzMj5gIDogYGFycmF5PHUzMiwgJHtyYW5rfT5gO1xuICAgICAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHRlbnNvclR5cGUsIGNvbXBvbmVudHMpO1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMV07XG4gICAgICBjb25zdCBzdG9yYWdlVHlwZSA9IHR5cGVvZiBtYXBwZWRUeXBlID09PSAnc3RyaW5nJyA/IG1hcHBlZFR5cGUgOiBtYXBwZWRUeXBlWzBdO1xuICAgICAgY29uc3QgdHlwZSA9IHtpbmRpY2VzOiBpbmRpY2VzVHlwZSwgdmFsdWU6IHZhbHVlVHlwZSwgc3RvcmFnZTogc3RvcmFnZVR5cGUsIHRlbnNvcjogdGVuc29yVHlwZX07XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZURpbSA9IChkaW06IG51bWJlcnxzdHJpbmcpOiBzdHJpbmcgPT4gdHlwZW9mIGRpbSA9PT0gJ3N0cmluZycgPyBkaW0gOiBgJHtkaW19dWA7XG5cbiAgICAgIGNvbnN0IGltcGxlbWVudGF0aW9uVXNlZCA9IHtcbiAgICAgICAgb2Zmc2V0VG9JbmRpY2VzOiBmYWxzZSxcbiAgICAgICAgaW5kaWNlc1RvT2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6IGZhbHNlLFxuICAgICAgICBzZXQ6IGZhbHNlLFxuICAgICAgICBzZXRCeUluZGljZXM6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBnZXRCeUluZGljZXM6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgdW5pZm9ybVByZWZpeCA9IHVzZVVuaWZvcm0gPyAndW5pZm9ybXMuJyA6ICcnO1xuICAgICAgY29uc3Qgc2hhcGUgPSBgJHt1bmlmb3JtUHJlZml4fSR7bmFtZX1fc2hhcGVgO1xuICAgICAgY29uc3Qgc3RyaWRlcyA9IGAke3VuaWZvcm1QcmVmaXh9JHtuYW1lfV9zdHJpZGVzYDtcblxuICAgICAgbGV0IG8yaVNuaXBwZXQgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7IGkrKykge1xuICAgICAgICBvMmlTbmlwcGV0ICs9IGBcbiAgICBsZXQgZGltJHtpfSA9IGN1cnJlbnQgLyAke2dldEVsZW1lbnRBdChzdHJpZGVzLCBpLCByYW5rKX07XG4gICAgbGV0IHJlc3Qke2l9ID0gY3VycmVudCAlICR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfTtcbiAgICBpbmRpY2VzWyR7aX1dID0gZGltJHtpfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7aX07XG4gICAgYDtcbiAgICAgIH1cbiAgICAgIG8yaVNuaXBwZXQgKz0gYGluZGljZXNbJHtyYW5rIC0gMX1dID0gY3VycmVudDtgO1xuXG4gICAgICBjb25zdCBvZmZzZXRUb0luZGljZXNJbXBsZW1lbnRhdGlvbiA9IHJhbmsgPCAyID8gJycgOiBgXG4gIGZuIG8yaV8ke25hbWV9KG9mZnNldDogdTMyKSAtPiAke3R5cGUuaW5kaWNlc30ge1xuICAgIHZhciBpbmRpY2VzOiAke3R5cGUuaW5kaWNlc307XG4gICAgdmFyIGN1cnJlbnQgPSBvZmZzZXQ7XG4gICAgJHtvMmlTbmlwcGV0fVxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9YDtcblxuICAgICAgY29uc3Qgb2Zmc2V0VG9JbmRpY2VzID0gKHZhck9mZnNldDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5vZmZzZXRUb0luZGljZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmFuayA8IDIgPyB2YXJPZmZzZXQgOiBgbzJpXyR7bmFtZX0oJHt2YXJPZmZzZXR9KWA7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvZmZzZXRzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgaWYgKHJhbmsgPj0gMikge1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgb2Zmc2V0cy5wdXNoKGAke2dldEVsZW1lbnRBdChzdHJpZGVzLCBpLCByYW5rKX0gKiAoaW5kaWNlc1ske2l9XSlgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbiA9IHJhbmsgPCAyID8gJycgOiBgXG4gIGZuIGkyb18ke25hbWV9KGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICByZXR1cm4gJHtvZmZzZXRzLmpvaW4oJysnKX07XG4gIH1gO1xuXG4gICAgICBjb25zdCBpbmRpY2VzVG9PZmZzZXQgPSAodmFySW5kaWNlczogc3RyaW5nKSA9PiB7XG4gICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmFuayA8IDIgPyB2YXJJbmRpY2VzIDogYGkyb18ke25hbWV9KCR7dmFySW5kaWNlc30pYDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZGljZXMgPSAoLi4uaW5pdDogUmVhZG9ubHlBcnJheTxudW1iZXJ8c3RyaW5nPikgPT5cbiAgICAgICAgICByYW5rID09PSAwID8gJzB1JyA6IGAke3R5cGUuaW5kaWNlc30oJHtpbml0Lm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKX0pYDtcblxuICAgICAgY29uc3QgaW5kaWNlc0dldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyfHN0cmluZykgPT4ge1xuICAgICAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gYCR7dmFySW5kaWNlc31gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgJHtnZXRFbGVtZW50QXQodmFySW5kaWNlcywgaWR4LCByYW5rKX1gO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbmRpY2VzU2V0ID0gKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXJ8c3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgICAgIHJldHVybiBgJHt2YXJJbmRpY2VzfT0ke3ZhbHVlfTtgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgJHtnZXRFbGVtZW50QXQodmFySW5kaWNlcywgaWR4LCByYW5rKX09JHt2YWx1ZX07YDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbjoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgICAgIGNvbnN0IGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0ID0gKHZhckluZGljZXM6IHN0cmluZywgb3V0cHV0OiBJbmRpY2VzSGVscGVyKSA9PiB7XG4gICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGltcGxLZXkgPSBgJHtvdXRwdXQubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7bmFtZX1PZmZzZXRgO1xuICAgICAgICBpZiAoaW1wbEtleSBpbiBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2ltcGxLZXl9KCR7dmFySW5kaWNlc30pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBpZHggPSBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGkgKyBvdXRwdXQucmFuayAtIHJhbmspO1xuICAgICAgICAgIG9mZnNldHMucHVzaChgJHtpbmRpY2VzR2V0KHN0cmlkZXMsIGkpfSAqICgke2lkeH0gJSAke2luZGljZXNHZXQoc2hhcGUsIGkpfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uW2ltcGxLZXldID1cbiAgICAgICAgICAgIGBmbiAke2ltcGxLZXl9KG91dHB1dEluZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICAgcmV0dXJuICR7b2Zmc2V0cy5sZW5ndGggPiAwID8gb2Zmc2V0cy5qb2luKCcrJykgOiAnMHUnfTtcbiAgICAgICAgICAgfWA7XG5cbiAgICAgICAgcmV0dXJuIGAke2ltcGxLZXl9KCR7dmFySW5kaWNlc30pYDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNldEJ5T2Zmc2V0ID0gKG9mZnNldDogbnVtYmVyfHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGUuc3RvcmFnZSA9PT0gdHlwZS52YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPSR7dmFsdWV9O2A7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAnaTMyJykge1xuICAgICAgICAgIC8vIGludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09dmVjMjx1MzI+KHUzMigke3ZhbHVlfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7dmFsdWV9IDwgMCkpO2A7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAndTMyJykge1xuICAgICAgICAgIC8vIHVpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPXZlYzI8dTMyPih1MzIoJHt2YWx1ZX0pLCAwdSk7YDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd1MzInICYmIHR5cGUudmFsdWUgPT09ICd2ZWM0PGJvb2w+Jykge1xuICAgICAgICAgIC8vIGJvb2wsIGNvbXBvbmVudHMgPT09IDRcbiAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke3ZhbHVlfSkpO2A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3R5cGUuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt0eXBlLnZhbHVlfSB5ZXRgKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcblxuICAgICAgY29uc3QgZ2V0QnlPZmZzZXQgPSAob2Zmc2V0OiBudW1iZXJ8c3RyaW5nKSA9PiAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZS5zdG9yYWdlID09PSB0eXBlLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV1gO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3ZlYzI8dTMyPicgJiYgdHlwZS52YWx1ZSA9PT0gJ2kzMicpIHtcbiAgICAgICAgICAvLyBpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICAgIHJldHVybiBgaTMyKCR7bmFtZX1bJHtvZmZzZXR9XS54KWA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAndTMyJykge1xuICAgICAgICAgIC8vIHVpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICAgIHJldHVybiBgdTMyKCR7bmFtZX1bJHtvZmZzZXR9XS54KWA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndTMyJyAmJiB0eXBlLnZhbHVlID09PSAndmVjNDxib29sPicpIHtcbiAgICAgICAgICAvLyBib29sLCBjb21wb25lbnRzID09PSA0XG4gICAgICAgICAgcmV0dXJuIGB2ZWM0PGJvb2w+KGJvb2woJHtuYW1lfVske29mZnNldH1dICYgMHhGRnUpLCBib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkYwMHUpLCBib29sKCR7bmFtZX1bJHtcbiAgICAgICAgICAgICAgb2Zmc2V0fV0gJiAweEZGMDAwMHUpLCBib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkYwMDAwMDB1KSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt0eXBlLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7dHlwZS52YWx1ZX0geWV0YCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG5cbiAgICAgIGNvbnN0IGdldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uID0gcmFuayA8IDIgPyAnJyA6IGBcbiAgZm4gZ2V0XyR7bmFtZX1CeUluZGljZXMoaW5kaWNlczogJHt0eXBlLmluZGljZXN9KSAtPiAke3ZhbHVlVHlwZX0ge1xuICAgIHJldHVybiAke2dldEJ5T2Zmc2V0KGBpMm9fJHtuYW1lfShpbmRpY2VzKWApfTtcbiAgfWA7XG5cbiAgICAgIGNvbnN0IGdldEltcGxlbWVudGF0aW9uID0gcmFuayA8IDIgPyAnJyA6ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcChpID0+IGBkJHtpfTogdTMyYCkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3QgZGltc1BhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoaSA9PiBgZCR7aX1gKS5qb2luKCcsICcpO1xuICAgICAgICByZXR1cm4gYFxuICBmbiBnZXRfJHtuYW1lfSgke2Z1bmN0aW9uUGFyYW1zfSkgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICByZXR1cm4gZ2V0XyR7bmFtZX1CeUluZGljZXMoJHtpbmRpY2VzKGRpbXNQYXJhbXMpfSk7XG4gIH1gO1xuICAgICAgfSkoKTtcblxuICAgICAgY29uc3QgZ2V0ID0gKC4uLmluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyfHN0cmluZz4pID0+IHtcbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoICE9PSByYW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7cmFua31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRpY2VzID0gaW5kaWNlcy5tYXAobm9ybWFsaXplRGltKS5qb2luKCcsJyk7XG5cbiAgICAgICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZ2V0QnlPZmZzZXQoJzB1Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBnZXRCeU9mZnNldChub3JtYWxpemVkSW5kaWNlc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldCA9IHRydWU7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGBnZXRfJHtuYW1lfSgke25vcm1hbGl6ZWRJbmRpY2VzfSlgO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBnZXRCeUluZGljZXMgPSAodmFySW5kaWNlczogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgICAgIHJldHVybiBnZXRCeU9mZnNldCh2YXJJbmRpY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzID0gdHJ1ZTtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYGdldF8ke25hbWV9QnlJbmRpY2VzKCR7dmFySW5kaWNlc30pYDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24gPSByYW5rIDwgMiA/ICcnIDogYFxuICBmbiBzZXRfJHtuYW1lfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30sIHZhbHVlOiAke3ZhbHVlVHlwZX0pIHtcbiAgICAke3NldEJ5T2Zmc2V0KGBpMm9fJHtuYW1lfShpbmRpY2VzKWAsICd2YWx1ZScpfVxuICB9YDtcblxuICAgICAgY29uc3Qgc2V0SW1wbGVtZW50YXRpb24gPSByYW5rIDwgMiA/ICcnIDogKCgpID0+IHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25QYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKGkgPT4gYGQke2l9OiB1MzJgKS5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCBkaW1zUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcChpID0+IGBkJHtpfWApLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBgXG4gIGZuIHNldF8ke25hbWV9KCR7ZnVuY3Rpb25QYXJhbXN9LCB2YWx1ZTogJHt2YWx1ZVR5cGV9KSB7XG4gICAgc2V0XyR7bmFtZX1CeUluZGljZXMoJHtpbmRpY2VzKGRpbXNQYXJhbXMpfSwgdmFsdWUpO1xuICB9YDtcbiAgICAgIH0pKCk7XG5cbiAgICAgIGNvbnN0IHNldCA9ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyfHN0cmluZz4pID0+IHtcbiAgICAgICAgaWYgKGluZGljZXNBbmRWYWx1ZS5sZW5ndGggIT09IHJhbmsgKyAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7cmFua31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGluZGljZXNBbmRWYWx1ZVtyYW5rXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkSW5kaWNlcyA9IGluZGljZXNBbmRWYWx1ZS5zbGljZSgwLCByYW5rKS5tYXAobm9ybWFsaXplRGltKS5qb2luKCcsJyk7XG5cbiAgICAgICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc2V0QnlPZmZzZXQoJzB1JywgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gc2V0QnlPZmZzZXQobm9ybWFsaXplZEluZGljZXNbMF0sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuc2V0ID0gdHJ1ZTtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzID0gdHJ1ZTtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYHNldF8ke25hbWV9KCR7bm9ybWFsaXplZEluZGljZXN9LCAke3ZhbHVlfSlgO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRCeUluZGljZXMgPSAodmFySW5kaWNlczogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgICAgIHJldHVybiBzZXRCeU9mZnNldCh2YXJJbmRpY2VzLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLnNldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGBzZXRfJHtuYW1lfUJ5SW5kaWNlcygke3ZhckluZGljZXN9LCAke3ZhbHVlfSk7YDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgaW1wbCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgaW1wbHMgPSBbXTtcbiAgICAgICAgbGV0IG5lZWRTaGFwZVN0cmlkZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5vZmZzZXRUb0luZGljZXMpIHtcbiAgICAgICAgICBpbXBscy5wdXNoKG9mZnNldFRvSW5kaWNlc0ltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCkge1xuICAgICAgICAgIGltcGxzLnB1c2goaW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQpIHtcbiAgICAgICAgICBPYmplY3QudmFsdWVzKGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24pLmZvckVhY2goaW1wbCA9PiBpbXBscy5wdXNoKGltcGwpKTtcbiAgICAgICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLnNldCkge1xuICAgICAgICAgIGltcGxzLnB1c2goc2V0SW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzKSB7XG4gICAgICAgICAgaW1wbHMucHVzaChzZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbik7XG4gICAgICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5nZXQpIHtcbiAgICAgICAgICBpbXBscy5wdXNoKGdldEltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmdldEJ5SW5kaWNlcykge1xuICAgICAgICAgIGltcGxzLnB1c2goZ2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXNlVW5pZm9ybSAmJiBuZWVkU2hhcGVTdHJpZGVzKSB7XG4gICAgICAgICAgaW1wbHMudW5zaGlmdChcbiAgICAgICAgICAgICAgYGNvbnN0ICR7c2hhcGV9ID0gJHt0eXBlLmluZGljZXN9KCR7c2hhcGVPclJhbmsuam9pbignLCcpfSk7YCxcbiAgICAgICAgICAgICAgYGNvbnN0ICR7c3RyaWRlc30gPSAke3R5cGUuaW5kaWNlc30oJHtTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoc2hhcGVPclJhbmspLmpvaW4oJywnKX0pO2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbXBscy5qb2luKCdcXG4nKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGltcGwsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG9mZnNldFRvSW5kaWNlcyxcbiAgICAgICAgaW5kaWNlc1RvT2Zmc2V0LFxuICAgICAgICBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldCxcbiAgICAgICAgaW5kaWNlcyxcbiAgICAgICAgaW5kaWNlc0dldCxcbiAgICAgICAgaW5kaWNlc1NldCxcbiAgICAgICAgc2V0LFxuICAgICAgICBzZXRCeU9mZnNldCxcbiAgICAgICAgc2V0QnlJbmRpY2VzLFxuICAgICAgICBnZXQsXG4gICAgICAgIGdldEJ5T2Zmc2V0LFxuICAgICAgICBnZXRCeUluZGljZXMsXG4gICAgICAgIC8vIGlzVmVjNCxcbiAgICAgICAgdXNhZ2UsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHN0cmlkZXMsXG4gICAgICAgIHNoYXBlLFxuICAgICAgICByYW5rXG4gICAgICB9O1xuICAgIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSBpbnB1dC4gYXZhaWxhYmxlIHZhbHVlcyBhcmUgMSwgMiwgMywgNC4gZGVmYXVsdCBpcyAxLlxuICogQHJldHVybnMgYW4gSW5kaWNlc0hlbHBlciBmb3IgdGhlIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgaW5wdXRWYXJpYWJsZSA9XG4gICAgKG5hbWU6IHN0cmluZywgdHlwZTogbnVtYmVyLCBzaGFwZU9yUmFuazogbnVtYmVyfHJlYWRvbmx5IG51bWJlcltdLCBjb21wb25lbnRzOiAxfDJ8M3w0ID0gMSk6IEluZGljZXNIZWxwZXIgPT5cbiAgICAgICAgY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ2lucHV0JywgY29tcG9uZW50cyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgSW5kaWNlc0hlbHBlciBmb3IgYW4gb3V0cHV0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgb3V0cHV0LiBhdmFpbGFibGUgdmFsdWVzIGFyZSAxLCAyLCAzLCA0LiBkZWZhdWx0IGlzIDEuXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgb3V0cHV0LlxuICovXG5leHBvcnQgY29uc3Qgb3V0cHV0VmFyaWFibGUgPVxuICAgIChuYW1lOiBzdHJpbmcsIHR5cGU6IG51bWJlciwgc2hhcGVPclJhbms6IG51bWJlcnxyZWFkb25seSBudW1iZXJbXSwgY29tcG9uZW50czogMXwyfDN8NCA9IDEpOiBJbmRpY2VzSGVscGVyID0+XG4gICAgICAgIGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdvdXRwdXQnLCBjb21wb25lbnRzKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIHZhcmlhYmxlLlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIHZhcmlhYmxlLiBhdmFpbGFibGUgdmFsdWVzIGFyZSAxLCAyLCAzLCA0LiBkZWZhdWx0IGlzIDEuXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbFZhcmlhYmxlID1cbiAgICAobmFtZTogc3RyaW5nLCB0eXBlOiBudW1iZXIsIHNoYXBlT3JSYW5rOiBudW1iZXJ8cmVhZG9ubHkgbnVtYmVyW10sIGNvbXBvbmVudHM6IDF8MnwzfDQgPSAxKTogSW5kaWNlc0hlbHBlciA9PlxuICAgICAgICBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnaW50ZXJuYWwnLCBjb21wb25lbnRzKTtcblxuZXhwb3J0IHR5cGUgVW5pZm9ybURhdGFFbGVtZW50VHlwZSA9ICd1MzInfCdmMTYnfCdmMzInfCdpMzInO1xuZXhwb3J0IHR5cGUgVW5pZm9ybXNBcnJheVR5cGUgPSBBcnJheTx7bmFtZTogc3RyaW5nOyB0eXBlOiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlOyBsZW5ndGg/OiBudW1iZXJ9PjtcblxuLyoqXG4gKiBBIFNoYWRlckhlbHBlciBpcyBhIGhlbHBlciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBXR1NMIGNvZGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVySGVscGVyIHtcbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBzdGFydCBvZiBtYWluIGZ1bmN0aW9uIGluIFdHU0wgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgKiAgLi4uXG4gICAqXG4gICAqICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICogICAgLy8geW91ciBjb2RlIGhlcmUgaW5zaWRlIG1haW4oKSBmdW5jdGlvblxuICAgKiAgICAuLi5cbiAgICogIH1cbiAgICogYDtcbiAgICpcbiAgICogQHBhcmFtIHdvcmtncm91cFNpemUgLSBhbiBvcHRpb25hbCB3b3JrZ3JvdXAgc2l6ZS4gZGVmYXVsdCBpcyBXT1JLR1JPVVBfU0laRS5cbiAgICovXG4gIG1haW5TdGFydCh3b3JrZ3JvdXBTaXplPzogbnVtYmVyfFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IHN0cmluZztcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNvZGUgc25pcHBldCBmb3IgZ3VhcmRpbmcgYWdhaW5zdCBvdXQtb2YtYm91bmRzIHNpemUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgKiAgLi4uXG4gICAqXG4gICAqICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICogICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cbiAgICpcbiAgICogICAgLy8geW91ciBjb2RlIGhlcmUgaW5zaWRlIG1haW4oKSBmdW5jdGlvblxuICAgKiAgICAuLi5cbiAgICogIH1cbiAgICogYDtcbiAgICpcbiAgICogQHBhcmFtIHNpemUgLSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSB0byBndWFyZCBhZ2FpbnN0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqL1xuICBndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHNpemU6IHVua25vd24pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHNuaXBwZXQgZm9yIGRlY2xhcmluZyBtdWx0aXBsZSBpbnB1dHMgb3Igb3V0cHV0cy5cbiAgICpcbiAgICogQHBhcmFtIHZhcmlhYmxlcyAtIGFuIGFycmF5IG9mIEluZGljZXNIZWxwZXIgZm9yIHRoZSB2YXJpYWJsZXMuXG4gICAqL1xuICBkZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBvbmUgdW5pZm9ybS4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgdW5pZm9ybS5cbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiB0aGUgdW5pZm9ybS5cbiAgICogQHBhcmFtIGxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdGhlIHVuaWZvcm0sIGRlZmF1bHQgdG8gMSB3aGVuIGl0IGlzIG5vdCBwcm92aWRlZC5cbiAgICovXG4gIHJlZ2lzdGVyVW5pZm9ybShuYW1lOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgbGVuZ3RoPzogbnVtYmVyKTogU2hhZGVySGVscGVyO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy4gQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBtdWx0aXBsZSB1bmlmb3Jtcy5cbiAgICpcbiAgICogQHBhcmFtIHVuaWZvcm1zIC0gYW4gYXJyYXkgb2YgdW5pZm9ybXMuIEVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgYW4gb2JqZWN0IHdpdGggMiBwcm9wZXJ0aWVzOiBgbmFtZWAgYW5kXG4gICAqICAgICBgdHlwZWAuXG4gICAqL1xuICByZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSk6IFNoYWRlckhlbHBlcjtcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgbXVsdGlwbGUgaW50ZXJuYWwgdmFyaWFibGVzLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlXG4gICAqIGludGVybmFsIHZhcmlhYmxlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhcmlhYmxlcyAtIGFuIGFycmF5IG9mIEluZGljZXNIZWxwZXIgZm9yIHRoZSB2YXJpYWJsZXMuXG4gICAqL1xuICByZWdpc3RlckludGVybmFsVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogU2hhZGVySGVscGVyO1xufVxuXG5jbGFzcyBTaGFkZXJIZWxwZXJJbXBsIGltcGxlbWVudHMgU2hhZGVySGVscGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBub3JtYWxpemVkRGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBwcml2YXRlIGxpbWl0czogR1BVU3VwcG9ydGVkTGltaXRzKSB7fVxuXG4gIGd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoc2l6ZTogbnVtYmVyfHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gR3VhcmQgYWdhaW5zdCBvdXQtb2YtYm91bmRzIHdvcmsgZ3JvdXAgc2l6ZXNcbiAgICBjb25zdCBzaXplSW5Db2RlID0gdHlwZW9mIHNpemUgPT09ICdudW1iZXInID8gYCR7c2l6ZX11YCA6IHNpemU7XG4gICAgcmV0dXJuIGBpZiAoZ2xvYmFsX2lkeCA+PSAke3NpemVJbkNvZGV9KSB7IHJldHVybjsgfWA7XG4gIH1cblxuICBtYWluU3RhcnQod29ya2dyb3VwU2l6ZTogbnVtYmVyfFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFdPUktHUk9VUF9TSVpFKSB7XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVggPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyB3b3JrZ3JvdXBTaXplIDogd29ya2dyb3VwU2l6ZVswXTtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWSA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IDEgOiB3b3JrZ3JvdXBTaXplWzFdO1xuICAgIGNvbnN0IHdvcmtncm91cFNpemVaID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gMSA6IHdvcmtncm91cFNpemVbMl07XG5cbiAgICBpZiAod29ya2dyb3VwU2l6ZVggPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVggfHxcbiAgICAgICAgd29ya2dyb3VwU2l6ZVkgPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVkgfHxcbiAgICAgICAgd29ya2dyb3VwU2l6ZVogPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHtcbiAgICAgICAgICB3b3JrZ3JvdXBTaXplWn1dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIHNpemUgWyR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfSwgJHtcbiAgICAgICAgICB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn1dLmApO1xuICAgIH1cblxuICAgIGlmICh3b3JrZ3JvdXBTaXplWCAqIHdvcmtncm91cFNpemVZICogd29ya2dyb3VwU2l6ZVogPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHtcbiAgICAgICAgICB3b3JrZ3JvdXBTaXplWn1dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIGludm9jYXRpb25zICR7XG4gICAgICAgICAgdGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwfS5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBpczFEaW1lbnNpb25EaXNwYXRjaCA9IHRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV0gPT09IDEgJiYgdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXSA9PT0gMTtcbiAgICBjb25zdCBwYXJhbUxpc3QgPSBpczFEaW1lbnNpb25EaXNwYXRjaCA/IGBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihudW1fd29ya2dyb3VwcykgbnVtX3dvcmtncm91cHMgOiB2ZWMzPHUzMj5gO1xuICAgIGNvbnN0IGdsb2JhbElkeERlZmluaXRpb24gPSBpczFEaW1lbnNpb25EaXNwYXRjaCA/XG4gICAgICAgICdsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54OyBsZXQgbG9jYWxfaWR4ID0gbG9jYWxfaWQueDsnIDpcbiAgICAgICAgYGxldCBnbG9iYWxfaWR4ID0gKHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXG4gICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiBudW1fd29ya2dyb3Vwc1swXSArIHdvcmtncm91cF9pZC54KSAqICR7XG4gICAgICAgICAgICB3b3JrZ3JvdXBTaXplWCAqIHdvcmtncm91cFNpemVZICogd29ya2dyb3VwU2l6ZVp9dSArIGxvY2FsX2lkeDtgO1xuXG4gICAgcmV0dXJuIGBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke3dvcmtncm91cFNpemVafSlcbiAgZm4gbWFpbigke3BhcmFtTGlzdH0pIHtcbiAgICAke2dsb2JhbElkeERlZmluaXRpb259XG4gIGA7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGU6IEluZGljZXNIZWxwZXIpOiB2b2lkIHtcbiAgICBpZiAodmFyaWFibGUucmFuayAhPT0gMCkge1xuICAgICAgaWYgKHZhcmlhYmxlLnNoYXBlLnN0YXJ0c1dpdGgoJ3VuaWZvcm1zLicpKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTogdmFyaWFibGUuc2hhcGUucmVwbGFjZSgndW5pZm9ybXMuJywgJycpLCB0eXBlOiAndTMyJywgbGVuZ3RoOiB2YXJpYWJsZS5yYW5rfSk7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFibGUuc3RyaWRlcy5zdGFydHNXaXRoKCd1bmlmb3Jtcy4nKSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6IHZhcmlhYmxlLnN0cmlkZXMucmVwbGFjZSgndW5pZm9ybXMuJywgJycpLCB0eXBlOiAndTMyJywgbGVuZ3RoOiB2YXJpYWJsZS5yYW5rfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZWNsYXJlVmFyaWFibGUodmFyaWFibGU6IEluZGljZXNIZWxwZXIsIGJpbmRpbmdJbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAodmFyaWFibGUudXNhZ2UgPT09ICdpbnRlcm5hbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSBpbnRlcm5hbCB2YXJpYWJsZSB3aXRoIGRlY2xhcmVWYXJpYWJsZSgpLiB1c2UgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcygpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHRoaXMudmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICAgIHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh2YXJpYWJsZSk7XG5cbiAgICBjb25zdCBhY2Nlc3MgPSB2YXJpYWJsZS51c2FnZSA9PT0gJ2lucHV0JyA/ICdyZWFkJyA6ICdyZWFkX3dyaXRlJztcbiAgICBjb25zdCBzdG9yYWdlVHlwZSA9IHZhcmlhYmxlLnR5cGUuc3RvcmFnZTtcbiAgICByZXR1cm4gYEBncm91cCgwKSBAYmluZGluZygke2JpbmRpbmdJbmRleH0pIHZhcjxzdG9yYWdlLCAke2FjY2Vzc30+ICR7dmFyaWFibGUubmFtZX06IGFycmF5PCR7c3RvcmFnZVR5cGV9PjtgO1xuICB9XG5cbiAgZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhcmlhYmxlcy5tYXAodiA9PiB0aGlzLmRlY2xhcmVWYXJpYWJsZSh2LCB0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckludGVybmFsVmFyaWFibGUodmFyaWFibGU6IEluZGljZXNIZWxwZXIpOiB2b2lkIHtcbiAgICBpZiAodmFyaWFibGUudXNhZ2UgIT09ICdpbnRlcm5hbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlKTtcbiAgfVxuXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXIge1xuICAgIHZhcmlhYmxlcy5mb3JFYWNoKHYgPT4gdGhpcy5yZWdpc3RlckludGVybmFsVmFyaWFibGUodikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVnaXN0ZXJVbmlmb3JtKG5hbWU6IHN0cmluZywgdHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZSwgbGVuZ3RoID0gMSk6IFNoYWRlckhlbHBlciB7XG4gICAgdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lLCB0eXBlLCBsZW5ndGh9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlZ2lzdGVyVW5pZm9ybXMoYWRkaXRpb25hbFVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSk6IFNoYWRlckhlbHBlciB7XG4gICAgdGhpcy51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXMuY29uY2F0KGFkZGl0aW9uYWxVbmlmb3Jtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcml2YXRlIGludGVybmFsVmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10gPSBbXTtcbiAgcHJpdmF0ZSB2YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSA9IFtdO1xuICBwcml2YXRlIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtdO1xuICBwcml2YXRlIHVuaWZvcm1EZWNsYXJhdGlvbigpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1TbmlwcGV0czogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHtuYW1lLCB0eXBlLCBsZW5ndGh9IG9mIHRoaXMudW5pZm9ybXMpIHtcbiAgICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2YxNicpIHtcbiAgICAgICAgICB1bmlmb3JtU25pcHBldHMucHVzaChgQGFsaWduKDE2KSAke25hbWV9OmFycmF5PG1hdDJ4NDwke3R5cGV9PiwgJHtNYXRoLmNlaWwobGVuZ3RoIC8gOCl9PmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGAke25hbWV9OmFycmF5PHZlYzQ8JHt0eXBlfT4sICR7TWF0aC5jZWlsKGxlbmd0aCAvIDQpfT5gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZVRlbXAgPSBsZW5ndGggPT0gbnVsbCB8fCBsZW5ndGggPT09IDEgPyB0eXBlIDogYHZlYyR7bGVuZ3RofTwke3R5cGV9PmA7XG4gICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGAke25hbWV9OiR7dHlwZVRlbXB9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dW5pZm9ybVNuaXBwZXRzLmpvaW4oJywgJyl9IH07XG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2A7XG4gIH1cbiAgcHJpdmF0ZSB2YXJpYWJsZUluZGV4ID0gMDtcblxuICAvKipcbiAgICogR2V0IGFkZGl0aW9uYWwgaW1wbGVtZW50YXRpb24gdGhhdCBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgc2hhZGVyIHNvdXJjZS5cbiAgICovXG4gIGdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkgKyB0aGlzLnZhcmlhYmxlcy5tYXAoaSA9PiBpLmltcGwoKSkuam9pbignXFxuJykgK1xuICAgICAgICB0aGlzLmludGVybmFsVmFyaWFibGVzLm1hcChpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhcmlhYmxlIGluZm8gb2YgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKi9cbiAgZ2V0IHZhcmlhYmxlc0luZm8oKTogUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm9bXXx1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCB1bmlmb3JtV2dzbFR5cGVUb0RhdGFUeXBlID0gKHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUpID0+XG4gICAgICAgIChbRGF0YVR5cGUudWludDMyLCBEYXRhVHlwZS5mbG9hdDE2LCBEYXRhVHlwZS5mbG9hdCxcbiAgICAgICAgICBEYXRhVHlwZS5pbnQzMl1bWyd1MzInLCAnZjE2JywgJ2YzMicsICdpMzInXS5pbmRleE9mKHR5cGUpXSk7XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWFwKHUgPT4gKFt1bmlmb3JtV2dzbFR5cGVUb0RhdGFUeXBlKHUudHlwZSksIHUubGVuZ3RoID8/IDFdKSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNoYWRlckhlbHBlciA9IChkaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGxpbWl0czogR1BVU3VwcG9ydGVkTGltaXRzKSA9PlxuICAgIG5ldyBTaGFkZXJIZWxwZXJJbXBsKGRpc3BhdGNoR3JvdXAsIGxpbWl0cyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvYmxvYi9tYXN0ZXIvdGZqcy1jb3JlL3NyYy9vcHMvYnJvYWRjYXN0X3V0aWwudHMjTDE4LUw0MFxuICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyBpbiB0aGUgaW5wdXQgc2hhcGUgdGhhdCBhcmUgYnJvYWRjYXN0ZWQgdG9cbiAqIHByb2R1Y2UgdGhlIHByb3ZpZGVkIG91dHB1dCBzaGFwZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgZGltZW5zaW9ucyBhcmUgMC1pbmRleGVkIGFuZCBzb3J0ZWQuIEFuIGV4YW1wbGU6XG4gKiBpblNoYXBlID0gWzQsIDEsIDNdXG4gKiBvdXRTaGFwZSA9IFs1LCA0LCAzLCAzXVxuICogcmVzdWx0ID0gWzFdLiBEaW1lbnNpb24gMSAoMm5kIGRpbWVuc2lvbiBvZiBpbnB1dCkgZ2V0cyBicm9hZGNhc3RlZCAxID0+IDMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCcm9hZGNhc3REaW1zID0gKGluU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBvdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGluUmFuayA9IGluU2hhcGUubGVuZ3RoO1xuICBjb25zdCBkaW1zOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgY29uc3QgZGltID0gaW5SYW5rIC0gMSAtIGk7XG4gICAgY29uc3QgYSA9IGluU2hhcGVbZGltXSB8fCAxO1xuICAgIGNvbnN0IGIgPSBvdXRTaGFwZVtvdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICBpZiAoYiA+IDEgJiYgYSA9PT0gMSkge1xuICAgICAgZGltcy51bnNoaWZ0KGRpbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaW1zO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBwZXJtOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkUGVybSA9IChpbnB1dFJhbms6IG51bWJlciwgcGVybTogbnVtYmVyW10pOiBudW1iZXJbXSA9PlxuICAgIChwZXJtICYmIHBlcm0ubGVuZ3RoICE9PSBpbnB1dFJhbmspID8gWy4uLihuZXcgQXJyYXkoaW5wdXRSYW5rKS5rZXlzKCkpXS5yZXZlcnNlKCkgOiBwZXJtO1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGVybTogbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PlxuICAgIFNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oaW5wdXRTaGFwZSwgZ2V0QWRqdXN0ZWRQZXJtKGlucHV0U2hhcGUubGVuZ3RoLCBwZXJtKSk7XG5cbmNvbnN0IHBlcm1GdW5jdGlvbkJvZHkgPSAocGVybTogbnVtYmVyW10sIHJhbms6IG51bWJlciwgaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJldmVyc2VGdW5jID0gW107XG4gIHJldmVyc2VGdW5jLnB1c2goYGZuIHBlcm0oaTogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtpbnB1dC50eXBlLmluZGljZXN9O2ApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgIHJldmVyc2VGdW5jLnB1c2goaW5wdXQuaW5kaWNlc1NldCgnYScsIHBlcm1baV0sIGBpWyR7aX1dYCkpO1xuICB9XG4gIHJldmVyc2VGdW5jLnB1c2goJ3JldHVybiBhO30nKTtcbiAgcmV0dXJuIHJldmVyc2VGdW5jLmpvaW4oJ1xcbicpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvID0gKGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LCBwZXJtQXR0cjogbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0RGF0YVR5cGUgPSBpbnB1dFRlbnNvci5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRUZW5zb3IuZGltcy5sZW5ndGg7XG4gIGNvbnN0IHBlcm0gPSBnZXRBZGp1c3RlZFBlcm0oaW5wdXRSYW5rLCBwZXJtQXR0cik7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZ2V0T3V0cHV0U2hhcGUoaW5wdXRUZW5zb3IuZGltcywgcGVybSk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dERhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dERhdGFUeXBlLCBpbnB1dFJhbmspO1xuICBsZXQgZ2V0U2hhZGVyU291cmNlO1xuICBpZiAocGVybS5sZW5ndGggPT09IDIgJiYgcGVybVswXSA9PT0gMSAmJiBwZXJtWzFdID09PSAwKSB7XG4gICAgY29uc3Qgd2dzbFR5cGUgPSBvdXRwdXQudHlwZS52YWx1ZTtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbMTYsIDE2LCAxXTtcbiAgICBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICB2YXI8d29ya2dyb3VwPiB0aWxlIDogYXJyYXk8YXJyYXk8JHt3Z3NsVHlwZX0sICR7d29ya2dyb3VwU2l6ZVswXSArIDF9PiwgJHt3b3JrZ3JvdXBTaXplWzBdfT47XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCh3b3JrZ3JvdXBTaXplKX1cbiAgICB2YXIgeCA9IHdvcmtncm91cF9pZC54ICogJHt3b3JrZ3JvdXBTaXplWzBdfXUgKyBsb2NhbF9pZC54O1xuICAgIHZhciB5ID0gd29ya2dyb3VwX2lkLnkgKiAke3dvcmtncm91cFNpemVbMF19dSArIGxvY2FsX2lkLnk7XG4gICAgbGV0IHdpZHRoID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzBdO1xuICAgIGxldCBoZWlnaHQgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgaWYgKHggPCB3aWR0aCAmJiB5IDwgaGVpZ2h0KSB7XG4gICAgICB0aWxlW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtpbnB1dC5nZXRCeU9mZnNldCgneSAqIHdpZHRoICsgeCcpfTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIHggPSB3b3JrZ3JvdXBfaWQueSAqICR7d29ya2dyb3VwU2l6ZVswXX11ICsgbG9jYWxfaWQueDtcbiAgICB5ID0gd29ya2dyb3VwX2lkLnggKiAke3dvcmtncm91cFNpemVbMF19dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKHggPCBoZWlnaHQgJiYgeSA8IHdpZHRoKSB7XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgneSAqIGhlaWdodCArIHgnLCAndGlsZVtsb2NhbF9pZC54XVtsb2NhbF9pZC55XScpfVxuICAgIH1cbiAgfWA7XG4gIH0gZWxzZSB7XG4gICAgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cblxuICAke3Blcm1GdW5jdGlvbkJvZHkocGVybSwgaW5wdXRSYW5rLCBpbnB1dCwgb3V0cHV0KX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cbiAgfWA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnVHJhbnNwb3NlJyxcbiAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke3Blcm1BdHRyfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXX0sXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0cykgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOlxuICAgICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpXSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdHJhbnNwb3NlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzLnBlcm0pKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtwZXJtOiBhdHRyaWJ1dGVzLnBlcm0gYXMgbnVtYmVyW119KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVNoYWRlckNhY2hlSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7Y3JlYXRlUmVkdWNlQXR0cmlidXRlc0Zyb21JbnB1dHMsIFJlZHVjZUF0dHJpYnV0ZXN9IGZyb20gJy4vcmVkdWNlJztcbmltcG9ydCB7Y3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm99IGZyb20gJy4vdHJhbnNwb3NlJztcblxuY29uc3QgcmVkdWNlT3BzOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgbWF4OiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpJyxcbiAgbWluOiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpJyxcbiAgbWVhbjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIHN1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIHByb2Q6ICdiZXN0VmFsdWUgKiBjYW5kaWRhdGUnLFxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGUnLFxuICBsb2dTdW1FeHA6ICdiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKScsXG4gIGwxOiAnYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSknLFxuICBsMjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZSdcbn07XG5cbmNvbnN0IHJlZHVjZVNoYXJlZE9wczoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gIG1heDogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKScsXG4gIG1pbjogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKScsXG4gIG1lYW46ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBzdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBwcm9kOiAnYmVzdFZhbHVlICogY2FuZGlkYXRlJyxcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbG9nU3VtRXhwOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbDE6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBsMjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZSdcbn07XG5cbmNvbnN0IHJlZHVjZUluaXRWYWx1ZXM6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICBtYXg6ICdfQVtvZmZzZXRdJyxcbiAgbWluOiAnX0Fbb2Zmc2V0XScsXG4gIG1lYW46ICcwJyxcbiAgc3VtOiAnMCcsXG4gIHByb2Q6ICcxJyxcbiAgc3VtU3F1YXJlOiAnMCcsXG4gIGxvZ1N1bUV4cDogJzAnLFxuICBsMTogJzAnLFxuICBsMjogJzAnLFxuICBsb2dTdW06ICcwJ1xufTtcblxuY29uc3QgcmVkdWNlT3V0cHV0VmFsdWVzOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgbWF4OiAnYmVzdFZhbHVlJyxcbiAgbWluOiAnYmVzdFZhbHVlJyxcbiAgc3VtOiAnYmVzdFZhbHVlJyxcbiAgcHJvZDogJ2Jlc3RWYWx1ZScsXG4gIHN1bVNxdWFyZTogJ2Jlc3RWYWx1ZScsXG4gIGxvZ1N1bUV4cDogJ2xvZyhiZXN0VmFsdWUpJyxcbiAgbDE6ICdiZXN0VmFsdWUnLFxuICBsMjogJ3NxcnQoYmVzdFZhbHVlKScsXG4gIGxvZ1N1bTogJ2xvZyhiZXN0VmFsdWUpJ1xufTtcblxuY29uc3QgZ2V0SW5uZXJNb3N0QXhlcyA9IChudW1Jbm5lckF4ZXM6IG51bWJlciwgcmFuazogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSBudW1Jbm5lckF4ZXM7IGkgPCByYW5rOyArK2kpIHtcbiAgICByZXMucHVzaChpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuY29uc3QgY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyA9IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogW251bWJlcltdLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtdO1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgIG91dHB1dFNoYXBlLnB1c2goc2hhcGVbZGltXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlZHVjZVNoYXBlID0gYXhlcy5tYXAoZGltID0+IHNoYXBlW2RpbV0pO1xuICByZXR1cm4gW291dHB1dFNoYXBlLCByZWR1Y2VTaGFwZV07XG59O1xuXG5jb25zdCBleHBhbmRTaGFwZVRvS2VlcERpbSA9IChzaGFwZTogbnVtYmVyW10sIGF4ZXM6IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoICsgYXhlcy5sZW5ndGg7XG4gIGNvbnN0IGV4cGFuZFNoYXBlID0gW107XG4gIGxldCBzaGFwZUlkeCA9IDA7XG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgZXhwYW5kU2hhcGUucHVzaChzaGFwZVtzaGFwZUlkeCsrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGFuZFNoYXBlLnB1c2goMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHBhbmRTaGFwZTtcbn07XG5cbmNvbnN0IGFyZUF4ZXNJbm5lck1vc3REaW1zID0gKGF4ZXM6IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGF4ZXNbYXhlcy5sZW5ndGggLSBpIC0gMV0gIT09IHJhbmsgLSAxIC0gaSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGdldEF4ZXNQZXJtdXRhdGlvbiA9IChheGVzOiBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByZXMgPSBbXTtcbiAgaWYgKCFhcmVBeGVzSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICByZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXhlcy5mb3JFYWNoKGF4aXMgPT4gcmVzLnB1c2goYXhpcykpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlU2hhcmVkUHJvZ3JhbUluZm8gPVxuICAgIChuYW1lOiBzdHJpbmcsIHNoYWRlckNhY2hlOiBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgcmVkdWNlVHlwZTogc3RyaW5nLFxuICAgICBvdXRwdXREYXRhVHlwZTogRGF0YVR5cGUsIG91dHB1dFNoYXBlOiBudW1iZXJbXSwgcmVkdWNlU2hhcGU6IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuXG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3QgcmVkdWNlU2l6ZSA9IFNoYXBlVXRpbC5zaXplKHJlZHVjZVNoYXBlKTtcblxuICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdfQScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZSk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0Jywgb3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcblxuICAgICAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDMyO1xuXG4gICAgICBjb25zdCBzaGFyZWRNZW1vcnlTbmlwcGV0ID0gYFxuICAgICAgICAgIHZhcjx3b3JrZ3JvdXA+IGFCZXN0VmFsdWVzIDogYXJyYXk8ZjMyLCAke3dvcmtncm91cFNpemV9PjtcbiAgICAgICBgO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdyZWR1Y2VTaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICR7c2hhcmVkTWVtb3J5U25pcHBldH1cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCh3b3JrZ3JvdXBTaXplKX1cblxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke3dvcmtncm91cFNpemV9O1xuICAgICAgICAgIGxldCBvZmZzZXQgPSBvdXRwdXRJbmRleCAqIHVuaWZvcm1zLnJlZHVjZVNpemU7XG5cbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gZjMyKCR7cmVkdWNlSW5pdFZhbHVlc1tyZWR1Y2VUeXBlXX0pO1xuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHt3b3JrZ3JvdXBTaXplfSkge1xuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZjMyKCR7aW5wdXQuZ2V0QnlPZmZzZXQoJ29mZnNldCArIGsnKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke3JlZHVjZU9wc1tyZWR1Y2VUeXBlXX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7d29ya2dyb3VwU2l6ZX11KTtcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke3JlZHVjZVNoYXJlZE9wc1tyZWR1Y2VUeXBlXX07XG4gICAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAobG9jYWxfaWR4ID09IDB1KSB7XG4gICAgICAgICAgJHtcbiAgICAgICAgICBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgICAgICdvdXRwdXRJbmRleCcsXG4gICAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICAgICAgcmVkdWNlVHlwZSA9PT0gJ21lYW4nID8gYCR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oYmVzdFZhbHVlIC8gZjMyKHVuaWZvcm1zLnJlZHVjZVNpemUpKWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oJHtyZWR1Y2VPdXRwdXRWYWx1ZXNbcmVkdWNlVHlwZV19KWB9YCl9O1xuICAgICAgICAgfVxuICAgICAgICB9YDtcblxuICAgICAgLy8gT25lIHdvcmsgZ3JvdXAgaXMgcmVzcG9uc2libGUgZm9yIG9ubHkgb25lIGVsZW1lbnQgb2Ygb3V0cHV0LlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc2hhZGVyQ2FjaGUsXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogb3V0cHV0U2l6ZX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcmVkdWNlU2l6ZX1dXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCByZWR1Y2VDb21tb24gPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgbmFtZTogc3RyaW5nLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLFxuICAgICByZWR1Y2VUeXBlOiAnc3VtJ3wnc3VtU3F1YXJlJ3wncHJvZCd8J21pbid8J21heCd8J21lYW4nfCdsb2dTdW1FeHAnfCdsMSd8J2wyJ3wnbG9nU3VtJyk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMgPVxuICAgICAgICAgIGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG5cbiAgICAgIGxldCB1cGRhdGVkQXhlcyA9IHVwZGF0ZWRBdHRyaWJ1dGVzLmF4ZXM7XG4gICAgICBpZiAodXBkYXRlZEF4ZXMubGVuZ3RoID09PSAwICYmICF1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykge1xuICAgICAgICB1cGRhdGVkQXhlcyA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubWFwKChfZGltLCBpKSA9PiBpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZUF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyh1cGRhdGVkQXhlcywgY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuXG4gICAgICBsZXQgYXhlcyA9IG5vcm1hbGl6ZUF4ZXM7XG4gICAgICBsZXQgaW5wdXQgPSBjb250ZXh0LmlucHV0c1swXTtcbiAgICAgIGNvbnN0IHBlcm11dGVkQXhlcyA9IGdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCBjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gICAgICBpZiAocGVybXV0ZWRBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgICBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgcGVybXV0ZWRBeGVzKSwge2lucHV0czogWzBdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG4gICAgICAgIGF4ZXMgPSBnZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtvdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGVdID0gY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dC5kaW1zLCBheGVzKTtcbiAgICAgIGxldCBmaW5hbE91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICBpZiAodXBkYXRlZEF0dHJpYnV0ZXMua2VlcERpbXMpIHtcbiAgICAgICAgZmluYWxPdXRwdXRTaGFwZSA9IGV4cGFuZFNoYXBlVG9LZWVwRGltKG91dHB1dFNoYXBlLCBub3JtYWxpemVBeGVzKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZVJlZHVjZVNoYXJlZFByb2dyYW1JbmZvKFxuICAgICAgICAgICAgICBuYW1lLCB7aGludDogdXBkYXRlZEF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXX0sIFtpbnB1dF0sIHJlZHVjZVR5cGUsXG4gICAgICAgICAgICAgIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBmaW5hbE91dHB1dFNoYXBlLCByZWR1Y2VTaGFwZSksXG4gICAgICAgICAge2lucHV0czogW2lucHV0XX0pO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNZWFuU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWVhblNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtZWFuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTDFTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMMVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsMScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwyU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTDJTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbDInKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1FeHBTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1FeHBTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbG9nU3VtRXhwJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWF4U2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWF4U2hhcmVkJywgYXR0cmlidXRlcywgJ21heCcpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1pblNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZU1pblNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtaW4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlUHJvZFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdwcm9kJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlU3VtU2hhcmVkJywgYXR0cmlidXRlcywgJ3N1bScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bVNxdWFyZVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZVN1bVNxdWFyZVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdzdW1TcXVhcmUnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbG9nU3VtJyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVNoYWRlckNhY2hlSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge3JlZHVjZUwxU2hhcmVkLCByZWR1Y2VMMlNoYXJlZCwgcmVkdWNlTG9nU3VtRXhwU2hhcmVkLCByZWR1Y2VMb2dTdW1TaGFyZWQsIHJlZHVjZU1heFNoYXJlZCwgcmVkdWNlTWVhblNoYXJlZCwgcmVkdWNlTWluU2hhcmVkLCByZWR1Y2VQcm9kU2hhcmVkLCByZWR1Y2VTdW1TaGFyZWQsIHJlZHVjZVN1bVNxdWFyZVNoYXJlZH0gZnJvbSAnLi9yZWR1Y2Utc2hhcmVkJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCB8fCBpbnB1dHMubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMiAmJiBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXhlcyBpbnB1dCBkaW1zLicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlZHVjZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBrZWVwRGltczogYm9vbGVhbjtcbiAgbm9vcFdpdGhFbXB0eUF4ZXM6IGJvb2xlYW47XG4gIGF4ZXM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgdHlwZSBSZWR1Y2VPcCA9XG4gICAgKGlucHV0OiBJbmRpY2VzSGVscGVyLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gICAgIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCAuLi5zdHJpbmdbXV07XG5cbmNvbnN0IG5vT3A6IFJlZHVjZU9wID0gKGlucHV0KSA9PiBbJycsICcnLCBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCwgJyddO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvID1cbiAgICAobmFtZTogc3RyaW5nLCBzaGFkZXJDYWNoZTogUHJvZ3JhbVNoYWRlckNhY2hlSW5mbywgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIHJlZHVjZU9wOiBSZWR1Y2VPcCxcbiAgICAgYXhlc0lucHV0OiBudW1iZXJbXSwgb3V0cHV0RGF0YVR5cGU6IERhdGFUeXBlLCBrZWVwRGltcyA9IGZhbHNlLCBub29wV2l0aEVtcHR5QXhlcyA9IGZhbHNlKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyhheGVzSW5wdXQsIGlucHV0UmFuayk7XG4gICAgICBjb25zdCByZWR1Y2VPbkFsbEF4ZXMgPSAhbm9vcFdpdGhFbXB0eUF4ZXMgJiYgYXhlcy5sZW5ndGggPT09IDA7XG4gICAgICBpbnB1dFNoYXBlLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgICAgaWYgKHJlZHVjZU9uQWxsQXhlcyB8fCBheGVzLmluZGV4T2YoaSkgPj0gMCkge1xuICAgICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUucHVzaCgxKTtcbiAgICAgICAgICB9ICAvLyBlbHNlIHsgLy8gc2tpcCB0aGlzIGF4aXN9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0U2hhcGUucHVzaChkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdOyAgLy8gY29weSBvdXRwdXQgaW5kZXhlcyB0byBpbnB1dCBpbmRleGVzXG5cbiAgICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdfQScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRSYW5rKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIG91dHB1dERhdGFUeXBlLCBvdXRwdXRSYW5rKTtcbiAgICAgICAgY29uc3Qgb3BzID0gcmVkdWNlT3AoaW5wdXQsIG91dHB1dCwgYXhlcyk7XG4gICAgICAgIGxldCByZWR1Y2VPcHMgPSBvcHNbMl07XG5cbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGwgPSAwOyBrIDwgaW5wdXRSYW5rOyBrKyspIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIGF4aXMgaXMgcmVkdWNlZFxuICAgICAgICAgIGlmIChyZWR1Y2VPbkFsbEF4ZXMgfHwgYXhlcy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb29wIG92ZXIgdGhlIGQtdGggYXhpc1xuICAgICAgICAgICAgcmVkdWNlT3BzID0gYGZvcih2YXIgaiR7a306IHUzMiA9IDA7IGoke2t9IDwgJHtpbnB1dFNoYXBlW2tdfTsgaiR7a30rKykge1xuICAgICAgICAgICAgICAgICAgJHtvcHNbMl0uaW5jbHVkZXMoJ2xhc3RfaW5kZXgnKSA/IGBsZXQgbGFzdF9pbmRleCA9IGoke2t9O2AgOiAnJ31cbiAgICAgICAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGssIGBqJHtrfWApfVxuICAgICAgICAgICAgICAgICAgJHtyZWR1Y2VPcHN9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkeENvcHkucHVzaChgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgb3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgbCkpfTtgKTtcbiAgICAgICAgICAgIGwrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBcblxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgICAgICR7aWR4Q29weS5qb2luKCdcXG4nKX1cbiAgICAgICAgICAke29wc1swXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICAgJHtvcHNbMV19XG4gICAgICAgICAgJHtyZWR1Y2VPcHN9XG4gICAgICAgICAgJHtvcHNbM119XG4gICAgICAgICAgJHtvcHMubGVuZ3RoID09PSA0ID8gb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJykgOiBvcHMuc2xpY2UoNCkuam9pbignXFxuJyl9XG4gICAgICAgIH1gO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc2hhZGVyQ2FjaGUsXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtczpcbiAgICAgICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSldXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlQXR0cmlidXRlc0Zyb21JbnB1dHMgPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IFJlZHVjZUF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgYXhlczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGlmIChpbnB1dHNbMV0uZGltc1swXSA+IDApIHtcbiAgICAgICAgaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKHYgPT4gYXhlcy5wdXNoKE51bWJlcih2KSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICAgICAgICB7YXhlcywga2VlcERpbXM6IGF0dHJpYnV0ZXMua2VlcERpbXMsIG5vb3BXaXRoRW1wdHlBeGVzOiBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzfSk7XG4gICAgfTtcblxuY29uc3QgcnVuUmVkdWNlUHJvZ3JhbSA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBuYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMsIHJlZHVjZU9wOiBSZWR1Y2VPcCk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XG4gICAgICBjb25zdCB1cGRhdGVkQXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyA9XG4gICAgICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXG4gICAgICAgICAgICAgIG5hbWUsIHtoaW50OiB1cGRhdGVkQXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSwgW2lucHV0c1swXV0sXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzICYmIHVwZGF0ZWRBdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID09PSAwID8gbm9PcCA6IHJlZHVjZU9wLFxuICAgICAgICAgICAgICB1cGRhdGVkQXR0cmlidXRlcy5heGVzLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHVwZGF0ZWRBdHRyaWJ1dGVzLmtlZXBEaW1zLFxuICAgICAgICAgICAgICB1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyksXG4gICAgICAgICAge2lucHV0czogWzBdfSk7XG4gICAgfTtcblxuY29uc3QgcmVkdWNlTG9nU3VtTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT5cbiAgICAgIFtgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICAgICcnLFxuICAgICAgIGB2YWx1ZSArPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICAgICd2YWx1ZSA9IGxvZyh2YWx1ZSk7JyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTG9nU3VtJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTDFOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PlxuICAgICAgW2B2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgICAgJycsXG4gICAgICAgYHZhbHVlICs9IGFicygke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgICAnJyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTDEnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VMMk5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+XG4gICAgICBbYHZhciB0ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO2AsXG4gICAgICAgJycsXG4gICAgICAgYHQgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFxuICAgICAgICd2YWx1ZSA9IHNxcnQodmFsdWUpOycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUwyJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTG9nU3VtRXhwTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT5cbiAgICAgIFtgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICAgICcnLFxuICAgICAgIGB2YWx1ZSArPSBleHAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICAgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1FeHAnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNYXhOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgX291dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXG4gICAgICBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgIGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICAnJyxcbiAgICBdO1xuICB9O1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNYXgnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNZWFuTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGxldCBzaXplID0gMS4wO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBkZXBlbmRzIG9uIHRoZSBpbnB1dCBkaW1zLiBJZiB3ZSB3YW50IHRvIHVzZSB1bmlmb3JtLCB0aGlzIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgICAgICAgc2l6ZSAqPSBjb250ZXh0LmlucHV0c1swXS5kaW1zW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAndmFyIHN1bSA9IGYzMigwKTsnLFxuICAgICAgJycsXG4gICAgICBgc3VtICs9IGYzMigke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgIGBsZXQgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfShzdW0gLyAke3NpemV9KTtgLFxuICAgIF07XG4gIH07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1lYW4nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNaW5OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgX291dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7ICAvLyBmaXJzdCBlbGVtZW50XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICAgYHZhbHVlID0gbWluKHZhbHVlLCAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgICcnLFxuICAgIF07XG4gIH07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1pbicsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZVByb2ROYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PlxuICAgICAgW2B2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDEpO2AsXG4gICAgICAgJycsXG4gICAgICAgYHZhbHVlICo9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVByb2QnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VTdW1OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PlxuICAgICAgW2B2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgICAgJycsXG4gICAgICAgYHZhbHVlICs9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVN1bScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZVN1bVNxdWFyZU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+XG4gICAgICBbYHZhciB0ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO2AsXG4gICAgICAgJycsXG4gICAgICAgYHQgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTsgdmFsdWUgKz0gdCAqIHQ7YCxcbiAgICAgICAnJyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlU3VtU3F1YXJlJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgdXNlTmFpdmVSZWR1Y2VNZXRob2QgPVxuICAgIChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCBub29wV2l0aEVtcHR5QXhlczogYm9vbGVhbik6IGJvb2xlYW4gPT4ge1xuICAgICAgaWYgKGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub29wV2l0aEVtcHR5QXhlcztcbiAgICAgIH1cblxuICAgICAgbGV0IG91dHB1dFNpemUgPSAxO1xuICAgICAgbGV0IHJlZHVjZVNpemUgPSAxO1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgYXhlcy5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgICAgICBvdXRwdXRTaXplICo9IHNoYXBlW2RpbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVkdWNlU2l6ZSAqPSBzaGFwZVtkaW1dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb25kaXRpb24gZGF0YSBpcyB2ZXJ5IHJvdWdoLCBhbHRob3VnaCBjb25zaWRlcmluZyB0aGUgY291bnQgb2YgRXhlY3V0aW9uIFVuaXQgKEVVKSwgdGhlIHBvdGVudGlhbFxuICAgICAgLy8gd29yayBncm91cHMgaW4gYSBFVSBhbmQgdGhlIGNvdW50cyBvZiBsb29wcyBpbiB0aGUgbmFpdmUgYW5kIHNoYXJlZCBtZXRob2RzLCBhbHNvIGRvaW5nIGV4cGVyaW1lbnRzXG4gICAgICAvLyBvbiBzb21lIG1hY2hpbmVzLlxuICAgICAgcmV0dXJuIHJlZHVjZVNpemUgPCAzMiAmJiBvdXRwdXRTaXplID4gMTAyNDtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWVhbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZU1lYW5OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VNZWFuU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTDEgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VMMU5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZUwxU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTDIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VMMk5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZUwyU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTG9nU3VtRXhwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTG9nU3VtRXhwTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTG9nU3VtRXhwU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWF4ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTWF4TmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTWF4U2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWluID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTWluTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTWluU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlUHJvZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZVByb2ROYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VQcm9kU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlU3VtTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlU3VtU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU3F1YXJlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlU3VtU3F1YXJlTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlU3VtU3F1YXJlU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTG9nU3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTG9nU3VtTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTG9nU3VtU2hhcmVkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vLyBUT0RPOiB0aGlzIGlzIHRoZSBzYW1lIG5haXZlIGltcGxlbWVudGF0aW9uIHdlIHVzZSBmb3IgcmVkdWNlIHRoYXQgaGFzXG4vLyBwZXJmb3JtYW5jZSBsaW1pdGF0aW9ucyB3aGVuIHRoZSByZWR1Y2VkIGF4aXMgaXMgbG9uZy4gTmVlZCB0byBhZGRcbi8vIGEgb3B0aW1pemVkIGNvZGVwYXRoIGZvciB0aGlzLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0fSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8sIFJlZHVjZU9wfSBmcm9tICcuL3JlZHVjZSc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDAgfHwgaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBBcmdNaW5NYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAga2VlcERpbXM6IGJvb2xlYW47XG4gIGF4aXM6IG51bWJlcjtcbiAgc2VsZWN0TGFzdEluZGV4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBhcmdNaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFyZ01pbk1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBhcmdNaW5NYXhPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7ICAvLyBmaXJzdCBlbGVtZW50XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcXG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxcbiAgICAgIGBpZiAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0gJHthdHRyaWJ1dGVzLnNlbGVjdExhc3RJbmRleCA+IDAgPyAnPD0nIDogJzwnfSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXG4gICAgICAnJywgb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2Jlc3RfaW5kZXgnKVxuICAgIF07XG4gIH07XG5cbiAgY29udGV4dC5jb21wdXRlKFxuICAgICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXG4gICAgICAgICAgJ0FyZ01pbicsIHtoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ119LCBbY29udGV4dC5pbnB1dHNbMF1dLCBhcmdNaW5NYXhPcCxcbiAgICAgICAgICBbYXR0cmlidXRlcy5heGlzXSwgRGF0YVR5cGUuaW50NjQsIGF0dHJpYnV0ZXMua2VlcERpbXMpLFxuICAgICAge2lucHV0czogWzBdfSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXJnTWF4ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBcmdNaW5NYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgYXJnTWluTWF4T3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQsIGF4ZXMpID0+IHtcbiAgICBjb25zdCBpZHhaZXJvID0gW107XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0X2luZGljZXNbJHtrfV0gPSAwO2ApOyAgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLCBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XFxudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsXG4gICAgICBgaWYgKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9ICR7YXR0cmlidXRlcy5zZWxlY3RMYXN0SW5kZXggPiAwID8gJz49JyA6ICc+J30gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFxuICAgICAgJycsIG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdiZXN0X2luZGV4JylcbiAgICBdO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvKFxuICAgICAgICAgICdhcmdNYXgnLCB7aGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSwgW2NvbnRleHQuaW5wdXRzWzBdXSwgYXJnTWluTWF4T3AsXG4gICAgICAgICAgW2F0dHJpYnV0ZXMuYXhpc10sIERhdGFUeXBlLmludDY0LCBhdHRyaWJ1dGVzLmtlZXBEaW1zKSxcbiAgICAgIHtpbnB1dHM6IFswXX0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXJnTWluTWF4QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEFyZ01pbk1heEF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PEFyZ01pbk1heEF0dHJpYnV0ZXMsIGtleW9mIEF0dHJpYnV0ZVdpdGhDYWNoZUtleT4pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIEdwdURhdGFUeXBlLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEF0dGVudGlvblFrdkZvcm1hdCB7XG4gIHVua25vd24sICAgICAgICAgIC8vIGVudW0gdmFsdWUgbm90IHNldCwgb3IgZGVwZW5kcyBvbiBxa3YgcHJvamVjdGlvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzXG4gIHFrdkJOU0gsICAgICAgICAgIC8vIGZvciBub24tcGFja2VkIHFrdiwgcGVybXV0ZWRcbiAgcWt2QlNOSCwgICAgICAgICAgLy8gZm9yIG5vbi1wYWNrZWQgcWt2LCBub3QgcGVybXV0ZWQsIHVzZWQgYnkgbWVtb3J5IGVmZmljaWVudCBhdHRlbnRpb24gb3IgTXVsdGlIZWFkQXR0ZW50aW9uXG4gIHFrdkJTTjNILCAgICAgICAgIC8vIGZvciBUUlQgZnVzZWQgYXR0ZW50aW9uLCBxa3YgYXJlIHBhY2tlZFxuICBxa3ZCTlNIcWt2QlMzTkgsICAvLyBmb3IgVFJUIGZ1c2VkIGNhdXNhbCBhdHRlbnRpb24sIGRhdGEgaGFzIHR3byBmb3JtYXRzIChxa3YgaXMgM0JOU0gsIGdlbW1fYnVmZmVyIGlzIEJTM05IKVxuICBxS3ZCU05IeEJTTjJILCAgICAvLyBmb3IgVFJUIGZ1c2VkIGNyb3NzIGF0dGVudGlvbiwga3YgYXJlIHBhY2tlZFxuICBxa3ZUTkgsICAgICAgICAgICAvLyBmb3IgbWVtb3J5IGVmZmljaWVudCBhdHRlbnRpb24sIHFrdiBhcmUgbm90IHBhY2tlZCwgYW5kIHBhZGRpbmdzIGFyZSByZW1vdmVkLlxuICBxa3ZUTjNILCAgICAgICAgICAvLyBmb3IgVFJUIGZ1c2VkIGF0dGVudGlvbiwgcWt2IGFyZSBwYWNrZWQgYW5kIHBhZGRpbmdzIGFyZSByZW1vdmVkXG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIEF0dGVudGlvbk1hc2tUeXBlIHtcbiAgbm9uZSwgICAgICAgICAgICAgICAgICAvLyBObyBtYXNrXG4gIG1hc2sxZEtleVNlcUxlbiwgICAgICAgLy8gW2JhdGNoX3NpemVdLCBrZXkgc2VxdWVuY2UgbGVuZ3RoXG4gIG1hc2sxZEVuZFN0YXJ0LCAgICAgICAgLy8gWzIgKiBiYXRjaF9zaXplXSB3aXRoIGVuZCBwb3NpdGlvbnMgYW5kIHN0YXJ0IHBvc2l0aW9uc1xuICBtYXNrMURLZXlTZXFMZW5TdGFydCwgIC8vIFszICogYmF0Y2hfc2l6ZSArIDJdIHdpdGggW2tleV9sZW5bMF0sIC4uLiwga2V5X2xlbltiYXRjaF9zaXplIC0gMV0sIHF1ZXJ5X3N0YXJ0WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLiwgcXVlcnlfc3RhcnRbYmF0Y2hfc2l6ZSAtIDFdLCBxdWVyeV9lbmRbYmF0Y2hfc2l6ZSAtIDFdLCBrZXlfc3RhcnRbMF0sIC4uLixcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXlfc3RhcnRbYmF0Y2hfc2l6ZSAtIDFdLCBrZXlfZW5kW2JhdGNoX3NpemUgLSAxXV1cbiAgbWFzazJkRHVtbXksICAgICAgICAgICAvLyBkdW1teSBtYXNrIHdpdGggc2hhcGUgWzEsIDFdIG9yIFtiYXRjaF9zaXplLCAxXS4gSXQgaGFzIHNhbWUgZWZmZWN0IGFzIG5vIG1hc2suXG4gIG1hc2syZEtleVBhZGRpbmcsICAgICAgLy8gW2JhdGNoX3NpemUsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aF1cbiAgbWFzazNkQXR0ZW50aW9uLCAgICAgICAvLyBbYmF0Y2hfc2l6ZSwgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhdXG4gIG1hc2s0ZE1lZ2F0cm9uLCAgICAgICAgLy8gTWVnYXRyb24gY2F1c2FsIG1hc2sgd2l0aCBzaGFwZSBbYmF0Y2hfc2l6ZSwgMSwgbWF4X3NlcXVlbmNlX2xlbmd0aCwgbWF4X3NlcXVlbmNlX2xlbmd0aF1cbiAgbWFza1Vua25vd25cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRlbnRpb25QYXJhbWV0ZXJzIHtcbiAgYmF0Y2hTaXplOiBudW1iZXI7XG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBrdlNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIHRvdGFsU2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgbWF4U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgaW5wdXRIaWRkZW5TaXplOiBudW1iZXI7XG4gIGhpZGRlblNpemU6IG51bWJlcjtcbiAgdkhpZGRlblNpemU6IG51bWJlcjtcbiAgaGVhZFNpemU6IG51bWJlcjtcbiAgdkhlYWRTaXplOiBudW1iZXI7XG4gIG51bUhlYWRzOiBudW1iZXI7XG4gIGt2TnVtSGVhZHM/OiBudW1iZXI7XG4gIG5SZXBzPzogbnVtYmVyO1xuICBpc1VuaWRpcmVjdGlvbmFsPzogYm9vbGVhbjtcbiAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogYm9vbGVhbjtcbiAgbWFza0ZpbHRlclZhbHVlPzogbnVtYmVyO1xuICBtYXNrVHlwZTogQXR0ZW50aW9uTWFza1R5cGU7XG4gIHNjYWxlOiBudW1iZXI7XG4gIGJyb2FkY2FzdFJlc1Bvc0JpYXM6IGJvb2xlYW47XG4gIHBhc3NQYXN0SW5LdjogYm9vbGVhbjtcbiAgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQ7XG4gIGlzUGFzdGt2QlNOSD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0ZW50aW9uQXR0cnMge1xuICBudW1IZWFkczogbnVtYmVyO1xuICBrdk51bUhlYWRzPzogbnVtYmVyO1xuICBpc1VuaWRpcmVjdGlvbmFsPzogbnVtYmVyO1xuICBtYXNrRmlsdGVyVmFsdWU/OiBudW1iZXI7XG4gIHNjYWxlOiBudW1iZXI7XG4gIGRvUm90YXJ5OiBudW1iZXI7XG4gIHFrdkhpZGRlblNpemVzOiBudW1iZXJbXTtcbiAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogYm9vbGVhbjtcbn1cblxuY29uc3QgdmFsaWRhdGVBdHRlbnRpb25JbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uUGFyYW1ldGVycyA9PiB7XG4gIC8vIEFiYnJldmlhdGlvbiBhbmQgTWVhbmluZ3M6XG4gIC8vICAgQjogICAgYmF0Y2hfc2l6ZVxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxuICAvLyAgIFA6ICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIChwYXN0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTDogICAga3Zfc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBUOiAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBwYXN0X3NlcXVlbmNlX2xlbmd0aCArIGt2X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIE46ICAgIG51bV9oZWFkc1xuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxuICAvLyAgIEhfdjogIHZfaGVhZF9zaXplXG4gIC8vICAgRF9pOiAgaW5wdXQgaGlkZGVuIHNpemVcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxuICAvLyAgIERfdjogIHZfaGlkZGVuX3NpemUgPSBudW1faGVhZHMgKiB2X2hlYWRfc2l6ZVxuXG4gIC8vIFdoZW4gcGFzdCBzdGF0ZSBpcyB1c2VkLCBRLCBLIGFuZCBWIHNob3VsZCBoYXZlIHNhbWUgaGlkZGVuIHNpemUgKHVubGVzcyB3ZSBzcGxpdCBpdCBpbnRvIHBhc3Rfa2V5IGFuZCBwYXN0X3ZhbHVlKS5cblxuICAvLyBJbnB1dCBzaGFwZXM6XG4gIC8vICAgaW5wdXQgICAgICAgIChRL0svVikgICAgOiAoQiwgUywgRF9pKVxuICAvLyAgIHdlaWdodHMgICAgICAoUS9LL1YpICAgIDogKERfaSwgRCArIEQgKyBEX3YpXG4gIC8vICAgYmlhcyAgICAgICAgIChRL0svVikgICAgOiAoRCArIEQgKyBEX3YpXG4gIC8vICAgbWFza19pbmRleCAgICAgICAgICAgICAgOiBzZWUgYmVsb3dcbiAgLy8gICBwYXN0ICAgICAgICAgKEsvVikgICAgICA6ICgyLCBCLCBOLCBQLCBIKSBvciBOVUxMXG4gIC8vICAgcmVsYXRpdmVfcG9zaXRpb25fYmlhcyAgICAgICAgICAgIDogKEIsIE4sIFMsIFQpIG9yIE5VTExcblxuICAvLyBGb3IgbWFza19pbmRleCwgdGhlIGZvbGxvd2luZyBzaGFwZXMgYXJlIHN1cHBvcnRlZDpcbiAgLy8gICAgIE5VTEwsIChCLCAxKSwgKDEsIDEpXG4gIC8vICAgICAoQiksICgyICogQiksICgzICogQiArIDIpXG4gIC8vICAgICAoQiwgVClcbiAgLy8gICAgIChCLCBTLCBUKVxuICAvLyAgICAgKEIsIDEsIE0sIE0pXG4gIC8vXG4gIC8vIFdoZW4gYSBtb2RlbCBpcyBwcnVuZWQgKGxpa2Ugc29tZSBhdHRlbnRpb24gaGVhZHMgYXJlIHJlbW92ZWQgaW4gUS9LL1YpLCBpbnB1dF9oaWRkZW5fc2l6ZSBjb3VsZCBiZSBsYXJnZXJcbiAgLy8gdGhhbiBoaWRkZW4gZGltZW5zaW9uIG9mIFEsIEsgYW5kIFYuXG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dHNbMF07XG4gIGNvbnN0IHdlaWdodHMgPSBpbnB1dHNbMV07XG4gIGNvbnN0IGJpYXMgPSBpbnB1dHNbMl07XG4gIGNvbnN0IG1hc2tJbmRleCA9IGlucHV0c1szXTtcbiAgY29uc3QgcGFzdCA9IGlucHV0c1s0XTtcbiAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbkJpYXMgPSBpbnB1dHNbNV07XG5cbiAgaWYgKHBhc3QgJiYgcmVsYXRpdmVQb3NpdGlvbkJpYXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIHJlbGF0aXZlX3Bvc2l0aW9uX2JpYXMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0LmRpbXNbMF07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1sxXTtcbiAgY29uc3QgaW5wdXRIaWRkZW5TaXplID0gaW5wdXQuZGltc1syXTtcblxuICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICh3ZWlnaHRzLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcIndlaWdodHNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKHdlaWdodHMuZGltc1swXSAhPT0gaW5wdXRIaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCAxIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAyIG9mIGlucHV0IDAnKTtcbiAgfVxuXG4gIGlmIChiaWFzLmRpbXNbMF0gIT09IHdlaWdodHMuZGltc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDEgb2YgaW5wdXQgXCJ3ZWlnaHRzXCInKTtcbiAgfVxuXG4gIGxldCBxSGlkZGVuU2l6ZSA9IGJpYXMuZGltc1swXSAvIDM7XG4gIGxldCBrSGlkZGVuU2l6ZSA9IHFIaWRkZW5TaXplO1xuICBsZXQgdkhpZGRlblNpemUgPSBrSGlkZGVuU2l6ZTtcbiAgaWYgKGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdxa3ZfaGlkZGVuX3NpemVzIGF0dHJpYnV0ZSBzaG91bGQgaGF2ZSAzIGVsZW1lbnRzJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3ogb2YgYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplcykge1xuICAgICAgaWYgKHN6ICUgYXR0cmlidXRlcy5udW1IZWFkcyAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSBudW1faGVhZHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBxSGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMF07XG4gICAga0hpZGRlblNpemUgPSBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzWzFdO1xuICAgIHZIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1syXTtcbiAgfVxuXG4gIGNvbnN0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcblxuICBpZiAocUhpZGRlblNpemUgIT09IGtIaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdxa3ZfaGlkZGVuX3NpemVzIGZpcnN0IGVsZW1lbnQgc2hvdWxkIGJlIHNhbWUgYXMgdGhlIHNlY29uZCcpO1xuICB9XG5cbiAgaWYgKGJpYXMuZGltc1swXSAhPT0gcUhpZGRlblNpemUgKyBrSGlkZGVuU2l6ZSArIHZIaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7XG4gIH1cblxuICBsZXQgcGFzdFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgaWYgKHBhc3QpIHtcbiAgICBpZiAoa0hpZGRlblNpemUgIT09IHZIaWRkZW5TaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgbXVzdCBoYXZlIDUgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzBdICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpcnN0IGRpbWVuc2lvbiBtdXN0IGJlIDInKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1sxXSAhPT0gYmF0Y2hTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHNlY29uZCBkaW1lbnNpb24gbXVzdCBiZSBiYXRjaF9zaXplJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgdGhpcmQgZGltZW5zaW9uIG11c3QgYmUgbnVtX2hlYWRzJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbNF0gIT09IGtIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFhdHRyaWJ1dGVzLnBhc3RQcmVzZW50U2hhcmVCdWZmZXIpIHtcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3QuZGltc1szXTtcbiAgICB9XG4gICAgLy8gVE9ETzogaGFuZGxlIHBhc3Rfc2VxX2xlblxuICB9XG5cbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IGt2U2VxdWVuY2VMZW5ndGggKyBwYXN0U2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gLTE7XG5cbiAgY29uc3QgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xuICBpZiAobWFza0luZGV4KSB7XG4gICAgLy8gbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5NQVNLX1VOS05PV047XG4gICAgLy8gVE9ETzogaGFuZGxlIG1hc2tcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hc2sgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgaWYgKHBhc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3QgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXRjaFNpemUsXG4gICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcbiAgICBpbnB1dEhpZGRlblNpemUsXG4gICAgaGlkZGVuU2l6ZTogcUhpZGRlblNpemUsXG4gICAgdkhpZGRlblNpemUsXG4gICAgaGVhZFNpemU6IE1hdGguZmxvb3IocUhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICBudW1IZWFkczogYXR0cmlidXRlcy5udW1IZWFkcyxcbiAgICBpc1VuaWRpcmVjdGlvbmFsOiBmYWxzZSxcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcbiAgICBtYXNrRmlsdGVyVmFsdWU6IGF0dHJpYnV0ZXMubWFza0ZpbHRlclZhbHVlLFxuICAgIG1hc2tUeXBlLFxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXM6IGZhbHNlLFxuICAgIHBhc3NQYXN0SW5LdjogZmFsc2UsXG4gICAgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2Qk5TSCxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUluUGxhY2VTb2Z0bWF4UHJvZ3JhbUluZm8gPSAoX2NvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dDogVGVuc29yVmlldywgbjogbnVtYmVyLCBkOiBudW1iZXIpID0+IHtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoZCk7XG4gIGxldCBXRyA9IDY0O1xuICBjb25zdCBkQ29tcCA9IGQgLyBjb21wb25lbnRzO1xuICBpZiAoZENvbXAgPCBXRykge1xuICAgIFdHID0gMTtcbiAgfSBlbHNlIGlmIChkQ29tcCAvIDggPCA2NCkge1xuICAgIFdHID0gTWF0aC5jZWlsKGRDb21wIC8gOCk7XG4gIH1cbiAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQgPSBNYXRoLmNlaWwoZCAvIGNvbXBvbmVudHMgLyBXRyk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7dHlwZTogaW5wdXQuZGF0YVR5cGUsIGRhdGE6IDEgLyBkfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZENvbXB9LFxuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGVsZW1lbnRzUGVyVGhyZWFkfVxuICBdO1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dC5kYXRhVHlwZSwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGYzMlR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKERhdGFUeXBlLmZsb2F0LCBjb21wb25lbnRzKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpbnB1dEhlbHBlciA9IG91dHB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGVsZW1WYWx1ZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGlucHV0LmRhdGFUeXBlKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7bmFtZTogJ2RfaW52JywgdHlwZTogZWxlbVZhbHVlVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlfSwge25hbWU6ICdkX2NvbXAnLCB0eXBlOiAndTMyJ30sXG4gICAgICB7bmFtZTogJ2VsZW1lbnRzX3Blcl90aHJlYWQnLCB0eXBlOiAndTMyJ31cbiAgICBdO1xuXG4gICAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX21heDogYXJyYXk8ZjMyLCAke1dHfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRocmVhZF9zdW06IGFycmF5PGYzMiwgJHtXR30+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0SGVscGVyKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtcbiAgICAgIFdHLCAxLCAxXG4gICAgXSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IHdvcmtncm91cF9pZC54ICogdW5pZm9ybXMuZF9jb21wICsgbG9jYWxfb2Zmc2V0O1xuXG4gICAgdmFyIHRocmVhZF9tYXhfdmVjdG9yID0gJHtmMzJUeXBlfSgtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHVuaWZvcm1zLmRfY29tcDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpID0+IHtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuICd0aHJlYWRfbWF4X3ZlY3Rvcic7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gJ21heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSc7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gJ21heChtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSksIG1heCh0aHJlYWRfbWF4X3ZlY3Rvci56LCB0aHJlYWRfbWF4X3ZlY3Rvci53KSknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtjb21wb25lbnRzfWApO1xuICAgICAgfVxuICAgIH0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBtYXhfdmFsdWUgPSAgZjMyKC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke1dHfTsgaSsrKSB7XG4gICAgICBtYXhfdmFsdWUgPSBtYXgodGhyZWFkX21heFtpXSwgbWF4X3ZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtX3ZlY3RvciA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHVuaWZvcm1zLmRfY29tcDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCkgPT4ge1xuICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gJ3N1bV92ZWN0b3InO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnknO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnkgKyBzdW1fdmVjdG9yLnogKyBzdW1fdmVjdG9yLncnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtjb21wb25lbnRzfWApO1xuICAgICAgfVxuICAgIH0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBzdW06IGYzMiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtXR307IGkrKykge1xuICAgICAgc3VtICs9IHRocmVhZF9zdW1baV07XG4gICAgfVxuXG4gICAgaWYgKHN1bSA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMuZF9jb21wOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0odW5pZm9ybXMuZF9pbnYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMuZF9jb21wOyBpKyspIHtcbiAgICAgICAgdmFyIGYzMmlucHV0ID0gJHtmMzJUeXBlfSh4W29mZnNldCArIGldKTtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdBdHRlbnRpb25Qcm9ic1NvZnRtYXgnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7V0d9OyR7ZGF0YVR5cGV9OyR7Y29tcG9uZW50c31gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtvdXRwdXRzOiBbXSwgZGlzcGF0Y2hHcm91cDoge3g6IG59LCBwcm9ncmFtVW5pZm9ybXN9KSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUF0dGVudGlvblByb2JzUHJvZ3JhbUluZm8gPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgcTogVGVuc29yVmlldywga2V5OiBUZW5zb3JWaWV3LCBwYXN0S2V5OiBUZW5zb3JWaWV3fHVuZGVmaW5lZCxcbiAgICAgcmVsYXRpdmVQb3NpdGlvbkJpYXM6IFRlbnNvclZpZXd8dW5kZWZpbmVkLCBwYXJhbWV0ZXJzOiBBdHRlbnRpb25QYXJhbWV0ZXJzLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyxcbiAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBwYXJhbWV0ZXJzLmt2U2VxdWVuY2VMZW5ndGg7XG4gICAgICBjb25zdCBwcm9ic1NoYXBlID0gW3BhcmFtZXRlcnMuYmF0Y2hTaXplLCBwYXJhbWV0ZXJzLm51bUhlYWRzLCBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLCB0b3RhbFNlcXVlbmNlTGVuZ3RoXTtcbiAgICAgIGNvbnN0IHByZXNlbnRLZXkgPSBwYXJhbWV0ZXJzLmt2TnVtSGVhZHMgPT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Lm91dHB1dENvdW50ID4gMTtcbiAgICAgIGNvbnN0IHByZXNlbnRLZXlTaGFwZSA9IHByZXNlbnRLZXkgP1xuICAgICAgICAgIFtwYXJhbWV0ZXJzLmJhdGNoU2l6ZSwgcGFyYW1ldGVycy5udW1IZWFkcywgdG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1ldGVycy5oZWFkU2l6ZV0gOlxuICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgLy8gVE9ETzogaGFuZGxlIG1hc2tcblxuICAgICAgY29uc3QgYWxwaGEgPSBhdHRyaWJ1dGVzLnNjYWxlID09PSAwID8gMS4wIC8gTWF0aC5zcXJ0KHBhcmFtZXRlcnMuaGVhZFNpemUpIDogYXR0cmlidXRlcy5zY2FsZTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKHBhcmFtZXRlcnMuaGVhZFNpemUpO1xuICAgICAgY29uc3QgdmVjdG9yaXplZEhlYWRTaXplID0gcGFyYW1ldGVycy5oZWFkU2l6ZSAvIGNvbXBvbmVudHM7XG4gICAgICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0ge1xuICAgICAgICB4OiBNYXRoLmNlaWwodG90YWxTZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgICAgIHk6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICAgICAgejogcGFyYW1ldGVycy5iYXRjaFNpemUgKiBwYXJhbWV0ZXJzLm51bUhlYWRzXG4gICAgICB9O1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RofSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdmVjdG9yaXplZEhlYWRTaXplfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aH0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMubnVtSGVhZHN9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGFscGhhfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFzdFNlcXVlbmNlTGVuZ3RofSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RofVxuICAgICAgXTtcblxuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICAgICAgaWYgKHBhc3RLZXkpIHtcbiAgICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICAgICAgfVxuICAgICAgaWYgKHJlbGF0aXZlUG9zaXRpb25CaWFzKSB7XG4gICAgICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dHB1dHMgPSBbe2RpbXM6IHByb2JzU2hhcGUsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH1dO1xuICAgICAgaWYgKHByZXNlbnRLZXkpIHtcbiAgICAgICAgb3V0cHV0cy5wdXNoKHtkaW1zOiBwcmVzZW50S2V5U2hhcGUhLCBkYXRhVHlwZTogcS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHR9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBxSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdxJywgcS5kYXRhVHlwZSwgcS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3Qga0lucHV0ID0gaW5wdXRWYXJpYWJsZSgna2V5Jywga2V5LmRhdGFUeXBlLCBrZXkuZGltcywgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFycyA9IFtxSW5wdXQsIGtJbnB1dF07XG4gICAgICAgIGlmIChwYXN0S2V5KSB7XG4gICAgICAgICAgY29uc3QgcGFzdEtleUlucHV0ID0gaW5wdXRWYXJpYWJsZSgncGFzdF9rZXknLCBwYXN0S2V5LmRhdGFUeXBlLCBwYXN0S2V5LmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgICAgIGlucHV0VmFycy5wdXNoKHBhc3RLZXlJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlUG9zaXRpb25CaWFzKSB7XG4gICAgICAgICAgaW5wdXRWYXJzLnB1c2goXG4gICAgICAgICAgICAgIGlucHV0VmFyaWFibGUoJ3JlbGF0aXZlX3Bvc2l0aW9uX2JpYXMnLCByZWxhdGl2ZVBvc2l0aW9uQmlhcy5kYXRhVHlwZSwgcmVsYXRpdmVQb3NpdGlvbkJpYXMuZGltcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBxLmRhdGFUeXBlLCBwcm9ic1NoYXBlKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0VmFycyA9IFtvdXRwdXRdO1xuICAgICAgICBpZiAocHJlc2VudEtleSkge1xuICAgICAgICAgIG91dHB1dFZhcnMucHVzaChvdXRwdXRWYXJpYWJsZSgncHJlc2VudF9rZXknLCBxLmRhdGFUeXBlLCBwcmVzZW50S2V5U2hhcGUhLCBjb21wb25lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZjMyVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoRGF0YVR5cGUuZmxvYXQsIGNvbXBvbmVudHMpO1xuXG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgICAgICB7bmFtZTogJ00nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnSycsIHR5cGU6ICd1MzInfSwge25hbWU6ICdOJywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgIHtuYW1lOiAnbnVtX2hlYWRzJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMicgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZX0sXG4gICAgICAgICAge25hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInfSwge25hbWU6ICdrdl9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtUSUxFX1NJWkV9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtxSW5wdXQudHlwZS5zdG9yYWdlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUs6IGFycmF5PCR7cUlucHV0LnR5cGUuc3RvcmFnZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCAuLi5vdXRwdXRWYXJzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtcbiAgICAgICAgICBUSUxFX1NJWkUsIFRJTEVfU0laRSwgMVxuICAgICAgICBdKX1cbiAgICAvLyB4IGhvbGRzIHRoZSBOIGFuZCB5IGhvbGRzIHRoZSBNXG4gICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQuejtcbiAgICBsZXQgbSA9IHdvcmtncm91cF9pZC55ICogVElMRV9TSVpFO1xuICAgIGxldCBuID0gd29ya2dyb3VwX2lkLnggKiBUSUxFX1NJWkU7XG4gICAgbGV0IHFPZmZzZXQgPSB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyAqIGhlYWRJZHggKyBtICogdW5pZm9ybXMuSztcbiAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKHBhc3RLZXkgJiYgcHJlc2VudEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICBsZXQga09mZnNldCA9IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLksgKiBoZWFkSWR4O1xuICAgIGxldCBwYXN0S2V5T2Zmc2V0ID0gdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LICogaGVhZElkeDtgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgIGxldCBrT2Zmc2V0ID0gdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKiBoZWFkSWR4ICsgbiAqIHVuaWZvcm1zLks7YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9XG4gICAgJHtwcmVzZW50S2V5ID8gJ2xldCBwcmVzZW50S2V5T2Zmc2V0ID0gaGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LOycgOiAnJ31cbiAgICB2YXIgdmFsdWUgPSAke2YzMlR5cGV9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHFbcU9mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgIGlmIChwYXN0S2V5ICYmIHByZXNlbnRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aWxlS1tpZHhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSAtIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RpbGVLW2lkeF0gPSBrZXlba09mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdOyc7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfVxuICAgICAgJHtcbiAgICAgICAgICAgIHByZXNlbnRLZXkgP1xuICAgICAgICAgICAgICAgICdwcmVzZW50X2tleVtwcmVzZW50S2V5T2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF0gPSB0aWxlS1tpZHhdOycgOlxuICAgICAgICAgICAgICAgICcnfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgdmFsdWUgKz0gJHtmMzJUeXBlfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRPZmZzZXQgPSBoZWFkSWR4ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBoZWFkT2Zmc2V0ICsgZ2xvYmFsX2lkLnkgKiB1bmlmb3Jtcy5OICsgZ2xvYmFsX2lkLng7XG4gICAgICB2YXIgc3VtOiBmMzIgPSAkeygoKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiAndmFsdWUnO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gJ3ZhbHVlLnggKyB2YWx1ZS55JztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgcmV0dXJuICd2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtjb21wb25lbnRzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG4gICAgICAgIG91dHB1dFtvdXRwdXRJZHhdID0gJHtvdXRwdXQudHlwZS52YWx1ZX0gKHN1bSAqIHVuaWZvcm1zLmFscGhhKSArICR7XG4gICAgICAgICAgICByZWxhdGl2ZVBvc2l0aW9uQmlhcyA/ICdyZWxhdGl2ZV9wb3NpdGlvbl9iaWFzW291dHB1dElkeF0nIDogJzAuMCd9O1xuICAgIH1cbiAgfWA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0F0dGVudGlvblByb2JzJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICBoaW50OiBgJHtjb21wb25lbnRzfTske3JlbGF0aXZlUG9zaXRpb25CaWFzICE9PSB1bmRlZmluZWR9OyR7cGFzdEtleSAhPT0gdW5kZWZpbmVkfTske2NvbnRleHQub3V0cHV0Q291bnR9YCxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llc1xuICAgICAgICB9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe291dHB1dHMsIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLCBwcm9ncmFtVW5pZm9ybXN9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuXG5cbmNvbnN0IGNyZWF0ZVZ4QXR0ZW50aW9uU2NvcmVQcm9ncmFtSW5mbyA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBwcm9iczogVGVuc29yVmlldywgdjogVGVuc29yVmlldywgcGFzdFZhbHVlOiBUZW5zb3JWaWV3fHVuZGVmaW5lZCxcbiAgICAgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzLCBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoO1xuICAgICAgY29uc3QgblJlcHMgPSBwYXJhbXMublJlcHMgPyBwYXJhbXMublJlcHMgOiAxO1xuICAgICAgY29uc3QgcmVwZWF0ZWRWSGlkZGVuU2l6ZSA9IHBhcmFtcy52SGlkZGVuU2l6ZSAqIG5SZXBzO1xuICAgICAgY29uc3QgcHJlc2VudFZhbHVlID0gcGFyYW1zLmt2TnVtSGVhZHMgPT0gbnVsbCAmJiBjb250ZXh0Lm91dHB1dENvdW50ID4gMTtcbiAgICAgIGNvbnN0IHByZXNlbnRWYWx1ZVNoYXBlID1cbiAgICAgICAgICBwcmVzZW50VmFsdWUgPyBbcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLm51bUhlYWRzLCB0b3RhbFNlcXVlbmNlTGVuZ3RoLCBwYXJhbXMuaGVhZFNpemVdIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLCByZXBlYXRlZFZIaWRkZW5TaXplXTtcbiAgICAgIGNvbnN0IFRJTEVfU0laRSA9IDEyO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgICAgIHg6IE1hdGguY2VpbChwYXJhbXMudkhlYWRTaXplIC8gVElMRV9TSVpFKSxcbiAgICAgICAgeTogTWF0aC5jZWlsKHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgICAgIHo6IHBhcmFtcy5iYXRjaFNpemUgKiBwYXJhbXMubnVtSGVhZHNcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLnNlcXVlbmNlTGVuZ3RofSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aH0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy52SGVhZFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMubnVtSGVhZHN9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiByZXBlYXRlZFZIaWRkZW5TaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFzdFNlcXVlbmNlTGVuZ3RofSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGh9XG4gICAgICBdO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPVxuICAgICAgICAgIHBhc3RWYWx1ZSA/IFsndHlwZScsICd0eXBlJywgJ3R5cGUnXSA6IFsndHlwZScsICd0eXBlJ107XG4gICAgICBjb25zdCBvdXRwdXRzID0gW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH1dO1xuICAgICAgaWYgKHByZXNlbnRWYWx1ZSkge1xuICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IHByZXNlbnRWYWx1ZVNoYXBlISwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2JzSGVscGVyID0gaW5wdXRWYXJpYWJsZSgncHJvYnMnLCBwcm9icy5kYXRhVHlwZSwgcHJvYnMuZGltcyk7XG4gICAgICAgIGNvbnN0IHZIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCd2Jywgdi5kYXRhVHlwZSwgdi5kaW1zKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYXJzID0gW3Byb2JzSGVscGVyLCB2SGVscGVyXTtcbiAgICAgICAgaWYgKHBhc3RWYWx1ZSkge1xuICAgICAgICAgIGlucHV0VmFycy5wdXNoKGlucHV0VmFyaWFibGUoJ3Bhc3RfdmFsdWUnLCBwYXN0VmFsdWUuZGF0YVR5cGUsIHBhc3RWYWx1ZS5kaW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHByb2JzLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgICAgIGNvbnN0IG91dHB1dFZhcnMgPSBbb3V0cHV0XTtcbiAgICAgICAgaWYgKHByZXNlbnRWYWx1ZSkge1xuICAgICAgICAgIG91dHB1dFZhcnMucHVzaChvdXRwdXRWYXJpYWJsZSgncHJlc2VudF92YWx1ZScsIHByb2JzLmRhdGFUeXBlLCBwcmVzZW50VmFsdWVTaGFwZSEpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdNJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ0snLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnTicsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICB7bmFtZTogJ251bV9oZWFkcycsIHR5cGU6ICd1MzInfSwge25hbWU6ICd2X2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgIHtuYW1lOiAncGFzdF9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAna3Zfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMid9XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBgXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7VElMRV9TSVpFfXU7XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke3Byb2JzSGVscGVyLnR5cGUudmFsdWV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtwcm9ic0hlbHBlci50eXBlLnZhbHVlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIC4uLm91dHB1dFZhcnMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1xuICAgICAgICAgIFRJTEVfU0laRSwgVElMRV9TSVpFLCAxXG4gICAgICAgIF0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQuejtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICBsZXQgb2Zmc2V0QSA9IGhlYWRJZHggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XG4gICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKHBhc3RWYWx1ZSAmJiBwcmVzZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgbGV0IHBhc3RWYWx1ZU9mZnNldCA9IGhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBuO1xuICAgIGxldCB2T2Zmc2V0ID0gaGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKyBuO1xuICAgICAgYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgIGxldCBvZmZzZXRCID0gaGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LICsgbjtcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfVxuICAgICR7cHJlc2VudFZhbHVlID8gJ2xldCBwcmVzZW50VmFsdWVPZmZzZXQgPSBoZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKyBuOycgOiAnJ31cbiAgIHZhciB2YWx1ZSA9ICR7cHJvYnNIZWxwZXIudHlwZS5zdG9yYWdlfSgwKTtcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKHBhc3RWYWx1ZSAmJiBwcmVzZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbGVLW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkgLSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgdGlsZUtbaWR4XSA9IHZbb2Zmc2V0QiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgIGA7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfVxuICAgICAgICAke3ByZXNlbnRWYWx1ZSA/ICdwcmVzZW50X3ZhbHVlW3ByZXNlbnRWYWx1ZU9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXSA9IHRpbGVLW2lkeF07JyA6ICcnfVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgIHZhbHVlICs9IHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54XTtcbiAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICB9XG5cbiAgIC8vIHdlIG5lZWQgdG8gdHJhbnNwb3NlIG91dHB1dCBmcm9tIEJOU0hfdiB0byBCU05EX3ZcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGN1cnJlbnRCYXRjaEhlYWROdW1iZXIgPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICBsZXQgb3V0cHV0SWR4ID0gYmF0Y2hJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZSArIG0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplXG4gICAgICAgKyBjdXJyZW50QmF0Y2hIZWFkTnVtYmVyICogdW5pZm9ybXMuTiArIG47XG4gICAgIG91dHB1dFtvdXRwdXRJZHhdID0gdmFsdWU7XG4gICB9XG4gIH1gO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0F0dGVudGlvblNjb3JlJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtwYXN0VmFsdWUgIT09IHVuZGVmaW5lZH07JHtjb250ZXh0Lm91dHB1dENvdW50fWAsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtvdXRwdXRzLCBkaXNwYXRjaEdyb3VwOiBkaXNwYXRjaCwgcHJvZ3JhbVVuaWZvcm1zfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGFwcGx5QXR0ZW50aW9uID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIHE6IFRlbnNvclZpZXcsIGs6IFRlbnNvclZpZXcsIHY6IFRlbnNvclZpZXcsIF9tYXNrSW5kZXg6IFRlbnNvclZpZXd8dW5kZWZpbmVkLFxuICAgICBfcGFzdDogVGVuc29yVmlld3x1bmRlZmluZWQsIHBhc3RLZXk6IFRlbnNvclZpZXd8dW5kZWZpbmVkLCBwYXN0VmFsdWU6IFRlbnNvclZpZXd8dW5kZWZpbmVkLFxuICAgICByZWxhdGl2ZVBvc2l0aW9uQmlhczogVGVuc29yVmlld3x1bmRlZmluZWQsIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRDb3VudCA9IGNvbnRleHQub3V0cHV0Q291bnQ7XG4gICAgICBjb25zdCBwYXN0U2VxdWVuY2VMZW5ndGggPVxuICAgICAgICAgIHBhcmFtZXRlcnMua3ZOdW1IZWFkcyAhPT0gdW5kZWZpbmVkIHx8IG91dHB1dENvdW50ID4gMSA/IHBhcmFtZXRlcnMucGFzdFNlcXVlbmNlTGVuZ3RoIDogMDtcbiAgICAgIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBwYXJhbWV0ZXJzLmt2U2VxdWVuY2VMZW5ndGg7XG5cbiAgICAgIGNvbnN0IGlucHV0c0sgPSAocGFyYW1ldGVycy5rdk51bUhlYWRzID09PSB1bmRlZmluZWQgJiYgb3V0cHV0Q291bnQgPiAxICYmIHBhc3RLZXkpID8gW3EsIGssIHBhc3RLZXldIDogW3EsIGtdO1xuICAgICAgaWYgKHJlbGF0aXZlUG9zaXRpb25CaWFzKSB7XG4gICAgICAgIGlucHV0c0sucHVzaChyZWxhdGl2ZVBvc2l0aW9uQmlhcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJ1biBBdHRlbnRpb25Qcm9ic1xuICAgICAgY29uc3QgcHJvYnMgPSBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlQXR0ZW50aW9uUHJvYnNQcm9ncmFtSW5mbyhcbiAgICAgICAgICAgICAgY29udGV4dCwgcSwgaywgb3V0cHV0Q291bnQgPiAxID8gcGFzdEtleSA6IHVuZGVmaW5lZCwgcmVsYXRpdmVQb3NpdGlvbkJpYXMsIHBhcmFtZXRlcnMsIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCksXG4gICAgICAgICAge2lucHV0czogaW5wdXRzSywgb3V0cHV0czogKHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA9PT0gdW5kZWZpbmVkICYmIG91dHB1dENvdW50ID4gMSkgPyBbLTEsIDFdIDogWy0xXX0pWzBdO1xuXG4gICAgICAvLyBSdW4gU29mdG1heFxuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZUluUGxhY2VTb2Z0bWF4UHJvZ3JhbUluZm8oXG4gICAgICAgICAgICAgIGNvbnRleHQsIHByb2JzLCBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHMgKiBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLFxuICAgICAgICAgICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoKSxcbiAgICAgICAgICB7aW5wdXRzOiBbcHJvYnNdLCBvdXRwdXRzOiBbXX0pO1xuXG4gICAgICAvLyBSdW4gQXR0cmlvblNjb3JlXG4gICAgICBjb25zdCBpbnB1dHNWID1cbiAgICAgICAgICAocGFyYW1ldGVycy5rdk51bUhlYWRzID09PSB1bmRlZmluZWQgJiYgb3V0cHV0Q291bnQgPiAxICYmIHBhc3RWYWx1ZSkgPyBbcHJvYnMsIHYsIHBhc3RWYWx1ZV0gOiBbcHJvYnMsIHZdO1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZVZ4QXR0ZW50aW9uU2NvcmVQcm9ncmFtSW5mbyhcbiAgICAgICAgICAgICAgY29udGV4dCwgcHJvYnMsIHYsIG91dHB1dENvdW50ID4gMSAmJiBwYXN0VmFsdWUgPyBwYXN0VmFsdWUgOiB1bmRlZmluZWQsIHBhcmFtZXRlcnMsIHBhc3RTZXF1ZW5jZUxlbmd0aCksXG4gICAgICAgICAge2lucHV0czogaW5wdXRzViwgb3V0cHV0czogKHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA9PT0gdW5kZWZpbmVkICYmIG91dHB1dENvdW50ID4gMSkgPyBbMCwgMl0gOiBbMF19KTtcbiAgICB9O1xuXG5jb25zdCBwcmVwYXJlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBwYXJhbWV0ZXJzOiBBdHRlbnRpb25QYXJhbWV0ZXJzKSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW1xuICAgIHBhcmFtZXRlcnMuYmF0Y2hTaXplLFxuICAgIHBhcmFtZXRlcnMubnVtSGVhZHMsXG4gICAgcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXJhbWV0ZXJzLmhlYWRTaXplLFxuICBdO1xuICBjb25zdCBNID0gcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgSyA9IHBhcmFtZXRlcnMuaW5wdXRIaWRkZW5TaXplO1xuICBjb25zdCBOID0gcGFyYW1ldGVycy5oZWFkU2l6ZTtcbiAgY29uc3QgVElMRV9TSVpFID0gMTI7XG4gIGNvbnN0IGRpc3BhdGNoID0ge1xuICAgIHg6IE1hdGguY2VpbChwYXJhbWV0ZXJzLmhlYWRTaXplIC8gVElMRV9TSVpFKSxcbiAgICB5OiBNYXRoLmNlaWwocGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgejogcGFyYW1ldGVycy5iYXRjaFNpemUgKiBwYXJhbWV0ZXJzLm51bUhlYWRzXG4gIH07XG4gIGNvbnN0IGlucHV0cyA9IFtjb250ZXh0LmlucHV0c1swXSwgY29udGV4dC5pbnB1dHNbMV0sIGNvbnRleHQuaW5wdXRzWzJdXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE19LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBLfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTn0sXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5udW1IZWFkc30sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGVhZFNpemV9LFxuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGlkZGVuU2l6ZX0sXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5oaWRkZW5TaXplICsgcGFyYW1ldGVycy5oaWRkZW5TaXplICsgcGFyYW1ldGVycy52SGlkZGVuU2l6ZX1cbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXRRID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9xJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0SyA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfaycsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dFYgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X3YnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcyk7XG4gICAgY29uc3Qgd2VpZ2h0ID0gaW5wdXRWYXJpYWJsZSgnd2VpZ2h0JywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcyk7XG4gICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUuc3RvcmFnZTtcblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHtuYW1lOiAnTScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdLJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ04nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnbnVtX2hlYWRzJywgdHlwZTogJ3UzMid9LFxuICAgICAge25hbWU6ICdoZWFkX3NpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnbGRiJywgdHlwZTogJ3UzMid9XG4gICAgXTtcbiAgICByZXR1cm4gYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSW5wdXQ6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRLOiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFY6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCB3ZWlnaHQsIGJpYXMsIG91dHB1dFEsIG91dHB1dEssIG91dHB1dFYpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1xuICAgICAgVElMRV9TSVpFLCBUSUxFX1NJWkUsIDFcbiAgICBdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke2RhdGFUeXBlfSgwKTtcbiAgICB2YXIgdmFsdWVLID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgdmFyIHZhbHVlViA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YDtcbiAgfTtcblxuICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgICAge1xuICAgICAgICBuYW1lOiAnQXR0ZW50aW9uUHJlcGFyZScsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7aW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJywgJ3R5cGUnXX0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0fSxcbiAgICAgICAgICAgIHtkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH0sXG4gICAgICAgICAgICB7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHR9LFxuICAgICAgICAgIF0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9LFxuICAgICAge2lucHV0cywgb3V0cHV0czogWy0xLCAtMSwgLTFdfSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXR0ZW50aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IHZvaWQgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUF0dGVudGlvbklucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG5cbiAgY29uc3QgW3EsIGssIHZdID0gcHJlcGFyZShjb250ZXh0LCBwYXJhbXMpO1xuXG4gIHJldHVybiBhcHBseUF0dGVudGlvbihcbiAgICAgIGNvbnRleHQsIHEsIGssIHYsIGNvbnRleHQuaW5wdXRzWzRdLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LmlucHV0c1s1XSwgcGFyYW1zLCBhdHRyaWJ1dGVzKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hOb3JtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGVwc2lsb246IG51bWJlcjtcbiAgcmVhZG9ubHkgbW9tZW50dW06IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BhdGlhbDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgdHJhaW5pbmdNb2RlOiBib29sZWFuO1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJ3wnTkNIVyc7XG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0cycpO1xuICB9XG5cbiAgY29uc3QgY2hlY2tTaGFwZUVxdWFsID0gKGFjdHVhbDogcmVhZG9ubHkgbnVtYmVyW10sIGV4cGVjdGVkOiByZWFkb25seSBudW1iZXJbXSwgbWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgciA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBpZiAociAhPT0gYWN0dWFsLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9OiBudW0gZGltZW5zaW9ucyAhPSAke3J9YCk7XG4gICAgfVxuICAgIGV4cGVjdGVkLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIGlmICh2ICE9PSBhY3R1YWxbaV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21lc3NhZ2V9OiBkaW1bJHtpfV0gZG8gbm90IG1hdGNoYCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBzaGFwZSA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgP1xuICAgICAgICAoYXR0cmlidXRlcy5zcGF0aWFsID8gaW5wdXRzWzBdLmRpbXMuc2xpY2UoLTEpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0c1swXS5kaW1zLnNsaWNlKC0xKS5jb25jYXQoaW5wdXRzWzBdLmRpbXMuc2xpY2UoMSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMSkpKSA6XG4gICAgICAgIGlucHV0c1swXS5kaW1zLnNsaWNlKDEsIGF0dHJpYnV0ZXMuc3BhdGlhbCA/IDIgOiB1bmRlZmluZWQpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMV0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IHNjYWxlJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1syXS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgQicpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbM10uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IG1lYW4nKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzRdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCB2YXInKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzFdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgc2NhbGUnKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzJdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgQicpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbM10uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCBtZWFuJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1s0XS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IHZhcicpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVCYXRjaE5vcm1JbmZlcmVuY2VQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3Qge2Vwc2lsb24sIHNwYXRpYWwsIGZvcm1hdH0gPSBhdHRyaWJ1dGVzO1xuICAgICAgY29uc3QgeVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gc3BhdGlhbCA/IGdldE1heENvbXBvbmVudHMoeVNoYXBlW3lTaGFwZS5sZW5ndGggLSAxXSkgOiAxO1xuICAgICAgY29uc3QgY0NvbXBvbmVudHMgPSBmb3JtYXQgPT09ICdOSFdDJyAmJiB5U2hhcGUubGVuZ3RoID4gMSA/IGNvbXBvbmVudHMgOiAxO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKHlTaGFwZSkgLyBjb21wb25lbnRzO1xuICAgICAgLy8gT25seSBzdXBwb3J0IHVuaWZvcm1zIGZvciBvcHNldCB2ZXJzaW9uID49IDkgKHNwYXRpYWwgPSB0cnVlKS5cbiAgICAgIGNvbnN0IHVzZVNoYXBlc1VuaWZvcm1zID0gc3BhdGlhbDtcbiAgICAgIGNvbnN0IHNoYXBlT3JSYW5rID0gdXNlU2hhcGVzVW5pZm9ybXMgPyB5U2hhcGUubGVuZ3RoIDogeVNoYXBlO1xuICAgICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IHNjYWxlID0gaW5wdXRWYXJpYWJsZSgnc2NhbGUnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLCBjQ29tcG9uZW50cyk7XG4gICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IGlucHV0TWVhbiA9IGlucHV0VmFyaWFibGUoJ2lucHV0TWVhbicsIGlucHV0c1szXS5kYXRhVHlwZSwgaW5wdXRzWzNdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IGlucHV0VmFyID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRWYXInLCBpbnB1dHNbNF0uZGF0YVR5cGUsIGlucHV0c1s0XS5kaW1zLCBjQ29tcG9uZW50cyk7XG4gICAgICBjb25zdCB5ID0gb3V0cHV0VmFyaWFibGUoJ3knLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHNoYXBlT3JSYW5rLCBjb21wb25lbnRzKTtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgaW5wdXRzIHdpdGggZGlmZmVyZW50IGRhdGEgdHlwZS4gQ3VycmVudCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgaW5wdXRzIGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlxuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgc2hhZGVyIGNvbXBpbGF0aW9uIHdpbGwgZmFpbC5cbiAgICAgIGNvbnN0IGNhbGNDT2Zmc2V0ID0gKCk6IHN0cmluZyA9PiB7XG4gICAgICAgIGxldCBjT2Zmc2V0ID0gJyc7XG4gICAgICAgIGlmIChzcGF0aWFsKSB7XG4gICAgICAgICAgY09mZnNldCA9IGBsZXQgY09mZnNldCA9ICR7XG4gICAgICAgICAgICAgIHlTaGFwZS5sZW5ndGggPT09IDEgICA/ICcwdScgOlxuICAgICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTkhXQycgPyBgb3V0cHV0SW5kaWNlc1ske3lTaGFwZS5sZW5ndGggLSAxfV0gLyAke2NvbXBvbmVudHN9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdXRwdXRJbmRpY2VzWzFdJ307YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTkNIVycpIHtcbiAgICAgICAgICAgIGNPZmZzZXQgPSBgXG4gICAgICAgICAgICAke3kuaW5kaWNlc1NldCgnb3V0cHV0SW5kaWNlcycsICcwJywgJzAnKX1cbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHt5LmluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycpfTtgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgQyBjaGFubmVsLlxuICAgICAgICAgICAgY09mZnNldCA9IGB2YXIgY0luZGljZXMgPSAke3NjYWxlLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGNJbmRpY2VzWzBdID0gb3V0cHV0SW5kaWNlc1ske3lTaGFwZS5sZW5ndGggLSAxfV07YDtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBEMSB4IC4uLiB4IERuIGNoYW5uZWxzLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzY2FsZS5yYW5rOyBpKyspIHtcbiAgICAgICAgICAgICAgY09mZnNldCArPSBgY0luZGljZXNbJHtpfV0gPSBvdXRwdXRJbmRpY2VzWyR7aX1dO2A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjT2Zmc2V0ICs9IGBsZXQgY09mZnNldCA9ICR7c2NhbGUuaW5kaWNlc1RvT2Zmc2V0KCdjSW5kaWNlcycpfTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY09mZnNldDtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRJbmZlcmVuY2VNb2RlU2hhZGVyU291cmNlID0gKGhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gIGNvbnN0IGVwc2lsb24gPSAke2Vwc2lsb259O1xuICAke2hlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBzY2FsZSwgYmlhcywgaW5wdXRNZWFuLCBpbnB1dFZhciwgeSl9XG4gICR7aGVscGVyLm1haW5TdGFydCgpfVxuICAke2hlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgdmFyIG91dHB1dEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfWApfTtcbiAgICAke2NhbGNDT2Zmc2V0KCl9XG4gICAgbGV0IHNjYWxlID0gJHtzY2FsZS5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtcbiAgICBsZXQgYmlhcyA9ICR7Ymlhcy5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtcbiAgICBsZXQgaW5wdXRNZWFuID0gJHtpbnB1dE1lYW4uZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IGlucHV0VmFyID0gJHtpbnB1dFZhci5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtcbiAgICBsZXQgeCA9ICR7eC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgdmFsdWUgPSAoeCAtIGlucHV0TWVhbikgKiBpbnZlcnNlU3FydChpbnB1dFZhciArIGVwc2lsb24pICogc2NhbGUgKyBiaWFzO1xuICAgICR7eS5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdCYXRjaE5vcm1hbGl6YXRpb24nLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuZXBzaWxvbn1fJHthdHRyaWJ1dGVzLmZvcm1hdH1fJHtzcGF0aWFsfV8ke2NvbXBvbmVudHN9YCxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogdXNlU2hhcGVzVW5pZm9ybXMgPyBbJ3JhbmsnLCAndHlwZScsICd0eXBlJywgJ3R5cGUnLCAndHlwZSddIDogdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2U6IGdldEluZmVyZW5jZU1vZGVTaGFkZXJTb3VyY2UsXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBpbnB1dHNbMF0uZGltcywgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiB1c2VTaGFwZXNVbmlmb3JtcyA/XG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSxcbiAgICAgICAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh5U2hhcGUpLFxuICAgICAgICAgICAgICBdIDpcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQmF0Y2hOb3JtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEJhdGNoTm9ybUF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyBPbWl0PEJhdGNoTm9ybUF0dHJpYnV0ZXMsIGtleW9mIEF0dHJpYnV0ZVdpdGhDYWNoZUtleT4pO1xuXG5leHBvcnQgY29uc3QgYmF0Y2hOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHZvaWQgPT4ge1xuICBjb25zdCB7aW5wdXRzLCBvdXRwdXRDb3VudH0gPSBjb250ZXh0O1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlcyA9IHBhcnNlQmF0Y2hOb3JtQXR0cmlidXRlcyh7Li4uYXR0cmlidXRlcywgb3V0cHV0Q291bnR9KTtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQpIHtcbiAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy50cmFpbmluZ01vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvKGlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAoIVszMjAsIDY0MCwgMTI4MF0uaW5jbHVkZXMoaW5wdXRzWzBdLmRpbXNbMl0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODAnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1syXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmlhc0FkZFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuXG4gIGNvbnN0IGNoYW5uZWxzID0gaW5wdXRzWzBdLmRpbXNbMl07XG4gIC8vIHNpbmNlIGNoYW5uZWwgbnVtYmVyIGNhbiBiZSBvbmx5IDMyMC82NDAvMTI4MCwgaXQncyBhbHdheXMgZGl2aXNhYmxlIGJ5IDRcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQ7XG5cbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGRhdGFUeXBlLCBbY2hhbm5lbHNdLCA0KTtcbiAgY29uc3QgcmVzaWR1YWwgPSBpbnB1dFZhcmlhYmxlKCdyZXNpZHVhbCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUsIDQpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICBjb25zdCBjaGFubmVscyA9ICR7Y2hhbm5lbHN9dSAvIDQ7XG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGJpYXMsIHJlc2lkdWFsLCBvdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XG4gICAgbGV0IHZhbHVlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfVxuICAgICAgKyAke2JpYXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHggJSBjaGFubmVscycpfSArICR7cmVzaWR1YWwuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQmlhc0FkZCcsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX1cbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc0FkZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCaWFzQWRkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtNQVhfQ0xJUCwgTUlOX0NMSVAsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5cbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcbnR5cGUgRWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb246IHN0cmluZykgPT4gc3RyaW5nO1xudHlwZSBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCA9IEJ1aWx0aW5GdW5jdGlvbk5hbWV8RWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uO1xuXG5jb25zdCBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1TaGFkZXIgPVxuICAgIChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlciwgZGF0YXNpemU6IG51bWJlciwgaW5wdXREYXRhVHlwZTogbnVtYmVyLCBvdXRwdXREYXRhVHlwZTogbnVtYmVyLFxuICAgICBmdW5jQ2FsbDogRWxlbWVudHdpc2VGdW5jdGlvbkNhbGwsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCB2ZWNTaXplID0gTWF0aC5jZWlsKGRhdGFzaXplIC8gNCk7XG5cbiAgICAgIGxldCBleHByZXNzaW9uID0gJyc7XG4gICAgICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICBleHByZXNzaW9uID0gYCR7ZnVuY0NhbGx9KGEpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBmdW5jQ2FsbCgnYScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0RGF0YScsIGlucHV0RGF0YVR5cGUsIFt2ZWNTaXplXSwgNCk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIG91dHB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xuXG4gICAgICByZXR1cm4gYFxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuXG4gICR7YWRkaXRpb25hbEltcGxlbWVudGF0aW9uID8/ICcnfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XG5cbiAgICBsZXQgYSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBleHByZXNzaW9uKX1cbiAgfWA7XG4gICAgfTtcblxuY29uc3QgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0OiBUZW5zb3JWaWV3LCBuYW1lOiBzdHJpbmcsIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxuICAgICBjYWNoZUtleT86IHN0cmluZywgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGlucHV0LmRhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4gKHtcbiAgICAgIG5hbWUsXG4gICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ119LFxuICAgICAgZ2V0U2hhZGVyU291cmNlOiBzaGFkZXJIZWxwZXIgPT4gY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtU2hhZGVyKFxuICAgICAgICAgIHNoYWRlckhlbHBlciwgU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcyksIGlucHV0LmRhdGFUeXBlLCBvdXRwdXREYXRhVHlwZSwgZnVuY0NhbGwsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiksXG4gICAgICBnZXRSdW5EYXRhOiAoaW5wdXRUZW5zb3JzKSA9PiAoe1xuICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IGlucHV0LmRpbXMsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZX1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOlxuICAgICAgICAgICAge3g6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShpbnB1dFRlbnNvcnNbMF0uZGltcykgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogdmVjIHNpemUgKi8pfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGlucHV0LmRpbXMpIC8gNCl9LFxuICAgICAgICBdLFxuICAgICAgfSlcbiAgICB9KTtcblxuZXhwb3J0IGNvbnN0IGFicyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FicycsICdhYnMnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYWNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Fjb3MnLCAnYWNvcycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Fjb3NoJywgJ2Fjb3NoJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFzaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBc2luJywgJ2FzaW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXNpbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBc2luaCcsICdhc2luaCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhdGFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXRhbicsICdhdGFuJykpO1xufTtcbmV4cG9ydCBjb25zdCBhdGFuaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0F0YW5oJywgJ2F0YW5oJykpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDYXN0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHRvOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNhdHVyYXRlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlQ2FzdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDYXN0QXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHt0bzogbnVtYmVyfSk7XG5cblxuZXhwb3J0IGNvbnN0IGNhc3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENhc3RBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGxldCBmdW5jOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbDtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLnRvKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgZnVuYyA9ICd2ZWM0PGYxNj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIGZ1bmMgPSAndmVjNDxmMzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgZnVuYyA9ICd2ZWM0PHUzMj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIGZ1bmMgPSAndmVjNDxpMzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIGZ1bmMgPSAndmVjNDxib29sPic7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHthdHRyaWJ1dGVzLnRvfWApO1xuICB9XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdDYXN0JywgZnVuYywgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBhdHRyaWJ1dGVzLnRvKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaXBBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgbWluOiBudW1iZXI7XG4gIHJlYWRvbmx5IG1heDogbnVtYmVyO1xufVxuXG5jb25zdCBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgbWluID0gKGlucHV0cy5sZW5ndGggPj0gMiAmJiBpbnB1dHNbMV0uZGF0YSAhPT0gMCkgPyBpbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiBNSU5fQ0xJUDtcbiAgY29uc3QgbWF4ID0gKGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YSAhPT0gMCkgPyBpbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiBNQVhfQ0xJUDtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7bWluLCBtYXh9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjbGlwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBjbGlwQXR0cmlidXRlczogQ2xpcEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGNsaXBBdHRyaWJ1dGVzIDogZ2VuZXJhdGVDbGlwQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnQ2xpcCcsIGEgPT4gYGNsYW1wKCR7YX0sIGNsaXBfbWluXywgY2xpcF9tYXhfKWAsIGBcbiAgICBjb25zdCBjbGlwX21pbl86IHZlYzQ8JHtkYXRhVHlwZX0+ID0gdmVjNCgke2RhdGFUeXBlfSgke2F0dHJpYnV0ZXMubWlufSkpO1xuICAgIGNvbnN0IGNsaXBfbWF4XzogdmVjNDwke2RhdGFUeXBlfT4gPSB2ZWM0KCR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5tYXh9KSk7XG5gLFxuICAgICAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXkpLFxuICAgICAge2lucHV0czogWzBdfSk7XG59O1xuXG5leHBvcnQgY29uc3QgY2VpbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NlaWwnLCAnY2VpbCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb3MgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdDb3MnLCAnY29zJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvc2ggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdDb3NoJywgJ2Nvc2gnKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFscGhhQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUFscGhhQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEFscGhhQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHthbHBoYTogbnVtYmVyfSk7XG5cbmV4cG9ydCBjb25zdCBlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnRWx1JywgYSA9PiBgZWx1X3ZmMzIoJHthfSlgLCBgXG4gIGNvbnN0IGVsdV9hbHBoYV8gPSAke2RhdGFUeXBlfSgke2F0dHJpYnV0ZXMuYWxwaGF9KTtcblxuICBmbiBlbHVfZjMyKGE6ICR7ZGF0YVR5cGV9KSAtPiAke2RhdGFUeXBlfSB7XG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XG4gIH1cblxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PCR7ZGF0YVR5cGV9PikgLT4gdmVjNDwke2RhdGFUeXBlfT4ge1xuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xuICB9YCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXkpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlcmZJbXBsID0gKHZhclR5cGUgPSAnZjMyJykgPT4gYFxuY29uc3QgcjA6ICR7dmFyVHlwZX0gPSAwLjMyNzU5MTE7XG5jb25zdCByMTogJHt2YXJUeXBlfSA9IDAuMjU0ODI5NTkyO1xuY29uc3QgcjI6ICR7dmFyVHlwZX0gPSAtMC4yODQ0OTY3MzY7XG5jb25zdCByMzogJHt2YXJUeXBlfSA9IDEuNDIxNDEzNzQxO1xuY29uc3QgcjQ6ICR7dmFyVHlwZX0gPSAtMS40NTMxNTIwMjc7XG5jb25zdCByNTogJHt2YXJUeXBlfSA9IDEuMDYxNDA1NDI5O1xuXG5mbiBlcmZfdmYzMih2OiB2ZWM0PCR7dmFyVHlwZX0+KSAtPiB2ZWM0PCR7dmFyVHlwZX0+IHtcbiAgbGV0IGFic3YgPSBhYnModik7XG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xufWA7XG5cbmV4cG9ydCBjb25zdCBlcmYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdFcmYnLCBhID0+IGBlcmZfdmYzMigke2F9KWAsIGVyZkltcGwoZGF0YVR5cGUpKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXhwJywgJ2V4cCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmbG9vciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Zsb29yJywgJ2Zsb29yJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSwgJ0dlbHUnLCBhID0+IGAwLjUgKiAke2F9ICogKDEuMCArIGVyZl92ZjMyKCR7YX0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAsIGVyZkltcGwoZGF0YVR5cGUpKSk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVha3lSZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBbHBoYUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSwgJ0xlYWt5UmVsdScsIGEgPT4gYHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7YX0sICR7YX0sICR7YX0gPj0gdmVjNDwke2RhdGFUeXBlfT4oMC4wKSlgLFxuICAgICAgYGNvbnN0IGxlYWt5X3JlbHVfYWxwaGFfID0gJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLmFscGhhfSk7YCwgYXR0cmlidXRlcy5jYWNoZUtleSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IG5vdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ05vdCcsIGEgPT4gYCEke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IG5lZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ05lZycsIGEgPT4gYC0ke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlY2lwcm9jYWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdSZWNpcHJvY2FsJywgYSA9PiBgMS4wLyR7YX1gKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnUmVsdScsIGEgPT4gYHNlbGVjdCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCAke2F9LCAke2F9ID4gdmVjNDwke2RhdGFUeXBlfT4oMC4wKSlgKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2lnbW9pZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpZ21vaWQnLCBhID0+IGAoMS4wIC8gKDEuMCArIGV4cCgtJHthfSkpKWApKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFyZFNpZ21vaWRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcbiAgcmVhZG9ubHkgYmV0YTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgcGFyc2VIYXJkU2lnbW9pZEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoYXR0cmlidXRlcyBhcyB7XG4gICAgICBhbHBoYTogbnVtYmVyO1xuICAgICAgYmV0YTogbnVtYmVyO1xuICAgIH0pO1xuXG5leHBvcnQgY29uc3QgaGFyZFNpZ21vaWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEhhcmRTaWdtb2lkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnSGFyZFNpZ21vaWQnLFxuICAgICAgYSA9PiBgbWF4KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksIG1pbih2ZWM0PCR7ZGF0YVR5cGV9PigxLjApLCAke2F0dHJpYnV0ZXMuYWxwaGF9ICogJHthfSArIHZlYzQ8JHtkYXRhVHlwZX0+KCR7XG4gICAgICAgICAgYXR0cmlidXRlcy5iZXRhfSkpKWAsXG4gICAgICB1bmRlZmluZWQsIGF0dHJpYnV0ZXMuY2FjaGVLZXkpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTaW4nLCAnc2luJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNpbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdTaW5oJywgJ3NpbmgnKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc3FydCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NxcnQnLCAnc3FydCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdUYW4nLCAndGFuJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRhbmhFeHByZXNzaW9uID0gKGE6IHN0cmluZykgPT4gYHNpZ24oJHthfSkgKiAoMSAtIGV4cCgtMiAqIGFicygke2F9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHthfSkpKWA7XG5cbmV4cG9ydCBjb25zdCB0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIC8vIFRPRE86IHJldmlzaXQgYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL2dwdXdlYi9ncHV3ZWIvaXNzdWVzLzQ0NTggaXMgcmVzb2x2ZWRcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdUYW5oJywgdGFuaEV4cHJlc3Npb24pKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmYXN0R2VsdUltcGwgPSAodmFyVHlwZSA9ICdmMzInKSA9PiBgXG5jb25zdCBmYXN0X2dlbHVfYTogJHt2YXJUeXBlfSA9IDAuNTtcbmNvbnN0IGZhc3RfZ2VsdV9iOiAke3ZhclR5cGV9ID0gMC43OTc4ODQ1NjA4MDI4NjU0O1xuY29uc3QgZmFzdF9nZWx1X2M6ICR7dmFyVHlwZX0gPSAwLjAzNTY3NzQwODEzNjMwMDEyNTtcblxuZm4gdGFuaF92KHY6IHZlYzQ8JHt2YXJUeXBlfT4pIC0+IHZlYzQ8JHt2YXJUeXBlfT4ge1xuICByZXR1cm4gJHt0YW5oRXhwcmVzc2lvbigndicpfTtcbn1cbmA7XG5cbmV4cG9ydCBjb25zdCBmYXN0R2VsdUV4cHJlc3Npb24gPSAoeDogc3RyaW5nKSA9PlxuICAgIGAoZmFzdF9nZWx1X2EgKyBmYXN0X2dlbHVfYSAqIHRhbmhfdigke3h9ICogKGZhc3RfZ2VsdV9jICogJHt4fSAqICR7eH0gKyBmYXN0X2dlbHVfYikpKSAqICR7eH1gO1xuXG5leHBvcnQgY29uc3QgZmFzdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSwgJ0Zhc3RHZWx1JywgZmFzdEdlbHVFeHByZXNzaW9uLCBmYXN0R2VsdUltcGwoZGF0YVR5cGUpLCB1bmRlZmluZWQsXG4gICAgICBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRocmVzaG9sZGVkUmVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogbnVtYmVyID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSwgJ1RocmVzaG9sZGVkUmVsdScsIGEgPT4gYHNlbGVjdCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCAke2F9LCAke2F9ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxcbiAgICAgIGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtkYXRhVHlwZX0+KCR7YXR0cmlidXRlcy5hbHBoYX0pO2AsIGF0dHJpYnV0ZXMuY2FjaGVLZXkpKTtcbiAgcmV0dXJuIDA7XG59O1xuXG5leHBvcnQgY29uc3QgbG9nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTG9nJywgJ2xvZycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBxdWlja0dlbHVJbXBsID0gKHZhclR5cGU6IHN0cmluZywgYWxwaGE6IG51bWJlcikgPT4gYFxuY29uc3QgYWxwaGEgPSB2ZWM0PCR7dmFyVHlwZX0+KCR7YWxwaGF9KTtcbmNvbnN0IG9uZSA9ICR7dmFyVHlwZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke3ZhclR5cGV9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7dmFyVHlwZX0+KSAtPiB2ZWM0PCR7dmFyVHlwZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke3ZhclR5cGV9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmA7XG5cbmV4cG9ydCBjb25zdCBxdWlja0dlbHVFeHByZXNzaW9uID0gKHg6IHN0cmluZykgPT4gYHF1aWNrX2dlbHVfaW1wbCgke3h9KWA7XG5cbmV4cG9ydCBjb25zdCBxdWlja2dlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnUXVpY2tHZWx1JywgcXVpY2tHZWx1RXhwcmVzc2lvbiwgcXVpY2tHZWx1SW1wbChkVHlwZSwgYXR0cmlidXRlcy5hbHBoYSksIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSkpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZX0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHtlcmZJbXBsfSBmcm9tICcuL3VuYXJ5LW9wJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAoIVsyNTYwLCA1MTIwLCAxMDI0MF0uaW5jbHVkZXMoaW5wdXRzWzBdLmRpbXNbMl0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDAnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1syXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmlhc1NwbGl0R2VsdVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIG91dHB1dFNoYXBlWzJdID0gb3V0cHV0U2hhcGVbMl0gLyAyO1xuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCA0KTtcbiAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIFtpbnB1dHNbMF0uZGltc1syXV0sIDQpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQ7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7aW5wdXRzWzBdLmRpbXNbMl0gLyA0IC8gMn11O1xuXG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGJpYXMsIG91dHB1dCl9XG5cbiAgJHtlcmZJbXBsKGRhdGFUeXBlKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcbiAgICBsZXQgYmF0Y2hJbmRleCA9IGdsb2JhbF9pZHggLyBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmlhc0lkeCArIGJhdGNoSW5kZXggKiBoYWxmQ2hhbm5lbHMgKiAyO1xuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xuICAgIGxldCB2YWx1ZVJpZ2h0ID0gaW5wdXRbaW5wdXRPZmZzZXQgKyBoYWxmQ2hhbm5lbHNdICsgYmlhc1tiaWFzSWR4ICsgaGFsZkNoYW5uZWxzXTtcbiAgICBsZXQgZ2VsdVJpZ2h0ID0gdmFsdWVSaWdodCAqIDAuNSAqIChlcmZfdmYzMih2YWx1ZVJpZ2h0IC8gTV9TUVJUMikgKyAxKTtcblxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlTGVmdCAqIGdlbHVSaWdodCcpfVxuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCaWFzU3BsaXRHZWx1JyxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfVxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBiaWFzU3BsaXRHZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJpYXNTcGxpdEdlbHVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge0Jyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcbnR5cGUgQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbiA9IChleHByZXNzaW9uQTogc3RyaW5nLCBleHByZXNzaW9uQjogc3RyaW5nKSA9PiBzdHJpbmc7XG50eXBlIEJpbmFyeUZ1bmN0aW9uQ2FsbCA9IEJ1aWx0aW5GdW5jdGlvbk5hbWV8QmluYXJ5Q3VzdG9tRXhwcmVzc2lvbnx7XG4gIHNjYWxhcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgdmVjdG9yOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xufTtcblxuY29uc3QgY3JlYXRlQmluYXJ5T3BQcm9ncmFtU2hhZGVyID1cbiAgICAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsIGRpbXNBOiByZWFkb25seSBudW1iZXJbXSwgZGltc0I6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zT3V0cHV0OiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgdmVjdG9yaXplOiBib29sZWFuLCBkb0Jyb2FkY2FzdDogYm9vbGVhbiwgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0OiBib29sZWFuLCBmdW5jQ2FsbDogQmluYXJ5RnVuY3Rpb25DYWxsLFxuICAgICB0eXBlQTogbnVtYmVyLCB0eXBlQjogbnVtYmVyLCB0eXBlT3V0cHV0OiBudW1iZXIsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZykgPT4ge1xuICAgICAgbGV0IGV4cHJlc3Npb25TY2FsYXI6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG4gICAgICBsZXQgZXhwcmVzc2lvblZlY3RvcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgZnVuY0NhbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gKGEsIGIpID0+IGAke2Z1bmNDYWxsfSgoJHthfSksKCR7Yn0pKWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jQ2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBleHByZXNzaW9uU2NhbGFyID0gZXhwcmVzc2lvblZlY3RvciA9IGZ1bmNDYWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwcmVzc2lvblNjYWxhciA9IGZ1bmNDYWxsLnNjYWxhcjtcbiAgICAgICAgZXhwcmVzc2lvblZlY3RvciA9IGZ1bmNDYWxsLnZlY3RvcjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dERhdGEnLCB0eXBlT3V0cHV0LCBkaW1zT3V0cHV0Lmxlbmd0aCwgNCk7XG4gICAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYURhdGEnLCB0eXBlQSwgZGltc0EubGVuZ3RoLCA0KTtcbiAgICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiRGF0YScsIHR5cGVCLCBkaW1zQi5sZW5ndGgsIDQpO1xuXG4gICAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICAgICAgaWYgKHZlY3Rvcml6ZSkge1xuICAgICAgICBpZiAoZG9Ccm9hZGNhc3QpIHtcbiAgICAgICAgICBjb25zdCBpc0FPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoZGltc0EpID09PSAxO1xuICAgICAgICAgIGNvbnN0IGlzQk9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQikgPT09IDE7XG4gICAgICAgICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBkaW1zQS5sZW5ndGggPiAwICYmIGRpbXNBW2RpbXNBLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICAgICAgICBjb25zdCBiTGFzdERpbURpdmlzaWJsZUJ5NCA9IGRpbXNCLmxlbmd0aCA+IDAgJiYgZGltc0JbZGltc0IubGVuZ3RoIC0gMV0gJSA0ID09PSAwO1xuICAgICAgICAgIGlmIChpc0FPbmVFbGVtZW50IHx8IGlzQk9uZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICAgICAgICAgIGlzQU9uZUVsZW1lbnQgPyBgJHthLnR5cGUudmFsdWV9KCR7YS5nZXRCeU9mZnNldCgnMCcpfS54KWAgOiBhLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksXG4gICAgICAgICAgICAgICAgICAgIGlzQk9uZUVsZW1lbnQgPyBgJHtiLnR5cGUudmFsdWV9KCR7Yi5nZXRCeU9mZnNldCgnMCcpfS54KWAgOiBiLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JykpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4ICogNHUnKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgICAgICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgfHwgYUxhc3REaW1EaXZpc2libGVCeTQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZ2V0QnlPZmZzZXQoJ29mZnNldEEgLyA0dScpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHthLnR5cGUudmFsdWV9KCR7YS5nZXRCeU9mZnNldCgnb2Zmc2V0QSAvIDR1Jyl9W29mZnNldEEgJSA0dV0pYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5nZXRCeU9mZnNldCgnb2Zmc2V0QiAvIDR1JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KCdvZmZzZXRCIC8gNHUnKX1bb2Zmc2V0QiAlIDR1XSlgKSl9XG4gICAgICAgICAgYDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWdubWVudCA9IG91dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgICAgICAgJ2dsb2JhbF9pZHgnLCBleHByZXNzaW9uVmVjdG9yKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZG9Ccm9hZGNhc3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbkEgPSBgYURhdGFbaW5kZXhBJHt4fV1bY29tcG9uZW50QSR7eH1dYDtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uQiA9IGBiRGF0YVtpbmRleEIke3h9XVtjb21wb25lbnRCJHt4fV1gO1xuICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke3h9ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7eH0gPSBvZmZzZXRBJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7eH0gPSBvZmZzZXRCJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke3h9ID0gb2Zmc2V0QSR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHt4fSA9IG9mZnNldEIke3h9ICUgNHU7XG4gICAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2V4cHJlc3Npb25TY2FsYXIoZXhwcmVzc2lvbkEsIGV4cHJlc3Npb25CKX0pO1xuICAgICAgICAgIGA7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlT3V0cHV0ID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAwKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDEpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMil9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAzKX1cbiAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgndmVjX3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhhLCBiLCBvdXRwdXQpfVxuXG4gICAgICAgICR7YWRkaXRpb25hbEltcGxlbWVudGF0aW9uID8/ICcnfVxuXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxuICAgICAgICAke2Fzc2lnbm1lbnR9XG4gICAgICB9YDtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvID1cbiAgICAobmFtZTogc3RyaW5nLCBjYWNoZUtleTogc3RyaW5nLCBhOiBUZW5zb3JWaWV3LCBiOiBUZW5zb3JWaWV3LCBmdW5jQ2FsbDogQmluYXJ5RnVuY3Rpb25DYWxsLFxuICAgICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsIG91dHB1dERhdGFUeXBlOiBudW1iZXIgPSBhLmRhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaXNCcm9hZGNhc3QgPSAhU2hhcGVVdGlsLmFyZUVxdWFsKGEuZGltcywgYi5kaW1zKTtcbiAgICAgIGxldCBvdXRwdXRTaGFwZSA9IGEuZGltcztcbiAgICAgIGxldCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoYS5kaW1zKTtcblxuICAgICAgbGV0IHZlY3Rvcml6ZSA9IGZhbHNlO1xuICAgICAgbGV0IHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCA9IGZhbHNlO1xuXG4gICAgICAvLyBUT0RPOiBkZWFsIHdpdGggemVyby1zaXplZCB0ZW5zb3JzIChlZy4gZGltcz1bMSwwXSlcbiAgICAgIGNvbnN0IGNhY2hlS2V5QXV4ID0gW2lzQnJvYWRjYXN0XTtcbiAgICAgIGlmIChpc0Jyb2FkY2FzdCkge1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkU2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhLmRpbXMsIGIuZGltcywgZmFsc2UpO1xuICAgICAgICBpZiAoIWNhbGN1bGF0ZWRTaGFwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xuICAgICAgICBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgICBjb25zdCBpc0FPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoYS5kaW1zKSA9PT0gMTtcbiAgICAgICAgY29uc3QgaXNCT25lRWxlbWVudCA9IFNoYXBlVXRpbC5zaXplKGIuZGltcykgPT09IDE7XG4gICAgICAgIGNvbnN0IGFMYXN0RGltRGl2aXNpYmxlQnk0ID0gYS5kaW1zLmxlbmd0aCA+IDAgJiYgYS5kaW1zW2EuZGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICAgIGNvbnN0IGJMYXN0RGltRGl2aXNpYmxlQnk0ID0gYi5kaW1zLmxlbmd0aCA+IDAgJiYgYi5kaW1zW2IuZGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICAgIGNhY2hlS2V5QXV4LnB1c2goaXNBT25lRWxlbWVudCk7XG4gICAgICAgIGNhY2hlS2V5QXV4LnB1c2goaXNCT25lRWxlbWVudCk7XG4gICAgICAgIGNhY2hlS2V5QXV4LnB1c2goYUxhc3REaW1EaXZpc2libGVCeTQpO1xuICAgICAgICBjYWNoZUtleUF1eC5wdXNoKGJMYXN0RGltRGl2aXNpYmxlQnk0KTtcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB2ZWN0b3JpemUgY2FuIGJlIGVuYWJsZWRcbiAgICAgICAgbGV0IHNoYXJlZERpbWVuc2lvbiA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3V0cHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBkaW1BID0gYS5kaW1zW2EuZGltcy5sZW5ndGggLSBpXSA/PyAxO1xuICAgICAgICAgIGNvbnN0IGRpbUIgPSBiLmRpbXNbYi5kaW1zLmxlbmd0aCAtIGldID8/IDE7XG4gICAgICAgICAgaWYgKGRpbUEgPT09IGRpbUIpIHtcbiAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbiAqPSBkaW1BO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlZERpbWVuc2lvbiAlIDQgPT09IDApIHtcbiAgICAgICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgPSB0cnVlO1xuICAgICAgICAgIHZlY3Rvcml6ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBT25lRWxlbWVudCB8fCBpc0JPbmVFbGVtZW50IHx8IGFMYXN0RGltRGl2aXNpYmxlQnk0IHx8IGJMYXN0RGltRGl2aXNpYmxlQnk0KSB7XG4gICAgICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZWxlbWVudC13aXNlXG4gICAgICAgIHZlY3Rvcml6ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjYWNoZUtleUF1eC5wdXNoKHZlY3Rvcml6ZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogY2FjaGVLZXkgKyBjYWNoZUtleUF1eC5tYXAoKHgpID0+IHgudG9TdHJpbmcoKSkuam9pbignXycpLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddLFxuICAgICAgICB9LFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+IGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbVNoYWRlcihcbiAgICAgICAgICAgIHNoYWRlckhlbHBlciwgYS5kaW1zLCBiLmRpbXMsIG91dHB1dFNoYXBlLCB2ZWN0b3JpemUsIGlzQnJvYWRjYXN0LCBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQsIGZ1bmNDYWxsLFxuICAgICAgICAgICAgYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSwgb3V0cHV0RGF0YVR5cGUsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiksXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIGNvbXBvbmVudCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNCl9LFxuICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYS5kaW1zLCBiLmRpbXMsIG91dHB1dFNoYXBlKVxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBydW5CaW5hcnlPcCA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBuYW1lOiBzdHJpbmcsIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgICAgY2FjaGVLZXk/OiBzdHJpbmcsIG91dHB1dERhdGFUeXBlPzogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmluYXJ5T3BQcm9ncmFtSW5mbyhcbiAgICAgICAgICBuYW1lLCBjYWNoZUtleSA/PyAnJywgY29udGV4dC5pbnB1dHNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLCBmdW5jQ2FsbCwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgICAgIG91dHB1dERhdGFUeXBlKSk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGFkZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnQWRkJywgKGEsIGIpID0+IGAke2F9KyR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkaXYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0RpdicsIChhLCBiKSA9PiBgJHthfS8ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgICBjb250ZXh0LCAnRXF1YWwnLCAoe3NjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT09JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX09PSR7Yn0pYH0pLCB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsIERhdGFUeXBlLmJvb2wpO1xufTtcblxuZXhwb3J0IGNvbnN0IG11bCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnTXVsJywgKGEsIGIpID0+IGAke2F9KiR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwb3cgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgdHlwZSA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7XG4gIGNvbnN0IHJvdW5kU3RyID0gdHlwZSA9PT0gJ2kzMicgPyAncm91bmQnIDogJyc7XG4gIHJ1bkJpbmFyeU9wKFxuICAgICAgY29udGV4dCwgJ1BvdycsICh7c2NhbGFyOiAoYSwgYikgPT4gYHBvd19jdXN0b20oJHthfSwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7Yn0pYH0pLFxuICAgICAgYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dHlwZX0sIGIgOiAke3R5cGV9KSAtPiAke3R5cGV9IHtcbiAgICAgIGlmIChiID09ICR7dHlwZX0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0eXBlfSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R5cGV9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0eXBlfSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0eXBlfSgyLjApKSkgIT0gMS4wKSAqICR7dHlwZX0oJHtcbiAgICAgICAgICByb3VuZFN0cn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dHlwZX0+LCBiIDogdmVjNDwke3R5cGV9PikgLT4gdmVjNDwke3R5cGV9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dHlwZX0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdWIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ1N1YicsIChhLCBiKSA9PiBgJHthfS0ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICAgIGNvbnRleHQsICdHcmVhdGVyJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX0+JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX0+JHtifSlgfSksIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgRGF0YVR5cGUuYm9vbCk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVzcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICAgIGNvbnRleHQsICdMZXNzJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX08JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX08JHtifSlgfSksIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgRGF0YVR5cGUuYm9vbCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlck9yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgICBjb250ZXh0LCAnR3JlYXRlck9yRXF1YWwnLCAoe3NjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT49JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX0+PSR7Yn0pYH0pLFxuICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIERhdGFUeXBlLmJvb2wpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxlc3NPckVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgICAgY29udGV4dCwgJ0xlc3NPckVxdWFsJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX08PSR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9PD0ke2J9KWB9KSxcbiAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBEYXRhVHlwZS5ib29sKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmNhdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBheGlzOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBmZXcgaW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgcmVmZXJlbmNlSW5kZXggPSAwO1xuICBjb25zdCByZWZlcmVuY2VJbnB1dCA9IGlucHV0c1tyZWZlcmVuY2VJbmRleF07XG4gIGNvbnN0IGlucHV0VHlwZSA9IHJlZmVyZW5jZUlucHV0LmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSByZWZlcmVuY2VJbnB1dC5kaW1zLmxlbmd0aDtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgaWYgKGkgPT09IHJlZmVyZW5jZUluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0eXBlcyBvZiBhbGwgaW5wdXRzIG1hdGNoXG4gICAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBkaW1lbnNpb25hbGl0eSBvZiBhbGwgaW5wdXRzIGFyZSB0aGUgc2FtZVxuICAgIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gaW5wdXRSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gICAgaW5wdXQuZGltcy5mb3JFYWNoKChkaW0sIGkpID0+IHtcbiAgICAgIGlmIChpICE9PSBheGlzICYmIGRpbSAhPT0gcmVmZXJlbmNlSW5wdXQuZGltc1tpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRleEltcGwgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHNpemVJbkNvbmNhdEF4aXNTdHI6IHN0cmluZyk6IHN0cmluZyA9PiBgXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtudW1iZXJPZlRlbnNvcnN9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc307IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcbiAgfWA7XG5cbmNvbnN0IGFzc2lnbk91dHB1dERhdGEgPSAoaW5wdXRzOiByZWFkb25seSBJbmRpY2VzSGVscGVyW10sIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xuICBjb25zdCBudW1iZXJPZlRlbnNvcnMgPSBpbnB1dHMubGVuZ3RoO1xuXG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGNvbnN0IHJldHVyblNuaXBwZXQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dHNbaV0uZ2V0QnlJbmRpY2VzKCdpbmRpY2VzJykpO1xuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKHJldHVyblNuaXBwZXQpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtpfSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGFkanVzdGVkQXhpczogbnVtYmVyLCBvdXRwdXRTaGFwZTogbnVtYmVyW10sIGRhdGFUeXBlOiBEYXRhVHlwZSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgICAgIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlucHV0VmFycyA9IG5ldyBBcnJheTxJbmRpY2VzSGVscGVyPihpbnB1dHMubGVuZ3RoKTtcblxuICAgICAgbGV0IHByZXZpb3VzU3VtID0gMDtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gW107XG4gICAgICBjb25zdCBpbnB1dFJhbmtzID0gW107XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX1dO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcHJldmlvdXNTdW0gKz0gaW5wdXRzW2ldLmRpbXNbYWRqdXN0ZWRBeGlzXTtcbiAgICAgICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgICAgICBpbnB1dFJhbmtzLnB1c2goaW5wdXRzW2ldLmRpbXMubGVuZ3RoKTtcbiAgICAgICAgaW5wdXRWYXJzW2ldID0gaW5wdXRWYXJpYWJsZShgaW5wdXQke2l9YCwgZGF0YVR5cGUsIGlucHV0UmFua3NbaV0pO1xuICAgICAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVJbkNvbmNhdEF4aXNbaV19KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1tpXS5kaW1zKSk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbmRpY2VzQXhpcyA9IG91dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYWRqdXN0ZWRBeGlzKTtcbiAgICAgIGNvbnN0IHNpemVJbkNvbmNhdEF4aXNTdHIgPVxuICAgICAgICAgIEFycmF5LmZyb20oQXJyYXkoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgpLmtleXMoKSkubWFwKGkgPT4gYHVuaWZvcm1zLnNpemVJbkNvbmNhdEF4aXMke2l9YCkuam9pbignLCcpO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG5cbiAgJHsoKCkgPT4ge1xuICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oYHNpemVJbkNvbmNhdEF4aXMke2l9YCwgJ3UzMicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCk7XG4gICAgICB9KSgpfVxuXG4gICR7Y2FsY3VsYXRlSW5wdXRJbmRleEltcGwoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgsIHNpemVJbkNvbmNhdEF4aXNTdHIpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7aW5kaWNlc0F4aXN9KTtcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xuICAgICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7c2l6ZUluQ29uY2F0QXhpcy5sZW5ndGh9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XG4gICAgICAke2luZGljZXNBeGlzfSAtPSBzaXplSW5Db25jYXRBeGlzW2lucHV0SW5kZXggLSAxdV07XG4gICAgfVxuXG4gICAgJHthc3NpZ25PdXRwdXREYXRhKGlucHV0VmFycywgb3V0cHV0KX1cbiAgfWA7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdDb25jYXQnLFxuICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke2FkanVzdGVkQXhpc31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNvbmNhdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29uY2F0QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBhZGp1c3RlZEF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhZGp1c3RlZEF4aXMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVbYWRqdXN0ZWRBeGlzXSA9XG4gICAgICBpbnB1dHMucmVkdWNlKChzdW0sIGlucHV0KSA9PiBzdW0gKyAoaW5wdXQuZGltcy5sZW5ndGggPiBhZGp1c3RlZEF4aXMgPyBpbnB1dC5kaW1zW2FkanVzdGVkQXhpc10gOiAwKSwgMCk7XG4gIC8vIDAgbGVuZ3RoIHRlbnNvcnMgYXJlIHZhbGlkIGZvciBjb25jYXQsIHJlbW92ZSB0aGVtXG4gIGNvbnN0IG5vbkVtcHR5SW5wdXRzID0gaW5wdXRzLmZpbHRlcihpbnB1dCA9PiBTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSA+IDApO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICBjcmVhdGVDb25jYXRQcm9ncmFtSW5mbyhub25FbXB0eUlucHV0cywgYWRqdXN0ZWRBeGlzLCBvdXRwdXRTaGFwZSwgaW5wdXRzWzBdLmRhdGFUeXBlKSwge2lucHV0czogbm9uRW1wdHlJbnB1dHN9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb25jYXRBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7TUFYX0NMSVAsIE1JTl9DTElQfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7UHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhY3RpdmF0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNsaXBNaW4/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGNsaXBNYXg/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGFscGhhPzogbnVtYmVyO1xuICByZWFkb25seSBiZXRhPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZhdGlvblNuaXBwZXQgPVxuICAgIChhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCB2YWx1ZVR5cGU6IHN0cmluZywgYmFzZVR5cGUgPSAnZjMyJyk6IHN0cmluZyA9PiB7XG4gICAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbikge1xuICAgICAgICBjYXNlICdSZWx1JzpcbiAgICAgICAgICByZXR1cm4gYHZhbHVlID0gbWF4KHZhbHVlLCAke3ZhbHVlVHlwZX0oMC4wKSk7YDtcbiAgICAgICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICAgICAgcmV0dXJuIGB2YWx1ZSA9ICgke3ZhbHVlVHlwZX0oMS4wKSAvICgke3ZhbHVlVHlwZX0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtcbiAgICAgICAgY2FzZSAnQ2xpcCc6XG4gICAgICAgICAgcmV0dXJuIGB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAke3ZhbHVlVHlwZX0oJHtiYXNlVHlwZX0odW5pZm9ybXMuY2xpcF9taW4pKSwgJHt2YWx1ZVR5cGV9KCR7XG4gICAgICAgICAgICAgIGJhc2VUeXBlfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO1xuICAgICAgICBjYXNlICdIYXJkU2lnbW9pZCc6XG4gICAgICAgICAgcmV0dXJuIGB2YWx1ZSA9IG1heCgke3ZhbHVlVHlwZX0oMC4wKSwgbWluKCR7dmFsdWVUeXBlfSgxLjApLCAke2Jhc2VUeXBlfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7XG4gICAgICAgICAgICAgIGJhc2VUeXBlfSh1bmlmb3Jtcy5iZXRhKSkpO2A7XG4gICAgICAgIGNhc2UgJ0xlYWt5UmVsdSc6XG4gICAgICAgICAgcmV0dXJuIGB2YWx1ZSA9IHNlbGVjdCgke2Jhc2VUeXBlfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSwgdmFsdWUsIHZhbHVlID49ICR7dmFsdWVUeXBlfSgwLjApKTtgO1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWN0aXZhdGlvbiAke2F0dHJpYnV0ZXMuYWN0aXZhdGlvbn1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3QgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSA9XG4gICAgKGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3JtOiBQcm9ncmFtVW5pZm9ybVtdKSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm0ucHVzaChcbiAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWF4IX0sIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWluIX0pO1xuICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm0ucHVzaChcbiAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSF9LCB7dHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYmV0YSF9KTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnTGVha3lSZWx1Jykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSF9KTtcbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3QgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zID0gKGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSkgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICB1bmlmb3Jtcy5wdXNoKHtuYW1lOiAnY2xpcF9tYXgnLCB0eXBlOiAnZjMyJ30sIHtuYW1lOiAnY2xpcF9taW4nLCB0eXBlOiAnZjMyJ30pO1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0hhcmRTaWdtb2lkJykge1xuICAgIHVuaWZvcm1zLnB1c2goe25hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInfSwge25hbWU6ICdiZXRhJywgdHlwZTogJ2YzMid9KTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7bmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMid9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyA9XG4gICAgKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+fHVuZGVmaW5lZCk6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgYWN0aXZhdGlvbiA9IGF0dHJpYnV0ZXM/LmFjdGl2YXRpb24gYXMgc3RyaW5nIHx8ICcnO1xuICAgICAgaWYgKGFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICAgICAgY29uc3QgW2FscGhhLCBiZXRhXSA9IGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXIsIG51bWJlcl0gfHwgWzAuMiwgMC41XTtcbiAgICAgICAgcmV0dXJuIHthY3RpdmF0aW9uLCBhbHBoYSwgYmV0YX07XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdDbGlwJykge1xuICAgICAgICBjb25zdCBbY2xpcE1pbiwgY2xpcE1heF0gPSBhdHRyaWJ1dGVzPy5hY3RpdmF0aW9uX3BhcmFtcyBhcyBbbnVtYmVyLCBudW1iZXJdIHx8IFtNSU5fQ0xJUCwgTUFYX0NMSVBdO1xuICAgICAgICByZXR1cm4ge2FjdGl2YXRpb24sIGNsaXBNYXgsIGNsaXBNaW59O1xuICAgICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAnTGVha3lSZWx1Jykge1xuICAgICAgICBjb25zdCBbYWxwaGFdID0gYXR0cmlidXRlcz8uYWN0aXZhdGlvbl9wYXJhbXMgYXMgW251bWJlcl0gfHwgWzAuMDFdO1xuICAgICAgICByZXR1cm4ge2FjdGl2YXRpb24sIGFscGhhfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7YWN0aXZhdGlvbn07XG4gICAgfTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvYWN0aXZhdGlvbl91dGlsLnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5leHBvcnQgY29uc3QgdHlwZVNuaXBwZXQgPSAoY29tcG9uZW50OiBudW1iZXIsIGRhdGFUeXBlOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoIChjb21wb25lbnQpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZGF0YVR5cGU7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGB2ZWMzPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGB2ZWM0PCR7ZGF0YVR5cGV9PmA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb21wb25lbnR9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NuaXBwZXQgPSAoaGFzQmlhczogYm9vbGVhbik6IHN0cmluZyA9PiBgXG4gICAgICAke2hhc0JpYXMgPyAndmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpOycgOiAnJ31cbiAgICAgIGA7XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtY29yZS9zcmMvb3BzL2NvbnZfdXRpbC50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuZXhwb3J0IGNvbnN0IHV0aWxGdW5jdGlvbnMgPSAoc3RyaWRlU3RyOiBzdHJpbmcpID0+IChgXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xufVxuZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICBpMzIoJHtzdHJpZGVTdHJ9LngpLCBpMzIoJHtzdHJpZGVTdHJ9LnkpLCBpMzIoJHtzdHJpZGVTdHJ9LnopLCAxKSk7XG59XG5gKTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvbWF0bXVsX3BhY2tlZF93ZWJncHUudHNcbi8vXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRCcm9hZGNhc3REaW1zLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBpbnRlcm5hbFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHthcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0LCBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuLi9mdXNlLXV0aWxzJztcblxuaW1wb3J0IHt0eXBlU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuXG5jb25zdCB3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZSkge1xuICAgIHJldHVybiBgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgYDtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIGA7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZVJlc3VsdFNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbiwgaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2VBKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddOyd9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldOyd9XG4gICAgICAgIH1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldOyd9XG4gICAgICAgIH1gO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UgPVxuICAgICh3b3JrUGVyVGhyZWFkOiBudW1iZXJbXSwgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0eXBlID0gJ2YzMicsIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIsXG4gICAgIHRyYW5zcG9zZUEgPSBmYWxzZSwgdGlsZUlubmVyID0gMzIsIHNwbGl0SyA9IGZhbHNlLCBzcGxpdGVkRGltSW5uZXIgPSAzMik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCB0aWxlQU91dGVyID0gd29ya2dyb3VwU2l6ZVsxXSAqIHdvcmtQZXJUaHJlYWRbMV07XG4gICAgICBjb25zdCB0aWxlQk91dGVyID0gd29ya2dyb3VwU2l6ZVswXSAqIHdvcmtQZXJUaHJlYWRbMF07XG4gICAgICBjb25zdCB0aWxlQVdpZHRoID0gdHJhbnNwb3NlQSA/IHRpbGVBT3V0ZXIgOiB0aWxlSW5uZXI7XG4gICAgICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XG4gICAgICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gdGlsZUFXaWR0aCAvIHdvcmtncm91cFNpemVbMF07XG4gICAgICBjb25zdCByb3dQZXJUaHJlYWRCID0gdGlsZUlubmVyIC8gd29ya2dyb3VwU2l6ZVsxXTtcblxuICAgICAgaWYgKCEoKCh0cmFuc3Bvc2VBICYmIGlubmVyRWxlbWVudFNpemUgPT09IDQgJiYgd29ya1BlclRocmVhZFsxXSA9PT0gNCkgfHxcbiAgICAgICAgICAgICAoIXRyYW5zcG9zZUEgJiYgKGlubmVyRWxlbWVudFNpemUgPT09IDMgfHwgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCkpKSAmJlxuICAgICAgICAgICAgdGlsZUFXaWR0aCAlIHdvcmtncm91cFNpemVbMF0gPT09IDAgJiYgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB3b3JrUGVyVGhyZWFkWzBdID09PSA0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHt0cmFuc3Bvc2VBfSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7XG4gICAgICAgICAgICBpbm5lckVsZW1lbnRTaXplfSBhbmQgd29ya1BlclRocmVhZFsxXSAke3dvcmtQZXJUaHJlYWRbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0uIHRpbGVJbm5lciAke1xuICAgICAgICAgICAgdGlsZUlubmVyfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7d29ya2dyb3VwU2l6ZVsxXX0uIGNvbFBlclRocmVhZCAke1xuICAgICAgICAgICAgd29ya1BlclRocmVhZFswXX0gbXVzdCBiZSA0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aW5uZXJFbGVtZW50U2l6ZX08JHt0eXBlfT4sICR7dGlsZUFXaWR0aCAvIGlubmVyRWxlbWVudFNpemV9PiwgJHt0aWxlQUhpZ2h0fT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7dHlwZX0+LCAke3RpbGVCT3V0ZXIgLyB3b3JrUGVyVGhyZWFkWzBdfT4sICR7dGlsZUlubmVyfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7aW5uZXJFbGVtZW50U2l6ZX07XG5jb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVbMF19LCAke3dvcmtncm91cFNpemVbMV19LCAke3dvcmtncm91cFNpemVbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgJHtiYXRjaERpbXMgPyBgbGV0IGJhdGNoSW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygndTMyKGJhdGNoKScpfTtgIDogJyd9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbiAgbGV0IG51bV90aWxlcyA9ICR7c3BsaXRLID8gYCR7TWF0aC5jZWlsKHNwbGl0ZWREaW1Jbm5lciAvIHRpbGVJbm5lcil9YCA6ICcodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxJ307XG4gIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7dHlwZX0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7cm93UGVyVGhyZWFkQn07XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke1xuICAgICAgICAgIGJhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07J31cblxuICAgICAgICAgICR7Y2FsY3VsYXRlUmVzdWx0U25pcHBldCh0cmFuc3Bvc2VBLCBpbm5lckVsZW1lbnRTaXplKX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWA7XG4gICAgfTtcblxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBU25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZSkge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICAgICAgYDtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICAgICAgYDtcbiAgfVxufTtcblxuY29uc3QgcmVhZERhdGFGcm9tU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbikgPT5cbiAgICB0cmFuc3Bvc2VBID8gJ2xldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddOycgOiAnbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107JztcblxuLy8gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyBtZWFucyBzZXF1ZW50aWFsIGRhdGEgaW4gbWVtb3J5IGlzIGFjY2Vzc2VkIGJ5XG4vLyB0aHJlYWRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHRocmVhZCAoZGVmYXVsdCBiZWhhdmlvcikuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFNvdXJjZSA9XG4gICAgKHdvcmtQZXJUaHJlYWQ6IG51bWJlcltdLCB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHR5cGUgPSAnZjMyJywgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcixcbiAgICAgdHJhbnNwb3NlQSA9IGZhbHNlLCB0aWxlSW5uZXIgPSAzMiwgc3BsaXRLID0gZmFsc2UsIHNwbGl0ZWREaW1Jbm5lciA9IDMyLFxuICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtQZXJUaHJlYWRbMV0gKiB3b3JrZ3JvdXBTaXplWzFdO1xuICAgICAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtQZXJUaHJlYWRbMF0gKiB3b3JrZ3JvdXBTaXplWzBdO1xuICAgICAgY29uc3QgdGlsZUFXaWR0aCA9IHRyYW5zcG9zZUEgPyB0aWxlQU91dGVyIDogdGlsZUlubmVyO1xuICAgICAgY29uc3QgdGlsZUFIaWdodCA9IHRyYW5zcG9zZUEgPyB0aWxlSW5uZXIgOiB0aWxlQU91dGVyO1xuXG4gICAgICBpZiAoISh0aWxlQUhpZ2h0ICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB0aWxlQVdpZHRoICUgd29ya2dyb3VwU2l6ZVswXSA9PT0gMCAmJlxuICAgICAgICAgICAgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7dGlsZUFIaWdodH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7XG4gICAgICAgICAgICB3b3JrZ3JvdXBTaXplWzFdfSwgdGlsZUFXaWR0aCAke3RpbGVBV2lkdGh9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke1xuICAgICAgICAgICAgd29ya2dyb3VwU2l6ZVswXX0sIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7d29ya2dyb3VwU2l6ZVsxXX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd1BlclRocmVhZEEgPSB0aWxlQUhpZ2h0IC8gd29ya2dyb3VwU2l6ZVsxXTtcbiAgICAgIGNvbnN0IGNvbFBlclRocmVhZEEgPSB0aWxlQVdpZHRoIC8gd29ya2dyb3VwU2l6ZVswXTtcbiAgICAgIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrZ3JvdXBTaXplWzFdO1xuICAgICAgY29uc3QgbWF0bXVsU25pcHBldCA9IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgP1xuICAgICAgICAgIGBcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7dGlsZUJPdXRlcn07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7dGlsZUFIaWdodH07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3dvcmtncm91cFNpemVbMV19KSB7XG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt0aWxlQVdpZHRofTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7d29ya2dyb3VwU2l6ZVswXX0pIHtcbiAgICAgICAgICAke3dyaXRlRGF0YVRvU3ViQVNuaXBwZXQodHJhbnNwb3NlQSwgYmF0Y2hEaW1zKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3RpbGVJbm5lcn07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3dvcmtncm91cFNpemVbMV19KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7dGlsZUJPdXRlcn07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3dvcmtncm91cFNpemVbMF19KSB7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+O1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt3b3JrZ3JvdXBTaXplWzBdfV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7XG4gICAgICAgICAgICAgIHRyYW5zcG9zZUEgPyBgbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfV07YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfV1ba107YH1cbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19O1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3dvcmtncm91cFNpemVbMF19O1xuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBgIDpcbiAgICAgICAgICBgXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcblxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7cm93UGVyVGhyZWFkQX07XG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7Y29sUGVyVGhyZWFkQX07XG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7cm93UGVyVGhyZWFkQn07XG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRBfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHtjb2xQZXJUaHJlYWRBfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xuICAgICAgJHt3cml0ZURhdGFUb1N1YkFTbmlwcGV0KHRyYW5zcG9zZUEsIGJhdGNoRGltcyl9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgIH1cbiAgfVxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+O1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAke3JlYWREYXRhRnJvbVN1YkFTbmlwcGV0KHRyYW5zcG9zZUEpfVxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG59XG5cbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICB9XG59XG5gO1xuXG4gICAgICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHt0eXBlfSwgJHt0aWxlQVdpZHRofT4sICR7dGlsZUFIaWdodH0+O1xuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHt0eXBlfSwgJHt0aWxlQk91dGVyfT4sICR7dGlsZUlubmVyfT47XG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFswXX07XG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7dGlsZUlubmVyfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7d29ya2dyb3VwU2l6ZVswXX0sICR7d29ya2dyb3VwU2l6ZVsxXX0sICR7d29ya2dyb3VwU2l6ZVsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICAgIGxldCBiYXRjaCA9ICR7c3BsaXRLID8gJzAnIDogJ2kzMihnbG9iYWxJZC56KSd9O1xuICAgICR7YmF0Y2hEaW1zID8gYGxldCBiYXRjaEluZGljZXMgPSAke2JhdGNoRGltcy5vZmZzZXRUb0luZGljZXMoJ3UzMihiYXRjaCknKX07YCA6ICcnfVxuICAgIGxldCBudW1fdGlsZXMgPSAke1xuICAgICAgICAgIHNwbGl0SyA/IGAke01hdGguY2VpbChzcGxpdGVkRGltSW5uZXIgLyB0aWxlSW5uZXIpfWAgOiAnKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMSd9O1xuICAgIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuICAgICR7bWF0bXVsU25pcHBldH1cbiAgfVxuYDtcbiAgICB9O1xuXG5jb25zdCBtYXRNdWxSZWFkV3JpdGVGblNvdXJjZSA9XG4gICAgKGNvbXBvbmVudDogbnVtYmVyLCBoYXNCaWFzOiBib29sZWFuLCBhcHBseUFjdGl2YXRpb246IHN0cmluZywgdmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10sXG4gICAgIGJhdGNoU2hhcGVzOiBBcnJheTxyZWFkb25seSBudW1iZXJbXT4sIGlzQ2hhbm5lbHNMYXN0ID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgW2JhdGNoQVNoYXBlLCBiYXRjaEJTaGFwZSwgYmF0Y2hTaGFwZV0gPSBiYXRjaFNoYXBlcztcbiAgICAgIGNvbnN0IFtiYXRjaFZhcmlhYmxlLCBhVmFyaWFibGUsIGJWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGVdID0gdmFyaWFibGVzO1xuICAgICAgY29uc3QgYnJvYWRDYXN0QURpbXMgPSBnZXRCcm9hZGNhc3REaW1zKGJhdGNoQVNoYXBlLCBiYXRjaFNoYXBlKTtcbiAgICAgIGNvbnN0IGJyb2FkQ2FzdEJEaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhiYXRjaEJTaGFwZSwgYmF0Y2hTaGFwZSk7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSh2YXJpYWJsZXNbMF0udHlwZS50ZW5zb3IpO1xuICAgICAgY29uc3QgZ2V0QUluZGljZXMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFSYW5rID0gYVZhcmlhYmxlLnJhbms7XG4gICAgICAgIGNvbnN0IGJhdGNoUmFuayA9IGJhdGNoVmFyaWFibGUucmFuaztcbiAgICAgICAgbGV0IHJlc1N0ciA9IGB2YXIgYUluZGljZXM6ICR7YVZhcmlhYmxlLnR5cGUuaW5kaWNlc307YDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFSYW5rIC0gMiAtIDEsIGogPSBiYXRjaFJhbmsgLSAxOyBpID49IDA7IGktLSwgai0tKSB7XG4gICAgICAgICAgcmVzU3RyICs9IGBcXG5hSW5kaWNlc1ske2l9XSA9ICR7YmF0Y2hSYW5rID4gMSA/IGBiYXRjaEluZGljZXNbJHtqfV1gIDogJ2JhdGNoSW5kaWNlcyd9O2A7XG4gICAgICAgIH1cbiAgICAgICAgYnJvYWRDYXN0QURpbXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICByZXNTdHIgKz0gYFxcbmFJbmRpY2VzWyR7aX1dID0gMDtgO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzU3RyICs9IGBcXG5hSW5kaWNlc1ske2FSYW5rIC0gMn1dID0gdTMyKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgYUluZGljZXNbJHthUmFuayAtIDF9XSA9IHUzMihjb2xJbik7YDtcbiAgICAgICAgcmV0dXJuIHJlc1N0cjtcbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRCSW5kaWNlcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYlJhbmsgPSBiVmFyaWFibGUucmFuaztcbiAgICAgICAgY29uc3QgYmF0Y2hSYW5rID0gYmF0Y2hWYXJpYWJsZS5yYW5rO1xuICAgICAgICBsZXQgcmVzU3RyID0gYHZhciBiSW5kaWNlczogJHtiVmFyaWFibGUudHlwZS5pbmRpY2VzfTtgO1xuICAgICAgICBmb3IgKGxldCBpID0gYlJhbmsgLSAyIC0gMSwgaiA9IGJhdGNoUmFuayAtIDE7IGkgPj0gMDsgaS0tLCBqLS0pIHtcbiAgICAgICAgICByZXNTdHIgKz0gYFxcbmJJbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoSW5kaWNlc1ske2p9XWAgOiAnYmF0Y2hJbmRpY2VzJ307YDtcbiAgICAgICAgfVxuICAgICAgICBicm9hZENhc3RCRGltcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgIHJlc1N0ciArPSBgXFxuYkluZGljZXNbJHtpfV0gPSAwO2A7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNTdHIgKz0gYFxcbmJJbmRpY2VzWyR7YlJhbmsgLSAyfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBiSW5kaWNlc1ske2JSYW5rIC0gMX1dID0gdTMyKGNvbEluKTtgO1xuICAgICAgICByZXR1cm4gcmVzU3RyO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2JhdGNoVmFyaWFibGUudHlwZS5pbmRpY2VzfSkgLT4gJHtcbiAgICAgICAgICB0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcilcbiAgICAgIHtcbiAgICAgICAgJHtnZXRBSW5kaWNlcygpfVxuICAgICAgICB2YWx1ZSA9ICR7YVZhcmlhYmxlLmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIGJhdGNoSW5kaWNlczogJHtiYXRjaFZhcmlhYmxlLnR5cGUuaW5kaWNlc30pIC0+ICR7XG4gICAgICAgICAgdHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICAgICR7Z2V0QkluZGljZXMoKX1cbiAgICAgICAgdmFsdWUgPSAke2JWYXJpYWJsZS5nZXRCeUluZGljZXMoJ2JJbmRpY2VzJyl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xuICAgICAgICAke1xuICAgICAgICAgIGhhc0JpYXMgP1xuICAgICAgICAgICAgICBgdmFsdWUgPSB2YWx1ZSArICR7aXNDaGFubmVsc0xhc3QgPyAnYmlhc1tjb2xJbl0nIDogYCR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KGJpYXNbcm93XSlgfTtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgICAke291dHB1dFZhcmlhYmxlLnNldEJ5SW5kaWNlcygndmVjMzx1MzI+KGNvb3JkcyknLCAndmFsdWUnKX1cbiAgICAgIH1cbiAgICB9XG4gICAgYDtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIHJlc2hhcGVkT3V0cHV0U2hhcGU/OiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSAvKiBvbmx5IHVzZWQgZm9yIGNvbnYyZEJ5TWF0TXVsKi8pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0ZXJEaW1zQSA9IGFTaGFwZS5zbGljZSgwLCAtMik7XG4gICAgICBjb25zdCBvdXRlckRpbXNCID0gYlNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICAgIGNvbnN0IG91dGVyRGltcyA9IHJlc2hhcGVkT3V0cHV0U2hhcGUgPyByZXNoYXBlZE91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKSA6IG91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dGVyRGltcyk7XG4gICAgICBjb25zdCBkaW1BT3V0ZXIgPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgZGltSW5uZXIgPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZGltQk91dGVyID0gYlNoYXBlW2JTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGlzVmVjNCA9IGRpbUlubmVyICUgNCA9PT0gMCAmJiBkaW1CT3V0ZXIgJSA0ID09PSAwO1xuXG4gICAgICAvLyBUT0RPOiBmaW5lIHR1bmUgc2l6ZVxuICAgICAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQgPSBkaW1BT3V0ZXIgPD0gOCA/IFs0LCAxLCAxXSA6IFs0LCA0LCAxXTtcbiAgICAgIGNvbnN0IHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs4LCA4LCAxXTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgICAgICBNYXRoLmNlaWwoZGltQk91dGVyIC8gd29ya2dyb3VwU2l6ZVswXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzBdKSxcbiAgICAgICAgTWF0aC5jZWlsKGRpbUFPdXRlciAvIHdvcmtncm91cFNpemVbMV0gLyBlbGVtZW50c1BlclRocmVhZFsxXSksXG4gICAgICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrZ3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgICBjb25zdCBhU2hhcGVUZW1wID0gWy4uLm91dGVyRGltc0EsIGRpbUFPdXRlciwgZGltSW5uZXIgLyBjb21wb25lbnRzXTtcbiAgICAgIGNvbnN0IGFSYW5rID0gYVNoYXBlVGVtcC5sZW5ndGg7XG4gICAgICBjb25zdCBiU2hhcGVUZW1wID0gWy4uLm91dGVyRGltc0IsIGRpbUlubmVyLCBkaW1CT3V0ZXIgLyBjb21wb25lbnRzXTtcbiAgICAgIGNvbnN0IGJSYW5rID0gYlNoYXBlVGVtcC5sZW5ndGg7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUFPdXRlcn0sIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1Jbm5lcn1cbiAgICAgIF07XG4gICAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0ZXJEaW1zLCBhU2hhcGVUZW1wLCBiU2hhcGVUZW1wKSk7XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG5cbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgICAgIH1cbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlVGVtcCkpO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgYmF0Y2hSYW5rID0gb3V0ZXJEaW1zLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmF0Y2hEaW1zID0gaW50ZXJuYWxWYXJpYWJsZSgnYmF0Y2hEaW1zJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBiYXRjaFJhbmssIDEpO1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuXG4gICAgICAgIGNvbnN0IEEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBhUmFuaywgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IEIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBiUmFuaywgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlVGVtcC5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtBLCBCXTtcbiAgICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgICBjb25zdCBiaWFzQ29tcG9uZW50cyA9IGlzQ2hhbm5lbHNMYXN0ID8gY29tcG9uZW50cyA6IDE7XG4gICAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGJpYXNDb21wb25lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID1cbiAgICAgICAgICAgIFt7bmFtZTogJ2RpbV9hX291dGVyJywgdHlwZTogJ2kzMid9LCB7bmFtZTogJ2RpbV9iX291dGVyJywgdHlwZTogJ2kzMid9LCB7bmFtZTogJ2RpbV9pbm5lcicsIHR5cGU6ICdpMzInfV07XG4gICAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhY3RpdmF0aW9uQXR0cmlidXRlcywgdW5pZm9ybXMpO1xuICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xuICAgICAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcbiAgICAgICAgY29uc3QgZGVjbGFyZUZ1bmN0aW9ucyA9IG1hdE11bFJlYWRXcml0ZUZuU291cmNlKFxuICAgICAgICAgICAgY29tcG9uZW50cywgaGFzQmlhcywgYXBwbHlBY3RpdmF0aW9uLCBbYmF0Y2hEaW1zLCBBLCBCLCBvdXRwdXRdLCBbb3V0ZXJEaW1zQSwgb3V0ZXJEaW1zQiwgb3V0ZXJEaW1zXSxcbiAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0KTtcbiAgICAgICAgcmV0dXJuIGBcbiAgJHtcbiAgICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGJhdGNoRGltcykuZGVjbGFyZVZhcmlhYmxlcyhcbiAgICAgICAgICAgICAgICAuLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAke1xuICAgICAgICAgICAgaXNWZWM0ID8gbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UoZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtncm91cFNpemUsIGRhdGFUeXBlLCBiYXRjaERpbXMpIDpcbiAgICAgICAgICAgICAgICAgICAgIG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtncm91cFNpemUsIGRhdGFUeXBlLCBiYXRjaERpbXMpfVxuICAgICAgICAgICAgICAgICAgIGA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ01hdE11bCcsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogYCR7ZWxlbWVudHNQZXJUaHJlYWR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07JHtpc1ZlYzR9OyR7aXNDaGFubmVsc0xhc3R9YCxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llc1xuICAgICAgICB9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL2NvbnYyZF9tbV93ZWJncHUudHNcbi8vXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7TE9HX0RFQlVHfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge0NvbnZBdHRyaWJ1dGVzfSBmcm9tICcuLi9jb252JztcbmltcG9ydCB7YXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLCBnZXRBY3RpdmF0aW9uU25pcHBldH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XG5cbmltcG9ydCB7Ymlhc1NuaXBwZXQsIHR5cGVTbmlwcGV0fSBmcm9tICcuL2FjdGl2YXRpb25fdXRpbCc7XG5pbXBvcnQge3V0aWxGdW5jdGlvbnN9IGZyb20gJy4vY29udl91dGlsJztcbmltcG9ydCB7bWFrZU1hdE11bFBhY2tlZFNvdXJjZSwgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2V9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuXG5jb25zdCBjb252MmRDb21tb25TbmlwcGV0ID1cbiAgICAoaXNDaGFubmVsc0xhc3Q6IGJvb2xlYW4sIGZpdEFPdXRlcjogYm9vbGVhbiwgZml0Qk91dGVyOiBib29sZWFuLCBmaXRJbm5lcjogYm9vbGVhbiwgYWRkQmlhcyA9IGZhbHNlLFxuICAgICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcywgaW5uZXJFbGVtZW50U2l6ZVggPSA0LCBpbm5lckVsZW1lbnRTaXplVyA9IDQsIGlubmVyRWxlbWVudFNpemUgPSA0LFxuICAgICBkYXRhVHlwZSA9ICdmMzInKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGdldFhTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgICAgICBzd2l0Y2ggKGlubmVyRWxlbWVudFNpemUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gJ3Jlc0RhdGEgPSB4W3hJbmRleF07JztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gYHJlc0RhdGEgPSB2ZWMzPCR7ZGF0YVR5cGV9Pih4W3hJbmRleF0sIHhbeEluZGV4ICsgMV0sIHhbeEluZGV4ICsgMl0pO2A7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXggLyA0XTsnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ2V0V1NuaXBwZXQgPSAoaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAncmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pICsgY29sSW5dOyc7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuICdyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgLyA0ICsgY29sSW5dOyc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBjb29yZEFTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3QgPyBgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Um93LCB4Q29sLCB4Q2gpO1xuICAgIGAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcbiAgICBgO1xuXG4gICAgICBjb25zdCBjb29yZFJlc1NuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdCA/IGBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGA7XG5cbiAgICAgIGNvbnN0IHhIZWlnaHQgPSBpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMueF9zaGFwZVsxXSknIDogJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzJdKSc7XG4gICAgICBjb25zdCB4V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMueF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzNdKSc7XG4gICAgICBjb25zdCByb3cgPSBpc0NoYW5uZWxzTGFzdCA/ICdyb3cnIDogJ2NvbCc7XG4gICAgICBjb25zdCBjb2wgPSBpc0NoYW5uZWxzTGFzdCA/ICdjb2wnIDogJ3Jvdyc7XG4gICAgICBjb25zdCByZWFkWFNuaXBwZXQgPSBgXG4gICAgbGV0IGluQ2hhbm5lbHMgPSBpMzIodW5pZm9ybXMud19zaGFwZVsyXSk7XG4gICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICBsZXQgb3V0Um93ID0gJHtyb3d9IC8gb3V0V2lkdGg7XG4gICAgbGV0IG91dENvbCA9ICR7cm93fSAlIG91dFdpZHRoO1xuXG4gICAgbGV0IFdSb3cgPSAke2NvbH0gLyAoaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pICogaW5DaGFubmVscyk7XG4gICAgbGV0IFdDb2wgPSAke2NvbH0gLyBpbkNoYW5uZWxzICUgaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogdW5pZm9ybXMuc3RyaWRlWzBdICsgdW5pZm9ybXMuZGlsYXRpb25bMF0gKiBXUm93IC0gdW5pZm9ybXMucGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xuICAgIGxldCB4Q2ggPSAke2NvbH0gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHt4SGVpZ2h0fSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7eFdpZHRofSkge1xuICAgICAgJHtjb29yZEFTbmlwcGV0fVxuICAgICAgbGV0IHhJbmRleCA9IGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpO1xuICAgICAgJHtnZXRYU25pcHBldChpbm5lckVsZW1lbnRTaXplWCl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2A7XG5cbiAgICAgIGNvbnN0IHNhbXBsZVggPSBpc0NoYW5uZWxzTGFzdCA/IChmaXRBT3V0ZXIgJiYgZml0SW5uZXIgPyBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XG4gICAgJHtyZWFkWFNuaXBwZXR9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpIHtcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2ApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaXRJbm5lciAmJiBmaXRCT3V0ZXIgPyBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XG4gICAgJHtyZWFkWFNuaXBwZXR9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2ApO1xuXG4gICAgICBjb25zdCBzYW1wbGVXID0gYCR7Z2V0V1NuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcpfWA7XG5cbiAgICAgIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCBkYXRhVHlwZSk7XG4gICAgICBjb25zdCBhVHlwZSA9XG4gICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpIDogdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKTtcbiAgICAgIGNvbnN0IGJUeXBlID1cbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCA/IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXLCBkYXRhVHlwZSkgOiB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpO1xuICAgICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgcmVzVHlwZSwgZGF0YVR5cGUpO1xuICAgICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHthVHlwZX0ge1xuICAgICAgJHtpc0NoYW5uZWxzTGFzdCA/IHNhbXBsZVggOiBzYW1wbGVXfVxuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7YlR5cGV9IHtcbiAgICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVXIDogc2FtcGxlWH1cbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtyZXNUeXBlfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2lzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKSd9O1xuICAgICAgJHtjb29yZFJlc1NuaXBwZXR9XG4gICAgICAke2JpYXNTbmlwcGV0KGFkZEJpYXMpfVxuICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9YDtcbiAgICAgIHJldHVybiB1c2VyQ29kZTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZGltQU91dGVyOiBudW1iZXIsXG4gICAgIGRpbUJPdXRlcjogbnVtYmVyLCBkaW1Jbm5lcjogbnVtYmVyLCBoYXNCaWFzOiBib29sZWFuLCBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzOiBib29sZWFuKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICAgICAgY29uc3QgaW5DaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gaW5wdXRzWzBdLmRpbXNbM10gOiBpbnB1dHNbMF0uZGltc1sxXTtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IG91dHB1dFNoYXBlWzBdO1xuICAgICAgY29uc3Qgb3V0V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzJdIDogb3V0cHV0U2hhcGVbM107XG4gICAgICBjb25zdCBvdXRIZWlnaHQgPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzFdIDogb3V0cHV0U2hhcGVbMl07XG4gICAgICBjb25zdCBvdXRDaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbM10gOiBvdXRwdXRTaGFwZVsxXTtcbiAgICAgIC8vIFRPRE86IGVuYWJsZSB2ZWM0IGZvciBOQ0hXXG4gICAgICBjb25zdCBpc1ZlYzQgPSBpc0NoYW5uZWxzTGFzdCAmJiAoaW5DaGFubmVscyAlIDQgPT09IDAgfHwgaW5DaGFubmVscyAlIDMgPT09IDApICYmIG91dENoYW5uZWxzICUgNCA9PT0gMDtcblxuICAgICAgLy8gVE9ETzogZmluZSB0dW5lIHNpemVcbiAgICAgIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcbiAgICAgIGNvbnN0IGRpc3BhdGNoWSA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0V2lkdGggKiBvdXRIZWlnaHQgOiBvdXRDaGFubmVscztcbiAgICAgIGNvbnN0IHdvcmtHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs4LCA4LCAxXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IFtcbiAgICAgICAgTWF0aC5jZWlsKGRpc3BhdGNoWCAvIHdvcmtHcm91cFNpemVbMF0gLyBlbGVtZW50c1BlclRocmVhZFswXSksXG4gICAgICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgICAgICBNYXRoLmNlaWwoYmF0Y2hTaXplIC8gd29ya0dyb3VwU2l6ZVsyXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzJdKVxuICAgICAgXTtcblxuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252MmRfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XG5cbiAgICAgIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsc0xhc3QgJiYgaW5DaGFubmVscyAlIDQgIT09IDAgPyAzIDogNCkgOiAxO1xuICAgICAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtHcm91cFNpemVbMV0gKiBlbGVtZW50c1BlclRocmVhZFsxXTtcbiAgICAgIGNvbnN0IHRpbGVCT3V0ZXIgPSB3b3JrR3JvdXBTaXplWzBdICogZWxlbWVudHNQZXJUaHJlYWRbMF07XG4gICAgICBjb25zdCB0aWxlSW5uZXIgPSBNYXRoLm1heCh3b3JrR3JvdXBTaXplWzBdICogaW5uZXJFbGVtZW50U2l6ZSwgd29ya0dyb3VwU2l6ZVsxXSk7XG4gICAgICBjb25zdCBmaXRBT3V0ZXIgPSBkaW1BT3V0ZXIgJSB0aWxlQU91dGVyID09PSAwO1xuICAgICAgY29uc3QgZml0Qk91dGVyID0gZGltQk91dGVyICUgdGlsZUJPdXRlciA9PT0gMDtcbiAgICAgIGNvbnN0IGZpdElubmVyID0gZGltSW5uZXIgJSB0aWxlSW5uZXIgPT09IDA7XG4gICAgICBjb25zdCBlbGVtZW50c1NpemUgPSBpc1ZlYzQgPyBbaW5uZXJFbGVtZW50U2l6ZSwgNCwgNF0gOiBbMSwgMSwgMV07XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1BT3V0ZXJ9LCB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUJPdXRlcn0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltSW5uZXJ9LCB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV19LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlc30sIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnN9XG4gICAgICBdO1xuICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSk7XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgICAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICAgIHtuYW1lOiAnZGltX2Ffb3V0ZXInLCB0eXBlOiAnaTMyJ30sIHtuYW1lOiAnZGltX2Jfb3V0ZXInLCB0eXBlOiAnaTMyJ30sIHtuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMid9LFxuICAgICAgICAgIHtuYW1lOiAncGFkJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMn0sIHtuYW1lOiAnc3RyaWRlJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMn0sXG4gICAgICAgICAge25hbWU6ICdkaWxhdGlvbicsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDJ9XG4gICAgICAgIF07XG4gICAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG5cbiAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBjb21wb25lbnQgMiwgMy5cbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICAgICAgICBjb25zdCB0ID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgICAgIGxldCBkZWNsYXJlRnVuY3Rpb25zID0gYFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSkge1xuICAgICAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0odmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoZDAgOiBpMzIsIGQxIDogaTMyLCBkMiA6IGkzMiwgZDMgOiBpMzIsIHZhbHVlIDogJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSkge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke2lzVmVjNCA/ICcvIDQnIDogJyd9LCB2YWx1ZSk7XG4gICAgICB9YDtcbiAgICAgICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoXG4gICAgICAgICAgICAneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCBpbm5lckVsZW1lbnRTaXplID09PSAzID8gMSA6IGlubmVyRWxlbWVudFNpemUpO1xuICAgICAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbeCwgd107XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChiaWFzKTtcbiAgICAgICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7aXNDaGFubmVsc0xhc3QgPyAndycgOiAneSd9JHtpc1ZlYzQgPyAnLyA0JyA6ICcnfV07XG4gICAgICAgIH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgJHt1dGlsRnVuY3Rpb25zKCd1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlcycpfVxuICAgICAgICAvL3N0cnVjdCBVbmlmb3JtcyB7IHhTaGFwZSA6IHZlYzQ8aTMyPiwgd1NoYXBlIDogdmVjNDxpMzI+LCBvdXRTaGFwZSA6IHZlYzQ8aTMyPixcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcbiAgICAgICAgLy8gIGRpbGF0aW9uIDogdmVjMjxpMzI+LCBkaW1BT3V0ZXIgOiBpMzIsIGRpbUJPdXRlciA6IGkzMiwgZGltSW5uZXIgOiBpMzIgfTtcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAgICAgICAke1xuICAgICAgICAgICAgY29udjJkQ29tbW9uU25pcHBldChcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxzTGFzdCwgZml0QU91dGVyLCBmaXRCT3V0ZXIsIGZpdElubmVyLCBoYXNCaWFzLCBhdHRyaWJ1dGVzLCBlbGVtZW50c1NpemVbMF0sIGVsZW1lbnRzU2l6ZVsxXSxcbiAgICAgICAgICAgICAgICBlbGVtZW50c1NpemVbMl0sIHQpfVxuICAgICAgICAke1xuICAgICAgICAgICAgaXNWZWM0ID9cbiAgICAgICAgICAgICAgICBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya0dyb3VwU2l6ZSwgdCwgdW5kZWZpbmVkLCAhaXNDaGFubmVsc0xhc3QsIHRpbGVJbm5lcikgOlxuICAgICAgICAgICAgICAgIG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCB0LCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyLCBmYWxzZSwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzKX1gO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdDb252MkRNYXRNdWwnLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aW5uZXJFbGVtZW50U2l6ZX07JHtpc1ZlYzR9OyR7Zml0QU91dGVyfTske2ZpdEJPdXRlcn07JHtmaXRJbm5lcn07JHtcbiAgICAgICAgICAgICAgdGlsZUFPdXRlcn07JHt0aWxlQk91dGVyfTske3RpbGVJbm5lcn1gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzXG4gICAgICAgIH0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjNkX25haXZlX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtMT0dfREVCVUd9IGZyb20gJy4uLy4uLy4uL2xvZyc7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHtDb252QXR0cmlidXRlc30gZnJvbSAnLi4vY29udic7XG5cbmNvbnN0IGFycmF5UHJvZHVjdCA9IChhcnI6IG51bWJlcltdKSA9PiB7XG4gIGxldCBwcm9kdWN0ID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBwcm9kdWN0ICo9IGFycltpXTtcbiAgfVxuICByZXR1cm4gcHJvZHVjdDtcbn07XG5cbmNvbnN0IHBhcnNlM1R1cGxlUGFyYW0gPSAocGFyYW06IG51bWJlcnxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPT5cbiAgICB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInID8gW3BhcmFtLCBwYXJhbSwgcGFyYW1dIDogcGFyYW07XG5cbmNvbnN0IGdldEVmZmVjdGl2ZUZpbHRlclNpemUgPSAoZmlsdGVyU2l6ZTogbnVtYmVyLCBkaWxhdGlvbjogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgaWYgKGRpbGF0aW9uIDw9IDEpIHtcbiAgICByZXR1cm4gZmlsdGVyU2l6ZTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJTaXplICsgKGZpbHRlclNpemUgLSAxKSAqIChkaWxhdGlvbiAtIDEpO1xufTtcblxuY29uc3QgY29tcHV0ZURlZmF1bHRQYWQgPVxuICAgIChpbnB1dFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdfFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmaWVsZFNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIGRpbGF0aW9uID0gMSk6XG4gICAgICAgIG51bWJlciA9PiB7XG4gICAgICAgICAgY29uc3QgZWZmZWN0aXZlRmllbGRTaXplID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWVsZFNpemUsIGRpbGF0aW9uKTtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5wdXRTaGFwZVswXSAqIChzdHJpZGUgLSAxKSAtIHN0cmlkZSArIGVmZmVjdGl2ZUZpZWxkU2l6ZSkgLyAyKTtcbiAgICAgICAgfTtcblxuY29uc3QgY29tcHV0ZU91dHB1dFNoYXBlNEQgPVxuICAgIChpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZmlsdGVyU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0Q2hhbm5lbHM6IG51bWJlcixcbiAgICAgc3RyaWRlczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB6ZXJvUGFkPzogbnVtYmVyKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPT4ge1xuICAgICAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgemVyb1BhZCA9IGNvbXB1dGVEZWZhdWx0UGFkKGluU2hhcGUsIGZpbHRlclNoYXBlWzBdLCBzdHJpZGVzWzBdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dFNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCBvdXRDaGFubmVsc107XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgMzsgaW5kZXgrKykge1xuICAgICAgICBpZiAoaW5TaGFwZVtpbmRleF0gKyAyICogemVyb1BhZCA+PSBmaWx0ZXJTaGFwZVtpbmRleF0pIHtcbiAgICAgICAgICBvdXRTaGFwZVtpbmRleF0gPSBNYXRoLnRydW5jKChpblNoYXBlW2luZGV4XSAtIGZpbHRlclNoYXBlW2luZGV4XSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZXNbaW5kZXhdICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRTaGFwZTtcbiAgICB9O1xuXG5jb25zdCBnZXQzRFBhZEFuZE91dEluZm8gPVxuICAgIChwYWQ6IG51bWJlcnxzdHJpbmd8bnVtYmVyW10sIGluRGVwdGg6IG51bWJlciwgaW5IZWlnaHQ6IG51bWJlciwgaW5XaWR0aDogbnVtYmVyLCBzdHJpZGVEZXB0aDogbnVtYmVyLFxuICAgICBzdHJpZGVIZWlnaHQ6IG51bWJlciwgc3RyaWRlV2lkdGg6IG51bWJlciwgZmlsdGVyRGVwdGg6IG51bWJlciwgZmlsdGVySGVpZ2h0OiBudW1iZXIsXG4gICAgIGZpbHRlcldpZHRoOiBudW1iZXIpOiB7cGFkSW5mbzogUGFkSW5mbzNEOyBvdXREZXB0aDogbnVtYmVyOyBvdXRIZWlnaHQ6IG51bWJlcjsgb3V0V2lkdGg6IG51bWJlcn0gPT4ge1xuICAgICAgbGV0IHBhZEluZm86IFBhZEluZm8zRDtcbiAgICAgIGxldCBvdXREZXB0aDogbnVtYmVyO1xuICAgICAgbGV0IG91dEhlaWdodDogbnVtYmVyO1xuICAgICAgbGV0IG91dFdpZHRoOiBudW1iZXI7XG5cbiAgICAgIGlmIChwYWQgPT09ICdWQUxJRCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHBhZCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYWRJbmZvID0ge3RvcDogcGFkLCBib3R0b206IHBhZCwgbGVmdDogcGFkLCByaWdodDogcGFkLCBmcm9udDogcGFkLCBiYWNrOiBwYWR9O1xuICAgICAgICBjb25zdCBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTREKFxuICAgICAgICAgICAgW2luRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCAxXSwgW2ZpbHRlckRlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoXSwgMSxcbiAgICAgICAgICAgIFtzdHJpZGVEZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aF0sIHBhZCk7XG4gICAgICAgIG91dERlcHRoID0gb3V0U2hhcGVbMF07XG4gICAgICAgIG91dEhlaWdodCA9IG91dFNoYXBlWzFdO1xuICAgICAgICBvdXRXaWR0aCA9IG91dFNoYXBlWzJdO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhZCkpIHtcbiAgICAgICAgaWYgKCFwYWQuZXZlcnkoKHZhbCwgXywgYXJyKSA9PiB2YWwgPT09IGFyclswXSkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFkZGluZyBwYXJhbWV0ZXI6ICR7cGFkfWApO1xuICAgICAgICB9XG4gICAgICAgIHBhZEluZm8gPSB7dG9wOiBwYWRbMF0sIGJvdHRvbTogcGFkWzFdLCBsZWZ0OiBwYWRbMl0sIHJpZ2h0OiBwYWRbM10sIGZyb250OiBwYWRbNF0sIGJhY2s6IHBhZFs1XX07XG4gICAgICAgIGNvbnN0IG91dFNoYXBlID0gY29tcHV0ZU91dHB1dFNoYXBlNEQoXG4gICAgICAgICAgICBbaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIDFdLCBbZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdLCAxLFxuICAgICAgICAgICAgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSwgcGFkWzBdKTtcbiAgICAgICAgb3V0RGVwdGggPSBvdXRTaGFwZVswXTtcbiAgICAgICAgb3V0SGVpZ2h0ID0gb3V0U2hhcGVbMV07XG4gICAgICAgIG91dFdpZHRoID0gb3V0U2hhcGVbMl07XG4gICAgICB9IGVsc2UgaWYgKHBhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgJ1NBTUVfTE9XRVInLlxuICAgICAgICBvdXREZXB0aCA9IE1hdGguY2VpbChpbkRlcHRoIC8gc3RyaWRlRGVwdGgpO1xuICAgICAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoaW5IZWlnaHQgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGguY2VpbChpbldpZHRoIC8gc3RyaWRlV2lkdGgpO1xuICAgICAgICBjb25zdCBwYWRBbG9uZ0RlcHRoID0gKG91dERlcHRoIC0gMSkgKiBzdHJpZGVEZXB0aCArIGZpbHRlckRlcHRoIC0gaW5EZXB0aDtcbiAgICAgICAgY29uc3QgcGFkQWxvbmdIZWlnaHQgPSAob3V0SGVpZ2h0IC0gMSkgKiBzdHJpZGVIZWlnaHQgKyBmaWx0ZXJIZWlnaHQgLSBpbkhlaWdodDtcbiAgICAgICAgY29uc3QgcGFkQWxvbmdXaWR0aCA9IChvdXRXaWR0aCAtIDEpICogc3RyaWRlV2lkdGggKyBmaWx0ZXJXaWR0aCAtIGluV2lkdGg7XG4gICAgICAgIGNvbnN0IGZyb250ID0gTWF0aC5mbG9vcihwYWRBbG9uZ0RlcHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGJhY2sgPSBwYWRBbG9uZ0RlcHRoIC0gZnJvbnQ7XG4gICAgICAgIGNvbnN0IHRvcCA9IE1hdGguZmxvb3IocGFkQWxvbmdIZWlnaHQgLyAyKTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gcGFkQWxvbmdIZWlnaHQgLSB0b3A7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBwYWRBbG9uZ1dpZHRoIC0gbGVmdDtcblxuICAgICAgICBwYWRJbmZvID0ge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodCwgZnJvbnQsIGJhY2t9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6ICR7cGFkfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtwYWRJbmZvLCBvdXREZXB0aCwgb3V0SGVpZ2h0LCBvdXRXaWR0aH07XG4gICAgfTtcblxudHlwZSBQYWRJbmZvM0QgPSB7XG4gIHRvcDogbnVtYmVyOyBsZWZ0OiBudW1iZXI7IHJpZ2h0OiBudW1iZXI7IGJvdHRvbTogbnVtYmVyOyBmcm9udDogbnVtYmVyOyBiYWNrOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBDb252M0RJbmZvID0ge1xuICBiYXRjaFNpemU6IG51bWJlcjsgaW5EZXB0aDogbnVtYmVyOyBpbkhlaWdodDogbnVtYmVyOyBpbldpZHRoOiBudW1iZXI7IGluQ2hhbm5lbHM6IG51bWJlcjsgb3V0RGVwdGg6IG51bWJlcjtcbiAgb3V0SGVpZ2h0OiBudW1iZXI7XG4gIG91dFdpZHRoOiBudW1iZXI7XG4gIG91dENoYW5uZWxzOiBudW1iZXI7XG4gIGRhdGFGb3JtYXQ6ICdjaGFubmVsc0ZpcnN0JyB8ICdjaGFubmVsc0xhc3QnO1xuICBzdHJpZGVEZXB0aDogbnVtYmVyO1xuICBzdHJpZGVIZWlnaHQ6IG51bWJlcjtcbiAgc3RyaWRlV2lkdGg6IG51bWJlcjtcbiAgZGlsYXRpb25EZXB0aDogbnVtYmVyO1xuICBkaWxhdGlvbkhlaWdodDogbnVtYmVyO1xuICBkaWxhdGlvbldpZHRoOiBudW1iZXI7XG4gIGZpbHRlckRlcHRoOiBudW1iZXI7XG4gIGZpbHRlckhlaWdodDogbnVtYmVyO1xuICBmaWx0ZXJXaWR0aDogbnVtYmVyO1xuICBlZmZlY3RpdmVGaWx0ZXJEZXB0aDogbnVtYmVyO1xuICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6IG51bWJlcjtcbiAgZWZmZWN0aXZlRmlsdGVyV2lkdGg6IG51bWJlcjtcbiAgcGFkSW5mbzogUGFkSW5mbzNEO1xuICBpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgZmlsdGVyU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG59O1xuXG5leHBvcnQgY29uc3QgY29tcHV0ZUNvbnYzREluZm8gPVxuICAgIChpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmaWx0ZXJTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgc3RyaWRlczogbnVtYmVyfFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZGlsYXRpb25zOiBudW1iZXJ8W251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBwYWQ6IG51bWJlcnxzdHJpbmd8bnVtYmVyW10sXG4gICAgIGRlcHRod2lzZSA9IGZhbHNlLCBkYXRhRm9ybWF0OiAnY2hhbm5lbHNGaXJzdCd8J2NoYW5uZWxzTGFzdCcgPSAnY2hhbm5lbHNMYXN0Jyk6IENvbnYzREluZm8gPT4ge1xuICAgICAgbGV0IGJhdGNoU2l6ZSwgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIGluQ2hhbm5lbHM7XG4gICAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgW2JhdGNoU2l6ZSwgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIGluQ2hhbm5lbHNdID0gaW5TaGFwZTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgIFtiYXRjaFNpemUsIGluQ2hhbm5lbHMsIGluRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoXSA9IGluU2hhcGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YUZvcm1hdCAke2RhdGFGb3JtYXR9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBbZmlsdGVyQ2hhbm5lbHMsICwgZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdID0gZmlsdGVyU2hhcGU7XG5cbiAgICAgIGNvbnN0IFtzdHJpZGVEZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aF0gPSBwYXJzZTNUdXBsZVBhcmFtKHN0cmlkZXMpO1xuICAgICAgY29uc3QgW2RpbGF0aW9uRGVwdGgsIGRpbGF0aW9uSGVpZ2h0LCBkaWxhdGlvbldpZHRoXSA9IHBhcnNlM1R1cGxlUGFyYW0oZGlsYXRpb25zKTtcblxuICAgICAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlckRlcHRoLCBkaWxhdGlvbkRlcHRoKTtcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckhlaWdodCA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVySGVpZ2h0LCBkaWxhdGlvbkhlaWdodCk7XG4gICAgICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJXaWR0aCA9IGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVyV2lkdGgsIGRpbGF0aW9uV2lkdGgpO1xuICAgICAgY29uc3Qge3BhZEluZm8sIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRofSA9IGdldDNEUGFkQW5kT3V0SW5mbyhcbiAgICAgICAgICBwYWQsIGluRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCBzdHJpZGVEZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgZWZmZWN0aXZlRmlsdGVyRGVwdGgsXG4gICAgICAgICAgZWZmZWN0aXZlRmlsdGVySGVpZ2h0LCBlZmZlY3RpdmVGaWx0ZXJXaWR0aCk7XG5cbiAgICAgIGNvbnN0IG91dENoYW5uZWxzID0gZGVwdGh3aXNlID8gZmlsdGVyQ2hhbm5lbHMgKiBpbkNoYW5uZWxzIDogZmlsdGVyQ2hhbm5lbHM7XG5cbiAgICAgIGxldCBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgb3V0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRDaGFubmVscywgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGhdO1xuICAgICAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICBvdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoLCBvdXRDaGFubmVsc107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhdGNoU2l6ZSxcbiAgICAgICAgZGF0YUZvcm1hdCxcbiAgICAgICAgaW5EZXB0aCxcbiAgICAgICAgaW5IZWlnaHQsXG4gICAgICAgIGluV2lkdGgsXG4gICAgICAgIGluQ2hhbm5lbHMsXG4gICAgICAgIG91dERlcHRoLFxuICAgICAgICBvdXRIZWlnaHQsXG4gICAgICAgIG91dFdpZHRoLFxuICAgICAgICBvdXRDaGFubmVscyxcbiAgICAgICAgcGFkSW5mbyxcbiAgICAgICAgc3RyaWRlRGVwdGgsXG4gICAgICAgIHN0cmlkZUhlaWdodCxcbiAgICAgICAgc3RyaWRlV2lkdGgsXG4gICAgICAgIGZpbHRlckRlcHRoLFxuICAgICAgICBmaWx0ZXJIZWlnaHQsXG4gICAgICAgIGZpbHRlcldpZHRoLFxuICAgICAgICBlZmZlY3RpdmVGaWx0ZXJEZXB0aCxcbiAgICAgICAgZWZmZWN0aXZlRmlsdGVySGVpZ2h0LFxuICAgICAgICBlZmZlY3RpdmVGaWx0ZXJXaWR0aCxcbiAgICAgICAgZGlsYXRpb25EZXB0aCxcbiAgICAgICAgZGlsYXRpb25IZWlnaHQsXG4gICAgICAgIGRpbGF0aW9uV2lkdGgsXG4gICAgICAgIGluU2hhcGUsXG4gICAgICAgIG91dFNoYXBlLFxuICAgICAgICBmaWx0ZXJTaGFwZVxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcywgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBmaWx0ZXJEaW1zOiByZWFkb25seSBudW1iZXJbXSwgcGFkczogcmVhZG9ubHkgbnVtYmVyW10sIGRhdGFGb3JtYXQ6IHN0cmluZyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gICAgICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBpbnB1dHNbMF0uZGltc1szXSA6IGlucHV0c1swXS5kaW1zWzFdO1xuICAgICAgLy8gVE9ETzogZW5hYmxlIHZlYzQuXG4gICAgICBjb25zdCBpc1ZlYzQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHdvcmtHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs2NCwgMSwgMV07XG4gICAgICBjb25zdCBkaXNwYXRjaExheW91dCA9IHt4OiBvdXRwdXRTaGFwZS5tYXAoKF8sIGkpID0+IGkpfTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gW01hdGguY2VpbChhcnJheVByb2R1Y3QoZGlzcGF0Y2hMYXlvdXQueC5tYXAoZCA9PiBvdXRwdXRTaGFwZVtkXSkpIC8gKHdvcmtHcm91cFNpemVbMF0pKSwgMSwgMV07XG5cbiAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gICAgICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gaXNWZWM0ID8gKGlzQ2hhbm5lbHNMYXN0ICYmIGluQ2hhbm5lbHMgJSA0ICE9PSAwID8gMyA6IDQpIDogMTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBmaWx0ZXJEaW1zfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFkc30sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlc30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zfVxuICAgICAgXTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcykpO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgICAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICAgIHtuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnZmlsdGVyX2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aH0sXG4gICAgICAgICAge25hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogcGFkcy5sZW5ndGh9LFxuICAgICAgICAgIHtuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGh9LFxuICAgICAgICAgIHtuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RofVxuICAgICAgICBdO1xuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGNvbXBvbmVudCAyLCAzLlxuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICAgICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZShcbiAgICAgICAgICAgICd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIGlubmVyRWxlbWVudFNpemUgPT09IDMgPyAxIDogaW5uZXJFbGVtZW50U2l6ZSk7XG4gICAgICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCdXJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSAnJztcbiAgICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGJpYXMpO1xuICAgICAgICAgIGRlY2xhcmVGdW5jdGlvbnMgKz0gYFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogYXJyYXk8dTMyLCA1PikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbJHtpc0NoYW5uZWxzTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgNCwgNSkgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIDUpfSR7XG4gICAgICAgICAgICAgIGlzVmVjNCA/ICcvIDQnIDogJyd9XTtcbiAgICAgICAgfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAgICAgICAgICAgZm4gZ2V0WChkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7eC5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gZ2V0VyhkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7dy5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgbGV0IGJhdGNoID0gJHtnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDAsIHgucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgZDIgPSAke1xuICAgICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIHgucmFuayAtIDEsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIHgucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeEZSQ0Nvcm5lciA9IHZlYzM8dTMyPigke1xuICAgICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDIsIHgucmFuayl9LFxuICAgICAgICAgICAgICAke2lzQ2hhbm5lbHNMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAyLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspfSxcbiAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudEF0KCdjb29yZHMnLCA0LCB4LnJhbmspfSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICAgICAgbGV0IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xuICAgICAgICAgICAgICBsZXQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XG4gICAgICAgICAgICAgIGxldCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVkgPSAke1xuICAgICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAxLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMiwgeC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVaID0gJHtcbiAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMiwgeC5yYW5rKSA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDMsIHgucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVyA9ICR7XG4gICAgICAgICAgICBpc0NoYW5uZWxzTGFzdCA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDMsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCA0LCB4LnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVUgPSAke1xuICAgICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCA0LCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMSwgeC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSAoeFNoYXBlVSAvIDQpICogNDtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID0geFNoYXBlVSAlIDQ7XG5cbiAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwLjA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0geFNoYXBlWSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFNoYXBlWikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHhTaGFwZVcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gYGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDIsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMywgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAyLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMywgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBgZG90UHJvZCArPSBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICogZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKTtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRvdFByb2QgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gYGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICBgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICR7XG4gICAgICAgICAgICBpc0NoYW5uZWxzTGFzdCA/IGBsZXQgeFZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICBgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke2hhc0JpYXMgPyAnZG90UHJvZCA9IGRvdFByb2QgKyBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzKScgOiAnJ307XG4gICAgICAgICAgICAgIHJlc3VsdFtnbG9iYWxfaWR4XSA9IGYzMihkb3RQcm9kKTtcbiAgICAgICAgICB9YDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnQ29udjNETmFpdmUnLFxuICAgICAgICBzaGFkZXJDYWNoZTpcbiAgICAgICAgICAgIHtoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2lzQ2hhbm5lbHNMYXN0fTske2lubmVyRWxlbWVudFNpemV9OyR7aGFzQmlhc31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0TWF4Q29tcG9uZW50cywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHtjYWxjdWxhdGVPdXRwdXRTaGFwZSwgQ29udkF0dHJpYnV0ZXN9IGZyb20gJy4vY29udic7XG5pbXBvcnQge2FwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcywgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSwgZ2V0QWN0aXZhdGlvblNuaXBwZXR9IGZyb20gJy4vZnVzZS11dGlscyc7XG5cbi8qKlxuICogbmFpdmUgZ3JvdXBlZCBjb252IGltcGxlbWVudGF0aW9uLCBzdXBwb3J0cyAxZC8yZCBjb252XG4gKiBAcGFyYW0gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gLSBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBzcXVlZXplIHRoZSBvdXRwdXQgc2hhcGUsIG9ubHkgdXNlZCBpbiBjb252MWRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4gICAgIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gICAgICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07JyA6ICcnO1xuICAgICAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgICAgIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMF0gLyBhdHRyaWJ1dGVzLmdyb3VwO1xuXG4gICAgICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoXG4gICAgICAgICAgeFNoYXBlLCB3U2hhcGUsIGF0dHJpYnV0ZXMuZGlsYXRpb25zLCBhdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcywgaXNDaGFubmVsTGFzdCk7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmRpbGF0aW9uc30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnN0cmlkZXNbMF0sIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXV19LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5wYWRzWzBdLCBhdHRyaWJ1dGVzLnBhZHNbMV1dfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0Q2hhbm5lbHNQZXJHcm91cH1cbiAgICAgIF07XG4gICAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh4U2hhcGUsIHdTaGFwZSkpO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICAgICAgfVxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XG4gICAgICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XG4gICAgICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIHdTaGFwZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcnMgPSBbeCwgd107XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGh9LFxuICAgICAgICAgIHtuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IDJ9LCB7bmFtZTogJ3BhZHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiAyfSxcbiAgICAgICAgICB7bmFtZTogJ291dHB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHtpc0NoYW5uZWxMYXN0ID8gMyA6IDF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske2lzQ2hhbm5lbExhc3QgPyAxIDogMn1dLCBvdXRwdXRJbmRpY2VzWyR7XG4gICAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gMiA6IDN9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcblxuICAgIHZhciB2YWx1ZTogJHtvdXRwdXQudHlwZS52YWx1ZX0gPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtcbiAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqIHVuaWZvcm1zLndfc2hhcGVbMV0gKyB3SW5DaGFubmVsO1xuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbJHtpc0NoYW5uZWxMYXN0ID8gMSA6IDJ9XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVszXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7aXNDaGFubmVsTGFzdCA/IDIgOiAzfV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCB4VmFsID0gJHtcbiAgICAgICAgICAgIGlzQ2hhbm5lbExhc3QgPyB4LmdldCgnYmF0Y2gnLCAneEhlaWdodCcsICd4V2lkdGgnLCAnaW5wdXRfY2hhbm5lbCcpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmdldCgnYmF0Y2gnLCAnaW5wdXRfY2hhbm5lbCcsICd4SGVpZ2h0JywgJ3hXaWR0aCcpfTtcbiAgICAgICAgICBsZXQgd1ZhbCA9ICR7dy5nZXQoJ291dHB1dF9jaGFubmVsJywgJ3dJbkNoYW5uZWwnLCAnd0hlaWdodCcsICd3V2lkdGgnKX07XG4gICAgICAgICAgdmFsdWUgKz0geFZhbCp3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0dyb3VwZWRDb252JyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tcbiAgICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKG91dHB1dFNoYXBlWzNdKTtcbiAgICAgIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMob3V0cHV0U2hhcGVbMl0pO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMgLyBvdXRwdXROdW1iZXI7XG4gICAgICBjb25zdCB4U2hhcGUgPSBbaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1swXS5kaW1zWzFdLCBpbnB1dHNbMF0uZGltc1syXSwgaW5wdXRzWzBdLmRpbXNbM10gLyBjb21wb25lbnRzXTtcbiAgICAgIGNvbnN0IHdTaGFwZSA9IFtpbnB1dHNbMV0uZGltc1swXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdLCBpbnB1dHNbMV0uZGltc1szXSAvIGNvbXBvbmVudHNdO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGVJblNoYWRlciA9IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXSAvIGNvbXBvbmVudHNdO1xuXG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnN0cmlkZXNbMF0sIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXV19LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV19XG4gICAgICBdO1xuICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoeFNoYXBlLCB3U2hhcGUsIG91dHB1dFNoYXBlSW5TaGFkZXIpKTtcbiAgICAgIGNvbnN0IHhOdW1iZXIgPSAob3V0cHV0TnVtYmVyIC0gMSkgKiBhdHRyaWJ1dGVzLnN0cmlkZXNbMV0gKyB3U2hhcGVbMV07XG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVJblNoYWRlci5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xuICAgICAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgeFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCd3JywgaW5wdXRzWzFdLmRhdGFUeXBlLCB3U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xuICAgICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICAgIGlucHV0VmFycy5wdXNoKGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdOycgOiAnJztcbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICAgIHtuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJ30sXG4gICAgICAgICAge25hbWU6ICdzdHJpZGVzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMn0sXG4gICAgICAgICAge25hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMn0sXG4gICAgICAgIF07XG4gICAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG4gICAgICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIGxldCB3aWR0aDAgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbM107XG4gICAgbGV0IG91dHB1dF9jaGFubmVsID0gZ2xvYmFsX2lkeCAlIHdpZHRoMDtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvIHdpZHRoMDtcbiAgICBsZXQgd2lkdGgxID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdIC8gJHtvdXRwdXROdW1iZXJ9dTtcbiAgICBsZXQgY29sID0gKGluZGV4MSAlIHdpZHRoMSkgKiAke291dHB1dE51bWJlcn11O1xuICAgIGluZGV4MSA9IGluZGV4MSAvIHdpZHRoMTtcbiAgICBsZXQgcm93ID0gaW5kZXgxICUgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcblxuICAgIGxldCB4X2Nvcm5lciA9IHZlYzI8aTMyPihpMzIocm93KSwgaTMyKGNvbCkpICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG5cbiAgICB2YXIgeF92YWxzOiBhcnJheTwke3gudHlwZS52YWx1ZX0sICR7eE51bWJlcn0+O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dE51bWJlcn0+O1xuICAgIGxldCBpbnB1dF9jaGFubmVsID0gb3V0cHV0X2NoYW5uZWw7XG4gICAgLy8gVXNlIGNvbnN0YW50IGluc3RlYWQgb2YgdW5pZm9ybSBjYW4gZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UgZm9yIHcncyBoZWlnaHQvd2lkdGguXG4gICAgZm9yICh2YXIgd19oZWlnaHQ6IHUzMiA9IDB1OyB3X2hlaWdodCA8ICR7d1NoYXBlWzBdfTsgd19oZWlnaHQrKykge1xuICAgICAgbGV0IHhfaGVpZ2h0ID0geF9jb3JuZXIueCArIGkzMih3X2hlaWdodCk7XG4gICAgICBpZiAoeF9oZWlnaHQgPj0gMCAmJiB1MzIoeF9oZWlnaHQpIDwgdW5pZm9ybXMueF9zaGFwZVsxXSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7eE51bWJlcn07IGkrKykge1xuICAgICAgICAgIGxldCB4X3dpZHRoID0geF9jb3JuZXIueSArIGk7XG4gICAgICAgICAgaWYgKHhfd2lkdGggPj0gMCAmJiB1MzIoeF93aWR0aCkgPCB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICB4X3ZhbHNbaV0gPSAke3guZ2V0KCdiYXRjaCcsICd1MzIoeF9oZWlnaHQpJywgJ3UzMih4X3dpZHRoKScsICdpbnB1dF9jaGFubmVsJyl9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4X3ZhbHNbaV0gPSAke3gudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHdfd2lkdGg6IHUzMiA9IDB1OyB3X3dpZHRoIDwgJHt3U2hhcGVbMV19OyB3X3dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgd192YWwgPSAke3cuZ2V0KCd3X2hlaWdodCcsICd3X3dpZHRoJywgJzAnLCAnb3V0cHV0X2NoYW5uZWwnKX07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtvdXRwdXROdW1iZXJ9dTsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSBmbWEoeF92YWxzW2kgKiB1MzIodW5pZm9ybXMuc3RyaWRlc1sxXSkgKyB3X3dpZHRoXSwgd192YWwsIHZhbHVlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtvdXRwdXROdW1iZXJ9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke3Byb2Nlc3NCaWFzfVxuICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAke291dHB1dC5zZXQoJ2JhdGNoJywgJ3JvdycsICdjb2wgKyBpJywgJ291dHB1dF9jaGFubmVsJywgJ3ZhbHVlJyl9O1xuICAgIH1cbiAgfWA7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnR3JvdXBlZENvbnYtVmVjdG9yaXplJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2NvbXBvbmVudHN9OyR7b3V0cHV0TnVtYmVyfTske3hOdW1iZXJ9OyR7d1NoYXBlWzBdfTske3dTaGFwZVsxXX1gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBoYXNCaWFzID8gWydyYW5rJywgJ3JhbmsnLCAndHlwZSddIDogWydyYW5rJywgJ3JhbmsnXVxuICAgICAgICB9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7QnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZU1hdG11bFByb2dyYW1JbmZvfSBmcm9tICcuLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRCcm9hZGNhc3REaW1zLCBnZXRNYXhDb21wb25lbnRzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBpbnRlcm5hbFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge2FwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcywgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSwgZ2V0QWN0aXZhdGlvblNuaXBwZXQsIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXN9IGZyb20gJy4vZnVzZS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIHJlc2hhcGVkT3V0cHV0U2hhcGU/OiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSAvKiBvbmx5IHVzZWQgZm9yIGNvbnYyZEJ5TWF0TXVsKi8pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gICAgICBjb25zdCBNID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IE4gPSBiU2hhcGVbYlNoYXBlLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgSyA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhOKTtcbiAgICAgIGNvbnN0IGFDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhLKTtcbiAgICAgIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMoTSk7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICAgIGNvbnN0IG91dGVyRGltcyA9IHJlc2hhcGVkT3V0cHV0U2hhcGUgPyByZXNoYXBlZE91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKSA6IG91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dGVyRGltcyk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZUluU2hhZGVyID0gW2JhdGNoU2l6ZSwgTSwgTl07XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE19LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBOfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogS31cbiAgICAgIF07XG4gICAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0ZXJEaW1zLCBhU2hhcGUsIGJTaGFwZSkpO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICAgIH1cbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlSW5TaGFkZXIpKTtcblxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGJhdGNoRGltcyA9IGludGVybmFsVmFyaWFibGUoJ2JhdGNoX2RpbXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dGVyRGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgYVNoYXBlLmxlbmd0aCwgYUNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgYlNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlSW5TaGFkZXIubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICAgICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2EsIGJdO1xuICAgICAgICBsZXQgcHJvY2Vzc0JpYXMgPSAnJztcbiAgICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgICBjb25zdCBiaWFzQ29tcG9uZW50cyA9IGlzQ2hhbm5lbHNMYXN0ID8gY29tcG9uZW50cyA6IDE7XG4gICAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGJpYXNDb21wb25lbnRzKSk7XG4gICAgICAgICAgcHJvY2Vzc0JpYXMgPSBgJHtcbiAgICAgICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBgdmFsdWUgKz0gYmlhc1tjb2wgLyAke2JpYXNDb21wb25lbnRzfV07YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHZhbHVlICs9ICR7b3V0cHV0LnR5cGUudmFsdWV9KGJpYXNbcm93ICsgaV0pO2B9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG91dGVyRGltc0EgPSBhU2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgICAgICBjb25zdCBvdXRlckRpbXNCID0gYlNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgY29uc3QgYnJvYWRDYXN0QURpbXMgPSBnZXRCcm9hZGNhc3REaW1zKG91dGVyRGltc0EsIG91dGVyRGltcyk7XG4gICAgICAgIGNvbnN0IGJyb2FkQ2FzdEJEaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhvdXRlckRpbXNCLCBvdXRlckRpbXMpO1xuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdNJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ04nLCB0eXBlOiAndTMyJ30sXG4gICAgICAgICAge25hbWU6ICdLJywgdHlwZTogJ3UzMid9XG4gICAgICAgIF07XG4gICAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhY3RpdmF0aW9uQXR0cmlidXRlcywgdW5pZm9ybXMpO1xuXG4gICAgICAgIGNvbnN0IGdldEluZGljZXMgPSAodmFyaWFibGU6IEluZGljZXNIZWxwZXIsIGJyb2FkQ2FzdERpbXM6IG51bWJlcltdKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmFuayA9IHZhcmlhYmxlLnJhbms7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHZhcmlhYmxlLm5hbWU7XG4gICAgICAgICAgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBgdmFyICR7bmFtZX1faW5kaWNlcyA9ICR7dmFyaWFibGUudHlwZS5pbmRpY2VzfSgwdSwgMHUpO2A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGJhdGNoUmFuayA9IGJhdGNoRGltcy5yYW5rO1xuICAgICAgICAgIGxldCByZXNTdHIgPSBgdmFyICR7bmFtZX1faW5kaWNlczogJHt2YXJpYWJsZS50eXBlLmluZGljZXN9O2A7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHJhbmsgLSAyIC0gMSwgaiA9IGJhdGNoUmFuayAtIDE7IGkgPj0gMDsgaS0tLCBqLS0pIHtcbiAgICAgICAgICAgIHJlc1N0ciArPSBgXFxuJHtuYW1lfV9pbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoX2luZGljZXNbJHtqfV1gIDogJ2JhdGNoX2luZGljZXMnfTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicm9hZENhc3REaW1zLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICByZXNTdHIgKz0gYFxcbiR7bmFtZX1faW5kaWNlc1ske2l9XSA9IDA7YDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNTdHIgKz0gYCR7bmFtZX1faW5kaWNlc1ske3JhbmsgLSAyfV0gPSAwdTtcbiAgICAgICAgICAgICAgICAgICAgICR7bmFtZX1faW5kaWNlc1ske3JhbmsgLSAxfV0gPSAwdTtgO1xuICAgICAgICAgIHJldHVybiByZXNTdHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY2FsY1Jlc3VsdCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgICAgIGxldCBjYWxjU3RyID0gYHZhciBhX2RhdGE6ICR7YS50eXBlLnZhbHVlfTtgO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUNvbXBvbmVudHM7IGkrKykge1xuICAgICAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke2l9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7aX0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke2NvbXBvbmVudHN9XTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dE51bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICBjYWxjU3RyICs9IGBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke2l9KSAqIHVuaWZvcm1zLksgKyBrKSAvICR7YUNvbXBvbmVudHN9XTtgO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFDb21wb25lbnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICB2YWx1ZXNbJHtpfV0gPSBmbWEoJHtiLnR5cGUudmFsdWV9KGFfZGF0YSR7YUNvbXBvbmVudHMgPT09IDEgPyAnJyA6IGBbJHtqfV1gfSksIGJfZGF0YSR7an0sIHZhbHVlc1ske1xuICAgICAgICAgICAgICAgICAgaX1dKTtcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsY1N0cjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYFxuICAke1xuICAgICAgICAgICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoYmF0Y2hEaW1zKS5kZWNsYXJlVmFyaWFibGVzKFxuICAgICAgICAgICAgICAgIC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIGxldCBjb2wgPSAoZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5OIC8gJHtjb21wb25lbnRzfSkpICogJHtjb21wb25lbnRzfTtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHtjb21wb25lbnRzfSk7XG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtvdXRwdXROdW1iZXJ9O1xuICAgIGxldCByb3cgPSAoaW5kZXgxICUgc3RyaWRlMSkgKiAke291dHB1dE51bWJlcn07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gc3RyaWRlMTtcblxuICAgICR7b3V0cHV0U2hhcGUubGVuZ3RoID09PSAyID8gJycgOiBgbGV0IGJhdGNoX2luZGljZXMgPSAke2JhdGNoRGltcy5vZmZzZXRUb0luZGljZXMoJ2JhdGNoJyl9O2B9XG4gICAgJHtnZXRJbmRpY2VzKGEsIGJyb2FkQ2FzdEFEaW1zKX1cbiAgICBsZXQgYV9vZmZzZXQgPSAke2EuaW5kaWNlc1RvT2Zmc2V0KCdhX2luZGljZXMnKX07XG4gICAgJHtnZXRJbmRpY2VzKGIsIGJyb2FkQ2FzdEJEaW1zKX1cbiAgICBsZXQgYl9vZmZzZXQgPSAke2IuaW5kaWNlc1RvT2Zmc2V0KCdiX2luZGljZXMnKX07XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0TnVtYmVyfT47XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrID0gayArICR7YUNvbXBvbmVudHN9KSB7XG4gICAgICAke2NhbGNSZXN1bHQoKX1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtvdXRwdXROdW1iZXJ9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke3Byb2Nlc3NCaWFzfVxuICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICBsZXQgY3VyX2luZGljZXMgPSAke291dHB1dC50eXBlLmluZGljZXN9KGJhdGNoLCByb3cgKyBpLCBjb2wpO1xuICAgICAgbGV0IG9mZnNldCA9ICR7b3V0cHV0LmluZGljZXNUb09mZnNldCgnY3VyX2luZGljZXMnKX07XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHtjb21wb25lbnRzfWAsICd2YWx1ZScpfTtcbiAgICB9XG4gIH1cbiAgYDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnTWF0TXVsTmFpdmUnLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGAke2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259OyR7Y29tcG9uZW50c307JHthQ29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7aXNDaGFubmVsc0xhc3R9YCxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSA6IFsncmFuaycsICdyYW5rJ11cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXRNdWwgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXNbaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV0gIT09IGlucHV0c1sxXS5kaW1zW2lucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDJdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLicpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWF0TXVsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShjb250ZXh0LmlucHV0c1swXS5kaW1zLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zLCB0cnVlKTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gIH1cbiAgY29uc3QgTiA9IG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBLID0gY29udGV4dC5pbnB1dHNbMF0uZGltc1tjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdO1xuICBpZiAoTiA8IDggJiYgSyA8IDgpIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywge2FjdGl2YXRpb246ICcnfSwgb3V0cHV0U2hhcGUpKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHthY3RpdmF0aW9uOiAnJ30sIG91dHB1dFNoYXBlKSk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtQb29sQ29udlV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0fSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlQ29udjJETWF0TXVsUHJvZ3JhbUluZm99IGZyb20gJy4vM3JkLXBhcnR5L2NvbnYyZF9tbV93ZWJncHUnO1xuaW1wb3J0IHtjb21wdXRlQ29udjNESW5mbywgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mb30gZnJvbSAnLi8zcmQtcGFydHkvY29udjNkX25haXZlX3dlYmdwdSc7XG5pbXBvcnQge2NyZWF0ZU1hdG11bFByb2dyYW1JbmZvfSBmcm9tICcuLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5pbXBvcnQge2NyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8sIGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm99IGZyb20gJy4vY29udi1ncm91cGVkJztcbmltcG9ydCB7SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvfSBmcm9tICcuL21hdG11bCc7XG5pbXBvcnQge2NyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9XG4gICAgKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIGFkanVzdFBhZHM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgaXNDaGFubmVsTGFzdDogYm9vbGVhbik6IG51bWJlcltdID0+IHtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoaXNDaGFubmVsTGFzdCA/IDEgOiAyLCBpc0NoYW5uZWxMYXN0ID8gMyA6IDQpO1xuICAgICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNwYXRpYWxTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlWzBdO1xuICAgICAgY29uc3Qga2VybmVsU3BhdGlhbFNoYXBlID0ga2VybmVsU2hhcGUuc2xpY2UoMik7XG4gICAgICBjb25zdCBkaWxhdGVkS2VybmVsU2hhcGUgPSBrZXJuZWxTcGF0aWFsU2hhcGUubWFwKCh2LCBpKSA9PiB2ICsgKHYgLSAxKSAqIChkaWxhdGlvbnNbaV0gLSAxKSk7XG4gICAgICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQgPSBpbnB1dFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyBhZGp1c3RQYWRzW2ldICsgYWRqdXN0UGFkc1tpICsgc3BhdGlhbFJhbmtdKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID1cbiAgICAgICAgICBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQubWFwKCh2LCBpKSA9PiBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSk7XG4gICAgICBvdXRwdXRTaGFwZS5zcGxpY2UoMCwgMCwgYmF0Y2hTaXplKTtcbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcbiAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZBdHRyaWJ1dGVzIGV4dGVuZHMgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXV0b1BhZDogc3RyaW5nO1xuICByZWFkb25seSBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJ3wnTkNIVyc7XG4gIHJlYWRvbmx5IGdyb3VwOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB3SXNDb25zdDogYm9vbGVhbjtcbn1cblxuLy8gZm9yIHRyYW5zcG9zaW5nIHdlaWdodCB0ZW5zb3IgZnJvbSBbTSwgQy9ncm91cCwgS0gsIEtXXSB0byBbS0gsIEtXLCBDL2dyb3VwLCBNXVxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlID0gWzIsIDMsIDEsIDBdO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gUmVmZXIgdG8gdGhlIGJlbG93IGxpbmsgZm9yIGFsbCBpbnB1dCBjaGVja3NcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21hc3Rlci9kb2NzL09wZXJhdG9ycy5tZCNDb252XG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggPiA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmVhdGVyIHRoYW4gNUQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxIDogMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUwnKTtcbiAgfVxuXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMl0uZGltc1swXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xuICB9XG5cbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcbiAgfVxuXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXM+KGF0dHJpYnV0ZXM6IFQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogVCA9PiB7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGtlcm5lbFNoYXBlW2kgLSAyXSA9PT0gMCkge1xuICAgICAga2VybmVsU2hhcGVbaSAtIDJdID0gaW5wdXRzWzFdLmRpbXNbaV07XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICAgIGlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLnN0cmlkZXMsIGF0dHJpYnV0ZXMuZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyxcbiAgICAgIGF0dHJpYnV0ZXMuYXV0b1BhZCk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHBhZHN9KTtcbiAgcmV0dXJuIG5ld0F0dHJpYnV0ZXM7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb252QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENvbnZBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgYWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gIC8vIFRPRE8gOiBNYWtlIHRoaXMgZ2VuZXJpYyBlbm91Z2ggdG8gY29tcHV0ZSBkZWZhdWx0IGF0dHJpYnV0ZXMgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgYXMgJ05IV0MnIHwgJ05DSFcnO1xuICBjb25zdCBhdXRvUGFkID0gWydOT1RTRVQnLCAnVkFMSUQnLCAnU0FNRV9VUFBFUicsICdTQU1FX0xPV0VSJ11bYXR0cmlidXRlcy5hdXRvX3BhZCBhcyBudW1iZXJdO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBudW1iZXJbXTtcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwIGFzIG51bWJlcjtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbF9zaGFwZSBhcyBudW1iZXJbXTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcyBhcyBudW1iZXJbXTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBudW1iZXJbXTtcbiAgY29uc3Qgd0lzQ29uc3QgPSAoYXR0cmlidXRlcy53X2lzX2NvbnN0IGFzICgpID0+IGJvb2xlYW4pKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBhdXRvUGFkLFxuICAgIGZvcm1hdCxcbiAgICBkaWxhdGlvbnMsXG4gICAgZ3JvdXAsXG4gICAga2VybmVsU2hhcGUsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIHdJc0NvbnN0LFxuICAgIC4uLmFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9ufTtgXG4gIH07XG59O1xuXG5jb25zdCBjb252MmQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG5cbiAgLy8gY2hlY2sgYXR0cmlidXRlc1xuXG4gIC8vIGNvbnN0IGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBmYWxzZTsgLyogVE9ETzogYWRkIHN1cHBvcnQgZm9yIHByZWx1IGFjdGl2YXRpb24gd2VpZ2h0cyAqL1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGlmIChhdHRyaWJ1dGVzLmdyb3VwICE9PSAxKSB7XG4gICAgLy8gTlZJRElBIEdQVSB3aXRoIGFtcGVyZSBhcmNoaXRlY3R1cmUgZmFpbHMgd2l0aCBiZWxvdyAyIGNhc2VzLCBidXQgd2UgY291bGRuJ3QgcmVwcm8gdGhlbSB3aXRoIGFueSBvdGhlclxuICAgIC8vIEdQVXMuIFNvIGp1c3QgZGlzYWJsZSB2ZWN0b3JpemUgb24gTlZJRElBIGFtcGVyZSB0byBlbnN1cmUgYWx3YXlzIGNvcnJlY3Qgb3V0cHV0cy5cbiAgICAvLyBbd2ViZ3B1XUNvbnYgLSBjb252IC0gdmVjdG9yaXplIGdyb3VwIC0gQlxuICAgIC8vIFt3ZWJncHVdQ29udiAtIGNvbnYgLSB2ZWN0b3JpemUgZ3JvdXAgLSBEXG4gICAgY29uc3QgZW5hYmxlR3JvdXBlZENvbnZWZWN0b3JpemUgPSAhY29udGV4dC5hZGFwdGVySW5mby5pc0FyY2hpdGVjdHVyZSgnYW1wZXJlJyk7XG4gICAgaWYgKGVuYWJsZUdyb3VwZWRDb252VmVjdG9yaXplICYmIGlzQ2hhbm5lbHNMYXN0ICYmIGlucHV0c1sxXS5kaW1zWzBdID09PSBhdHRyaWJ1dGVzLmdyb3VwICYmXG4gICAgICAgIGlucHV0c1sxXS5kaW1zWzFdID09PSAxICYmIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdID09PSAxICYmIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdID09PSAxKSB7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKFxuICAgICAgICAgIGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGFkanVzdGVkQXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMsXG4gICAgICAgICAgaXNDaGFubmVsc0xhc3QpO1xuICAgICAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9IChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cbiAgICAgICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgICAgIGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlKSxcbiAgICAgICAgICAgICAge2lucHV0czogWzFdLCBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdfSlbMF07XG4gICAgICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjb252SW5wdXRzID0gW2lucHV0c1swXSwgdHJhbnNwb3NlZFdlaWdodF07XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBjb252SW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvKGNvbnZJbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGUpLCB7aW5wdXRzOiBjb252SW5wdXRzfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvKGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID09PSAzO1xuICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdO1xuICBjb25zdCBpbnB1dFdpZHRoID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAyIDogM107XG4gIGNvbnN0IGlucHV0Q2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcbiAgY29uc3Qgd2VpZ2h0SGVpZ2h0ID0gaW5wdXRzWzFdLmRpbXNbMl07XG4gIGNvbnN0IHdlaWdodFdpZHRoID0gaW5wdXRzWzFdLmRpbXNbM107XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVPdXRwdXRTaGFwZShcbiAgICAgIGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGFkanVzdGVkQXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMsXG4gICAgICBpc0NoYW5uZWxzTGFzdCk7XG4gIGNvbnN0IG91dEhlaWdodCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdO1xuICBjb25zdCBvdXRXaWR0aCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdO1xuICBjb25zdCBvdXRDaGFubmVscyA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuXG4gIGNvbnN0IHNhbWVTaXplID0gaXNDaGFubmVsc0xhc3QgJiYgd2VpZ2h0SGVpZ2h0ID09PSBpbnB1dEhlaWdodCAmJiB3ZWlnaHRXaWR0aCA9PT0gaW5wdXRXaWR0aCAmJlxuICAgICAgYXR0cmlidXRlcy5wYWRzWzBdID09PSAwICYmIGF0dHJpYnV0ZXMucGFkc1sxXSA9PT0gMDtcbiAgaWYgKHNhbWVTaXplIHx8XG4gICAgICAod2VpZ2h0SGVpZ2h0ID09PSAxICYmIHdlaWdodFdpZHRoID09PSAxICYmIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdID09PSAxICYmIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdID09PSAxICYmXG4gICAgICAgYXR0cmlidXRlcy5zdHJpZGVzWzBdID09PSAxICYmIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXSA9PT0gMSAmJiBhdHRyaWJ1dGVzLnBhZHNbMF0gPT09IDAgJiZcbiAgICAgICBhdHRyaWJ1dGVzLnBhZHNbMV0gPT09IDApKSB7XG4gICAgLy8gY29udjJkQnlNYXRNdWxcbiAgICBjb25zdCBiYXRjaCA9IG91dHB1dFNoYXBlWzBdO1xuICAgIGxldCB4UmVzaGFwZWQsIHdSZXNoYXBlZCwgbWF0bXVsT3V0cHV0U2hhcGU7XG4gICAgY29uc3QgbWF0bXVsSW5wdXRzID0gW107XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID0gKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgICAgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLFxuICAgICAgICAgICAgICB7aW5wdXRzOiBbMV0sIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV19KVswXTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzLndJc0NvbnN0ICYmICFjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QpIHtcbiAgICAgICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChzYW1lU2l6ZSkge1xuICAgICAgICBjb25zdCBzaGFyZWREaW0gPSBpbnB1dEhlaWdodCAqIGlucHV0V2lkdGggKiBpbnB1dENoYW5uZWxzO1xuICAgICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbMSwgYmF0Y2gsIHNoYXJlZERpbV0pO1xuICAgICAgICB3UmVzaGFwZWQgPSB0cmFuc3Bvc2VkV2VpZ2h0LnJlc2hhcGUoWzEsIHNoYXJlZERpbSwgb3V0Q2hhbm5lbHNdKTtcbiAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUgPSBbMSwgYmF0Y2gsIG91dENoYW5uZWxzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFtiYXRjaCwgaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoLCBpbnB1dENoYW5uZWxzXSk7XG4gICAgICAgIHdSZXNoYXBlZCA9IHRyYW5zcG9zZWRXZWlnaHQucmVzaGFwZShbMSwgaW5wdXRDaGFubmVscywgb3V0Q2hhbm5lbHNdKTtcbiAgICAgICAgbWF0bXVsT3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG91dEhlaWdodCAqIG91dFdpZHRoLCBvdXRDaGFubmVsc107XG4gICAgICB9XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh4UmVzaGFwZWQpO1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2god1Jlc2hhcGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoW2JhdGNoLCBpbnB1dENoYW5uZWxzLCBpbnB1dEhlaWdodCAqIGlucHV0V2lkdGhdKTtcbiAgICAgIHdSZXNoYXBlZCA9IGlucHV0c1sxXS5yZXNoYXBlKFsxLCBvdXRDaGFubmVscywgaW5wdXRDaGFubmVsc10pO1xuICAgICAgbWF0bXVsT3V0cHV0U2hhcGUgPSBbYmF0Y2gsIG91dENoYW5uZWxzLCBvdXRIZWlnaHQgKiBvdXRXaWR0aF07XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh3UmVzaGFwZWQpO1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goeFJlc2hhcGVkKTtcbiAgICB9XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKGlucHV0c1syXSk7XG4gICAgfVxuICAgIGNvbnN0IE4gPSBtYXRtdWxPdXRwdXRTaGFwZVsyXTtcbiAgICBjb25zdCBLID0gbWF0bXVsSW5wdXRzWzBdLmRpbXNbbWF0bXVsSW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV07XG4gICAgLy8gVHVuZSB0aGUgdGhyZXNob2xkLlxuICAgIGlmIChOIDwgOCAmJiBLIDwgOCkge1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8oXG4gICAgICAgICAgICAgIG1hdG11bElucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSwgbWF0bXVsT3V0cHV0U2hhcGUsIGlzQ2hhbm5lbHNMYXN0KSxcbiAgICAgICAgICB7aW5wdXRzOiBtYXRtdWxJbnB1dHN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKG1hdG11bElucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSwgbWF0bXVsT3V0cHV0U2hhcGUsIGlzQ2hhbm5lbHNMYXN0KSxcbiAgICAgICAgICB7aW5wdXRzOiBtYXRtdWxJbnB1dHN9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogaW1wbGVtZW50IGNvbnYyZFdpdGhJbTJDb2woKVxuXG4gIGNvbnN0IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgPSAvKiBiYWNrZW5kLmFkYXB0ZXJJbmZvLmlzSW50ZWwoKSAqLyB0cnVlO1xuXG4gIC8vIFNURVAuMTogdHJhbnNwb3NlIHdlaWdodFxuICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID0gKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlKSxcbiAgICAgICAgICB7aW5wdXRzOiBbMV0sIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV19KVswXTtcbiAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xuICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gIH1cblxuICAvLyBTVEVQLjI6IHByZXBhcmUgcmVzaGFwZWQgaW5wdXRzXG4gIGNvbnN0IGNvbnZJbnB1dHMgPSBbaW5wdXRzWzBdLCB0cmFuc3Bvc2VkV2VpZ2h0XTtcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBjb252SW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgfVxuXG4gIC8vIFNURVAuMzogY29tcHV0ZSBtYXRtdWxcbiAgY29uc3QgZGltQU91dGVyID0gaXNDaGFubmVsc0xhc3QgPyBvdXRIZWlnaHQgKiBvdXRXaWR0aCA6IG91dENoYW5uZWxzO1xuICBjb25zdCBkaW1CT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dENoYW5uZWxzIDogb3V0SGVpZ2h0ICogb3V0V2lkdGg7XG4gIGNvbnN0IGRpbUlubmVyID0gd2VpZ2h0SGVpZ2h0ICogd2VpZ2h0V2lkdGggKiBpbnB1dENoYW5uZWxzO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyhcbiAgICAgICAgICBjb252SW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciwgZGltSW5uZXIsIGhhc0JpYXMsXG4gICAgICAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyksXG4gICAgICB7aW5wdXRzOiBjb252SW5wdXRzfSk7XG59O1xuXG5jb25zdCBjb252MWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIGV4dGVuZCB0aGUgaW5wdXQgdG8gMkQgYnkgYWRkaW5nIEggZGltZW5zaW9uXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBpbnB1dHMgPSBbXG4gICAgY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShcbiAgICAgICAgaXNDaGFubmVsTGFzdCA/XG4gICAgICAgICAgICAvLyBbTiwgVywgQ10gLT4gW04sIEg9MSwgVywgQ11cbiAgICAgICAgICAgIFtjb250ZXh0LmlucHV0c1swXS5kaW1zWzBdLCAxLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzFdLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzJdXSA6XG4gICAgICAgICAgICAvLyBbTiwgQywgV10gLT4gW04sIEMsIEg9MSwgV11cbiAgICAgICAgICAgIFtjb250ZXh0LmlucHV0c1swXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzJdXSksXG4gICAgLy9bRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga1ddIC0+IFtGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrSD0xLCBrV11cbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSlcbiAgXTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlucHV0cy5wdXNoKGNvbnRleHQuaW5wdXRzWzJdKTtcbiAgfVxuICBjb25zdCBwYWRzID0gWzAsIGF0dHJpYnV0ZXMucGFkc1swXSwgMCwgYXR0cmlidXRlcy5wYWRzWzFdXTtcbiAgY29uc3Qgc3RyaWRlcyA9IFsxXS5jb25jYXQoYXR0cmlidXRlcy5zdHJpZGVzKTtcbiAgY29uc3QgZGlsYXRpb25zID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLmRpbGF0aW9ucyk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyh7Li4uYXR0cmlidXRlcywgcGFkcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZX0sIGlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHcm91cGVkQ29udlByb2dyYW1JbmZvKFxuICAgICAgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICAgICBvdXRwdXRTaGFwZSA9PiBpc0NoYW5uZWxMYXN0ID8gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM11dIDogW10pKTtcbn07XG5cbmNvbnN0IGNvbnYzZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyAnY2hhbm5lbHNMYXN0JyA6ICdjaGFubmVsc0ZpcnN0JztcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBpbnB1dHMpO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5hdXRvUGFkID09PSAnTk9UU0VUJyA/IGF0dHJpYnV0ZXMucGFkcyA6IGF0dHJpYnV0ZXMuYXV0b1BhZDtcbiAgY29uc3QgY29udkluZm8gPSBjb21wdXRlQ29udjNESW5mbyhcbiAgICAgIGlucHV0c1swXS5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICBpbnB1dHNbMV0uZGltcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgYXR0cmlidXRlcy5zdHJpZGVzIGFzIG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgcGFkcyBhcyBzdHJpbmcgfCBudW1iZXJbXSwgZmFsc2UsIGZvcm1hdCk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDb252M0ROYWl2ZVByb2dyYW1JbmZvKFxuICAgICAgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIGNvbnZJbmZvLm91dFNoYXBlLFxuICAgICAgW2NvbnZJbmZvLmZpbHRlckRlcHRoLCBjb252SW5mby5maWx0ZXJIZWlnaHQsIGNvbnZJbmZvLmZpbHRlcldpZHRoXSxcbiAgICAgIFtjb252SW5mby5wYWRJbmZvLmZyb250LCBjb252SW5mby5wYWRJbmZvLnRvcCwgY29udkluZm8ucGFkSW5mby5sZWZ0XSwgZm9ybWF0KSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29udiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICBjb252MWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICBjb252M2QoY29udGV4dCwgY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnYyZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL2NvbnZfYmFja3Byb3BfbW1fd2ViZ3B1LnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge0xPR19ERUJVR30gZnJvbSAnLi4vLi4vLi4vbG9nJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHtDb252VHJhbnNwb3NlQXR0cmlidXRlc30gZnJvbSAnLi4vY29udi10cmFuc3Bvc2UnO1xuaW1wb3J0IHthcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0fSBmcm9tICcuLi9mdXNlLXV0aWxzJztcblxuaW1wb3J0IHtiaWFzU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHt1dGlsRnVuY3Rpb25zfSBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQge21ha2VNYXRNdWxQYWNrZWRTb3VyY2UsIG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlfSBmcm9tICcuL21hdG11bF9wYWNrZWRfd2ViZ3B1JztcblxuY29uc3QgY29udjJkVHJhbnNwb3NlQ29tbW9uU25pcHBldCA9XG4gICAgKGlzQ2hhbm5lbHNMYXN0OiBib29sZWFuLCBhZGRCaWFzID0gZmFsc2UsIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLCB0eXBlOiBzdHJpbmcsXG4gICAgIGlubmVyRWxlbWVudFNpemUgPSA0KTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGdldFdTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgICAgICBzd2l0Y2ggKGlubmVyRWxlbWVudFNpemUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gJ3JldHVybiB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTsnO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgY29vcmQxID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAxLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgY29vcmQyID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAyLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgY29vcmQzID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAzLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgdjAgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcbiAgICAgICAgICAgIGxldCB2MSA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQxLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcbiAgICAgICAgICAgIGxldCB2MiA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQyLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcbiAgICAgICAgICAgIGxldCB2MyA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQzLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTtcbiAgICAgICAgICAgIHJldHVybiAke3R5cGV9KHYwLCB2MSwgdjIsIHYzKTtcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBjb29yZEFTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3QgPyBgXG4gICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIGlYUiwgaVhDLCB4Q2gpO1xuICAgICAgYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgaVhSLCBpWEMpO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgY29vcmRSZXNTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3QgPyBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgO1xuXG4gICAgICBjb25zdCB4SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsyXSknO1xuICAgICAgY29uc3QgeFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknO1xuICAgICAgY29uc3Qgcm93ID0gaXNDaGFubmVsc0xhc3QgPyAncm93JyA6ICdjb2wnO1xuICAgICAgY29uc3QgY29sID0gaXNDaGFubmVsc0xhc3QgPyAnY29sJyA6ICdyb3cnO1xuXG4gICAgICBjb25zdCByZWFkQVNuaXBwZXQgPSBgXG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsxXSknfTtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgICBsZXQgb3V0Um93ID0gJHtyb3d9IC8gb3V0V2lkdGg7XG4gICAgICBsZXQgb3V0Q29sID0gJHtyb3d9ICUgb3V0V2lkdGg7XG5cbiAgICAgIGxldCBXUm93ID0gJHtjb2x9IC8gKHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgICBsZXQgV0NvbCA9ICR7Y29sfSAvIGluQ2hhbm5lbHMgJSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTtcbiAgICAgIGxldCB4UiA9IGYzMihvdXRSb3cgLSB1bmlmb3Jtcy5wYWRzWzBdICsgdW5pZm9ybXMuZGlsYXRpb25zWzBdICogV1JvdykgLyBmMzIodW5pZm9ybXMuc3RyaWRlc1swXSk7XG4gICAgICBsZXQgeEMgPSBmMzIob3V0Q29sIC0gdW5pZm9ybXMucGFkc1sxXSArIHVuaWZvcm1zLmRpbGF0aW9uc1sxXSAqIFdDb2wpIC8gZjMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pO1xuICAgICAgaWYgKHhSIDwgMC4wIHx8IHhSID49IGYzMigke3hIZWlnaHR9KSB8fCBmcmFjdCh4UikgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGlmICh4QyA8IDAuMCB8fCB4QyA+PSBmMzIoJHt4V2lkdGh9KSB8fCBmcmFjdCh4QykgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGxldCBpWFIgPSBpMzIoeFIpO1xuICAgICAgbGV0IGlYQyA9IGkzMih4Qyk7XG4gICAgICBsZXQgeENoID0gJHtjb2x9ICUgaW5DaGFubmVscztcbiAgICAgICR7Y29vcmRBU25pcHBldH1cbiAgICAgIHJldHVybiB4W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpLyR7aW5uZXJFbGVtZW50U2l6ZX1dO2A7XG5cbiAgICAgIGNvbnN0IHNhbXBsZUEgPSBpc0NoYW5uZWxzTGFzdCA/IGBcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAgICR7cmVhZEFTbmlwcGV0fVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAgICR7cmVhZEFTbmlwcGV0fVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtgO1xuXG4gICAgICBjb25zdCBzYW1wbGVXID0gYFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICAgIGxldCBpbkNoYW5uZWxzID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknIDogJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKSd9O1xuICAgICAgbGV0IGNvb3JkWCA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzBdIC0gMSAtIHJvdyAvICh1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXSAqIGluQ2hhbm5lbHMpO1xuICAgICAgbGV0IGNvb3JkWSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdIC0gMSAtIChyb3cgLyBpbkNoYW5uZWxzKSAlIHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdO1xuICAgICAgaWYgKCR7XG4gICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyAncm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAncm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9hX291dGVyJ30gICYmIGNvb3JkWCA+PSAwICYmIGNvb3JkWSA+PSAwKSB7XG4gICAgICAgIGxldCByb3dJbm5lciA9IHJvdyAlIGluQ2hhbm5lbHM7XG4gICAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sLCByb3dJbm5lcik7XG4gICAgICAgICR7Z2V0V1NuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSl9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHt0eXBlfSgwLjApO1xuICAgICAgYDtcblxuICAgICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgdHlwZSk7XG4gICAgICBjb25zdCB1c2VyQ29kZSA9IGBcbiAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHt0eXBlfSB7XG4gICAgJHtpc0NoYW5uZWxzTGFzdCA/IHNhbXBsZUEgOiBzYW1wbGVXfVxuICB9XG5cbiAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHt0eXBlfSB7XG4gICAgJHtpc0NoYW5uZWxzTGFzdCA/IHNhbXBsZVcgOiBzYW1wbGVBfVxuICB9XG5cbiAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbnB1dCA6ICR7dHlwZX0pIHtcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbnB1dDtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgICAke2Nvb3JkUmVzU25pcHBldH1cbiAgICAgICR7Ymlhc1NuaXBwZXQoYWRkQmlhcyl9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgIHJlc3VsdFtnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMsIHZlYzQ8aTMyPih1bmlmb3Jtcy5yZXN1bHRfc2hhcGUpKS8ke2lubmVyRWxlbWVudFNpemV9XSA9IHZhbHVlO1xuICAgIH1cbiAgfWA7XG4gICAgICByZXR1cm4gdXNlckNvZGU7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbnYyRFRyYW5zcG9zZU1hdE11bFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIGRpbUFPdXRlcjogbnVtYmVyLCBkaW1CT3V0ZXI6IG51bWJlciwgZGltSW5uZXI6IG51bWJlciwgaGFzQmlhczogYm9vbGVhbixcbiAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkczogYm9vbGVhbik6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IGlucHV0c1swXS5kaW1zWzNdIDogaW5wdXRzWzBdLmRpbXNbMV07XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSBvdXRwdXRTaGFwZVswXTtcbiAgICAgIGNvbnN0IG91dFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsyXSA6IG91dHB1dFNoYXBlWzNdO1xuICAgICAgY29uc3Qgb3V0SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsxXSA6IG91dHB1dFNoYXBlWzJdO1xuICAgICAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzNdIDogb3V0cHV0U2hhcGVbMV07XG4gICAgICAvLyBUT0RPOiBlbmFibGUgdmVjNCBmb3IgTkNIV1xuICAgICAgY29uc3QgaXNWZWM0ID0gaXNDaGFubmVsc0xhc3QgJiYgKGluQ2hhbm5lbHMgJSA0ID09PSAwICYmIGluQ2hhbm5lbHMgJSAzKSAmJiBvdXRDaGFubmVscyAlIDQgPT09IDA7XG5cbiAgICAgIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXG4gICAgICBjb25zdCBkaXNwYXRjaFggPSBpc0NoYW5uZWxzTGFzdCA/IG91dENoYW5uZWxzIDogb3V0V2lkdGggKiBvdXRIZWlnaHQ7XG4gICAgICBjb25zdCBkaXNwYXRjaFkgPSBpc0NoYW5uZWxzTGFzdCA/IG91dFdpZHRoICogb3V0SGVpZ2h0IDogb3V0Q2hhbm5lbHM7XG4gICAgICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gICAgICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IGRpbUFPdXRlciA8PSA4ID8gWzQsIDEsIDFdIDogWzQsIDQsIDFdO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSBbXG4gICAgICAgIE1hdGguY2VpbChkaXNwYXRjaFggLyB3b3JrR3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgICAgICBNYXRoLmNlaWwoZGlzcGF0Y2hZIC8gd29ya0dyb3VwU2l6ZVsxXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzFdKSxcbiAgICAgICAgTWF0aC5jZWlsKGJhdGNoU2l6ZSAvIHdvcmtHcm91cFNpemVbMl0gLyBlbGVtZW50c1BlclRocmVhZFsyXSlcbiAgICAgIF07XG5cbiAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udl9iYWNrcHJvcF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcblxuICAgICAgY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9IGlzVmVjNCA/IDQgOiAxO1xuICAgICAgY29uc3QgdGlsZUlubmVyID0gTWF0aC5tYXgod29ya0dyb3VwU2l6ZVswXSAqIGlubmVyRWxlbWVudFNpemUsIHdvcmtHcm91cFNpemVbMV0pO1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICAgICAgY29uc3QgZmlsdGVyRGltcyA9XG4gICAgICAgICAgW2F0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0sIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM11dO1xuICAgICAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGltcyA9IFtcbiAgICAgICAgZmlsdGVyRGltc1swXSArIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSA8PSAxID8gMCA6IChmaWx0ZXJEaW1zWzBdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gLSAxKSksXG4gICAgICAgIGZpbHRlckRpbXNbMV0gKyAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPD0gMSA/IDAgOiAoZmlsdGVyRGltc1sxXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIC0gMSkpXG4gICAgICBdO1xuICAgICAgY29uc3QgcGFkcyA9IFtcbiAgICAgICAgZWZmZWN0aXZlRmlsdGVyRGltc1swXSAtIDEgLSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLnBhZHNbMF0gKyBhdHRyaWJ1dGVzLnBhZHNbMl0pIC8gMiksXG4gICAgICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzFdICsgYXR0cmlidXRlcy5wYWRzWzNdKSAvIDIpXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQU91dGVyfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1CT3V0ZXJ9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUlubmVyfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnN0cmlkZXN9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBmaWx0ZXJEaW1zfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBwYWRzfVxuICAgICAgXTtcbiAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcykpO1xuXG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgICAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCd3JywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIDEpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcblxuICAgICAgICBsZXQgZGVjbGFyZUZ1bmN0aW9ucyA9ICcnO1xuICAgICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XG4gICAgICAgICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHtiaWFzLnR5cGUudmFsdWV9IHtcbiAgICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgICAgICAgIH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICAgIHtuYW1lOiAnZGltX2Ffb3V0ZXInLCB0eXBlOiAnaTMyJ30sIHtuYW1lOiAnZGltX2Jfb3V0ZXInLCB0eXBlOiAnaTMyJ30sIHtuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMid9LFxuICAgICAgICAgIHtuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDJ9LCB7bmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDJ9LFxuICAgICAgICAgIHtuYW1lOiAnZmlsdGVyX2RpbXMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aH0sXG4gICAgICAgICAge25hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogcGFkcy5sZW5ndGh9XG4gICAgICAgIF07XG4gICAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG4gICAgICAgIGNvbnN0IGVsZW1UeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSwgMSk7XG4gICAgICAgIGlmIChlbGVtVHlwZSAhPT0gJ2YxNicgJiYgZWxlbVR5cGUgIT09ICdmMzInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbGVtVHlwZSAke2VsZW1UeXBlfSBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICR7dXRpbEZ1bmN0aW9ucygndW5pZm9ybXMucmVzdWx0X3N0cmlkZXMnKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX07XG4gICAgICAgICR7ZGVjbGFyZUZ1bmN0aW9uc31cbiAgICAgICAgJHtjb252MmRUcmFuc3Bvc2VDb21tb25TbmlwcGV0KGlzQ2hhbm5lbHNMYXN0LCBoYXNCaWFzLCBhdHRyaWJ1dGVzLCB4LnR5cGUudmFsdWUsIGlubmVyRWxlbWVudFNpemUpfVxuICAgICAgICAke1xuICAgICAgICAgICAgaXNWZWM0ID8gbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtHcm91cFNpemUsIGVsZW1UeXBlLCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyKSA6XG4gICAgICAgICAgICAgICAgICAgICBtYWtlTWF0TXVsUGFja2VkU291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCBlbGVtVHlwZSwgdW5kZWZpbmVkLCAhaXNDaGFubmVsc0xhc3QsIHRpbGVJbm5lciwgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzKX1gO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0NvbnYyRFRyYW5zcG9zZU1hdE11bCcsXG4gICAgICAgIHNoYWRlckNhY2hlOlxuICAgICAgICAgICAge2hpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7ZWxlbWVudHNQZXJUaHJlYWR9OyR7d29ya0dyb3VwU2l6ZX07JHtpc1ZlYzR9YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udl9iYWNrcHJvcF93ZWJncHUudHNcblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtMT0dfREVCVUd9IGZyb20gJy4uLy4uLy4uL2xvZyc7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7Q29udlRyYW5zcG9zZUF0dHJpYnV0ZXN9IGZyb20gJy4uL2NvbnYtdHJhbnNwb3NlJztcblxuY29uc3QgY3JlYXRlQ29udlRyYW5zcG9zZTJET3BQcm9ncmFtU2hhZGVyU291cmNlID1cbiAgICAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGhhc0JpYXM6IGJvb2xlYW4sXG4gICAgIGlzMURpbWVuc2lvbkRpc3BhdGNoOiBib29sZWFuLCBpc1ZlYzQgPSBmYWxzZSwgZGF0YVR5cGU6IHN0cmluZywgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlLFxuICAgICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IHJvd0RpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMSA6IDI7XG4gICAgICBjb25zdCBjb2xEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDIgOiAzO1xuICAgICAgY29uc3QgY2hhbm5lbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDE7XG4gICAgICBjb25zdCB3b3JrUGVyVGhyZWFkID0gaXNWZWM0ID8gMiA6IDE7XG5cbiAgICAgIGxldCBkZWNsYXJlRnVuY3Rpb25zID0gYFxuICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IHUzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7ZGF0YVR5cGV9PmAgOiBkYXRhVHlwZX0pIHtcbiAgICByZXN1bHRbZmxhdEluZGV4XSA9ICR7aXNWZWM0ID8gYHZlYzQ8JHtkYXRhVHlwZX0+YCA6IGRhdGFUeXBlfSh2YWx1ZSk7XG4gIH1gO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8dTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke2RhdGFUeXBlfT5gIDogZGF0YVR5cGV9IHtcbiAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgIH1gO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICAgICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ1cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICBjb25zdCBkeSA9IGlucHV0VmFyaWFibGUoJ0R5JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbZHksIHddO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBbb3V0cHV0U2hhcGVbY2hhbm5lbERpbV1dLmxlbmd0aCwgY29tcG9uZW50cykpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcblxuICAgICAgY29uc3QgY29kZVNuaXBwZXQ0ID0gYHtcbiAgICAgICAgbGV0IGJhdGNoOiB1MzIgPSAke2lzMURpbWVuc2lvbkRpc3BhdGNoID8gJ2dsb2JhbF9pZC56JyA6ICd3b3JrZ3JvdXBfaWQueid9IC8gdW5pZm9ybXMucmVzdWx0X3NoYXBlWzFdO1xuICAgICAgICBsZXQgciA9ICR7aXMxRGltZW5zaW9uRGlzcGF0Y2ggPyAnZ2xvYmFsX2lkLnonIDogJ3dvcmtncm91cF9pZC56J30gJSB1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMV07XG4gICAgICAgIGxldCBjID0gJHtpczFEaW1lbnNpb25EaXNwYXRjaCA/ICdnbG9iYWxfaWQueScgOiAnd29ya2dyb3VwX2lkLnknfSAqICR7d29ya1BlclRocmVhZH07XG4gICAgICAgIGxldCBkMTogdTMyID0gJHtpczFEaW1lbnNpb25EaXNwYXRjaCA/ICdnbG9iYWxfaWQueCcgOiAnd29ya2dyb3VwX2lkLngnfSAqIDQ7XG5cbiAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHZlYzI8aTMyPih1bmlmb3Jtcy5wYWRzKTtcblxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgIHZhciBkb3RQcm9kOiBhcnJheTx2ZWM0PCR7ZGF0YVR5cGV9PiwgJHt3b3JrUGVyVGhyZWFkfT47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt3b3JrUGVyVGhyZWFkfTsgaSsrKSB7XG4gICAgICAgICAgZG90UHJvZFtpXSA9IHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgdmFyIGR5UiA9ICgke2RhdGFUeXBlfShkeUNvcm5lci54KSArICR7ZGF0YVR5cGV9KHdSKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzLngpO1xuICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXSAtIDEgLSB3UjtcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVsxXSkgfHxcbiAgICAgICAgICAgICAgZnJhY3QoZHlSKSA+IDAuMCB8fCB3UlBlcm0gPCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuXG4gICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV07IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICBsZXQgZHlDID0gKCR7ZGF0YVR5cGV9KGR5Q29ybmVyLnkpICsgJHtkYXRhVHlwZX0od0MpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICBsZXQgZHlDMiA9ICgke2RhdGFUeXBlfShkeUNvcm5lci55KSArIDEuMCArICR7ZGF0YVR5cGV9KHdDKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xuICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdIC0gMSAtIHdDO1xuICAgICAgICAgICAgaWYgKHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgYkR5Q1ZhbDIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBiRHlDVmFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHlDMiA8IDAuMCB8fCBkeUMyID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWzJdKSB8fFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QzIpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGJEeUNWYWwyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgIGxldCBpZHlDMjogdTMyID0gdTMyKGR5QzIpO1xuICAgICAgICAgICAgaWYgKGJEeUNWYWwgJiYgYkR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gdW5pZm9ybXMuRHlfc2hhcGVbM107XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyIDp1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDEnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDInLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDMnLCAnZDInKX07XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtkeS5nZXQoJ2JhdGNoJywgJ2lkeVInLCAnaWR5QycsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2RhdGFUeXBlfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMF0gPSBkb3RQcm9kWzBdICsgdG1wdmFsO1xuXG4gICAgICAgICAgICAgICAgeFZhbHVlID0gICR7ZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMyJywgJ2QyJyl9O1xuXG4gICAgICAgICAgICAgICAgZG90UHJvZFsxXSA9IGRvdFByb2RbMV0gKyB2ZWM0PCR7ZGF0YVR5cGV9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbCkge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVske2NoYW5uZWxEaW19XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMycsICdkMicpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke2R5LmdldCgnYmF0Y2gnLCAnaWR5UicsICdpZHlDJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7ZGF0YVR5cGV9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYkR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgbGV0IGQyTGVuZ3RoID0gdW5pZm9ybXMuRHlfc2hhcGVbM107XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IGQyTGVuZ3RoOyBkMiA9IGQyICsgNCkge1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUwID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTEgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDEnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTIgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDInLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTMgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMSArIDMnLCAnZDInKX07XG5cbiAgICAgICAgICAgICAgICB2YXIgeFZhbHVlID0gJHtkeS5nZXQoJ2JhdGNoJywgJ2lkeVInLCAnaWR5QzInLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtkYXRhVHlwZX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHRtcHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke3dvcmtQZXJUaHJlYWR9OyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kW2ldICsgJHtoYXNCaWFzID8gJ2JpYXNbYytpXScgOiBgdmVjNDwke2RhdGFUeXBlfT4oMC4wKWB9O1xuICAgICAgICAgICR7b3V0cHV0LnNldCgnYmF0Y2gnLCAncicsICdjICsgaScsICdkMScsICd2YWx1ZScpfTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gICAgICBjb25zdCBjb2RlU25pcHBldCA9IGBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgMCl9O1xuICAgICAgICAgIGxldCBkMSA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBjaGFubmVsRGltKX07XG4gICAgICAgICAgbGV0IHIgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgcm93RGltKX07XG4gICAgICAgICAgbGV0IGMgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgY29sRGltKX07XG4gICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgICAgbGV0IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG4gICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cbiAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICB2YXIgZG90UHJvZCA9ICR7ZGF0YVR5cGV9KDAuMCk7XG4gICAgICAgICAgZm9yICh2YXIgd1I6IHUzMiA9IDA7IHdSIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLng7IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgICBpZiAod1IgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueCAhPSAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGR5UiA9ICgke2RhdGFUeXBlfShkeVJDb3JuZXIpICsgJHtkYXRhVHlwZX0od1IpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXNbMF0pO1xuICAgICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnggLSAxIC0gd1IgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueDtcbiAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWyR7cm93RGltfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcbiAgICAgICAgICAgICAgICB3UlBlcm0gPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgICAgaWYgKHdDICUgdW5pZm9ybXMuZGlsYXRpb25zLnkgIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtkYXRhVHlwZX0oZHlDQ29ybmVyKSArICR7ZGF0YVR5cGV9KHdDKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xuICAgICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueSAtIDEgLSB3QyAvIHVuaWZvcm1zLmRpbGF0aW9ucy55O1xuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVske2NvbERpbX1dKSB8fFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gZ3JvdXBJZCAqIHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwOyBkMiA9IGQyICsgMSkge1xuICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke1xuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMnLCAnaW5wdXRDaGFubmVsJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkuZ2V0KCdiYXRjaCcsICdpbnB1dENoYW5uZWwnLCAnaWR5UicsICdpZHlDJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUgPSAke3cuZ2V0KCdpbnB1dENoYW5uZWwnLCAnd091dENoYW5uZWwnLCAndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknKX07XG4gICAgICAgICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsID0gaW5wdXRDaGFubmVsICsgMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kICsgJHtoYXNCaWFzID8gJ2JpYXNbZDFdJyA6IGAke2RhdGFUeXBlfSgwLjApYH07XG4gICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XG4gICAgICAgIGA7XG5cbiAgICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICR7ZGVjbGFyZUZ1bmN0aW9uc31cblxuICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9O1xuICAke2lzVmVjNCA/IGNvZGVTbmlwcGV0NCA6IGNvZGVTbmlwcGV0fX1gO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbiAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICAgIC8vIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgICAgIC8vIGNvbnN0IGluQ2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcbiAgICAgIC8vIFRPRE8gRW5hYmxlIGlzVmVjNCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIC8vIERpc2FibGVkIGR1ZSB0byB3ZWlnaHQgbWF0cml4IGxheW91dCBpc3N1ZVxuICAgICAgLy8gY29uc3QgaXNWZWM0ID0gYXR0cmlidXRlcy5ncm91cCA9PT0gMSAmJiBpc0NoYW5uZWxzTGFzdCAmJiBpbkNoYW5uZWxzICUgNCA9PT0gMCAmJiBvdXRDaGFubmVscyAlIDQgPT09IDA7XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IFtcbiAgICAgICAgTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCksXG4gICAgICAgIDEsXG4gICAgICAgIDEsXG4gICAgICBdO1xuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XG5cbiAgICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSBbYXR0cmlidXRlcy5zdHJpZGVzWzBdLCBhdHRyaWJ1dGVzLnN0cmlkZXNbMV1dO1xuICAgICAgY29uc3QgZmlsdGVyRGltcyA9XG4gICAgICAgICAgW2F0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0sIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM11dO1xuICAgICAgY29uc3QgZGlsYXRpb25zID0gW2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdLCBhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXV07XG4gICAgICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zID0gW1xuICAgICAgICBmaWx0ZXJEaW1zWzBdICtcbiAgICAgICAgICAgIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSA8PSAxID9cbiAgICAgICAgICAgICAgICAgMCA6XG4gICAgICAgICAgICAgICAgIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gLSAxKSksXG4gICAgICAgIGZpbHRlckRpbXNbMV0gK1xuICAgICAgICAgICAgKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIDw9IDEgP1xuICAgICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgICAgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM10gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXSAtIDEpKVxuICAgICAgXTtcbiAgICAgIGNvbnN0IHBhZHMgPSBbXG4gICAgICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzBdICsgYXR0cmlidXRlcy5wYWRzWzJdKSAvIDIpLFxuICAgICAgICBlZmZlY3RpdmVGaWx0ZXJEaW1zWzFdIC0gMSAtIE1hdGguZmxvb3IoYXR0cmlidXRlcy5wYWRzWzFdICsgYXR0cmlidXRlcy5wYWRzWzNdKSAvIDJcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGlzVmVjNCA9IGZhbHNlO1xuICAgICAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwO1xuICAgICAgY29uc3Qgd1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBpbnB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMF0gLyBncm91cDtcbiAgICAgIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMV07XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0cmlkZXN9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBmaWx0ZXJEaW1zfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZGlsYXRpb25zfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWZmZWN0aXZlRmlsdGVyRGltc30sIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogcGFkc30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0Q2hhbm5lbHNQZXJHcm91cH0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dENoYW5uZWxzUGVyR3JvdXB9LFxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpXG4gICAgICBdO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICAgICAgfVxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICAgICAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSBkaXNwYXRjaFsxXSA9PT0gMSAmJiBkaXNwYXRjaFsyXSA9PT0gMTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc3RyaWRlcy5sZW5ndGh9LFxuICAgICAgICAgIHtuYW1lOiAnZmlsdGVyX2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aH0sXG4gICAgICAgICAge25hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aH0sXG4gICAgICAgICAge25hbWU6ICdlZmZlY3RpdmVfZmlsdGVyX2RpbXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBlZmZlY3RpdmVGaWx0ZXJEaW1zLmxlbmd0aH0sXG4gICAgICAgICAge25hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogcGFkcy5sZW5ndGh9LCB7bmFtZTogJ2lucHV0X2NoYW5uZWxzX3Blcl9ncm91cCcsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICB7bmFtZTogJ291dHB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICAgICAgcmV0dXJuIGAke1xuICAgICAgICAgICAgY3JlYXRlQ29udlRyYW5zcG9zZTJET3BQcm9ncmFtU2hhZGVyU291cmNlKFxuICAgICAgICAgICAgICAgIHNoYWRlckhlbHBlciwgaW5wdXRzLCBvdXRwdXRTaGFwZSwgaGFzQmlhcywgaXMxRGltZW5zaW9uRGlzcGF0Y2gsIGlzVmVjNCwgZGF0YVR5cGUsIHVuaWZvcm1zLFxuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0KX1gO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdDb252VHJhbnNwb3NlMkQnLFxuICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9O2AsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXX0sXG4gICAgICAgICAgb3V0cHV0czogW3tcbiAgICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0fSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlQ29udjJEVHJhbnNwb3NlTWF0TXVsUHJvZ3JhbUluZm99IGZyb20gJy4vM3JkLXBhcnR5L2NvbnZfYmFja3Byb3BfbW1fd2ViZ3B1JztcbmltcG9ydCB7Y3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm99IGZyb20gJy4vM3JkLXBhcnR5L2NvbnZfYmFja3Byb3Bfd2ViZ3B1JztcbmltcG9ydCB7Q29udkF0dHJpYnV0ZXN9IGZyb20gJy4vY29udic7XG5pbXBvcnQge3BhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlc30gZnJvbSAnLi9mdXNlLXV0aWxzJztcbmltcG9ydCB7Y3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm99IGZyb20gJy4vdHJhbnNwb3NlJztcblxuY29uc3QgY29tcHV0ZVRvdGFsUGFkID1cbiAgICAoaW5EaW06IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIGFkajogbnVtYmVyLCBrZXJuZWw6IG51bWJlciwgZGlsYXRpb246IG51bWJlciwgb3V0U2l6ZTogbnVtYmVyKSA9PlxuICAgICAgICAoaW5EaW0gLSAxKSAqIHN0cmlkZSArIGFkaiArIChrZXJuZWwgLSAxKSAqIGRpbGF0aW9uICsgMSAtIG91dFNpemU7XG5cbmNvbnN0IGRpc3RyaWJ1dGVQYWRkaW5nID0gKHRvdGFsUGFkOiBudW1iZXIsIGF1dG9QYWQ6IHN0cmluZywgcGFkczogbnVtYmVyW10sIGhlYWQ6IG51bWJlciwgdGFpbDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IHNtYWxsUGFkID0gTWF0aC5mbG9vcih0b3RhbFBhZCAvIDIpO1xuICBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHNtYWxsUGFkO1xuICAgIHBhZHNbdGFpbF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xuICB9IGVsc2UgaWYgKGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJykge1xuICAgIHBhZHNbaGVhZF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xuICAgIHBhZHNbdGFpbF0gPSBzbWFsbFBhZDtcbiAgfVxufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGVBbmRQYWRzID1cbiAgICAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSwgYXV0b1BhZDogc3RyaW5nLFxuICAgICBncm91cDogbnVtYmVyLCBwYWRzOiBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIGlzQ2hhbm5lbExhc3Q6IGJvb2xlYW4sIG91dHB1dFBhZGRpbmc6IG51bWJlcltdLFxuICAgICBvdXRwdXRTaGFwZTogbnVtYmVyW10pID0+IHtcbiAgICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGggLSAyO1xuICAgICAgY29uc3QgdXBkYXRlT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZS5sZW5ndGggPT09IDA7XG4gICAgICBpZiAob3V0cHV0UGFkZGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGF0aWFsUmFuazsgKytpKSB7XG4gICAgICAgICAgb3V0cHV0UGFkZGluZy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuICAgICAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBrZXJuZWxTaGFwZVtpc0NoYW5uZWxMYXN0ID8gMyA6IDFdICogZ3JvdXA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGlucHV0U2hhcGUubGVuZ3RoIC0gc3BhdGlhbFJhbmsgLSAoaXNDaGFubmVsTGFzdCA/IDEgOiAwKTsgaSA8IHNwYXRpYWxSYW5rOyArK2ksICsraikge1xuICAgICAgICBjb25zdCBpblNpemUgPSBpbnB1dFNoYXBlW2pdO1xuICAgICAgICBjb25zdCBvdXRTaXplID0gdXBkYXRlT3V0cHV0U2hhcGUgPyBpblNpemUgKiBzdHJpZGVzW2ldIDogb3V0cHV0U2hhcGVbaV07XG4gICAgICAgIGNvbnN0IHRvdGFsUGFkID0gY29tcHV0ZVRvdGFsUGFkKGluU2l6ZSwgc3RyaWRlc1tpXSwgcGFkc1tpXSwga2VybmVsU2hhcGVbal0sIGRpbGF0aW9uc1tpXSwgb3V0U2l6ZSk7XG4gICAgICAgIGRpc3RyaWJ1dGVQYWRkaW5nKHRvdGFsUGFkLCBhdXRvUGFkLCBwYWRzLCBpLCBpICsgc3BhdGlhbFJhbmspO1xuICAgICAgICBpZiAodXBkYXRlT3V0cHV0U2hhcGUpIHtcbiAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKFxuICAgICAgICAgICAgICBzdHJpZGVzW2ldICogKGluU2l6ZSAtIDEpICsgb3V0cHV0UGFkZGluZ1tpXSArIChrZXJuZWxTaGFwZVtqXSAtIDEpICogZGlsYXRpb25zW2ldICsgMSAtIHBhZHNbaV0gLVxuICAgICAgICAgICAgICBwYWRzW2kgKyBzcGF0aWFsUmFua10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXRwdXRTaGFwZS5zcGxpY2UoMCwgMCwgYmF0Y2hTaXplKTtcbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcbiAgICB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXMge1xuICByZWFkb25seSBvdXRwdXRQYWRkaW5nOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5jb25zdCBnZXRBZGp1c3RlZENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzID1cbiAgICA8VCBleHRlbmRzIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPihhdHRyaWJ1dGVzOiBULCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFQgPT4ge1xuICAgICAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gICAgICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICAgICAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAwIHx8IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSkgPT09IDApIHtcbiAgICAgICAga2VybmVsU2hhcGUubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dHNbMV0uZGltcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtlcm5lbFNoYXBlLnB1c2goaW5wdXRzWzFdLmRpbXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gICAgICBrZXJuZWxTaGFwZS5zcGxpY2UoMCwgMCwgaW5wdXRzWzFdLmRpbXNbMF0pO1xuICAgICAga2VybmVsU2hhcGUuc3BsaWNlKGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDEsIDAsIGlucHV0c1sxXS5kaW1zWzFdKTtcblxuICAgICAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLnNsaWNlKCk7XG4gICAgICBjb25zdCBvdXRwdXRQYWRkaW5nID0gYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nLnNsaWNlKCk7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBsZXQgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMuc2xpY2UoKTtcbiAgICAgIGlmIChkaWxhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPT09IDApIHtcbiAgICAgICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAgICAgICBkaWxhdGlvbnMgPSBuZXcgQXJyYXkoc3BhdGlhbFJhbmspLmZpbGwoMSk7XG4gICAgICB9XG4gICAgICBsZXQgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5zbGljZSgpO1xuICAgICAgaWYgKHN0cmlkZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPT09IDApIHtcbiAgICAgICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAgICAgICBzdHJpZGVzID0gbmV3IEFycmF5KHNwYXRpYWxSYW5rKS5maWxsKDEpO1xuICAgICAgfVxuICAgICAgLy8gSWYgb3V0cHV0U2hhcGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIG9wLCBpbmZlciBpdCBmcm9tIHRoZSBwYXJhbWV0ZXJzXG4gICAgICAvLyBTaW1pbGFybHksIGF1dG9tYXRpY2FsbHkgaW5mZXIgcGFkcyBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMoXG4gICAgICAgICAgaW5wdXRTaGFwZSwga2VybmVsU2hhcGUsIGRpbGF0aW9ucywgYXR0cmlidXRlcy5hdXRvUGFkLCBhdHRyaWJ1dGVzLmdyb3VwLCBwYWRzLCBzdHJpZGVzLCBpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICBvdXRwdXRQYWRkaW5nLCBvdXRwdXRTaGFwZSk7XG5cbiAgICAgIC8vIGFsd2F5cyByZXR1cm4gYSBuZXcgb2JqZWN0IHNvIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICAgICAgY29uc3QgbmV3QXR0cmlidXRlczogVCA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xuICAgICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHBhZHMsIG91dHB1dFBhZGRpbmcsIG91dHB1dFNoYXBlLCBkaWxhdGlvbnMsIHN0cmlkZXN9KTtcbiAgICAgIHJldHVybiBuZXdBdHRyaWJ1dGVzO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XG4gIGNvbnN0IGF1dG9QYWQgPVxuICAgICAgWydOT1RTRVQnLCAnVkFMSUQnLCAnU0FNRV9VUFBFUicsXG4gICAgICAgJ1NBTUVfTE9XRVInXVt0eXBlb2YgYXR0cmlidXRlcy5hdXRvUGFkID09ICd1bmRlZmluZWQnID8gMCA6IGF0dHJpYnV0ZXMuYXV0b1BhZCBhcyBudW1iZXJdO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXAgYXMgbnVtYmVyO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCB3SXNDb25zdCA9IChhdHRyaWJ1dGVzLndJc0NvbnN0IGFzICgpID0+IGJvb2xlYW4pKCk7XG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICByZXR1cm4ge1xuICAgIGF1dG9QYWQsXG4gICAgZm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBncm91cCxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBvdXRwdXRQYWRkaW5nLFxuICAgIG91dHB1dFNoYXBlLFxuICAgIHBhZHMsXG4gICAgc3RyaWRlcyxcbiAgICB3SXNDb25zdCxcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgICBjYWNoZUtleTogYCR7YXR0cmlidXRlcy5mb3JtYXR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07YFxuICB9O1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZUcmFuc3Bvc2VcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgLy8gVE9ETyA6IE5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDEgOiAxXTtcbiAgY29uc3QgZmlsdGVySW5DaGFubmVsID0gaW5wdXRzWzFdLmRpbXNbMF07XG4gIGlmIChkYXRhQ2hhbm5lbCAhPT0gZmlsdGVySW5DaGFubmVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMJyk7XG4gIH1cblxuICBjb25zdCBmZWF0dXJlTWFwcyA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcblxuICAvLyBpZiBiaWFzIGlzIHByb3ZpZGVkIGl0IHNob3VsZCBiZSAxRCBhbmQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBmZWF0dXJlIG1hcHNcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgKGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBpbnB1dHNbMl0uZGltc1swXSAhPT0gZmVhdHVyZU1hcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJpYXMnKTtcbiAgfVxuXG4gIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgY29uc3QgZGlsYXRpb25zU2V0ID0gYXR0cmlidXRlcy5kaWxhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gIGlmIChkaWxhdGlvbnNTZXQgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIGNvbnN0IHN0cmlkZXNTZXQgPSBhdHRyaWJ1dGVzLnN0cmlkZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICBpZiAoc3RyaWRlc1NldCAmJiBhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBwYWRzIGRpbWVuc2lvblxuICBjb25zdCBwYWRzU2V0ID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgaWYgKHBhZHNTZXQgJiYgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmsgKiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rICogMn1EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBvdXRwdXQgcGFkZGluZyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICYmIGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZy5sZW5ndGggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dF9wYWRkaW5nIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gIGNvbnN0IGtlcm5lbFNoYXBlU2V0ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIGlmIChrZXJuZWxTaGFwZVNldCAmJiBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2VybmVsIHNoYXBlJyk7XG4gIH1cblxuICAvLyBhcyB3aXRoIGtlcm5lbFNoYXBlLCBtdXN0IGhhdmUgc2FtZSBudW1iZXIgb2Ygc3BhdGlhbCBkaW1zIGFzIGlucHV0XG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBvdXRwdXQgc2hhcGUnKTtcbiAgfVxufTtcblxuLy8gZm9yIHRyYW5zcG9zaW5nIHdlaWdodCB0ZW5zb3IgZnJvbSBbQywgTS9ncm91cCwgS0gsIEtXXSB0byBbS0gsIEtXLCBNL2dyb3VwLCBDXVxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlUGVybSA9IFsyLCAzLCAxLCAwXTtcblxuY29uc3QgY29udlRyYW5zcG9zZTJkID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBpbnB1dHMpO1xuICAgICAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhZGp1c3RlZEF0dHJpYnV0ZXMub3V0cHV0U2hhcGU7XG4gICAgICBjb25zdCBvdXRDaGFubmVscyA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICAgICAgY29uc3QgaW5wdXRDaGFubmVscyA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICAgICAgLy8gU3dpdGNoIHRvIG5haXZlIG1ldGhvZCB3aGVuIG91dENoYW5uZWxzIGFuZCBpbnB1dENoYW5uZWxzIGFyZSB2ZXJ5IHNtYWxsLiBJdCdzIGJlY2F1c2UgdGhhdCBpbiB0aGlzIGNhc2UgaXQnc1xuICAgICAgLy8gbm90IHN1aXRhYmxlIGZvciBtYXRtdWwgdmVyc2lvbiBzaW5jZSBtYXRtdWwgdXNlcyB0aWxlIHNpemUgMzJ4MzIgcmVzdWx0aW5nIHRoZSB1bmRlcmx5aW5nIGV4ZWN1dGlvbiB1bml0XG4gICAgICAvLyB1dGlsaXphdGlvbiByYXRlIGlzIHZlcnkgbG93LlxuICAgICAgaWYgKGFkanVzdGVkQXR0cmlidXRlcy5ncm91cCAhPT0gMSB8fCAob3V0Q2hhbm5lbHMgPT09IDEgJiYgaW5wdXRDaGFubmVscyA9PT0gMSkpIHtcbiAgICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbnZUcmFuc3Bvc2UyRFByb2dyYW1JbmZvKGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dEhlaWdodCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdO1xuICAgICAgY29uc3Qgb3V0V2lkdGggPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcbiAgICAgIGNvbnN0IHdlaWdodEhlaWdodCA9IGlucHV0c1sxXS5kaW1zWzJdO1xuICAgICAgY29uc3Qgd2VpZ2h0V2lkdGggPSBpbnB1dHNbMV0uZGltc1szXTtcblxuICAgICAgY29uc3QgZGltQU91dGVyID0gaXNDaGFubmVsc0xhc3QgPyBvdXRIZWlnaHQgKiBvdXRXaWR0aCA6IG91dENoYW5uZWxzO1xuICAgICAgY29uc3QgZGltQk91dGVyID0gaXNDaGFubmVsc0xhc3QgPyBvdXRDaGFubmVscyA6IG91dEhlaWdodCAqIG91dFdpZHRoO1xuICAgICAgY29uc3QgZGltSW5uZXIgPSB3ZWlnaHRIZWlnaHQgKiB3ZWlnaHRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG5cbiAgICAgIGNvbnN0IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgPSAvKiBiYWNrZW5kLmFkYXB0ZXJJbmZvLmlzSW50ZWwoKSAqLyB0cnVlO1xuXG5cbiAgICAgIC8vIFNURVAuMTogdHJhbnNwb3NlIHdlaWdodFxuICAgICAgY29uc3QgdHJhbnNwb3NlZFdlaWdodCA9IChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cbiAgICAgICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgICAgIGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgd2VpZ2h0VHJhbnNwb3NlUGVybSksXG4gICAgICAgICAgICAgIHtpbnB1dHM6IFsxXSwgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXX0pWzBdO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xuICAgICAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBTVEVQLjI6IHByZXBhcmUgcmVzaGFwZWQgaW5wdXRzXG4gICAgICBjb25zdCBjb252VHJhbnNwb3NlSW5wdXRzID0gW2lucHV0c1swXSwgdHJhbnNwb3NlZFdlaWdodF07XG4gICAgICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA9PT0gMztcbiAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgIGlmICghaXNDaGFubmVsc0xhc3QgJiYgaW5wdXRzWzJdLmRpbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY29udlRyYW5zcG9zZUlucHV0cy5wdXNoKGlucHV0c1syXS5yZXNoYXBlKFtpbnB1dHNbMl0uZGltc1swXSwgMSwgMV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb252VHJhbnNwb3NlSW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTVEVQLjM6IGNvbXB1dGUgbWF0bXVsXG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlQ29udjJEVHJhbnNwb3NlTWF0TXVsUHJvZ3JhbUluZm8oXG4gICAgICAgICAgICAgIGNvbnZUcmFuc3Bvc2VJbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIGRpbUFPdXRlciwgZGltQk91dGVyLCBkaW1Jbm5lciwgaGFzQmlhcyxcbiAgICAgICAgICAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyksXG4gICAgICAgICAge2lucHV0czogY29udlRyYW5zcG9zZUlucHV0c30pO1xuICAgIH07XG5cbmNvbnN0IGNvbnZUcmFuc3Bvc2UxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gZXh0ZW5kIHRoZSBpbnB1dCB0byAyRCBieSBhZGRpbmcgSCBkaW1lbnNpb25cbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG5cbiAgY29uc3QgaW5wdXRzID0gW1xuICAgIGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoXG4gICAgICAgIGlzQ2hhbm5lbExhc3QgP1xuICAgICAgICAgICAgLy8gW04sIFcsIENdIC0+IFtOLCBIPTEsIFcsIENdXG4gICAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV0gOlxuICAgICAgICAgICAgLy8gW04sIEMsIFddIC0+IFtOLCBDLCBIPTEsIFddXG4gICAgICAgICAgICBbY29udGV4dC5pbnB1dHNbMF0uZGltc1swXSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1sxXSwgMSwgY29udGV4dC5pbnB1dHNbMF0uZGltc1syXV0pLFxuICAgIC8vW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtXXSAtPiBbRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga0g9MSwga1ddXG4gICAgY29udGV4dC5pbnB1dHNbMV0ucmVzaGFwZShbY29udGV4dC5pbnB1dHNbMV0uZGltc1swXSwgY29udGV4dC5pbnB1dHNbMV0uZGltc1sxXSwgMSwgY29udGV4dC5pbnB1dHNbMV0uZGltc1syXV0pXG4gIF07XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBpbnB1dHMucHVzaChjb250ZXh0LmlucHV0c1syXSk7XG4gIH1cbiAgbGV0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZTtcbiAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBrZXJuZWxTaGFwZVswXSA9PT0gMCkge1xuICAgIGtlcm5lbFNoYXBlID0gW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dO1xuICB9XG4gIGxldCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucztcbiAgaWYgKGRpbGF0aW9ucy5sZW5ndGggPT09IDAgfHwgZGlsYXRpb25zWzBdID09PSAwKSB7XG4gICAgZGlsYXRpb25zID0gWzFdO1xuICB9XG4gIGxldCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzO1xuICBpZiAoc3RyaWRlcy5sZW5ndGggPT09IDAgfHwgc3RyaWRlc1swXSA9PT0gMCkge1xuICAgIHN0cmlkZXMgPSBbMV07XG4gIH1cbiAgbGV0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHM7XG4gIGlmIChwYWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHBhZHMgPSBbMCwgMF07XG4gIH1cbiAgcGFkcyA9IFswLCBwYWRzWzBdLCAwLCBwYWRzWzFdXTtcbiAgc3RyaWRlcyA9IFsxXS5jb25jYXQoc3RyaWRlcyk7XG4gIGRpbGF0aW9ucyA9IFsxXS5jb25jYXQoZGlsYXRpb25zKTtcbiAga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGtlcm5lbFNoYXBlKTtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID1cbiAgICAgIGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMoey4uLmF0dHJpYnV0ZXMsIHBhZHMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGV9LCBpbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8oXG4gICAgICBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgICAgIG91dHB1dFNoYXBlID0+IGlzQ2hhbm5lbExhc3QgPyBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzNdXSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnZUcmFuc3Bvc2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgY29udlRyYW5zcG9zZTFkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnZUcmFuc3Bvc2UyZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldEVsZW1lbnRBdCwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VtU3VtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGV4Y2x1c2l2ZTogYm9vbGVhbjtcbiAgcmVhZG9ubHkgcmV2ZXJzZTogYm9vbGVhbjtcbn1cbmNvbnN0IGNyZWF0ZUN1bXN1bVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRUeXBlOiBudW1iZXIsIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzSW5wdXQ6IFRlbnNvclZpZXcsIGF0dHJpYnV0ZXM6IEN1bVN1bUF0dHJpYnV0ZXMpOlxuICAgICAgICBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpOyAgLy8gb3V0cHV0U2hhcGUgaXMgc2FtZSBhcyBpbnB1dFNoYXBlLlxuICAgICAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDsgICAgICAgICAgICAgICAgIC8vIGlucHV0L291dHB1dCByYW5rXG4gICAgICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0VHlwZSwgcmFuayk7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0VHlwZSwgcmFuayk7XG4gICAgICAgICAgY29uc3QgYXhpc1ZhbHVlID0gYXhpc0lucHV0LmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMiA/IGF4aXNJbnB1dC5nZXRJbnQzMkFycmF5KClbMF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIoYXhpc0lucHV0LmdldEJpZ0ludDY0QXJyYXkoKVswXSk7XG4gICAgICAgICAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF4aXNWYWx1ZSwgcmFuayk7XG4gICAgICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGAgaTMyKCR7aW5wdXQuaW5kaWNlc0dldCgnaW5wdXRJbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnKX0pIGA7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ3VuaWZvcm1zLmF4aXMnLCByYW5rKTtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyTGltaXQgPSBhdHRyaWJ1dGVzLnJldmVyc2UgPyBpbmRleCArIChhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSA/ICcgKyAxJyA6ICcnKSA6ICcwJztcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyTGltaXQgPSBhdHRyaWJ1dGVzLnJldmVyc2UgPyBtYXggOiBpbmRleCArIChhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSA/ICcnIDogJyArIDEnKTtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXG4gICAgICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0IDogaTMyID0gJHtsb3dlckxpbWl0fTtcbiAgICAgICAgICAgICAgICAgIGxldCBsYXN0IDogaTMyID0gJHt1cHBlckxpbWl0fTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgOiBpMzIgPSBmaXJzdDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0SW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJywgJ3UzMihpKScpfTtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0SW5kaWNlcycpfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3N1bScpfTtcbiAgICAgICAgICAgICAgICB9YDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiAnQ3VtU3VtJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSxcbiAgICAgICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogaW5wdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VHlwZX1dLFxuICAgICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpc30sXG4gICAgICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5wdXRTaGFwZSlcbiAgICAgICAgICAgICAgXVxuXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cblxuZXhwb3J0IGNvbnN0IGN1bXN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ3VtU3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gY29udGV4dC5pbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRUeXBlID0gY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGF4aXMgPSBjb250ZXh0LmlucHV0c1sxXTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUN1bXN1bVByb2dyYW1JbmZvKGlucHV0VHlwZSwgaW5wdXRTaGFwZSwgYXhpcywgYXR0cmlidXRlcyksIHtpbnB1dHM6IFswXX0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ3VtU3VtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEN1bVN1bUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBleGNsdXNpdmUgPSBhdHRyaWJ1dGVzLmV4Y2x1c2l2ZSBhcyBudW1iZXIgPT09IDE7XG4gIGNvbnN0IHJldmVyc2UgPSBhdHRyaWJ1dGVzLnJldmVyc2UgYXMgbnVtYmVyID09PSAxO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtleGNsdXNpdmUsIHJldmVyc2V9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQyd8J05DSFcnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgZXh0ZW5kcyBGb3JtYXRBdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBibG9ja3NpemU6IG51bWJlcjtcbiAgcmVhZG9ubHkgbW9kZTogc3RyaW5nO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXB0aFRvU3BhY2UgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZXB0aFRvU3BhY2UgcmVxdWlyZXMgNEQgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IHBlcm1GdW5jdGlvbkJvZHkgPSAocGVybTogbnVtYmVyW10sIHJhbms6IG51bWJlciwgaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJldmVyc2VGdW5jID0gW107XG4gIHJldmVyc2VGdW5jLnB1c2goYGZuIHBlcm0oaTogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtpbnB1dC50eXBlLmluZGljZXN9O2ApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgIHJldmVyc2VGdW5jLnB1c2goaW5wdXQuaW5kaWNlc1NldCgnYScsIHBlcm1baV0sIGBpWyR7aX1dYCkpO1xuICB9XG4gIHJldmVyc2VGdW5jLnB1c2goJ3JldHVybiBhO30nKTtcbiAgcmV0dXJuIHJldmVyc2VGdW5jLmpvaW4oJ1xcbicpO1xufTtcblxuY29uc3QgY3JlYXRlRGVwdGhUb1NwYWNlUHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3I6IFRlbnNvclZpZXcsIGF0dHJpYnV0ZXM6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGxldCBuOiBudW1iZXIsIGg6IG51bWJlciwgdzogbnVtYmVyLCBjOiBudW1iZXI7XG4gIGxldCBzaGFwZTogbnVtYmVyW107XG4gIGxldCBwZXJtOiBudW1iZXJbXTtcbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGJsb2Nrc2l6ZSA9IGF0dHJpYnV0ZXMuYmxvY2tzaXplO1xuICBjb25zdCBpc0RDUm1vZGUgPSBhdHRyaWJ1dGVzLm1vZGUgPT09ICdEQ1InO1xuICBpZiAoaXNDaGFubmVsTGFzdCkge1xuICAgIFtuLCBoLCB3LCBjXSA9IGlucHV0VGVuc29yLmRpbXM7XG4gICAgc2hhcGUgPSBpc0RDUm1vZGUgPyBbbiwgaCwgdywgYmxvY2tzaXplLCBibG9ja3NpemUsIGMgLyAoYmxvY2tzaXplICoqIDIpXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBbbiwgaCwgdywgYyAvIChibG9ja3NpemUgKiogMiksIGJsb2Nrc2l6ZSwgYmxvY2tzaXplXTtcbiAgICBwZXJtID0gaXNEQ1Jtb2RlID8gWzAsIDEsIDMsIDIsIDQsIDVdIDogWzAsIDEsIDQsIDIsIDUsIDNdO1xuICB9IGVsc2Uge1xuICAgIFtuLCBoLCB3LCBjXSA9IFtpbnB1dFRlbnNvci5kaW1zWzBdLCBpbnB1dFRlbnNvci5kaW1zWzJdLCBpbnB1dFRlbnNvci5kaW1zWzNdLCBpbnB1dFRlbnNvci5kaW1zWzFdXTtcbiAgICBzaGFwZSA9IGlzRENSbW9kZSA/IFtuLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgYyAvIChibG9ja3NpemUgKiogMiksIGgsIHddIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuLCBjIC8gKGJsb2Nrc2l6ZSAqKiAyKSwgYmxvY2tzaXplLCBibG9ja3NpemUsIGgsIHddO1xuICAgIHBlcm0gPSBpc0RDUm1vZGUgPyBbMCwgMywgNCwgMSwgNSwgMl0gOiBbMCwgMSwgNCwgMiwgNSwgM107XG4gIH1cbiAgY29uc3QgcmVzaGFwZWRJbnB1dFRlbnNvciA9IGlucHV0VGVuc29yLnJlc2hhcGUoc2hhcGUpO1xuICBjb25zdCByZXNoYXBlZElucHV0UmFuayA9IHJlc2hhcGVkSW5wdXRUZW5zb3IuZGltcy5sZW5ndGg7XG4gIGNvbnN0IGlucHV0RGF0YVR5cGUgPSBpbnB1dFRlbnNvci5kYXRhVHlwZTtcblxuICBjb25zdCByZXNoYXBlZElucHV0ID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0RGF0YVR5cGUsIHJlc2hhcGVkSW5wdXRSYW5rKTtcbiAgY29uc3QgcGVybWVkT3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0RGF0YVR5cGUsIHJlc2hhcGVkSW5wdXRSYW5rKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKHJlc2hhcGVkSW5wdXQsIHBlcm1lZE91dHB1dCl9XG5cbiAgJHtwZXJtRnVuY3Rpb25Cb2R5KHBlcm0sIHJlc2hhcGVkSW5wdXRSYW5rLCByZXNoYXBlZElucHV0LCBwZXJtZWRPdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7cGVybWVkT3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtwZXJtZWRPdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCByZXNoYXBlZElucHV0LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKSl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0RlcHRoVG9TcGFjZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtpbnB1dFRlbnNvci5kaW1zfTske2F0dHJpYnV0ZXMuYmxvY2tzaXplfTske2F0dHJpYnV0ZXMubW9kZX1gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ119LFxuICAgIGdldFJ1bkRhdGE6IChpbnB1dHMpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaXNDaGFubmVsTGFzdCA/IFtuLCBoICogYmxvY2tzaXplLCB3ICogYmxvY2tzaXplLCBjIC8gKGJsb2Nrc2l6ZSAqKiAyKV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW24sIGMgLyAoYmxvY2tzaXplICoqIDIpLCBoICogYmxvY2tzaXplLCB3ICogYmxvY2tzaXplXTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBzaGFwZUJlZm9yZVBlcm0gPSByZXNoYXBlZElucHV0VGVuc29yLmRpbXM7XG4gICAgICBjb25zdCBzaGFwZUFmdGVyUGVybSA9IFNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oc2hhcGVCZWZvcmVQZXJtLCBwZXJtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOlxuICAgICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhzaGFwZUJlZm9yZVBlcm0sIHNoYXBlQWZ0ZXJQZXJtKV0sXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlcHRoVG9TcGFjZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVEZXB0aFRvU3BhY2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgICAgYmxvY2tzaXplOiBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZSBhcyBudW1iZXIsXG4gICAgICBtb2RlOiBhdHRyaWJ1dGVzLm1vZGUgYXMgc3RyaW5nLFxuICAgICAgZm9ybWF0OiBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVydcbiAgICB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBFaW5zdW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgZXF1YXRpb246IHN0cmluZztcbn1cbi8vIFRoZSBlcXVhdGlvbiBhdHRyaWJ1dGUgdmFsdWUgaXMgYSBzdHJpbmcgd2hpY2ggY29uc2lzdHMgb2YgbGVmdCBoYW5kIHNpZGUgKExIUykgYW5kIG9wdGlvbmFsbHkgcmlnaHQgaGFuZCBzaWRlIChSSFMpXG4vLyBzZXBhcmF0ZWQgYnkgJy0+Jy4gRXguIFwiaWosamsgLT4gaWtcIiBleHByZXNzZXMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4vLyAgICAgXCJpai0+amlcIiBleHByZXNzZXMgbWF0cml4IHRyYW5zcG9zZVxuLy8gICAgICBcImlpLT5pXCIgZGlhZ29uYWwgZWxlbWVudHMgb2YgYSBzcXVhcmUgbWF0cml4XG4vLyBMSFMgY29uc2lzdHMgb2YgYSBzZXF1ZW5jZSBvZiB0ZXJtcyBzZXBhcmF0ZWQgYnkgY29tbWFzLiBFYWNoIHRlcm0gY29ycmVzcG9uZHMgdG8gYW4gaW5wdXQgdmFyaWFibGUuXG4vLyBFYWNoIHN5bWJvbCBjb3JyZXNwb25kcyB0byBhIGRpbWVuc2lvbiBpbiB0aGUgaW5wdXQgdmFyaWFibGUuIFRoZSBzeW1ib2wgY2FuIGJlIGVpdGhlciBhIGxldHRlciwgJ2EnIHRvICd6JyBvciAnQScgdG9cbi8vICdaJyBvciAnLi4uJyB0byByZXByZXNlbnQgYXJiaXRyYXJ5IGRpbWVuc2lvbnMuXG5cbmNvbnN0IHN5bWJvbFBhdHRlcm4gPVxuICAgICdbYS16QS1aXXxcXFxcLlxcXFwuXFxcXC4nOyAgLy8gVGhlIHBhdHRlcm4gZWFjaCBzeW1ib2wgaW4gZWFjaCB0ZXJtIGluIHRoZSBzeW1ib2xpYyBlcXVhdGlvbiBzaG91bGQgbWF0Y2hcbmNvbnN0IHRlcm1QYXR0ZXJuID0gJygnICsgc3ltYm9sUGF0dGVybiArICcpKyc7ICAgLy8gVGhlIHBhdHRlcm4gZWFjaCB0ZXJtIGluIHRoZSBzeW1ib2xpYyBlcXVhdGlvbiBzaG91bGQgbWF0Y2hcbmNvbnN0IHRlcm1QYXR0ZXJuT25seSA9ICdeJyArIHRlcm1QYXR0ZXJuICsgJyQnOyAgLy8gVGhlIHBhdHRlcm5zIG9ubHkgbWF0Y2hzIGEgdGVybSBiZWdpbiB0byBlbmQuXG5jb25zdCBsaHNQYXR0ZXJuID0gJygnICsgdGVybVBhdHRlcm4gKyAnLCkqJyArIHRlcm1QYXR0ZXJuOyAgLy8gVGhlIHBhdHRlcm4gdGhlIExIUyBzaG91bGQgbWF0Y2hcbmNvbnN0IGxoc1BhdHRlcm5Pbmx5ID0gJ14nICsgbGhzUGF0dGVybiArICckJzsgICAgICAgICAgICAgICAvLyBUaGUgcGF0dGVybnMgb25seSBtYXRjaHMgYSBMSFMgYmVnaW4gdG8gZW5kLlxuXG5pbnRlcmZhY2UgU3ltYm9sSW5mbyB7XG4gIGNvdW50OiBudW1iZXI7ICAgICAgICAgICAvLyBTeW1ib2wgY29ycmVzcG9uZGluZyB0byBhIGRpbW1lbnNpb24gb2YgYW4gaW5wdXRcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXTsgIC8vIE51bWJlciBvZiBpbnB1dCB2YXJpYWJsZXMgdGhlIHN5bWJvbCBjb3JyZXNwb25kcyB0b1xuICBkaW1WYWx1ZTogbnVtYmVyOyAgICAgICAgLy8gTnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhlIHN5bWJvbCBjb3JyZXNwb25kcyB0b1xufVxuXG5jbGFzcyBFaW5zdW1UZXJtIHtcbiAgY29uc3RydWN0b3IoaW5wdXRJbmRleCA9IC0xKSB7XG4gICAgdGhpcy5zeW1ib2xUb0luZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyW10+KCk7XG4gICAgdGhpcy5pbnB1dEluZGV4ID0gaW5wdXRJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCBhIHN5bWJvbCB0byB0aGUgdGVybVxuICBhZGRTeW1ib2woc3ltYm9sOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSBbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZS5wdXNoKGluZGV4KTtcbiAgICB9XG4gICAgdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHN5bWJvbCwgdmFsdWUpO1xuICB9XG5cbiAgc3ltYm9sVG9JbmRpY2VzOiBNYXA8c3RyaW5nLCBudW1iZXJbXT47ICAvLyBNYXAgZnJvbSBzeW1ib2wgdG8gZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgY29ycmVzcG9uZGluZyB0byB0aGUgdGVybVxuICBpbnB1dEluZGV4OiBudW1iZXI7ICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIGZvciBvdXRwdXQgYW5kIDAsIDEsIDIsIC4uLiBmb3IgaW5wdXRzXG59XG5cbmNsYXNzIEVpbnN1bUVxdWF0aW9uIHtcbiAgY29uc3RydWN0b3IoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIHB1YmxpYyByZWFkb25seSBlcXVhdGlvbjogc3RyaW5nKSB7XG4gICAgdGhpcy5oYXNFbGxpcHNpcyA9IGZhbHNlO1xuICAgIHRoaXMuc3ltYm9sVG9JbmZvID0gbmV3IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+KCk7XG4gICAgdGhpcy5saHMgPSBuZXcgQXJyYXk8RWluc3VtVGVybT4oKTtcbiAgICB0aGlzLm91dHB1dERpbXMgPSBbXTtcbiAgICAvLyBBcyByaHMgbmVlZHMgdG8gYmUgdXBkYXRlZCBhbGxvdyB1c2luZyBsZXQgaW5zdGVhZCBvZiBjb25zdCBmb3IgYm90aCBsaHMgYW5kIHJocy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IFtsaHMsIHJoc10gPSBlcXVhdGlvbi5pbmNsdWRlcygnLT4nKSA/IGVxdWF0aW9uLnNwbGl0KCctPicsIDIpIDogW2VxdWF0aW9uLCAnJ107XG4gICAgaWYgKCFsaHMubWF0Y2goUmVnRXhwKGxoc1BhdHRlcm5Pbmx5KSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFRlcm1zID0gbGhzLnNwbGl0KCcsJyk7XG4gICAgaW5wdXRUZXJtcy5mb3JFYWNoKChpbnB1dFRlcm0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBkaW1zID0gaW5wdXRzW2luZGV4XS5kaW1zLnNsaWNlKCk7XG4gICAgICBpZiAoIWlucHV0VGVybS5tYXRjaChSZWdFeHAodGVybVBhdHRlcm5Pbmx5KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExIUyB0ZXJtJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBlaW5zdW1UZXJtID0gdGhpcy5wcm9jZXNzVGVybShpbnB1dFRlcm0sIHRydWUsIGRpbXMsIGluZGV4KTtcbiAgICAgIHRoaXMubGhzLnB1c2goZWluc3VtVGVybSk7XG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBSSFMgaWYgbm90IHNwZWNpZmllZFxuICAgIGlmIChyaHMgPT09ICcnKSB7XG4gICAgICAvLyBDb25zdHJ1Y3QgUkhTIGZyb20gTEhTIHRlcm1zL3N5bWJvbHNcbiAgICAgIHJocyArPSBbLi4udGhpcy5zeW1ib2xUb0luZm8uZW50cmllcygpXVxuICAgICAgICAgICAgICAgICAuZmlsdGVyKChbc3ltLCBpbmZvXSkgPT4gKGluZm8uY291bnQgPT09IDEgfHwgc3ltID09PSAnLi4uJykpXG4gICAgICAgICAgICAgICAgIC5tYXAoKFtzeW1dKSA9PiBzeW0pXG4gICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyaHMubWF0Y2goUmVnRXhwKHRlcm1QYXR0ZXJuKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJIUycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgb3V0cHV0IGRpbXNcbiAgICBjb25zdCByaHNTeW1ib2xzID0gcmhzLm1hdGNoKFJlZ0V4cChzeW1ib2xQYXR0ZXJuLCAnZycpKTtcbiAgICByaHNTeW1ib2xzPy5mb3JFYWNoKChzeW1ib2wpID0+IHtcbiAgICAgIGlmIChzeW1ib2wgPT09ICcuLi4nKSB7XG4gICAgICAgIHRoaXMub3V0cHV0RGltcyA9IHRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuc3ltYm9sVG9JbmZvLmdldChzeW1ib2wpO1xuICAgICAgICBpZiAoaW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFJIUyBzeW1ib2wnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dERpbXMucHVzaChpbmZvLmRpbVZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJocyA9IHRoaXMucHJvY2Vzc1Rlcm0ocmhzLCBmYWxzZSwgdGhpcy5vdXRwdXREaW1zKTtcbiAgfSAgLy8gRW5kIG9mIEVpbnN1bUVxYXRpb24gY29uc3RydWN0b3JcblxuICAvLyBBZGQgYSBzeW1ib2wgdG8gdGhlIGVxdWF0aW9uXG4gIGFkZFN5bWJvbChzeW1ib2w6IHN0cmluZywgZGltVmFsdWU6IG51bWJlciwgaW5wdXRJbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IGluZm8gPSB0aGlzLnN5bWJvbFRvSW5mby5nZXQoc3ltYm9sKTtcbiAgICBpZiAoaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mby5kaW1WYWx1ZSAhPT0gZGltVmFsdWUgJiYgaW5mby5jb3VudCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiBtaXNtYXRjaCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mby5jb3VudCsrO1xuICAgICAgICBpbmZvLmlucHV0SW5kaWNlcy5wdXNoKGlucHV0SW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge2NvdW50OiAxLCBkaW1WYWx1ZSwgaW5wdXRJbmRpY2VzOiBbaW5wdXRJbmRleF19O1xuICAgIH1cbiAgICB0aGlzLnN5bWJvbFRvSW5mby5zZXQoc3ltYm9sLCBpbmZvKTtcbiAgfVxuXG4gIC8vIFByb2Nlc3Mgb25lIGlucHV0L291dHB1dCB0ZXJtXG4gIHByb2Nlc3NUZXJtKHRlcm06IHN0cmluZywgaXNJbnB1dDogYm9vbGVhbiwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGluZGV4ID0gLTEpOiBFaW5zdW1UZXJtIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgbGV0IGVsbGlwc2lzID0gZmFsc2U7XG4gICAgbGV0IGVsbGlwc2lzRGltcyA9IFtdO1xuICAgIGxldCBuZXh0RGltID0gMDtcbiAgICAvLyBGb3Igb3V0cHV0IGVtcHR5IHN0cmluZyBpcyBhbGxvd2VkIGJlY2F1c2UgdGhlIG91dHB1dCBtYXkgYmUgcmVkdWNlZCB0byBhIHNjYWxhciB2YWx1ZVxuICAgIGlmICghdGVybS5tYXRjaChSZWdFeHAodGVybVBhdHRlcm5Pbmx5KSkgJiYgKCFpc0lucHV0ICYmIHRlcm0gIT09ICcnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExIUyB0ZXJtJyk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4U3ltYm9scyA9IHRlcm0ubWF0Y2goUmVnRXhwKHN5bWJvbFBhdHRlcm4sICdnJykpO1xuICAgIGNvbnN0IGVpbnN1bVRlcm0gPSBuZXcgRWluc3VtVGVybShpbmRleCk7XG4gICAgLy8gc3ltYm9sIGNhbiBiZSBlaXRoZXIgYSBsZXR0cmUsICdhJyB0byAneicgb3IgJ0EnIHRvICdaJywgb3IgJy4uLidcbiAgICBpbmRleFN5bWJvbHM/LmZvckVhY2goKHN5bWJvbDogc3RyaW5nLCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChzeW1ib2wgPT09ICcuLi4nKSB7XG4gICAgICAgIGlmIChlbGxpcHNpcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgZWxsaXBzaXMgaXMgYWxsb3dlZCBwZXIgaW5wdXQgdGVybScpO1xuICAgICAgICB9XG4gICAgICAgIGVsbGlwc2lzID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWxsaXBzaXNEaW1MZW5ndGggPSByYW5rIC0gaW5kZXhTeW1ib2xzLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChlbGxpcHNpc0RpbUxlbmd0aCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsbGlwc2lzIG91dCBvZiBib3VuZHMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbGxpcHNpc0RpbXMgPSBkaW1zLnNsaWNlKG5leHREaW0sIG5leHREaW0gKyBlbGxpcHNpc0RpbUxlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0VsbGlwc2lzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCAhPT0gZWxsaXBzaXNEaW1zLmxlbmd0aCB8fFxuICAgICAgICAgICAgICB0aGlzLmVsbGlwc2lzRGltcy50b1N0cmluZygpICE9PSBlbGxpcHNpc0RpbXMudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzSW5wdXQpIHtcbiAgICAgICAgICB0aGlzLmhhc0VsbGlwc2lzID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmVsbGlwc2lzRGltcyA9IGVsbGlwc2lzRGltcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsbGlwc2lzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSBMSFMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgJzAnLCAnMScsICcyJywgJzMnLCAnNCcsIGV0YyB0byByZXByZXNlbnQgZWxsaXBzaXMgZGltZW5zaW9ucyB0byBhdm9pZCBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZWxsaXBzaXNEaW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgc3ltYm9sID0gU3RyaW5nLmZyb21DaGFyQ29kZSgnMCcuY2hhckNvZGVBdCgwKSArIGopO1xuICAgICAgICAgIGVpbnN1bVRlcm0uYWRkU3ltYm9sKHN5bWJvbCwgaSArIGopO1xuICAgICAgICAgIHRoaXMuYWRkU3ltYm9sKHN5bWJvbCwgZGltc1tuZXh0RGltKytdLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVpbnN1bVRlcm0uYWRkU3ltYm9sKHN5bWJvbCwgaSArICh0aGlzLmhhc0VsbGlwc2lzID8gdGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIC0gMSA6IDApKTtcbiAgICAgICAgdGhpcy5hZGRTeW1ib2woc3ltYm9sLCBkaW1zW25leHREaW0rK10sIGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZWluc3VtVGVybTtcbiAgfVxuXG4gIHN5bWJvbFRvSW5mbzogTWFwPHN0cmluZywgU3ltYm9sSW5mbz47ICAvLyBBbGwgc3ltYm9scyBpbiB0aGUgZXF1YXRpb25cbiAgaGFzRWxsaXBzaXM6IGJvb2xlYW47ICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlcXVhdGlvbiBoYXMgZWxsaXBzaXMgb3Igbm90XG4gIGVsbGlwc2lzRGltczogbnVtYmVyW107ICAgICAgICAgICAgICAgICAvLyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZXF1YXRpb24gZWxsaXBzaXMgY29ycmVzcG9uZHMgdG8uXG4gIGxoczogRWluc3VtVGVybVtdOyAgICAgICAgICAgICAgICAgICAgICAvLyBUZXJtcyBvbiB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIGVxdWF0aW9uXG4gIHJoczogRWluc3VtVGVybTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBUZXJtIG9uIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIGVxdWF0aW9uXG4gIG91dHB1dERpbXM6IG51bWJlcltdOyAgICAgICAgICAgICAgICAgICAvLyBPdXRwdXQgZGltZW5zaW9ucyBvZiB0aGUgZXF1YXRpb25cbn0gIC8vIEVuZCBvZiBjbGFzcyBFaW5zdW1FcXVhdGlvblxuXG5jb25zdCBhcHBlbmRNYXggPSAobmFtZTogc3RyaW5nKTogc3RyaW5nID0+IG5hbWUgKyAnX21heCc7XG5cbmNvbnN0IGNyZWF0ZUVpbnN1bVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRTaGFwZXM6IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPiwgZGF0YVR5cGU6IG51bWJlciwgZWluc3VtRXF1YXRpb246IEVpbnN1bUVxdWF0aW9uLFxuICAgICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCByYW5rcyA9IGlucHV0U2hhcGVzLm1hcCgoZGltcykgPT4gZGltcy5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5wdXRWYXJzID0gcmFua3MubWFwKChyYW5rLCBpbmRleCkgPT4gaW5wdXRWYXJpYWJsZShgaW5wdXQke2luZGV4fWAsIGRhdGFUeXBlLCByYW5rKSk7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgY29uc3QgdW5pZm9ybXNTeW1ib2xzID1cbiAgICAgICAgICBbLi4uZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKChzeW1ib2wpID0+ICFlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhzeW1ib2wpKTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCBpbml0UHJvZCA9ICd2YXIgcHJvZCA9IDEuMDsnO1xuICAgICAgICBjb25zdCBpbml0U3VtID0gJ3ZhciBzdW0gPSAwLjA7JztcbiAgICAgICAgY29uc3QgdXBkYXRlU3VtID0gJ3N1bSArPSBwcm9kOyc7XG4gICAgICAgIGNvbnN0IHJlZHVjZU9wc1NldEluZGljZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGNvbnN0IHJlZHVjZU9wc0xvb3BIZWFkZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCByZWR1Y2VPcHNMb29wRm9vdGVyczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgcmVkdWNlT3BDb21wdXRlOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCBpc1JlZHVjZU9wc1dpdGhvdXRMb29wID0gZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLnNpemUgPT09IGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuc2l6ZTtcbiAgICAgICAgZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmZvckVhY2goKGluZm8sIHN5bWJvbCkgPT4ge1xuICAgICAgICAgIGlmIChlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhzeW1ib2wpKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk/LlswXTtcbiAgICAgICAgICAgIGlmIChvdXRwdXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGVpbnN1bUVxdWF0aW9uLmxocy5mb3JFYWNoKCh0ZXJtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uaW5wdXRJbmRpY2VzLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gdGVybS5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5kaWNlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzeW1ib2wgZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluZGljZXMuZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWR4Q29weS5wdXNoKGAke1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYXJzW2ldLmluZGljZXNTZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGlucHV0JHtpfUluZGljZXNgLCBpbmRleCwgb3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXRJbmRleCkpfWApO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGluZm8uaW5wdXRJbmRpY2VzLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IHRlcm0uc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzeW1ib2wgZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVkdWNlT3BzU2V0SW5kaWNlcy5wdXNoKGAke2lucHV0VmFyc1tpXS5pbmRpY2VzU2V0KGBpbnB1dCR7aX1JbmRpY2VzYCwgaW5kZXgsIGAke3N5bWJvbH1gKX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWR1Y2VPcENvbXB1dGUucHVzaChgcHJvZCAqPSAke2lucHV0VmFyc1tpXS5nZXRCeUluZGljZXMoYGlucHV0JHtpfUluZGljZXNgKX07YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVkdWNlT3BzTG9vcEhlYWRlcnMucHVzaChcbiAgICAgICAgICAgICAgICBgZm9yKHZhciAke3N5bWJvbH06IHUzMiA9IDA7ICR7c3ltYm9sfSA8IHVuaWZvcm1zLiR7YXBwZW5kTWF4KHN5bWJvbCl9OyAke3N5bWJvbH0rKykge2ApO1xuICAgICAgICAgICAgcmVkdWNlT3BzTG9vcEZvb3RlcnMucHVzaCgnfScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlZHVjZU9wcyA9IGlzUmVkdWNlT3BzV2l0aG91dExvb3AgP1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAuLi5pZHhDb3B5LFxuICAgICAgICAgICAgICBgbGV0IHN1bSA9ICR7aW5wdXRWYXJzLm1hcCgoaW5wdXRWYXIsIGkpID0+IGlucHV0VmFyLmdldEJ5SW5kaWNlcyhgaW5wdXQke2l9SW5kaWNlc2ApKS5qb2luKCcgKiAnKX07YFxuICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIC4uLmlkeENvcHksXG4gICAgICAgICAgICAgIGluaXRTdW0sXG4gICAgICAgICAgICAgIC4uLnJlZHVjZU9wc0xvb3BIZWFkZXJzLFxuICAgICAgICAgICAgICAuLi5yZWR1Y2VPcHNTZXRJbmRpY2VzLFxuICAgICAgICAgICAgICBpbml0UHJvZCxcbiAgICAgICAgICAgICAgLi4ucmVkdWNlT3BDb21wdXRlLFxuICAgICAgICAgICAgICB1cGRhdGVTdW0sXG4gICAgICAgICAgICAgIC4uLnJlZHVjZU9wc0xvb3BGb290ZXJzLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7XG4gICAgICAgICAgICBzaGFkZXJIZWxwZXJcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3Jtc1N5bWJvbHMubWFwKChzeW1ib2wpID0+ICh7bmFtZTogYCR7YXBwZW5kTWF4KHN5bWJvbCl9YCwgdHlwZTogJ3UzMid9KSkpXG4gICAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxuICAgICAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KX1cblxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICR7aW5wdXRWYXJzLm1hcCgoX3ZhciwgaSkgPT4gYHZhciBpbnB1dCR7aX1JbmRpY2VzOiAke2lucHV0VmFyc1tpXS50eXBlLmluZGljZXN9O2ApLmpvaW4oJ1xcbicpfVxuICAgICAgICAgICAgJHtyZWR1Y2VPcHMuam9pbignXFxuJyl9O1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc3VtJyl9O1xuICAgICAgICAgIH1gO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdFaW5zdW0nLFxuICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGVpbnN1bUVxdWF0aW9uLmVxdWF0aW9uLCBpbnB1dERlcGVuZGVuY2llczogaW5wdXRTaGFwZXMubWFwKCgpID0+ICdyYW5rJyl9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiB7XG4gICAgICAgICAgLy8gVGhlIHN5bWJvbHMgZnJvbSB1bmlmb3JtU3ltYm9scyBhcnJheSBhcmUgZ3VhcmFudGVlZCB0byBleGlzdCBpbiBlaW5zdW1FcXVhdGlvbnMuc3ltYm9sVG9JbmZvIG1hcC4gVGhlXG4gICAgICAgICAgLy8gZmlsdGVyIGlzIGFkZGVkIHRvIG1ha2Ugc3VyZSB0aGF0IGRpbVZhbHVlIGlzIG5ldmVyIDAuXG4gICAgICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zSW5pdDogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICAgICAgICAgIHVuaWZvcm1zU3ltYm9scy5maWx0ZXIoKHN5bWJvbCkgPT4gZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmhhcyhzeW1ib2wpKVxuICAgICAgICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAoc3ltYm9sKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmdldChzeW1ib2wpPy5kaW1WYWx1ZSB8fCAwfSkpO1xuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc0luaXQucHVzaCh7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSk7XG4gICAgICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID1cbiAgICAgICAgICAgICAgaW5wdXRTaGFwZXMubWFwKChkaW1zLCBfKSA9PiBbLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoZGltcyldKVxuICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBpbnB1dFByb2dyYW1Vbmlmb3JtcykgPT4gYWNjLmNvbmNhdChpbnB1dFByb2dyYW1Vbmlmb3JtcyksIHByb2dyYW1Vbmlmb3Jtc0luaXQpO1xuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG4gICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZX1dLFxuICAgICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBlaW5zdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEVpbnN1bUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZWluc3VtRXF1YXRpb24gPSBuZXcgRWluc3VtRXF1YXRpb24oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMuZXF1YXRpb24pO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGVpbnN1bUVxdWF0aW9uLm91dHB1dERpbXM7XG4gIGNvbnN0IGlucHV0U2hhcGVzID0gY29udGV4dC5pbnB1dHMubWFwKChpbnB1dCwgXykgPT4gaW5wdXQuZGltcyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFaW5zdW1Qcm9ncmFtSW5mbyhpbnB1dFNoYXBlcywgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGVpbnN1bUVxdWF0aW9uLCBvdXRwdXRTaGFwZSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRWluc3VtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEVpbnN1bUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBlcXVhdGlvbiA9IChhdHRyaWJ1dGVzLmVxdWF0aW9uIGFzIHN0cmluZykucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2VxdWF0aW9ufSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGFuZCByZXF1aXJlcyAyIGlucHV0LicpO1xuICB9XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgc2hhcGUgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCksIE51bWJlcik7XG5cbiAgbGV0IHNoYXBlSW5kZXggPSBzaGFwZS5sZW5ndGggPCBpbnB1dFNoYXBlLmxlbmd0aCA/IDAgOiBzaGFwZS5sZW5ndGggLSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgbGV0IGlucHV0U2hhcGVJbmRleCA9IGlucHV0U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoID8gMCA6IGlucHV0U2hhcGUubGVuZ3RoIC0gc2hhcGUubGVuZ3RoO1xuICBmb3IgKDsgc2hhcGVJbmRleCA8IHNoYXBlLmxlbmd0aCAmJiBpbnB1dFNoYXBlSW5kZXggPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytzaGFwZUluZGV4LCArK2lucHV0U2hhcGVJbmRleCkge1xuICAgIGlmIChzaGFwZVtzaGFwZUluZGV4XSAhPT0gaW5wdXRTaGFwZVtpbnB1dFNoYXBlSW5kZXhdICYmIHNoYXBlW3NoYXBlSW5kZXhdICE9PSAxICYmXG4gICAgICAgIGlucHV0U2hhcGVbaW5wdXRTaGFwZUluZGV4XSAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dCcpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRTaGFwZSA9IChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBkaWZmID0gc2hhcGUxLmxlbmd0aCAtIHNoYXBlMi5sZW5ndGg7XG4gIGNvbnN0IHNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7ICsraSkge1xuICAgIHNoYXBlLnB1c2goc2hhcGUxW2ldKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlMi5sZW5ndGg7ICsraSkge1xuICAgIHNoYXBlLnB1c2goc2hhcGUyW2ldID09PSAxID8gc2hhcGUxW2kgKyBkaWZmXSA6IHNoYXBlMltpXSk7XG4gIH1cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+XG4gICAgKGlucHV0U2hhcGUubGVuZ3RoID4gc2hhcGUubGVuZ3RoKSA/IGdldEFkanVzdGVkU2hhcGUoaW5wdXRTaGFwZSwgc2hhcGUpIDogZ2V0QWRqdXN0ZWRTaGFwZShzaGFwZSwgaW5wdXRTaGFwZSk7XG5cblxuY29uc3QgY3JlYXRlRXhwYW5kUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgc2hhcGUgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCksIE51bWJlcik7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNoYXBlKTtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCA/IDQgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICAgIGlmIChkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiBgXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3h9dWApfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHt4fSA9ICR7aW5wdXQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt4fSA9IG9mZnNldCR7eH0gJSA0dTtcbiAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2lucHV0LmdldEJ5T2Zmc2V0KGBpbmRleCR7eH1gKX1bY29tcG9uZW50JHt4fV0pO1xuICAgICAgICBgO1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9O1xuICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDIsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdkYXRhJyl9XG4gICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgIGxldCBpbnB1dE9mZnNldCA9ICR7aW5wdXQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeU9mZnNldCgnaW5wdXRPZmZzZXQnKSl9XG4gICAgICB9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAke2Fzc2lnbm1lbnR9YDtcbiAgfTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPVxuICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSldO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdFeHBhbmQnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7b3V0cHV0U2hhcGUubGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXX0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgfSlcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBleHBhbmQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRXhwYW5kUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpLCB7aW5wdXRzOiBbMF19KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZSwgV09SS0dST1VQX1NJWkV9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCAqIGFzIHVuYXJ5IGZyb20gJy4vdW5hcnktb3AnO1xuXG4vLyBHRUxVIGlzIGRlZmluZWQgYXMgWT0wLjUqWCooMSt0YW5oKDAuNzk3ODg1KlgrMC4wMzU2NzcqWCpYKlgpKSwgd2hlcmUgWCBtYXkgcHJlLWFkZCBhIGJpYXMuXG5cbmNvbnN0IGNyZWF0ZUZhc3RHZWx1UHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRUZW5zb3JzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzBdLmRpbXMpO1xuICBjb25zdCBiaWFzTGVuZ3RoID0gU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzFdLmRpbXMpO1xuICAvLyBjYW4gb25seSB1c2UgdmVjNCB3aGVuIGJpYXMgbGVuZ3RoIGlzIG11bHRpcGxlIG9mIDRcbiAgY29uc3QgdXNlVmVjNCA9IGJpYXNMZW5ndGggJSA0ID09PSAwO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgZGF0YVR5cGUsIFsxXSwgNCk7XG4gICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBkYXRhVHlwZSwgWzFdLCA0KTtcbiAgICBjb25zdCB5ID0gb3V0cHV0VmFyaWFibGUoJ3knLCBkYXRhVHlwZSwgWzFdLCA0KTtcblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFt7bmFtZTogJ291dHB1dF92ZWNfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdiaWFzX3NpemUnLCB0eXBlOiAndTMyJ31dO1xuXG4gICAgY29uc3Qgc2luZ2xlRWxlbWVudEJpYXMgPSAoaTogMHwxfDJ8MykgPT4gYFxuICAgICAgbGV0IGJpYXMke2l9X29mZnNldDogdTMyID0gKGdsb2JhbF9pZHggKiA0ICsgJHtpfSkgJSB1bmlmb3Jtcy5iaWFzX3NpemU7XG4gICAgICBsZXQgYmlhcyR7aX0gPSAke2JpYXMuZ2V0QnlPZmZzZXQoYGJpYXMke2l9X29mZnNldCAvIDRgKX1bYmlhcyR7aX1fb2Zmc2V0ICUgNF07YDtcbiAgICBjb25zdCBiaWFzR2V0RXhwcmVzc2lvbiA9IHVzZVZlYzQgP1xuICAgICAgICBgXG4gICAgICBsZXQgYmlhcyA9ICR7Ymlhcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5iaWFzX3NpemUgLyA0KScpfTtgIDpcbiAgICAgICAgYCR7c2luZ2xlRWxlbWVudEJpYXMoMCl9JHtzaW5nbGVFbGVtZW50QmlhcygxKX0ke3NpbmdsZUVsZW1lbnRCaWFzKDIpfSR7c2luZ2xlRWxlbWVudEJpYXMoMyl9XG4gICAgICBsZXQgYmlhcyA9ICR7eC50eXBlLnZhbHVlfShiaWFzMCwgYmlhczEsIGJpYXMyLCBiaWFzMyk7YDtcblxuICAgIHJldHVybiBgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBiaWFzLCB5KX1cblxuICAgICR7dW5hcnkuZmFzdEdlbHVJbXBsKHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoZGF0YVR5cGUpKX1cblxuICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXT1JLR1JPVVBfU0laRSl9XG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfdmVjX3NpemUnKX1cblxuICAgICAgbGV0IHggPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAke2JpYXNHZXRFeHByZXNzaW9ufVxuICAgICAgbGV0IHhfaW4gPSB4ICsgYmlhcztcbiAgICAgICR7eS5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIHVuYXJ5LmZhc3RHZWx1RXhwcmVzc2lvbigneF9pbicpKX1cbiAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdGYXN0R2VsdVdpdGhCaWFzJyxcbiAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke3VzZVZlYzR9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJ119LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBpbnB1dHNbMF0uZGltcywgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOlxuICAgICAgICAgIFt7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDQpfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmlhc0xlbmd0aH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gV09SS0dST1VQX1NJWkUgLyA0KX1cbiAgICB9KVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPCAyIHx8IFNoYXBlVXRpbC5zaXplKGNvbnRleHQuaW5wdXRzWzFdLmRpbXMpID09PSAwKSB7XG4gICAgdW5hcnkuZmFzdEdlbHUoY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUZhc3RHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGF4aXMsIDEsIC4uLmluZGljZXNTaGFwZSk7XG5cbiAgY29uc3QgYXhpc0RpbUxpbWl0ID0gaW5wdXRTaGFwZVtheGlzXTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCA/IDQgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBheGlzRGltTGltaXR9LFxuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXN9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMsIG91dHB1dFNoYXBlKVxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBpbnB1dFZhcmlhYmxlKCdkYXRhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGluZGljZXMgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dEluZGljZXMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcblxuICAgIGNvbnN0IGNhbGNEYXRhSW5kaWNlcyA9ICh4OiBudW1iZXJ8c3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGluZGljZXNSYW5rID0gaW5kaWNlc1NoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBjYWxjU3RyID0gYHZhciBpbmRpY2VzSW5kaWNlcyR7eH0gID0gJHtpbmRpY2VzLnR5cGUuaW5kaWNlc30oMCk7YDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlc1Jhbms7IGkrKykge1xuICAgICAgICBjYWxjU3RyICs9IGAke2luZGljZXNSYW5rID4gMSA/IGBpbmRpY2VzSW5kaWNlcyR7eH1bJHtpfV1gIDogYGluZGljZXNJbmRpY2VzJHt4fWB9ID0gJHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlLmxlbmd0aCA+IDEgPyBgb3V0cHV0SW5kaWNlcyR7eH1bdW5pZm9ybXMuYXhpcyArICR7aX1dYCA6IGBvdXRwdXRJbmRpY2VzJHt4fWB9O2A7XG4gICAgICB9XG4gICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICB2YXIgaWR4JHt4fSA9ICR7aW5kaWNlcy5nZXRCeUluZGljZXMoYGluZGljZXNJbmRpY2VzJHt4fWApfTtcbiAgICAgICAgICBpZiAoaWR4JHt4fSA8IDApIHtcbiAgICAgICAgICAgIGlkeCR7eH0gPSBpZHgke3h9ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMke3h9IDogJHtkYXRhLnR5cGUuaW5kaWNlc307XG4gICAgICAgIGA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBpbnB1dFJhbms7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gYXhpcykge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYCR7aW5wdXRSYW5rID4gMSA/IGBkYXRhSW5kaWNlcyR7eH1bJHtpfV1gIDogYGRhdGFJbmRpY2VzJHt4fWB9ID0gdTMyKGlkeCR7eH0pO2A7XG4gICAgICAgICAgaiArPSBpbmRpY2VzUmFuaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGAke2lucHV0UmFuayA+IDEgPyBgZGF0YUluZGljZXMke3h9WyR7aX1dYCA6IGBkYXRhSW5kaWNlcyR7eH1gfSA9ICR7XG4gICAgICAgICAgICAgIG91dHB1dFNoYXBlLmxlbmd0aCA+IDEgPyBgb3V0cHV0SW5kaWNlcyR7eH1bJHtqfV1gIDogYG91dHB1dEluZGljZXMke3h9YH07YDtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG4gICAgbGV0IGFzc2lnbm1lbnQ6IHN0cmluZztcbiAgICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IGBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eH11YCl9O1xuICAgICAgICAgICR7Y2FsY0RhdGFJbmRpY2VzKHgpfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHt4fSA9ICR7ZGF0YS5pbmRpY2VzVG9PZmZzZXQoYGRhdGFJbmRpY2VzJHt4fWApfTtcbiAgICAgICAgICBsZXQgaW5kZXgke3h9ID0gb2Zmc2V0JHt4fSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQke3h9ID0gb2Zmc2V0JHt4fSAlIDR1O1xuICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7ZGF0YS5nZXRCeU9mZnNldChgaW5kZXgke3h9YCl9W2NvbXBvbmVudCR7eH1dKTtcbiAgICAgICAgYDtcbiAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtjb21wb25lbnRzfTtcbiAgICAgICAgdmFyIHZhbHVlID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMCwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMSwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMiwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ3ZhbHVlJywgMywgJ3UzMicpfVxuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICAgICAgYDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgJHtjYWxjRGF0YUluZGljZXMoJycpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7ZGF0YS5nZXRCeUluZGljZXMoJ2RhdGFJbmRpY2VzJyl9O1xuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XG4gICAgICBgO1xuICAgIH1cbiAgICByZXR1cm4gYFxuICAgICAgJHtcbiAgICAgICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxuICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXG4gICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdheGlzJywgJ3UzMicpXG4gICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhkYXRhLCBpbmRpY2VzLCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgJHthc3NpZ25tZW50fVxuICAgICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dhdGhlcicsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnXX0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdhdGhlckF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2F4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXJ9KTtcblxuZXhwb3J0IGNvbnN0IGdhdGhlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBjb25zdCBpbnB1dE91dHB1dERhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICAgICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3QgaW5kaWNlc0RhdGFUeXBlID0gaW5wdXRzWzFdLmRhdGFUeXBlO1xuICAgICAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRSYW5rKTtcbiAgICAgIGNvbnN0IGF4aXNEaW1MaW1pdCA9IGlucHV0U2hhcGVbYXhpc107XG5cbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5kaWNlc1NoYXBlLnNsaWNlKDApO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcblxuICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0T3V0cHV0RGF0YVR5cGUsIGlucHV0UmFuayk7XG4gICAgICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5kaWNlc0lucHV0JywgaW5kaWNlc0RhdGFUeXBlLCBpbmRpY2VzU2hhcGUubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dE91dHB1dERhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuXG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXhpc0RpbUxpbWl0fSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpc31cbiAgICAgIF07XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBpbmRpY2VzU2hhcGUsIG91dHB1dFNoYXBlKSk7XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG5cbiAgICAgIC8vIGludDY0IGluZGljZXMgd291bGQgYmUgdHJlYXRlZCBhcyBsaXR0bGUgZW5kaWFuIGkzMiB3aXRoIGFzc3VtcHRpb24gdGhleSBmYWxsIGluIGkzMiBsaW1pdHNcbiAgICAgIC8vIFRoYXQgYXNzdW1wdGlvbiBpcyBzYWZlIGFzIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGFsbG9jYXRlID4yZ2IgYnVmZmVyIGZvciBpbnB1dCB0ZW5zb3JcbiAgICAgIC8vIElucHV0IGRhdGEgd2lsbCBiZSB0cmVhdGVkIGFzIHUzMiBvciB0d28gdTMyIGZvciA4LWJ5dGUgdGVuc29yc1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke1xuICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXG4gICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGluZGljZXMsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgIHZhciBpZHggPSAke2luZGljZXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtpbnB1dC50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaWR4KScpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dEluZGljZXMnKX07XG5cbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xuICB9YDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0dhdGhlckVsZW1lbnRzJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlcn0pO1xuXG5leHBvcnQgY29uc3QgZ2F0aGVyRWxlbWVudHMgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdhdGhlckVsZW1lbnRzUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtHZW1tVXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgaXMgbWlzc2luZycpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgMiB8fCBpbnB1dHMubGVuZ3RoID4gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWlkIGlucHV0IG51bWJlci4nKTtcbiAgfVxuXG4gIC8vICdDJyBjYW4gYmUgb2YgZGltZW5zaW9uYWxpdHkgMCwgMSBvciAyIG9ubHlcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLmRpbXMubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDJyk7XG4gIH1cblxuICBpZiAoKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzFdLmRhdGFUeXBlKSB8fFxuICAgICAgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMl0uZGF0YVR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZCcpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEdlbW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgdHJhbnNBOiBib29sZWFuO1xuICB0cmFuc0I6IGJvb2xlYW47XG4gIGFscGhhOiBudW1iZXI7XG4gIGJldGE6IG51bWJlcjtcbn1cblxuY29uc3QgY3JlYXRlR2VtbVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHZW1tQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcbiAgY29uc3QgW00sIE4sIEtdID0gR2VtbVV0aWwuZ2V0U2hhcGVPZkdlbW1SZXN1bHQoXG4gICAgICBhU2hhcGUsIGF0dHJpYnV0ZXMudHJhbnNBLCBiU2hhcGUsIGF0dHJpYnV0ZXMudHJhbnNCLCBpbnB1dHMubGVuZ3RoID09PSAzID8gaW5wdXRzWzJdLmRpbXMgOiB1bmRlZmluZWQpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtNLCBOXTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICB9XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE59LFxuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEt9LCB7dHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGF9LFxuICAgIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5iZXRhfVxuICBdO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBsZXQgbGluZSA9ICcnO1xuICAgIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW24gKiB1bmlmb3Jtcy5LICsga107JztcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07JztcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW24gKiB1bmlmb3Jtcy5LICsga107JztcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltrICogdW5pZm9ybXMuTiArIG5dOyc7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsY3VsYXRlQWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhID09PSAxID8gJycgOiAndmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7JztcbiAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMpO1xuICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcyk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBhLnR5cGUudmFsdWU7XG4gICAgbGV0IGM6IEluZGljZXNIZWxwZXJ8bnVsbCA9IG51bGw7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW2EsIGJdO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBjID0gaW5wdXRWYXJpYWJsZSgnYycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dCk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAge25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdNJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ04nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnSycsIHR5cGU6ICd1MzInfSxcbiAgICAgIHtuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJ30sIHtuYW1lOiAnYmV0YScsIHR5cGU6ICdmMzInfVxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICBsZXQgbSA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5OO1xuICAgIGxldCBuID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLk47XG5cbiAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgwKTtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgJHtsaW5lfVxuICAgIH1cblxuICAgICR7Y2FsY3VsYXRlQWxwaGF9XG4gICAgJHsoKCkgPT4ge1xuICAgICAgaWYgKGMgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYGxldCBjT2Zmc2V0ID0gJHtjLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCd2ZWMyKG0sIG4pJywgb3V0cHV0KX07IHZhbHVlICs9ICR7XG4gICAgICAgICAgICBkYXRhVHlwZX0odW5pZm9ybXMuYmV0YSkgKiAke2MuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9KSgpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHZW1tJyxcbiAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2VtbUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBHZW1tQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHRyYW5zQSA9IGF0dHJpYnV0ZXMudHJhbnNBIGFzIGJvb2xlYW47XG4gIGNvbnN0IHRyYW5zQiA9IGF0dHJpYnV0ZXMudHJhbnNCIGFzIGJvb2xlYW47XG4gIGNvbnN0IGFscGhhID0gYXR0cmlidXRlcy5hbHBoYSBhcyBudW1iZXI7XG4gIGNvbnN0IGJldGEgPSBhdHRyaWJ1dGVzLmJldGEgYXMgbnVtYmVyO1xuICByZXR1cm4ge3RyYW5zQSwgdHJhbnNCLCBhbHBoYSwgYmV0YSwgY2FjaGVLZXk6IGAke2F0dHJpYnV0ZXMudHJhbnNBfTske2F0dHJpYnV0ZXMudHJhbnNCfTske2F0dHJpYnV0ZXMuYWxwaGEgPT09IDF9YH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2VtbSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2VtbVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Y3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgR3B1RGF0YVR5cGUsIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7YXBwbHlBdHRlbnRpb24sIEF0dGVudGlvbkF0dHJzLCBBdHRlbnRpb25NYXNrVHlwZSwgQXR0ZW50aW9uUGFyYW1ldGVycywgQXR0ZW50aW9uUWt2Rm9ybWF0fSBmcm9tICcuL2F0dGVudGlvbic7XG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge2NyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IGdldElucHV0ID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBpOiBudW1iZXIpID0+XG4gICAgKGlucHV0cy5sZW5ndGggPiBpKSAmJiAoaW5wdXRzW2ldLmRpbXMubGVuZ3RoID4gMCkgJiYgKFNoYXBlVXRpbC5zaXplKGlucHV0c1tpXS5kaW1zKSkgPiAwID8gaW5wdXRzW2ldIDogdW5kZWZpbmVkO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcbiAgY29uc3QgcXVlcnkgPSBpbnB1dHNbMF07XG4gIGNvbnN0IGtleSA9IGdldElucHV0KGlucHV0cywgMSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0SW5wdXQoaW5wdXRzLCAyKTtcbiAgY29uc3QgYmlhcyA9IGdldElucHV0KGlucHV0cywgMyk7XG4gIGNvbnN0IGtleVBhZGRpbmdNYXNrID0gZ2V0SW5wdXQoaW5wdXRzLCA0KTtcbiAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbkJpYXMgPSBnZXRJbnB1dChpbnB1dHMsIDUpO1xuICBjb25zdCBwYXN0S2V5ID0gZ2V0SW5wdXQoaW5wdXRzLCA2KTtcbiAgY29uc3QgcGFzdFZhbHVlID0gZ2V0SW5wdXQoaW5wdXRzLCA3KTtcblxuICAvLyBBYmJyZXZpYXRpb24gYW5kIE1lYW5pbmdzOlxuICAvLyAgIEI6ICAgIGJhdGNoX3NpemVcbiAgLy8gICBTOiAgICBzZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBxdWVyeSlcbiAgLy8gICBQOiAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCAocGFzdCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIEw6ICAgIGt2X3NlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBNOiAgICBtYXhfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgVDogICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBrdl9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBOOiAgICBudW1faGVhZHNcbiAgLy8gICBIOiAgICBoZWFkIHNpemUgZm9yIFEgYW5kIEssIGFrYSBxX2hlYWRfc2l6ZSBvciBrX2hlYWRfc2l6ZSBvciBxa19oZWFkX3NpemVcbiAgLy8gICBIX3Y6ICB2X2hlYWRfc2l6ZVxuICAvLyAgIERfaTogIGlucHV0IGhpZGRlbiBzaXplXG4gIC8vICAgRDogICAgaGlkZGVuIHNpemUgZm9yIFEgYW5kIEsgKEQgPSBOICogSCksIGFrYSBxX2hpZGRlbl9zaXplIG9yIGtfaGlkZGVuX3NpemUgb3IgcWtfaGlkZGVuX3NpemVcbiAgLy8gICBEX3Y6ICB2X2hpZGRlbl9zaXplID0gbnVtX2hlYWRzICogdl9oZWFkX3NpemVcblxuICAvLyAgICAga2V5X3BhZGRpbmdfbWFzayAoSy9WKSAgICAgOiAoQikgb3IgKDIqQiArIDEpIG9yIChCLCBMKSBvciBOb25lXG4gIC8vICAgICByZWxhdGl2ZV9wb3NpdGlvbl9iaWFzICAgICA6IChCLCAxLCBTLCBMKVxuICAvLyAgICAgcGFzdF9rZXkgICAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUyosIEgpXG4gIC8vICAgICBwYXN0X3ZhbHVlICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcbiAgLy8gV2hlbiBubyBwYWNraW5nIGZvciBxL2svdjpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIFMsIEQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IChCLCBMLCBEKSBvciAoQiwgTiwgUyosIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBMLCBEX3YpIG9yIChCLCBOLCBTKiwgSClcbiAgLy8gICAgIGJpYXMgICAgICAgICAgICAgKFEvSy9WKSAgIDogKEQgKyBEICsgRF92KVxuICAvLyBXaGVuIHBhY2tlZCBrdiBpcyB1c2VkOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIE4sIDIsIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcbiAgLy8gICAgIGJpYXMgICAgICAgICAgICAgKFEvSy9WKSAgIDogTm9uZVxuICAvLyBXaGVuIHBhY2tlZCBxa3YgaXMgdXNlZDpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIEwsIE4sIDMsIEgpIG9yIChCLCBTLCAzKkQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IE5vbmVcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogTm9uZVxuICAvLyAgICAgYmlhcyAgICAgICAgICAgICAoUS9LL1YpICAgOiBOb25lIG9yIChEICsgRCArIERfdilcblxuICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGNvbnN0IGRtbWhhUGFja2luZyA9IGZhbHNlO1xuICBjb25zdCBiYXRjaFNpemUgPSBxdWVyeS5kaW1zWzBdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IHF1ZXJ5LmRpbXNbMV07XG4gIGNvbnN0IGhpZGRlblNpemUgPSBxdWVyeS5kaW1zLmxlbmd0aCA9PT0gMyA/IChkbW1oYVBhY2tpbmcgPyBxdWVyeS5kaW1zWzJdIC8gMyA6IHF1ZXJ5LmRpbXNbMl0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5udW1IZWFkcyAqIHF1ZXJ5LmRpbXNbNF07XG4gIGxldCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XG5cbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGxldCBtYXhTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGNvbnN0IGhlYWRTaXplID0gTWF0aC5mbG9vcihoaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyk7XG4gIGlmIChwYXN0S2V5ICYmIHBhc3RWYWx1ZSkge1xuICAgIGlmIChwYXN0S2V5LmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocGFzdEtleS5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHwgcGFzdEtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHBhc3RLZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7XG4gICAgfVxuICAgIGlmIChwYXN0VmFsdWUuZGltc1swXSAhPT0gYmF0Y2hTaXplIHx8IHBhc3RWYWx1ZS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8XG4gICAgICAgIHBhc3RWYWx1ZS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO1xuICAgIH1cbiAgICBpZiAocGFzdEtleS5kaW1zWzJdICE9PSBwYXN0VmFsdWUuZGltc1syXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAocGFzdF9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICAgIGlmIChwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xuICAgIG1heFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xuICB9IGVsc2UgaWYgKHBhc3RLZXkgfHwgcGFzdFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO1xuICB9XG5cbiAgbGV0IHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xuICBpZiAoa2V5KSB7XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoIDwgMyB8fCBrZXkuZGltcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IGtleS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBxdWVyeS5kaW1zWzJdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAoaGlkZGVuX3NpemUpJyk7XG4gICAgICB9XG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOSDtcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2UgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSAyIHx8IGtleS5kaW1zWzRdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO1xuICAgICAgfVxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFLdkJTTkh4QlNOMkg7XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIHsgIC8vIGtleV9kaW1zLnNpemUoKSA9PSA0IChjcm9zcy1hdHRlbnRpb24gd2l0aCBwYXN0X2tleSlcbiAgICAgIGlmIChrZXkuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC51bmtub3duO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzJdO1xuICAgIH1cbiAgfSBlbHNlIHsgIC8vIHBhY2tlZCBRS1ZcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1ICYmIChxdWVyeS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHF1ZXJ5LmRpbXNbM10gIT09IDMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcbiAgICB9XG5cbiAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOM0g7XG4gIH1cblxuICBpZiAoYmlhcykge1xuICAgIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCA9PT0gNSAmJiBxdWVyeS5kaW1zWzNdID09PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2LicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBtYXNrVHlwZTogQXR0ZW50aW9uTWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xuICBpZiAoa2V5UGFkZGluZ01hc2spIHtcbiAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2tVbmtub3duO1xuICAgIGNvbnN0IG1hc2tEaW1zID0ga2V5UGFkZGluZ01hc2suZGltcztcbiAgICBpZiAobWFza0RpbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobWFza0RpbXNbMF0gPT09IGJhdGNoU2l6ZSkge1xuICAgICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2sxZEtleVNlcUxlbjtcbiAgICAgIH0gZWxzZSBpZiAobWFza0RpbXNbMF0gPT09IDMgKiBiYXRjaFNpemUgKyAyKSB7XG4gICAgICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFzazFES2V5U2VxTGVuU3RhcnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYXNrRGltcy5sZW5ndGggPT09IDIgJiYgbWFza0RpbXNbMF0gPT09IGJhdGNoU2l6ZSAmJiBtYXNrRGltc1sxXSA9PT0ga3ZTZXF1ZW5jZUxlbmd0aCkge1xuICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMmRLZXlQYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobWFza1R5cGUgPT09IEF0dGVudGlvbk1hc2tUeXBlLm1hc2tVbmtub3duKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5X3BhZGRpbmdfbWFza1wiIHNoYXBlIHNoYWxsIGJlIChiYXRjaF9zaXplKSBvciAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hc2sgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgbGV0IHBhc3NQYXN0SW5LdiA9IGZhbHNlO1xuICBsZXQgdkhpZGRlblNpemUgPSBoaWRkZW5TaXplO1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggIT09IDMgJiYgdmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0gdmFsdWUuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1sxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzJdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMV0gKiB2YWx1ZS5kaW1zWzNdO1xuICAgICAgcGFzc1Bhc3RJbkt2ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsga3ZTZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgYnJvYWRjYXN0UmVzUG9zQmlhcyA9IGZhbHNlO1xuXG4gIGlmIChrZXlQYWRkaW5nTWFzaykge1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IHBhZGRpbmcgbWFzayBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBpZiAocmVsYXRpdmVQb3NpdGlvbkJpYXMpIHtcbiAgICBpZiAocmVsYXRpdmVQb3NpdGlvbkJpYXMuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJyZWxhdGl2ZV9wb3NpdGlvbl9iaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKChyZWxhdGl2ZVBvc2l0aW9uQmlhcy5kaW1zWzBdICE9PSBiYXRjaFNpemUgJiYgcmVsYXRpdmVQb3NpdGlvbkJpYXMuZGltc1swXSAhPT0gMSkgfHxcbiAgICAgICAgcmVsYXRpdmVQb3NpdGlvbkJpYXMuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCByZWxhdGl2ZVBvc2l0aW9uQmlhcy5kaW1zWzJdICE9PSBzZXF1ZW5jZUxlbmd0aCB8fFxuICAgICAgICByZWxhdGl2ZVBvc2l0aW9uQmlhcy5kaW1zWzNdICE9PSB0b3RhbFNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicmVsYXRpdmVfcG9zaXRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCAxLCBzZXF1ZW5jZV9sZW5ndGgsIGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZTogMCxcbiAgICBoaWRkZW5TaXplLFxuICAgIHZIaWRkZW5TaXplLFxuICAgIGhlYWRTaXplLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxuICAgIGlzVW5pZGlyZWN0aW9uYWw6IGZhbHNlLFxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxuICAgIG1hc2tGaWx0ZXJWYWx1ZTogYXR0cmlidXRlcy5tYXNrRmlsdGVyVmFsdWUsXG4gICAgbWFza1R5cGUsXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgYnJvYWRjYXN0UmVzUG9zQmlhcyxcbiAgICBwYXNzUGFzdEluS3YsXG4gICAgcWt2Rm9ybWF0LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlTXVsdGlIZWFkQXR0ZW50aW9uQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvbkF0dHJzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsuLi5hdHRyaWJ1dGVzfSk7XG5cbmNvbnN0IHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZTogVHJhbnNwb3NlQXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7cGVybTogWzAsIDIsIDEsIDNdfSk7XG5cbmNvbnN0IGFkZEJpYXNUcmFuc3Bvc2UgPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgcWt2OiBUZW5zb3JWaWV3LCBiaWFzOiBUZW5zb3JWaWV3LCBiYXRjaFNpemU6IG51bWJlciwgc2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbiAgICAgaGlkZGVuU2l6ZTogbnVtYmVyLCBiaWFzT2Zmc2V0OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIGhpZGRlblNpemVdO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJpYXNPZmZzZXR9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBoaWRkZW5TaXplfVxuICAgICAgXTtcblxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdxa3Zfd2l0aF9iaWFzJywgcWt2LmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgICAgIGNvbnN0IHFrdklucHV0ID0gaW5wdXRWYXJpYWJsZSgncWt2JywgcWt2LmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgICAgIGNvbnN0IGJpYXNJbnB1dCA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG5cbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICAgIHtuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnYmlhc19vZmZzZXQnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhxa3ZJbnB1dCwgYmlhc0lucHV0LCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIGxldCBiaWFzX29mZnNldF9pZHggPSAoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLmhpZGRlbl9zaXplKSArIHVuaWZvcm1zLmJpYXNfb2Zmc2V0O1xuXG4gICAgcWt2X3dpdGhfYmlhc1tnbG9iYWxfaWR4XSA9IHFrdltnbG9iYWxfaWR4XSArIGJpYXNbYmlhc19vZmZzZXRfaWR4XTtcbiAgfWA7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdNdWx0aUhlYWRBdHRlbnRpb25BZGRCaWFzJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZScsICd0eXBlJ119LFxuICAgICAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHFrdi5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHR9XSxcbiAgICAgICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtpbnB1dHM6IFtxa3YsIGJpYXNdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBiYXRjaFNpemU6IG51bWJlciwgbnVtSGVhZHM6IG51bWJlciwgc2VxdWVuY2VMZW5ndGg6IG51bWJlciwgaGVhZFNpemU6IG51bWJlcixcbiAgICAgaW5wdXQ6IFRlbnNvclZpZXcsIGJpYXM/OiBUZW5zb3JWaWV3LCBiaWFzT2Zmc2V0PzogbnVtYmVyKSA9PiB7XG4gICAgICAvLyBjb25zdCBuZXdEaW1zID0gW107XG5cbiAgICAgIGxldCByZXNoYXBlZElucHV0ID0gaW5wdXQ7XG4gICAgICBpZiAoIWJpYXMpIHtcbiAgICAgICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgcmVzaGFwZWRJbnB1dCA9IGlucHV0LnJlc2hhcGUoW2JhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIG51bUhlYWRzLCBoZWFkU2l6ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgICBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUucGVybSksXG4gICAgICAgICAgICB7aW5wdXRzOiBbcmVzaGFwZWRJbnB1dF0sIG91dHB1dHM6IFstMV19KVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzZXF1ZW5jZUxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzaGFwZWRJbnB1dCA9XG4gICAgICAgICAgICAgIGFkZEJpYXNUcmFuc3Bvc2UoY29udGV4dCwgaW5wdXQsIGJpYXMsIGJhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIG51bUhlYWRzICogaGVhZFNpemUsIGJpYXNPZmZzZXQhKTtcbiAgICAgICAgICByZXNoYXBlZElucHV0ID0gcmVzaGFwZWRJbnB1dC5yZXNoYXBlKFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBudW1IZWFkcywgaGVhZFNpemVdKTtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgICAgICBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUucGVybSksXG4gICAgICAgICAgICAgIHtpbnB1dHM6IFtyZXNoYXBlZElucHV0XSwgb3V0cHV0czogWy0xXX0pWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IG11bHRpSGVhZEF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiB2b2lkID0+IHtcbiAgY29uc3QgcGFyYW1zID0gdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBxdWVyeSA9IGNvbnRleHQuaW5wdXRzWzBdO1xuICBjb25zdCBrZXkgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDIpO1xuICBjb25zdCBiaWFzID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDMpO1xuICBjb25zdCBrZXlQYWRkaW5nTWFzayA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA0KTtcbiAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbkJpYXMgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNSk7XG4gIGNvbnN0IHBhc3RLZXkgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgNik7XG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA3KTtcbiAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgaWYgKGtleT8uZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8vIGFwcGx5QXR0ZW50aW9uIGV4cGVjdHMgQk5TSCBpbnB1dHNcbiAgY29uc3Qga3ZCTlNIID0ga2V5ICYmIHZhbHVlICYmIGtleS5kaW1zLmxlbmd0aCA9PT0gNCAmJiB2YWx1ZS5kaW1zLmxlbmd0aCA9PT0gNDtcblxuICBjb25zdCBRID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxuICAgICAgY29udGV4dCwgcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLm51bUhlYWRzLCBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsIHBhcmFtcy5oZWFkU2l6ZSwgcXVlcnksIGJpYXMsIDApO1xuXG4gIGlmIChrdkJOU0gpIHtcbiAgICByZXR1cm4gYXBwbHlBdHRlbnRpb24oXG4gICAgICAgIGNvbnRleHQsIFEsIGtleSwgdmFsdWUsIGtleVBhZGRpbmdNYXNrLCB1bmRlZmluZWQsIHBhc3RLZXksIHBhc3RWYWx1ZSwgcmVsYXRpdmVQb3NpdGlvbkJpYXMsIHBhcmFtcyxcbiAgICAgICAgYXR0cmlidXRlcyk7XG4gIH1cbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgfVxuICBjb25zdCBLID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxuICAgICAgY29udGV4dCwgcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLm51bUhlYWRzLCBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLmhlYWRTaXplLCBrZXksIGJpYXMsXG4gICAgICBwYXJhbXMuaGlkZGVuU2l6ZSk7XG5cbiAgY29uc3QgViA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICAgIGNvbnRleHQsIHBhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy5udW1IZWFkcywgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGgsIHBhcmFtcy52SGVhZFNpemUsIHZhbHVlLCBiaWFzLFxuICAgICAgMiAqIHBhcmFtcy5oaWRkZW5TaXplKTtcblxuICBhcHBseUF0dGVudGlvbihcbiAgICAgIGNvbnRleHQsIFEsIEssIFYsIGtleVBhZGRpbmdNYXNrLCB1bmRlZmluZWQsIHBhc3RLZXksIHBhc3RWYWx1ZSwgcmVsYXRpdmVQb3NpdGlvbkJpYXMsIHBhcmFtcywgYXR0cmlidXRlcyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgZ2V0UmVwZWF0cyA9IChyZXBlYXRzVGVuc29yVmlldzogVGVuc29yVmlldyk6IHJlYWRvbmx5IG51bWJlcltdID0+XG4gICAgQXJyYXkuZnJvbShyZXBlYXRzVGVuc29yVmlldy5nZXRCaWdJbnQ2NEFycmF5KCksIE51bWJlcik7XG5cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0ICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQxNiAmJlxuICAgICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQzMiAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLnVpbnQzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBvbmx5IHN1cHBvcnQgZmxvYXQsIGZsb2F0MTYsIGludDMyLCBhbmQgdWludDMyIGRhdGEgdHlwZXMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDY0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EJyk7XG4gIH1cblxuICBjb25zdCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSA9IGdldFJlcGVhdHMoaW5wdXRzWzFdKTtcblxuICBpZiAocmVwZWF0cy5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvcicpO1xuICB9XG59O1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcmVwZWF0czogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIG91dHB1dFNoYXBlLnB1c2goaW5wdXRTaGFwZVtpXSAqIHJlcGVhdHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dFNoYXBlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgc2hhcGU/OiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSA9IHNoYXBlID09IG51bGwgPyBnZXRSZXBlYXRzKGlucHV0c1sxXSkgOiBzaGFwZTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCByZXBlYXRzKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcblxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSAke2lucHV0LmluZGljZXMoLi4uaW5wdXRTaGFwZSl9O1xuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtpbnB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICBsZXQgaW5wdXRfZGltX2kgPSAke2lucHV0LmluZGljZXNHZXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9ICAlIGlucHV0X2RpbV9pO1xuXG4gICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2RpbV92YWx1ZScpfVxuICAgICAgfVxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKSl9XG4gICAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnVGlsZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtyZXBlYXRzfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXX0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6XG4gICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpXSxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdGlsZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUaWxlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpLCB7aW5wdXRzOiBbMF19KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7YXBwbHlBdHRlbnRpb24sIEF0dGVudGlvbkF0dHJzLCBBdHRlbnRpb25NYXNrVHlwZSwgQXR0ZW50aW9uUGFyYW1ldGVycywgQXR0ZW50aW9uUWt2Rm9ybWF0fSBmcm9tICcuL2F0dGVudGlvbic7XG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHttYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXN9IGZyb20gJy4vbXVsdGloZWFkLWF0dGVudGlvbic7XG5pbXBvcnQge2NyZWF0ZVRpbGVQcm9ncmFtSW5mb30gZnJvbSAnLi90aWxlJztcbmltcG9ydCB7Y3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8sIFRyYW5zcG9zZUF0dHJpYnV0ZXN9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gaW5wdXRzWzFdO1xuICBjb25zdCB2YWx1ZSA9IGlucHV0c1syXTtcbiAgY29uc3QgcGFzdEtleSA9IGlucHV0c1szXTtcbiAgY29uc3QgcGFzdFZhbHVlID0gaW5wdXRzWzRdO1xuXG4gIC8vIEFiYnJldmlhdGlvbiBhbmQgTWVhbmluZ3M6XG4gIC8vICAgQjogICAgYmF0Y2hfc2l6ZVxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxuICAvLyAgIFA6ICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIChwYXN0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTDogICAga3Zfc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBUOiAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBwYXN0X3NlcXVlbmNlX2xlbmd0aCArIGt2X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIE46ICAgIG51bV9oZWFkc1xuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxuICAvLyAgIEhfdjogIHZfaGVhZF9zaXplXG4gIC8vICAgRF9pOiAgaW5wdXQgaGlkZGVuIHNpemVcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxuICAvLyAgIERfdjogIHZfaGlkZGVuX3NpemUgPSBudW1faGVhZHMgKiB2X2hlYWRfc2l6ZVxuXG4gIC8vICAgICBwYXN0X2tleSAgICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcbiAgLy8gICAgIHBhc3RfdmFsdWUgICAgICAgICAgICAgICAgIDogKEIsIE4sIFMqLCBIKVxuICAvLyBXaGVuIG5vIHBhY2tpbmcgZm9yIHEvay92OlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIEQpIG9yIChCLCBOLCBTKiwgSClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIEwsIERfdikgb3IgKEIsIE4sIFMqLCBIKVxuICAvLyBXaGVuIHBhY2tlZCBrdiBpcyB1c2VkOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIE4sIDIsIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcbiAgLy8gV2hlbiBwYWNrZWQgcWt2IGlzIHVzZWQ6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBMLCBOLCAzLCBIKSBvciAoQiwgUywgMypEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiBOb25lXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcblxuICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGNvbnN0IGRtbWhhUGFja2luZyA9IGZhbHNlO1xuICBjb25zdCBiYXRjaFNpemUgPSBxdWVyeS5kaW1zWzBdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IHF1ZXJ5LmRpbXNbMV07XG4gIGNvbnN0IGhpZGRlblNpemUgPSBxdWVyeS5kaW1zLmxlbmd0aCA9PT0gMyA/IChkbW1oYVBhY2tpbmcgPyBxdWVyeS5kaW1zWzJdIC8gMyA6IHF1ZXJ5LmRpbXNbMl0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5udW1IZWFkcyAqIHF1ZXJ5LmRpbXNbNF07XG4gIGxldCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XG5cbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGxldCBtYXhTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGNvbnN0IGhlYWRTaXplID0gTWF0aC5mbG9vcihoaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyk7XG4gIGNvbnN0IGhhc1Bhc3RLZXkgPSBwYXN0S2V5ICYmIHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDA7XG4gIGNvbnN0IGhhc1Bhc3RWYWx1ZSA9IHBhc3RWYWx1ZSAmJiBwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDA7XG4gIC8vIFRPRE8gOiB0aGlzIHNob3VsZCBiZSBmcm9tIGF0dHJpYnV0ZXMuXG4gIGNvbnN0IGlzUGFzdGt2QlNOSCA9IHRydWU7XG4gIGlmIChoYXNQYXN0S2V5ICYmIGhhc1Bhc3RWYWx1ZSkge1xuICAgIGlmIChwYXN0S2V5LmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocGFzdFZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChpc1Bhc3RrdkJTTkgpIHtcbiAgICAgIC8vIEZvciBCU05IXG4gICAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMV07XG4gICAgICBtYXhTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIEJOU0hcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1syXTtcbiAgICAgIG1heFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoYXNQYXN0S2V5IHx8IGhhc1Bhc3RWYWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtcbiAgfVxuXG4gIGxldCBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdDtcbiAgaWYgKGtleSkge1xuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtcbiAgICB9XG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA8IDMgfHwga2V5LmRpbXMubGVuZ3RoID4gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSBrZXkuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO1xuICAgIH1cblxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChxdWVyeS5kaW1zWzJdICUga2V5LmRpbXNbMl0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO1xuICAgICAgfVxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTkg7XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gMiB8fCBrZXkuZGltc1s0XSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTtcbiAgICAgIH1cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xS3ZCU05IeEJTTjJIO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSB7ICAvLyBrZXlfZGltcy5zaXplKCkgPT0gNCAoY3Jvc3MtYXR0ZW50aW9uIHdpdGggcGFzdF9rZXkpXG4gICAgICBpZiAoa2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwga2V5LmRpbXNbM10gIT09IGhlYWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO1xuICAgICAgfVxuXG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQudW5rbm93bjtcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1syXTtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBwYWNrZWQgUUtWXG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzICYmIHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCA9PT0gNSAmJiAocXVlcnkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBxdWVyeS5kaW1zWzNdICE9PSAzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XG4gICAgfVxuXG4gICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTjNIO1xuICB9XG5cbiAgY29uc3QgbWFza1R5cGU6IEF0dGVudGlvbk1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubm9uZTtcbiAgbGV0IHBhc3NQYXN0SW5LdiA9IGZhbHNlO1xuICBsZXQgdkhpZGRlblNpemUgPSBoaWRkZW5TaXplO1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggIT09IDMgJiYgdmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0gdmFsdWUuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1sxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzJdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMV0gKiB2YWx1ZS5kaW1zWzNdO1xuICAgICAgcGFzc1Bhc3RJbkt2ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIGt2U2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IGJyb2FkY2FzdFJlc1Bvc0JpYXMgPSBmYWxzZTtcblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZTogMCxcbiAgICBoaWRkZW5TaXplLFxuICAgIHZIaWRkZW5TaXplLFxuICAgIGhlYWRTaXplLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyEpLFxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxuICAgIGt2TnVtSGVhZHM6IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyxcbiAgICBuUmVwczogYXR0cmlidXRlcy5udW1IZWFkcyAvIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyEsXG4gICAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogZmFsc2UsXG4gICAgbWFza1R5cGUsXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgYnJvYWRjYXN0UmVzUG9zQmlhcyxcbiAgICBwYXNzUGFzdEluS3YsXG4gICAgcWt2Rm9ybWF0LFxuICAgIGlzUGFzdGt2QlNOSCxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvID1cbiAgICAoYTogVGVuc29yVmlldywgYjogVGVuc29yVmlld3x1bmRlZmluZWQsIGRhdGFUeXBlOiBEYXRhVHlwZSwgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLnRvdGFsU2VxdWVuY2VMZW5ndGgsIHBhcmFtcy5rdk51bUhlYWRzISwgcGFyYW1zLmhlYWRTaXplXTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IDQ7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50O1xuICAgICAgY29uc3QgcHJlc2VudFNlcXVlbmNlTGVuZ3RoID0gcGFyYW1zLnRvdGFsU2VxdWVuY2VMZW5ndGg7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncHJlc2VudF9rdicsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudCk7XG4gICAgICBjb25zdCBpbnB1dEEgPSBpbnB1dFZhcmlhYmxlKCduZXdfa3YnLCBhLmRhdGFUeXBlLCBhLmRpbXMubGVuZ3RoLCBjb21wb25lbnQpO1xuICAgICAgY29uc3QgaW5wdXRCID0gYiA/IGlucHV0VmFyaWFibGUoJ3Bhc3Rfa3YnLCBiLmRhdGFUeXBlLCBiLmRpbXMubGVuZ3RoLCBjb21wb25lbnQpIDogdW5kZWZpbmVkO1xuXG4gICAgICBjb25zdCBIID0gTWF0aC5jZWlsKHBhcmFtcy5oZWFkU2l6ZSAvIGNvbXBvbmVudCk7XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IHt4OiBwcmVzZW50U2VxdWVuY2VMZW5ndGgsIHk6IGEuZGltc1swXSwgejogMX07XG5cbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gYiA/IFsncmFuaycsICdyYW5rJ10gOiBbJ3JhbmsnXTtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLnBhc3RTZXF1ZW5jZUxlbmd0aH0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RofSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLnRvdGFsU2VxdWVuY2VMZW5ndGh9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBpbnB1dHMgPSBbaW5wdXRBXTtcbiAgICAgIGlmIChpbnB1dEIpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXG4gICAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhhLmRpbXMpLCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiIS5kaW1zKSxcbiAgICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG4gICAgICAgIGlucHV0cy5wdXNoKGlucHV0Qik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhhLmRpbXMpLCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICB7bmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ3Bhc3Rfc2VxbGVuJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ25ld19zZXFsZW4nLCB0eXBlOiAndTMyJ30sXG4gICAgICAgIHtuYW1lOiAncHJlc2VudF9zZXFsZW4nLCB0eXBlOiAndTMyJ31cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHBhc3RTdHIgPSBgICAgICAgbGV0IHBhc3RfYmF0Y2hfc3RyaWRlID0gdW5pZm9ybXMucGFzdF9zZXFsZW4gKiBudW1faGVhZHMgKiBIO1xuICAgICAgICB2YXIgcGFzdF9oZWFkX3N0cmlkZSA9IHVuaWZvcm1zLnBhc3Rfc2VxbGVuICogSDtcbiAgICAgICAgaWYgKGlzX2JzbmgpIHtcbiAgICAgICAgICBwYXN0X2hlYWRfc3RyaWRlID0gSDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5fb2Zmc2V0ID0gYiAqIHBhc3RfYmF0Y2hfc3RyaWRlICsgcyAqIHJvd19zdHJpZGUgKyBuICogcGFzdF9oZWFkX3N0cmlkZSArIGg7XG4gICAgICAgIHByZXNlbnRfa3Zbb3V0X29mZnNldF0gPSBwYXN0X2t2W2luX29mZnNldF07YDtcbiAgICAgIGNvbnN0IG5ld1N0ciA9IGAgICAgICBsZXQgbmV3X2JhdGNoX3N0cmlkZSA9IHVuaWZvcm1zLm5ld19zZXFsZW4gKiBudW1faGVhZHMgKiBIO1xuICAgICAgICBsZXQgbmV3X3Jvd19zdHJpZGUgPSBudW1faGVhZHMgKiBIO1xuICAgICAgICBsZXQgbmV3X2hlYWRfc3RyaWRlID0gSDtcbiAgICAgICAgbGV0IGluX29mZnNldCA9IGIgKiBuZXdfYmF0Y2hfc3RyaWRlICsgKHMgLSBwYXN0X3NlcWxlbikgKiBuZXdfcm93X3N0cmlkZSArIG4gKiBuZXdfaGVhZF9zdHJpZGUgKyBoO1xuICAgICAgICBwcmVzZW50X2t2W291dF9vZmZzZXRdID0gbmV3X2t2W2luX29mZnNldF07YDtcbiAgICAgIGNvbnN0IGNvbmNhdFN0ciA9IGIgPyBgaWYgKHMgPCBwYXN0X3NlcWxlbikge1xuICAgICAgICAke3Bhc3RTdHJ9XG4gICAgICAgIH0gZWxzZSBpZiAocyA8IHBhc3Rfc2VxbGVuICsgdW5pZm9ybXMubmV3X3NlcWxlbikge1xuICAgICAgICAke25ld1N0cn1cbiAgICAgICAgfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpZiAocyA8IHBhc3Rfc2VxbGVuICsgdW5pZm9ybXMubmV3X3NlcWxlbikge1xuICAgICAgICAgICR7bmV3U3RyfVxuICAgICAgICB9YDtcblxuICAgICAgLy8gVE9ETzogaGFuZGxlIEggKiBwYXJhbXMua3ZOdW1IZWFkcyBncmVhdGVyIHRoYW4gbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwIGxpbWl0LlxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG5cbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dHMsIG91dHB1dCl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbXG4gICAgICAgIEgsIHBhcmFtcy5rdk51bUhlYWRzISwgMVxuICAgICAgXSl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICB2YXIgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgaCA9IGxvY2FsX2lkLng7XG4gICAgbGV0IG4gPSBsb2NhbF9pZC55O1xuICAgIGxldCBzID0gd29ya2dyb3VwX2lkLng7XG4gICAgbGV0IGIgPSB3b3JrZ3JvdXBfaWQueTtcbiAgICBsZXQgbnVtX2hlYWRzID0gJHtwYXJhbXMua3ZOdW1IZWFkcyF9dTtcbiAgICBsZXQgSCA9ICR7SH11O1xuXG4gICAgbGV0IHByZXNlbnRfc2VxbGVuID0gdW5pZm9ybXMucHJlc2VudF9zZXFsZW47XG4gICAgbGV0IHByZXNlbnRfYmF0Y2hfc3RyaWRlID0gcHJlc2VudF9zZXFsZW4gKiBudW1faGVhZHMgKiBIO1xuICAgIHZhciByb3dfc3RyaWRlID0gSDtcbiAgICBsZXQgaXNfYnNuaCA9ICR7cGFyYW1zLmlzUGFzdGt2QlNOSH07XG5cbiAgICBpZiAoaXNfYnNuaCkge1xuICAgICAgcm93X3N0cmlkZSA9IG51bV9oZWFkcyAqIEg7XG4gICAgfVxuICAgIHZhciBwcmVzZW50X2hlYWRfc3RyaWRlID0gcHJlc2VudF9zZXFsZW4gKiBIO1xuICAgIGlmIChpc19ic25oKSB7XG4gICAgICBwcmVzZW50X2hlYWRfc3RyaWRlID0gSDtcbiAgICB9XG5cbiAgICBsZXQgcGFzdF9zZXFsZW4gPSB1bmlmb3Jtcy5wYXN0X3NlcWxlbjtcblxuICAgIGxldCBvdXRfb2Zmc2V0ID0gYiAqIHByZXNlbnRfYmF0Y2hfc3RyaWRlICsgcyAqIHJvd19zdHJpZGUgKyBuICogcHJlc2VudF9oZWFkX3N0cmlkZSArIGg7XG4gICAgJHtjb25jYXRTdHJ9XG4gIH1gO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnQ29uY2F0UGFzdE5ldycsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7cGFyYW1zLmt2TnVtSGVhZHMhfSR7SH0keyEhYn1gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiBkaXNwYXRjaCxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdyb3VwUXVlcnlBdHRlbnRpb25BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uQXR0cnMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoey4uLmF0dHJpYnV0ZXN9KTtcblxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtwZXJtOiBbMCwgMiwgMSwgM119KTtcblxuY29uc3QgbWF5YmVFeHBhbmRBbmRUcmFuc3Bvc2VUb0JOU0ggPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXQ6IFRlbnNvclZpZXcsIHBhc3RLVjogVGVuc29yVmlld3x1bmRlZmluZWQsIHBhcmFtczogQXR0ZW50aW9uUGFyYW1ldGVycyxcbiAgICAgb3V0cHV0SW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcbiAgICAgIGNvbnN0IG51bUhlYWRzID0gcGFyYW1zLmt2TnVtSGVhZHMhO1xuICAgICAgY29uc3QgblJlcHMgPSBwYXJhbXMublJlcHMhO1xuICAgICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoID09PSAzICYmIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJlc2hhcGVkSW5wdXQgPSBpbnB1dC5yZXNoYXBlKFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIHBhcmFtcy5oZWFkU2l6ZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFzdEtWKSB7XG4gICAgICAgIHJlc2hhcGVkSW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgICBjcmVhdGVDb25jYXRQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCBwYXN0S1YsIHJlc2hhcGVkSW5wdXQuZGF0YVR5cGUsIHBhcmFtcyksXG4gICAgICAgICAgICB7aW5wdXRzOiBbcmVzaGFwZWRJbnB1dCwgcGFzdEtWXSwgb3V0cHV0czogW3BhcmFtcy5pc1Bhc3RrdkJTTkggPyBvdXRwdXRJbmRleCA6IC0xXX0pWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzaGFwZWRJbnB1dCA9IGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgIGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHVuZGVmaW5lZCwgcmVzaGFwZWRJbnB1dC5kYXRhVHlwZSwgcGFyYW1zKSxcbiAgICAgICAgICAgIHtpbnB1dHM6IFtyZXNoYXBlZElucHV0XSwgb3V0cHV0czogW3BhcmFtcy5pc1Bhc3RrdkJTTkggPyBvdXRwdXRJbmRleCA6IC0xXX0pWzBdO1xuICAgICAgfVxuICAgICAgaWYgKG5SZXBzICE9PSAxKSB7XG4gICAgICAgIHJlc2hhcGVkSW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgICBjcmVhdGVUaWxlUHJvZ3JhbUluZm8oW3Jlc2hhcGVkSW5wdXRdLCBbMSwgMSwgMSwgblJlcHNdKSwge2lucHV0czogW3Jlc2hhcGVkSW5wdXRdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG4gICAgICAgIHJlc2hhcGVkSW5wdXQgPVxuICAgICAgICAgICAgcmVzaGFwZWRJbnB1dC5yZXNoYXBlKFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMudG90YWxTZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMgKiBuUmVwcywgcGFyYW1zLmhlYWRTaXplXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlLnBlcm0pLFxuICAgICAgICAgIHtpbnB1dHM6IFtyZXNoYXBlZElucHV0XSwgb3V0cHV0czogWy0xXX0pWzBdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBncm91cFF1ZXJ5QXR0ZW50aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IHZvaWQgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIFFLViBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LmlucHV0c1sxXT8uZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGNvbnN0IFEgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgICBjb250ZXh0LCBwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMubnVtSGVhZHMsIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLmhlYWRTaXplLCBjb250ZXh0LmlucHV0c1swXSwgdW5kZWZpbmVkLFxuICAgICAgMCk7XG4gIGNvbnN0IHBhc3RLZXkgPSBjb250ZXh0LmlucHV0c1szXSAmJiBjb250ZXh0LmlucHV0c1szXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGNvbnRleHQuaW5wdXRzWzNdIDogdW5kZWZpbmVkO1xuICBjb25zdCBwYXN0VmFsdWUgPSBjb250ZXh0LmlucHV0c1s0XSAmJiBjb250ZXh0LmlucHV0c1s0XS5kaW1zLmxlbmd0aCAhPT0gMCA/IGNvbnRleHQuaW5wdXRzWzRdIDogdW5kZWZpbmVkO1xuICBjb25zdCBLID0gbWF5YmVFeHBhbmRBbmRUcmFuc3Bvc2VUb0JOU0goY29udGV4dCwgY29udGV4dC5pbnB1dHNbMV0sIHBhc3RLZXksIHBhcmFtcywgMSk7XG4gIGNvbnN0IFYgPSBtYXliZUV4cGFuZEFuZFRyYW5zcG9zZVRvQk5TSChjb250ZXh0LCBjb250ZXh0LmlucHV0c1syXSwgcGFzdFZhbHVlLCBwYXJhbXMsIDIpO1xuICBhcHBseUF0dGVudGlvbihjb250ZXh0LCBRLCBLLCBWLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcGFyYW1zLCBhdHRyaWJ1dGVzKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBmaWxsVmVjdG9yLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBzdW1WZWN0b3IsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzIHtcbiAgZXBzaWxvbjogbnVtYmVyO1xuICBmb3JtYXQ6ICdOSFdDJ3wnTkNIVyc7XG59XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgY29uc3QgYXhpcyA9IDI7XG4gICAgICBjb25zdCBub3JtQ291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG4gICAgICBjb25zdCBub3JtU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIGF4aXMpO1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMobm9ybVNpemUpO1xuICAgICAgY29uc3Qgbm9ybVBhY2tlZFNpemUgPSBub3JtU2l6ZSAvIGNvbXBvbmVudHM7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gW3hTaGFwZVswXSwgeFNoYXBlWzFdLCBub3JtUGFja2VkU2l6ZV07XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICd0eXBlJywgJ3R5cGUnXTtcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG5vcm1TaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbm9ybVBhY2tlZFNpemV9XTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIGlucHV0U2hhcGUpKTtcblxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gaW5wdXRWYXJpYWJsZSgnc2NhbGUnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zKTtcbiAgICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBbeCwgc2NhbGUsIGJpYXMsIG91dHB1dF07XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0geC50eXBlLnZhbHVlO1xuICAgICAgICBjb25zdCBmMzJUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICdmMzInIDogYHZlYyR7Y29tcG9uZW50c308ZjMyPmA7XG4gICAgICAgIGNvbnN0IHdvcmtncm91cFNpemUgPSA2NDtcblxuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbe25hbWU6ICdub3JtU2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdub3JtUGFja2VkU2l6ZScsIHR5cGU6ICd1MzInfV07XG4gICAgICAgIHJldHVybiBgXG4gIHZhcjx3b3JrZ3JvdXA+IG1lYW5TaGFyZWQgOiBmMzI7XG4gIHZhcjx3b3JrZ3JvdXA+IHNxdWFyZWROb3JtU2hhcmVkIDogZjMyO1xuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBTaGFyZWQgOiBhcnJheTwke2YzMlR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcbiAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9ICR7d29ya2dyb3VwU2l6ZX11O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCh3b3JrZ3JvdXBTaXplKX1cbiAgICBsZXQgbm9ybSA9IGdsb2JhbF9pZHggLyB3b3JrZ3JvdXBTaXplO1xuICAgIGxldCBiYXRjaCA9IG5vcm0gLyB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBjaGFubmVsID0gbm9ybSAlIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGxvY2FsSW5kZXggPSBsb2NhbF9pZC54O1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XG4gICAgdmFyIGluaXRpYWwgPSAke2YzMlR5cGV9KDApO1xuICAgIGZvciAodmFyIGggPSBsb2NhbEluZGV4OyBoIDwgdW5pZm9ybXMubm9ybVBhY2tlZFNpemU7IGggKz0gd29ya2dyb3VwU2l6ZSkge1xuICAgICAgaW5pdGlhbCA9IGluaXRpYWwgKyAke2YzMlR5cGV9KCR7eC5nZXQoJ2JhdGNoJywgJ2NoYW5uZWwnLCAnaCcpfSk7XG4gICAgfVxuICAgIHdvcmtncm91cFNoYXJlZFtsb2NhbEluZGV4XSA9IGluaXRpYWw7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtZWFuIG9mIGN1cnJlbnQgY2hhbm5lbCBkYXRhLlxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbEluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdICsgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbEluZGV4ID09IDApIHtcbiAgICAgIG1lYW5TaGFyZWQgPSAke3N1bVZlY3Rvcignd29ya2dyb3VwU2hhcmVkWzBdJywgY29tcG9uZW50cyl9IC8gZjMyKHVuaWZvcm1zLm5vcm1TaXplKTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gcmVpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnkuXG4gICAgaW5pdGlhbCA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCB1bmlmb3Jtcy5ub3JtUGFja2VkU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBsZXQgZGV2aWF0aW9uID0gICR7ZjMyVHlwZX0oJHt4LmdldCgnYmF0Y2gnLCAnY2hhbm5lbCcsICdoJyl9KSAtICR7ZjMyVHlwZX0obWVhblNoYXJlZCk7XG4gICAgICBpbml0aWFsID0gaW5pdGlhbCArIGRldmlhdGlvbiAqIGRldmlhdGlvbjtcbiAgICB9XG4gICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gaW5pdGlhbDtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHN1bSBvZiBzcXVhcmUgb2YgZGV2aWF0aW9uIG9mIGN1cnJlbnQgY2hhbm5lbCBkYXRhLlxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbEluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdICsgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbEluZGV4ID09IDApIHtcbiAgICAgIHNxdWFyZWROb3JtU2hhcmVkID0gJHtzdW1WZWN0b3IoJ3dvcmtncm91cFNoYXJlZFswXScsIGNvbXBvbmVudHMpfTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgbGV0IGludlN0ZERldiA9IGludmVyc2VTcXJ0KHNxdWFyZWROb3JtU2hhcmVkIC8gZjMyKHVuaWZvcm1zLm5vcm1TaXplKSArIGYzMigke2F0dHJpYnV0ZXMuZXBzaWxvbn0pKTtcbiAgICBsZXQgY2hhbm5lbFNjYWxlID0gaW52U3RkRGV2ICogZjMyKCR7c2NhbGUuZ2V0QnlPZmZzZXQoJ2NoYW5uZWwnKX0pO1xuICAgIGxldCBjaGFubmVsU2hpZnQgPSBmMzIoJHtiaWFzLmdldEJ5T2Zmc2V0KCdjaGFubmVsJyl9KSAtIG1lYW5TaGFyZWQgKiBjaGFubmVsU2NhbGU7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCB1bmlmb3Jtcy5ub3JtUGFja2VkU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke3guZ2V0KCdiYXRjaCcsICdjaGFubmVsJywgJ2gnKX0gKiAke2RhdGFUeXBlfSgke2YzMlR5cGV9KGNoYW5uZWxTY2FsZSkpICsgJHtkYXRhVHlwZX0oJHtcbiAgICAgICAgICAgIGYzMlR5cGV9KGNoYW5uZWxTaGlmdCkpO1xuICAgICAgJHtvdXRwdXQuc2V0KCdiYXRjaCcsICdjaGFubmVsJywgJ2gnLCAndmFsdWUnKX07XG4gICAgfVxuICB9YDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi57bmFtZTogJ0luc3RhbmNlTm9ybWFsaXphdGlvbid9LFxuICAgICAgICAvLyBUT0RPOiB1c2UgZXBzaWxvbiBhcyB1bmlmb3JtLiBDdXJyZW50bHkgZXBzaWxvbiBhcyB1bmlmb3JtIGZhaWxzIHRlc3RfaW5zdGFuY2Vub3JtX2Vwc2lsb24uXG4gICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7YXR0cmlidXRlcy5lcHNpbG9ufTske2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgIHtkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogbm9ybUNvdW50fSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgY29tcHV0ZU1lYW4gPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXQ6IFRlbnNvclZpZXcsIHNjYWxlOiBUZW5zb3JWaWV3LCBiaWFzOiBUZW5zb3JWaWV3LCBuOiBudW1iZXIsIGg6IG51bWJlciwgYzogbnVtYmVyLFxuICAgICBlcHNpbG9uOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGMpO1xuICAgICAgY29uc3QgV0cgPSA2NDtcbiAgICAgIC8vIHdlIHdpbGwgc3RvcmUgY2hhbm5lbCBzY2FsZSBhbmQgY2hhbm5lbCBzaGlmdCBpbiBbMiwgY29tcG9uZW50c10gbWF0cml4XG4gICAgICAvLyBvciBpbiB2ZWMyIHdoZW4gY29tcG9uZW50cyA9PSAxXG4gICAgICBjb25zdCBvdXRwdXRUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICd2ZWMyZicgOiBgbWF0Mngke2NvbXBvbmVudHN9ZmA7XG4gICAgICBjb25zdCBzdW1DYXN0VHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAnZjMyJyA6IGB2ZWMke2NvbXBvbmVudHN9ZmA7XG4gICAgICBjb25zdCBzZXRPdXRwdXRWYWx1ZSA9ICh2YXIxOiBzdHJpbmcsIHZhcjI6IHN0cmluZykgPT4gYCR7b3V0cHV0VHlwZX0oJHt2YXIxfSwgJHt2YXIyfSlgO1xuICAgICAgY29uc3QgdW5pdHNPZldvcmsgPSBuICogYyAvIGNvbXBvbmVudHM7XG4gICAgICBjb25zdCB3Z1NpemUgPSBNYXRoLmNlaWwoaCAvIFdHKTtcblxuICAgICAgY29uc3QgbWVhbklucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJ107XG4gICAgICBjb25zdCBtZWFuUHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB3Z1NpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBofSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihjIC8gY29tcG9uZW50cyl9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmZsb29yKGggKiBjIC8gY29tcG9uZW50cyl9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBnZXRNZWFuU2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0SGVscGVyID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcywgY29tcG9uZW50cyk7XG4gICAgICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXRIZWxwZXIpfVxuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7b3V0cHV0VHlwZX0+O1xuICBzdHJ1Y3QgVW5pZm9ybXMge3dnX3NpemU6dTMyLCBIOnUzMiwgQzp1MzIsIGltYWdlX3NpemU6dTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFdHKX1cbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvICR7V0d9IC8gdW5pZm9ybXMuQztcbiAgICBsZXQgY3VycmVudENoYW5uZWxOdW1iZXIgPSAoZ2xvYmFsX2lkeCAvICR7V0d9KSAlIHVuaWZvcm1zLkM7XG4gICAgbGV0IHdnT2Zmc2V0ID0gbG9jYWxfaWQueCAqIHVuaWZvcm1zLndnX3NpemU7XG4gICAgaWYgKHdnT2Zmc2V0ID49IHVuaWZvcm1zLkgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgd2dNYXggPSBtaW4od2dPZmZzZXQgKyB1bmlmb3Jtcy53Z19zaXplLCB1bmlmb3Jtcy5IKTtcblxuICAgIGxldCBvZmZzZXQgPSBjdXJyZW50SW1hZ2VOdW1iZXIgKiB1bmlmb3Jtcy5pbWFnZV9zaXplICsgY3VycmVudENoYW5uZWxOdW1iZXI7XG4gICAgdmFyIHN1bSA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xuICAgIHZhciBzcXVhcmVkU3VtID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gd2dPZmZzZXQ7IGkgPCB3Z01heDsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICR7c3VtQ2FzdFR5cGV9KGlucHV0W29mZnNldCArIGkgKiB1bmlmb3Jtcy5DXSk7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgICAgc3F1YXJlZFN1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3NldE91dHB1dFZhbHVlKCdzdW0nLCAnc3F1YXJlZFN1bScpfTtcbiAgfWA7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtZWFuVmFsdWVzID0gY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1Db21wdXRlTWVhbicsXG4gICAgICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXM6IG1lYW5JbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICAgICAge2RpbXM6IFtuLCBjLCBXRywgMl0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBuICogYyAvIGNvbXBvbmVudHN9LFxuICAgICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IG1lYW5Qcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0U2hhZGVyU291cmNlOiBnZXRNZWFuU2hhZGVyU291cmNlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge2lucHV0czogW2lucHV0XSwgb3V0cHV0czogWy0xXX0pWzBdO1xuXG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHVuaXRzT2ZXb3JrfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaH0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3IoYyAvIGNvbXBvbmVudHMpfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihXRyAqIGMgLyBjb21wb25lbnRzKX1cbiAgICAgIF07XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJywgJ3R5cGUnXTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBzY2FsZUhlbHBlciA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgc2NhbGUuZGF0YVR5cGUsIHNjYWxlLmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBiaWFzSGVscGVyID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGJpYXMuZGF0YVR5cGUsIGJpYXMuZGltcywgY29tcG9uZW50cyk7XG4gICAgICAgIHJldHVybiBgXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke291dHB1dFR5cGV9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZSA6IGFycmF5PCR7c2NhbGVIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZD4gYmlhcyA6IGFycmF5PCR7Ymlhc0hlbHBlci50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke291dHB1dFR5cGV9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHt1bml0c19vZl93b3JrIDogdTMyLCBIOiB1MzIsIEMgOiB1MzIsIGltYWdlX3NpemUgOiB1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoNCkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy51bml0c19vZl93b3JrJyl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5DO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IG9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIHVuaWZvcm1zLmltYWdlX3NpemU7XG4gICAgdmFyIHN1bSA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xuICAgIHZhciBzcXVhcmVkU3VtID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IG1pbigke1dHfSwgdW5pZm9ybXMuSCk7IGkrKykge1xuICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dFtvZmZzZXQgKyBpICsgY3VycmVudENoYW5uZWxOdW1iZXIgKiAke1dHfV07XG4gICAgICAgIHN1bSArPSB2YWx1ZVswXTtcbiAgICAgICAgc3F1YXJlZFN1bSArPSB2YWx1ZVsxXTtcbiAgICB9XG4gICAgc3VtID0gc3VtIC8gZjMyKHVuaWZvcm1zLkgpO1xuICAgIHNxdWFyZWRTdW0gPSBzcXVhcmVkU3VtIC8gZjMyKHVuaWZvcm1zLkgpO1xuICAgIGxldCBpbnZTdGREZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkU3VtIC0gc3VtICogc3VtICsgZjMyKCR7ZXBzaWxvbn0pKTtcbiAgICBsZXQgY2hhbm5lbFNjYWxlID0gaW52U3RkRGV2ICogJHtzdW1DYXN0VHlwZX0oc2NhbGVbY3VycmVudENoYW5uZWxOdW1iZXJdKTtcbiAgICBsZXQgY2hhbm5lbFNoaWZ0ID0gJHtzdW1DYXN0VHlwZX0oYmlhc1tjdXJyZW50Q2hhbm5lbE51bWJlcl0pIC0gc3VtICogY2hhbm5lbFNjYWxlO1xuXG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtzZXRPdXRwdXRWYWx1ZSgnY2hhbm5lbFNjYWxlJywgJ2NoYW5uZWxTaGlmdCcpfTtcbiAgfWA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtQ29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0JyxcbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSBlcHNpbG9uIGFzIHVuaWZvcm0uIEN1cnJlbnRseSBlcHNpbG9uIGFzIHVuaWZvcm0gZmFpbHMgdGVzdF9pbnN0YW5jZW5vcm1fZXBzaWxvbi5cbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7Y29tcG9uZW50c307JHtlcHNpbG9ufWAsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICB7ZGltczogW24sIGMsIDJdLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXR9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKHVuaXRzT2ZXb3JrIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtpbnB1dHM6IFttZWFuVmFsdWVzLCBzY2FsZSwgYmlhc10sIG91dHB1dHM6IFstMV19KVswXTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVJbnN0YW5jZU5vcm1OSFdDUHJvZ3JhbUluZm8gPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMpID0+IHtcbiAgICAgIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICBjb25zdCBOID0geFNoYXBlWzBdO1xuICAgICAgY29uc3QgQyA9IHhTaGFwZVt4U2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBIID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgMSkgLyBDO1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoQyk7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cztcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEh9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmZsb29yKEMgLyBjb21wb25lbnRzKX1dO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICAgICAgLy8gZmlyc3QgY29tcHV0ZSBtZWFuXG4gICAgICBjb25zdCBjaGFubmVsU2NhbGVTaGlmdCA9IGNvbXB1dGVNZWFuKGNvbnRleHQsIGlucHV0c1swXSwgaW5wdXRzWzFdLCBpbnB1dHNbMl0sIE4sIEgsIEMsIGF0dHJpYnV0ZXMuZXBzaWxvbik7XG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICAgICAgY29uc3Qgc2NhbGVUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICd2ZWMyZicgOiBgbWF0Mngke2NvbXBvbmVudHN9ZmA7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2FzdFR5cGUgPSBjb21wb25lbnRzID09PSAxID8gZGF0YVR5cGUgOiBgdmVjJHtjb21wb25lbnRzfTwke2RhdGFUeXBlfT5gO1xuXG4gICAgICAgIGNvbnN0IGlucHV0SGVscGVyID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0SGVscGVyID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpO1xuXG4gICAgICAgIHJldHVybiBgXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke2lucHV0SGVscGVyLnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlSW5wdXQgOiBhcnJheTwke3NjYWxlVHlwZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7b3V0cHV0SGVscGVyLnR5cGUuc3RvcmFnZX0+O1xuICBzdHJ1Y3QgVW5pZm9ybXMge0g6IHUzMiwgQyA6IHUzMn07XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLkMgKiB1bmlmb3Jtcy5IKTtcbiAgICBsZXQgY3VycmVudENoYW5uZWxOdW1iZXIgPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuQztcblxuICAgIGxldCBzY2FsZU9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIHVuaWZvcm1zLkMgKyBjdXJyZW50Q2hhbm5lbE51bWJlcjtcbiAgICBsZXQgc2NhbGUgPSBzY2FsZUlucHV0W3NjYWxlT2Zmc2V0XTtcbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBmbWEoaW5wdXRbZ2xvYmFsX2lkeF0sICR7c2NhbGVDYXN0VHlwZX0oc2NhbGVbMF0pLCAke3NjYWxlQ2FzdFR5cGV9KHNjYWxlWzFdKSk7XG4gIH1gO1xuICAgICAgfTtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uTkhXQycsXG4gICAgICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge2lucHV0czogW2lucHV0c1swXSwgY2hhbm5lbFNjYWxlU2hpZnRdfSk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGluc3RhbmNlTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJykge1xuICAgIGNyZWF0ZUluc3RhbmNlTm9ybU5IV0NQcm9ncmFtSW5mbyhjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUluc3RhbmNlTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2Nhc3RUb0YzMiwgZmlsbFZlY3RvciwgZ2V0TWF4Q29tcG9uZW50cywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgc3VtVmVjdG9yLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlLH0gZnJvbSAnLi9jb21tb24nO1xuXG5pbnRlcmZhY2UgTGF5ZXJOb3JtQXR0cmlidXRlcyB7XG4gIHNpbXBsaWZpZWQ6IGJvb2xlYW47XG4gIGF4aXM6IG51bWJlcjtcbiAgZXBzaWxvbjogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLicpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVMYXllck5vcm1Qcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBMYXllck5vcm1BdHRyaWJ1dGVzLCBvdXRwdXRDb3VudDogbnVtYmVyKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3Qgc2ltcGxpZmllZCA9IGF0dHJpYnV0ZXMuc2ltcGxpZmllZDtcblxuICAgICAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBjb25zdCBzY2FsZSA9IGlucHV0c1sxXTtcbiAgICAgIGNvbnN0IGJpYXMgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHNbMl07XG5cbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgeFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBub3JtQ291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG4gICAgICBjb25zdCBub3JtU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIGF4aXMpO1xuXG4gICAgICBjb25zdCBzY2FsZVNpemUgPSBTaGFwZVV0aWwuc2l6ZShzY2FsZS5kaW1zKTtcbiAgICAgIGNvbnN0IGJpYXNTaXplID0gYmlhcyA/IFNoYXBlVXRpbC5zaXplKGJpYXMuZGltcykgOiAwO1xuICAgICAgaWYgKHNjYWxlU2l6ZSAhPT0gbm9ybVNpemUgfHwgKGJpYXMgJiYgYmlhc1NpemUgIT09IG5vcm1TaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke25vcm1TaXplfS5cbiAgICAgICBTaXplIG9mIHNjYWxlIGFuZCBiaWFzIChpZiBwcm92aWRlZCkgbXVzdCBtYXRjaCB0aGlzLlxuICAgICAgIEdvdCBzY2FsZSBzaXplIG9mICR7c2NhbGVTaXplfSBhbmQgYmlhcyBzaXplIG9mICR7Ymlhc1NpemV9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lYW5JbnZTdGREZXZEaW06IG51bWJlcltdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaSA8IGF4aXMpIHtcbiAgICAgICAgICBtZWFuSW52U3RkRGV2RGltLnB1c2goeFNoYXBlW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZWFuSW52U3RkRGV2RGltLnB1c2goMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKG5vcm1TaXplKTtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbm9ybUNvdW50fSwge3R5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBub3JtU2l6ZX0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3Iobm9ybVNpemUgLyBjb21wb25lbnRzKX0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5lcHNpbG9ufVxuICAgICAgXTtcbiAgICAgIGlmIChiaWFzKSB7XG4gICAgICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3R5cGUnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhc01lYW5EYXRhT3V0cHV0ID0gb3V0cHV0Q291bnQgPiAxO1xuICAgICAgY29uc3QgaGFzSW52U3RkT3V0cHV0ID0gb3V0cHV0Q291bnQgPiAyO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gW1xuICAgICAgICAgIGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgICAgICBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIHNjYWxlLmRhdGFUeXBlLCBzY2FsZS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGJpYXMpIHtcbiAgICAgICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgYmlhcy5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgaWYgKGhhc01lYW5EYXRhT3V0cHV0KSB7XG4gICAgICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ21lYW5fZGF0YV9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbnZTdGRPdXRwdXQpIHtcbiAgICAgICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW52X3N0ZF9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICAgIHtuYW1lOiAnbm9ybV9jb3VudCcsIHR5cGU6ICd1MzInfSwge25hbWU6ICdub3JtX3NpemUnLCB0eXBlOiAnZjMyJ30sXG4gICAgICAgICAge25hbWU6ICdub3JtX3NpemVfdmVjdG9yaXplZCcsIHR5cGU6ICd1MzInfSwge25hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2YzMid9XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMubm9ybV9jb3VudCcpfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG4gICAgdmFyIG1lYW5fc3F1YXJlX3ZlY3RvciA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xuXG4gICAgZm9yICh2YXIgaDogdTMyID0gMHU7IGggPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaCsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3hbaCArIG9mZnNldF0nKX07XG4gICAgICBtZWFuX3ZlY3RvciArPSB2YWx1ZTtcbiAgICAgIG1lYW5fc3F1YXJlX3ZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbWVhbiA9ICR7c3VtVmVjdG9yKCdtZWFuX3ZlY3RvcicsIGNvbXBvbmVudHMpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZTtcbiAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke3N1bVZlY3RvcignbWVhbl9zcXVhcmVfdmVjdG9yJywgY29tcG9uZW50cyl9IC8gdW5pZm9ybXMubm9ybV9zaXplICR7XG4gICAgICAgICAgICBzaW1wbGlmaWVkID8gJycgOiAnLSBtZWFuICogbWVhbid9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICd4W2ogKyBvZmZzZXRdJyl9O1xuICAgICAgbGV0IGYzMnNjYWxlID0gJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICdzY2FsZVtqXScpfTtcbiAgICAgIG91dHB1dFtqICsgb2Zmc2V0XSA9ICR7dmFyaWFibGVzWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke3NpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4nfSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXG4gICAgICAgICR7YmlhcyA/IGArICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAnYmlhc1tqXScpfWAgOiAnJ31cbiAgICAgICk7XG4gICAgfVxuXG4gICAgJHtoYXNNZWFuRGF0YU91dHB1dCA/ICdtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbicgOiAnJ307XG4gICAgJHtoYXNJbnZTdGRPdXRwdXQgPyAnaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldicgOiAnJ307XG4gIH1gO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV07XG4gICAgICBpZiAoaGFzTWVhbkRhdGFPdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0cy5wdXNoKHtkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXR9KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNJbnZTdGRPdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0cy5wdXNoKHtkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXR9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0xheWVyTm9ybWFsaXphdGlvbicsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7Y29tcG9uZW50c307JHtvdXRwdXRDb3VudH07JHtzaW1wbGlmaWVkfWAsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT5cbiAgICAgICAgICAgICh7b3V0cHV0cywgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChub3JtQ291bnQgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LCBwcm9ncmFtVW5pZm9ybXN9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbGF5ZXJOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBMYXllck5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50KSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlLCBnZXRUZW5zb3JFbGVtZW50U2l6ZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuLy8gIFRPRE8gc3VwcG9ydCBxdWFudGl6YXRpb24gYml0cyBub3QgZXF1YWwgdG8gNFxuZXhwb3J0IGludGVyZmFjZSBNYXRNdWxOQml0c0F0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBrOiBudW1iZXI7XG4gIG46IG51bWJlcjtcbiAgYWNjdXJhY3lMZXZlbDogbnVtYmVyO1xuICBiaXRzOiBudW1iZXI7XG4gIGJsb2NrU2l6ZTogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgMyB8fCBpbnB1dHMubGVuZ3RoID4gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWF0TXVsTkJpdHMgcmVxdWlyZXMgMyBvciA0IGlucHV0cycpO1xuICB9XG4gIGNvbnN0IGEgPSBpbnB1dHNbMF07XG4gIGNvbnN0IGFSYW5rID0gYS5kaW1zLmxlbmd0aDtcbiAgaWYgKGEuZGltc1thUmFuayAtIDFdICE9PSBhdHRyaWJ1dGVzLmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsYXN0IGRpbSBvZiBpbnB1dCBzaGFwZSBkb2VzIG5vdCBtYXRjaCB0aGUgayB2YWx1ZScpO1xuICB9XG4gIGNvbnN0IG5CbG9ja3NQZXJDb2wgPSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLmsgKyBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSAtIDEpIC8gYXR0cmlidXRlcy5ibG9ja1NpemUpO1xuICBjb25zdCBibG9iU2l6ZSA9IGF0dHJpYnV0ZXMuYmxvY2tTaXplIC8gOCAqIGF0dHJpYnV0ZXMuYml0cztcbiAgY29uc3QgYiA9IGlucHV0c1sxXTtcbiAgaWYgKCFTaGFwZVV0aWwuYXJlRXF1YWwoYi5kaW1zLCBbYXR0cmlidXRlcy5uLCBuQmxvY2tzUGVyQ29sLCBibG9iU2l6ZV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGlucHV0cyBtdXN0IGJlIDNEIHRlbnNvciB3aXRoIHNoYXBlIE4gWCBuQmxvY2tzUGVyQ29sIFggYmxvYlNpemUnKTtcbiAgfVxuICBjb25zdCBzY2FsZXMgPSBpbnB1dHNbMl07XG4gIGNvbnN0IHNjYWxlc1NoYXBlID0gc2NhbGVzLmRpbXM7XG4gIGlmIChTaGFwZVV0aWwuc2l6ZShzY2FsZXNTaGFwZSkgIT09IGF0dHJpYnV0ZXMubiAqIG5CbG9ja3NQZXJDb2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxlcyBpbnB1dCBzaXplIGVycm9yLicpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgY29uc3QgemVyb1BvaW50cyA9IGlucHV0c1szXTtcbiAgICBjb25zdCB6ZXJvUG9pbnRzU2hhcGUgPSB6ZXJvUG9pbnRzLmRpbXM7XG4gICAgY29uc3QgZXhwZWN0ZWRaZXJvUG9pbnRzU2l6ZSA9XG4gICAgICAgIGF0dHJpYnV0ZXMuYml0cyA+IDQgPyAoYXR0cmlidXRlcy5uICogbkJsb2Nrc1BlckNvbCkgOiBhdHRyaWJ1dGVzLm4gKiBNYXRoLmZsb29yKChuQmxvY2tzUGVyQ29sICsgMSkgLyAyKTtcbiAgICBpZiAoU2hhcGVVdGlsLnNpemUoemVyb1BvaW50c1NoYXBlKSAhPT0gZXhwZWN0ZWRaZXJvUG9pbnRzU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd6ZXJvUG9pbnRzIGlucHV0IHNpemUgZXJyb3IuJyk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0TXVsTkJpdHNQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMsXG4gICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU6IG51bWJlcik6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGFSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBuQmxvY2tzUGVyQ29sID0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5rICsgYXR0cmlidXRlcy5ibG9ja1NpemUgLSAxKSAvIGF0dHJpYnV0ZXMuYmxvY2tTaXplKTtcbiAgICAgIGNvbnN0IGRpbUFPdXRlciA9IGlucHV0U2hhcGVbYVJhbmsgLSAyXTtcbiAgICAgIGNvbnN0IGRpbUlubmVyID0gYXR0cmlidXRlcy5rO1xuICAgICAgY29uc3QgZGltQk91dGVyID0gYXR0cmlidXRlcy5uO1xuICAgICAgY29uc3QgYmF0Y2hEaW1zID0gaW5wdXRTaGFwZS5zbGljZSgwLCBhUmFuayAtIDIpO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUoYmF0Y2hEaW1zKTtcbiAgICAgIGNvbnN0IGJsb2JTaXplID0gYXR0cmlidXRlcy5ibG9ja1NpemUgLyA4ICogYXR0cmlidXRlcy5iaXRzO1xuICAgICAgY29uc3QgYmxvYlNpemVJbldvcmRzID0gYmxvYlNpemUgLyA0O1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gICAgICBjb25zdCBvdXRwdXROdW1iZXIgPSBnZXRNYXhDb21wb25lbnRzKGRpbUFPdXRlcik7XG4gICAgICBjb25zdCBhQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYXR0cmlidXRlcy5rKTtcbiAgICAgIGNvbnN0IGJDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhibG9iU2l6ZUluV29yZHMpO1xuICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBnZXRUZW5zb3JFbGVtZW50U2l6ZShkYXRhVHlwZSkhO1xuICAgICAgY29uc3Qgd29ya2dyb3VwT3V0cHV0U2l6ZSA9IGRpbUFPdXRlciAqIG5CbG9ja3NQZXJDb2wgKiBlbGVtZW50U2l6ZTtcbiAgICAgIGNvbnN0IG1heE51bWJlck9mQ29tcG9uZW50cyA9IE1hdGguZmxvb3IobWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplIC8gd29ya2dyb3VwT3V0cHV0U2l6ZSk7XG4gICAgICBjb25zdCB1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyA9IG5CbG9ja3NQZXJDb2wgPD0gbWF4Q29tcHV0ZVdvcmtncm91cFNpemVzWzBdICYmIG1heE51bWJlck9mQ29tcG9uZW50cyA+IDA7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gKCF1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyB8fCBtYXhOdW1iZXJPZkNvbXBvbmVudHMgPj0gNCkgPyBnZXRNYXhDb21wb25lbnRzKGRpbUJPdXRlcikgOlxuICAgICAgICAgICgobWF4TnVtYmVyT2ZDb21wb25lbnRzID49IDIpICYmIGdldE1heENvbXBvbmVudHMoZGltQk91dGVyKSA+PSAyKSAgICAgID8gMiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBiYXRjaERpbXMuY29uY2F0KFtkaW1BT3V0ZXIsIGRpbUJPdXRlcl0pO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMgLyBvdXRwdXROdW1iZXI7XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IHVzZUJsb2Nrd2lzZU1hdE11bE5CaXRzID9cbiAgICAgICAgICBbXSA6XG4gICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmJsb2NrU2l6ZX1dO1xuICAgICAgY29uc3QgaW5wdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUlubmVyIC8gYUNvbXBvbmVudHNdO1xuICAgICAgY29uc3QgYlNoYXBlID0gU2hhcGVVdGlsLmNvbnZlcnRTaGFwZShpbnB1dHNbMV0uZGltcykuc2xpY2UoKTtcbiAgICAgIGJTaGFwZS5zcGxpY2UoLTEsIDEsIGJsb2JTaXplSW5Xb3JkcyAvIGJDb21wb25lbnRzKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGVUZW1wKSk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiU2hhcGUpKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1szXS5kaW1zKSkpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1CT3V0ZXIgLyBjb21wb25lbnRzXTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlVGVtcCkpO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGVUZW1wLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0UmFuaywgYUNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIERhdGFUeXBlLnVpbnQzMiwgYlNoYXBlLmxlbmd0aCwgYkNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBzY2FsZXMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2EsIGIsIHNjYWxlc107XG4gICAgICAgIGNvbnN0IHplcm9Qb2ludHMgPVxuICAgICAgICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoemVyb1BvaW50cykge1xuICAgICAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goemVyb1BvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlVGVtcC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFJhbmssIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbe25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdibG9ja19zaXplJywgdHlwZTogJ3UzMid9XTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICAgICAgICBjb25zdCBxRHFEYXRhVHlwZSA9ICgoKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChhQ29tcG9uZW50cykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gYGFycmF5PCR7ZGF0YVR5cGV9LCA4PmA7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBgbWF0NHgyPCR7ZGF0YVR5cGV9PmA7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHJldHVybiBgbWF0Mng0PCR7ZGF0YVR5cGV9PmA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7YUNvbXBvbmVudHN9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcblxuICAgICAgICBjb25zdCBwcm9jZXNzT25lQmxvY2sgPSBgXG4gICAgICAgIGZvciAodmFyIHdvcmQ6IHUzMiA9IDA7IHdvcmQgPCAke2Jsb2JTaXplSW5Xb3Jkc307IHdvcmQgKz0gJHtiQ29tcG9uZW50c30pIHtcbiAgICAgICAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgJzInLCAnd29yZCcpfTtcbiAgICAgICAgICBsZXQgYl9kYXRhID0gJHtiLmdldEJ5SW5kaWNlcygnYl9pbmRpY2VzJyl9O1xuICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2JDb21wb25lbnRzfTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYl92YWx1ZTogdTMyID0gJHtiQ29tcG9uZW50cyA9PT0gMSA/ICdiX2RhdGEnIDogJ2JfZGF0YVt3b3JkICsgaV0nfTtcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xuICAgICAgICAgICAgbGV0IGJfdmFsdWVfbG93ZXI6IHZlYzQ8dTMyPiA9IHVucGFjazR4VTgoYl92YWx1ZSAmIGJfbWFzayk7XG4gICAgICAgICAgICBsZXQgYl92YWx1ZV91cHBlcjogdmVjNDx1MzI+ID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIGJfbWFzayk7XG4gICAgICAgICAgICBsZXQgYl9xdWFudGl6ZWRfdmFsdWVzID0gJHtxRHFEYXRhVHlwZX0oJHtcbiAgICAgICAgICAgIEFycmF5LmZyb20oe2xlbmd0aDogNH0sIChfLCBpKSA9PiBgJHtkYXRhVHlwZX0oYl92YWx1ZV9sb3dlclske2l9XSksICR7ZGF0YVR5cGV9KGJfdmFsdWVfdXBwZXJbJHtpfV0pYClcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX0pO1xuICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gJHsoKCkgPT4ge1xuICAgICAgICAgIGlmIChhQ29tcG9uZW50cyA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3FEcURhdGFUeXBlfSgke1xuICAgICAgICAgICAgICAgIEFycmF5LmZyb20oe2xlbmd0aDogOH0sIChfLCBpKSA9PiBgKGJfcXVhbnRpemVkX3ZhbHVlc1ske2l9XSAtIHplcm9fcG9pbnQpICogc2NhbGVgKS5qb2luKCcsICcpfSk7YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtxRHFEYXRhVHlwZX0oJHtBcnJheSg4KS5maWxsKCd6ZXJvX3BvaW50Jykuam9pbignLCcpfSkpICogc2NhbGU7YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9O1xuICAgICAgICAgICAgLy8gTnVtYmVyIG9mIEIgZWxlbWVudHMgcGVyIDMyLWJpdCB3b3JkIGlzIDMyL2JpdHMgPSAzMi80ID0gOFxuICAgICAgICAgICAgZm9yICh2YXIgbTogdTMyID0gMDsgbSA8ICR7dXNlQmxvY2t3aXNlTWF0TXVsTkJpdHMgPyBkaW1BT3V0ZXIgOiBvdXRwdXROdW1iZXJ9dTsgbSsrKSB7XG4gICAgICAgICAgICAgICR7YS5pbmRpY2VzU2V0KCdhX2luZGljZXMnLCBpbnB1dFJhbmsgLSAyLCB1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyA/ICdtJyA6IGByb3cgKiAke291dHB1dE51bWJlcn0gKyBtYCl9O1xuICAgICAgICAgICAgICAke2EuaW5kaWNlc1NldCgnYV9pbmRpY2VzJywgaW5wdXRSYW5rIC0gMSwgJ3dvcmRfb2Zmc2V0Jyl9O1xuICAgICAgICAgICAgICB2YXIgaW5wdXRfb2Zmc2V0ID0gJHthLmluZGljZXNUb09mZnNldCgnYV9pbmRpY2VzJyl9O1xuICAgICAgICAgICAgICB2YXIgYV9kYXRhOiAke3FEcURhdGFUeXBlfTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8ICR7OCAvIGFDb21wb25lbnRzfTsgaisrKSB7XG4gICAgICAgICAgICAgICAgYV9kYXRhW2pdID0gJHthLmdldEJ5T2Zmc2V0KCdpbnB1dF9vZmZzZXQnKX07XG4gICAgICAgICAgICAgICAgaW5wdXRfb2Zmc2V0Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHt1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyA/ICd3b3JrZ3JvdXBfc2hhcmVkW3dvcmtncm91cF9zaGFyZWRfb2Zmc2V0ICsgbV0nIDogJ291dHB1dF92YWx1ZXNbbV0nfSR7XG4gICAgICAgICAgICBjb21wb25lbnRzID4gMSA/ICdbY10nIDogJyd9ICs9ICR7XG4gICAgICAgICAgICBBcnJheVxuICAgICAgICAgICAgICAgIC5mcm9tKFxuICAgICAgICAgICAgICAgICAgICB7bGVuZ3RoOiA4IC8gYUNvbXBvbmVudHN9LFxuICAgICAgICAgICAgICAgICAgICAoXywgaSkgPT4gYCR7XG4gICAgICAgICAgICAgICAgICAgICAgICBhQ29tcG9uZW50cyA9PT0gMSA/IGBhX2RhdGFbJHtpfV0gKiBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2l9XWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgZG90KGFfZGF0YVske2l9XSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV0pYH1gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcgKyAnKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezggLyBhQ29tcG9uZW50c307XG4gICAgICAgICAgfVxuICAgICAgICB9YDtcbiAgICAgICAgY29uc3QgdXBkYXRlWmVyb1BvaW50SW5kZXggPSB6ZXJvUG9pbnRzID8gYFxuICAgICAgICAgIHplcm9fcG9pbnRfb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgaWYgKHplcm9fcG9pbnRfb2Zmc2V0ID09IDMyKSB7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X29mZnNldCA9IDA7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2luZGV4Kys7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmQgPSAke3plcm9Qb2ludHMuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfaW5kZXgnKX07XG4gICAgICAgICAgfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJztcblxuICAgICAgICByZXR1cm4gdXNlQmxvY2t3aXNlTWF0TXVsTkJpdHMgPyBgXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQ6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke2RpbUFPdXRlciAqIG5CbG9ja3NQZXJDb2x9PjtcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtcbiAgICAgICAgICBuQmxvY2tzUGVyQ29sLCAxLCAxXG4gICAgICAgIF0pfVxuICAgICAgICAgIHZhciBhX2luZGljZXM6ICR7YS50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBibG9jayA9IGxvY2FsX2lkLng7XG4gICAgICAgICAgdmFyIGNvbCA9IHdvcmtncm91cF9pZC55O1xuICAgICAgICAgIHZhciBiYXRjaCA9IHdvcmtncm91cF9pZC56O1xuICAgICAgICAgICR7YS5pbmRpY2VzU2V0KCdhX2luZGljZXMnLCAnMCcsICdiYXRjaCcpfTtcbiAgICAgICAgICAvLyBUd28gemVybyBwb2ludHMgYXJlIHBhY2tlZCBpbnRvIG9uZSBieXRlIHdoZW4gdW5pZm9ybXMuYml0cyBpcyA0LlxuICAgICAgICAgIGZvciAodmFyIGM6IHUzMiA9IDA7IGMgPCAke2NvbXBvbmVudHN9OyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjb2xfdGltZXNfY29tcG9uZW50c19wbHVzX2MgPSBjb2wgKiAke2NvbXBvbmVudHN9ICsgYztcbiAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9Qb2ludHMgPyBgXG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlc19wZXJfY29sOiB1MzIgPSAoJHtuQmxvY2tzUGVyQ29sfSArIDEpIC8gMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfY291bnQ6IHUzMiA9IGNvbF90aW1lc19jb21wb25lbnRzX3BsdXNfYyAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmRfaW5kZXg6IHUzMiA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQ6IHUzMiA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9uaWJibGVfb2Zmc2V0OiB1MzIgPSBibG9jayAmIDB4MXU7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9iaXRzX29mZnNldDogdTMyID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZDogdTMyID0gJHt6ZXJvUG9pbnRzLmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X3dvcmRfaW5kZXgnKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJ31cbiAgICAgICAgICAgIHZhciBiX2luZGljZXM6ICR7Yi50eXBlLmluZGljZXN9O1xuICAgICAgICAgICAgJHtiLmluZGljZXNTZXQoJ2JfaW5kaWNlcycsICcwJywgJ2NvbF90aW1lc19jb21wb25lbnRzX3BsdXNfYycpfTtcbiAgICAgICAgICAgIC8vIFRoZSBzY2FsZSBhbmQgemVybyBwb2ludHMgYXJlIGNvbXB1dGVkIHBlciBibG9jay5cbiAgICAgICAgICAgIHZhciBzY2FsZXNfaW5kZXggPSBjb2xfdGltZXNfY29tcG9uZW50c19wbHVzX2MgKiAke25CbG9ja3NQZXJDb2x9ICsgYmxvY2s7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAke3NjYWxlcy5nZXRCeU9mZnNldCgnc2NhbGVzX2luZGV4Jyl9O1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7ZGF0YVR5cGV9KCR7emVyb1BvaW50cyA/ICcoemVyb19wb2ludF93b3JkKSAmIDB4RnUnIDogOC4wfSk7XG4gICAgICAgICAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgJzEnLCAnYmxvY2snKX07XG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQ6IHUzMiA9IGJsb2NrICogJHthdHRyaWJ1dGVzLmJsb2NrU2l6ZSAvIGFDb21wb25lbnRzfTtcbiAgICAgICAgICAgIHZhciB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldDogdTMyID0gYmxvY2sgKiAke2RpbUFPdXRlcn07XG4gICAgICAgICAgICAke3Byb2Nlc3NPbmVCbG9ja31cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgIHZhciBvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICB2YXIgZWxlbWVudHNfcGVyX3RocmVhZDogdTMyID0gJHtNYXRoLmNlaWwoZGltQU91dGVyIC8gbkJsb2Nrc1BlckNvbCl9O1xuICAgICAgICAgICR7b3V0cHV0LmluZGljZXNTZXQoJ291dHB1dF9pbmRpY2VzJywgJzAnLCAnYmF0Y2gnKX07XG4gICAgICAgICAgJHtvdXRwdXQuaW5kaWNlc1NldCgnb3V0cHV0X2luZGljZXMnLCBvdXRwdXRSYW5rIC0gMSwgJ2NvbCcpfTtcbiAgICAgICAgICAke291dHB1dC5pbmRpY2VzU2V0KCdvdXRwdXRfaW5kaWNlcycsIG91dHB1dFJhbmsgLSAyLCAnbG9jYWxfaWQueCAqIGVsZW1lbnRzX3Blcl90aHJlYWQnKX07XG4gICAgICAgICAgdmFyIG91dHB1dF9vZmZzZXQgPSAke291dHB1dC5pbmRpY2VzVG9PZmZzZXQoJ291dHB1dF9pbmRpY2VzJyl9O1xuICAgICAgICAgIGZvciAodmFyIG06IHUzMiA9IDB1OyBtIDwgZWxlbWVudHNfcGVyX3RocmVhZDsgbSsrKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gbSArIGxvY2FsX2lkLnggKiBlbGVtZW50c19wZXJfdGhyZWFkO1xuICAgICAgICAgICAgaWYgKHJvdyA8ICR7ZGltQU91dGVyfSkge1xuICAgICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICB2YXIgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQ6IHUzMiA9IHJvdztcbiAgICAgICAgICAgICAgZm9yICh2YXIgYjogdTMyID0gMHU7IGIgPCAke25CbG9ja3NQZXJDb2x9dTsgYisrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IHdvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXRdO1xuICAgICAgICAgICAgICAgIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0ICs9ICR7ZGltQU91dGVyfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnb3V0cHV0X29mZnNldCcsICdvdXRwdXRfdmFsdWUnKX07XG4gICAgICAgICAgICAgIG91dHB1dF9vZmZzZXQgKz0gJHtkaW1CT3V0ZXIgLyBjb21wb25lbnRzfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcbiAgICAgICAgICB2YXIgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgdmFyIGNvbCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgb3V0cHV0UmFuayAtIDEpfTtcbiAgICAgICAgICB2YXIgcm93ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCBvdXRwdXRSYW5rIC0gMil9O1xuICAgICAgICAgIHZhciBhX2luZGljZXM6ICR7YS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgICAgICAgLy8gVHdvIHplcm8gcG9pbnRzIGFyZSBwYWNrZWQgaW50byBvbmUgYnl0ZSBiZWNhdXNlIHVuaWZvcm1zLmJpdHMgPD0gNC5cbiAgICAgICAgICAvLyB6ZXJvX3BvaW50X29mZnNldCBpcyBlaXRoZXIgMCBvciA0LiBJdCBpcyBiaXQgb2Zmc2V0IHdpdGhpbiBvbmUgYnl0ZS5cbiAgICAgICAgICAvLyBUT0RPIHN1cHBvcnQgemVyb19wb2ludF9vZmZzZXQgZm9yIGJpdHMgPiA0XG4gICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9Qb2ludHMgPyBgXG4gICAgICAgICAgdmFyIHplcm9fcG9pbnRfYWJzX29mZnNldCA9IGNvbCAqICR7Y29tcG9uZW50c30gKiAoKCR7bkJsb2Nrc1BlckNvbH0gKyAxKSAvIDIpO1xuICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2luZGV4OiB1MzIgPSB6ZXJvX3BvaW50X2Fic19vZmZzZXQgLyA0O1xuICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMiA9ICR7emVyb1BvaW50cy5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCcpfTtcbiAgICAgICAgICB2YXIgemVyb19wb2ludF9vZmZzZXQ6IHUzMiA9ICh6ZXJvX3BvaW50X2Fic19vZmZzZXQgJSA0KSAqIDg7YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyd9XG4gICAgICAgICAgdmFyIHNjYWxlX2luZGV4ID0gY29sICogJHtuQmxvY2tzUGVyQ29sICogY29tcG9uZW50c307XG4gICAgICAgICAgdmFyIGJfaW5kaWNlczogJHtiLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgZm9yICh2YXIgYzogdTMyID0gMDsgYyA8ICR7Y29tcG9uZW50c307IGMrKykge1xuICAgICAgICAgICAgJHtiLmluZGljZXNTZXQoJ2JfaW5kaWNlcycsICcwJywgYGNvbCAqICR7Y29tcG9uZW50c30gKyBjYCl9O1xuICAgICAgICAgICAgdmFyIGJsb2NrX29mZnNldDogdTMyID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGJsb2NrOiB1MzIgPSAwOyBibG9jayA8ICR7bkJsb2Nrc1BlckNvbH07IGJsb2NrKyspIHtcbiAgICAgICAgICAgICAgLy8gVGhlIHNjYWxlIGFuZCB6ZXJvIHBvaW50cyBhcmUgY29tcHV0ZWQgcGVyIGJsb2NrLlxuICAgICAgICAgICAgICBsZXQgc2NhbGUgPSAke3NjYWxlcy5nZXRCeU9mZnNldCgnc2NhbGVfaW5kZXgnKX07XG4gICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7ZGF0YVR5cGV9KCR7emVyb1BvaW50cyA/ICdleHRyYWN0Qml0cyh6ZXJvX3BvaW50X3dvcmQsIHplcm9fcG9pbnRfb2Zmc2V0LCA0KScgOiA4LjB9KTtcbiAgICAgICAgICAgICAgJHtiLmluZGljZXNTZXQoJ2JfaW5kaWNlcycsICcxJywgJ2Jsb2NrJyl9O1xuICAgICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQ6IHUzMiA9IGJsb2NrX29mZnNldDtcbiAgICAgICAgICAgICAgJHtwcm9jZXNzT25lQmxvY2t9XG4gICAgICAgICAgICAgIHNjYWxlX2luZGV4Kys7XG4gICAgICAgICAgICAgICR7dXBkYXRlWmVyb1BvaW50SW5kZXh9XG4gICAgICAgICAgICAgIGJsb2NrX29mZnNldCArPSB1bmlmb3Jtcy5ibG9ja19zaXplIC8gJHthQ29tcG9uZW50c307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcm9wIHRoZSB0cmFpbGluZyA0IGJpdHMgaWYgdGhlIHplcm9fcG9pdF9vZmZzZXQgaXMgbm90IGEgYnl0ZSBib3VuZGFyeSB0byBhbGlnbiB3aXRoIHRoZSBuZXh0IGJ5dGUuXG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb1BvaW50cyA/IGBpZiAoemVyb19wb2ludF9vZmZzZXQgJSA4ID4gMCkge1xuICAgICAgICAgICAgICAgICR7dXBkYXRlWmVyb1BvaW50SW5kZXh9XG4gICAgICAgICAgICAgIH1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgJHtvdXRwdXROdW1iZXJ9dTsgaysrKSB7XG4gICAgICAgICAgICAgICR7b3V0cHV0LmluZGljZXNTZXQoJ291dHB1dF9pbmRpY2VzJywgb3V0cHV0UmFuayAtIDIsIGAke291dHB1dE51bWJlcn0gKiByb3cgKyBrYCl9O1xuICAgICAgICAgICAgICAke291dHB1dC5zZXRCeUluZGljZXMoJ291dHB1dF9pbmRpY2VzJywgJ291dHB1dF92YWx1ZXNba10nKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfWA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdXNlQmxvY2t3aXNlTWF0TXVsTkJpdHMgPyAnQmxvY2t3aXNlTWF0TXVsTkJpdHMnIDogJ01hdE11bE5CaXRzJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2RpbUFPdXRlcn07JHtkYXRhVHlwZX07JHtpbnB1dHMubGVuZ3RofWAsXG4gICAgICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IEFycmF5KGlucHV0cy5sZW5ndGgpLmZpbGwoJ3JhbmsnKVxuICAgICAgICB9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlfV0sXG4gICAgICAgICAgbmFtZTogdXNlQmxvY2t3aXNlTWF0TXVsTkJpdHMgPyAnQmxvY2t3aXNlTWF0TXVsTkJpdHMnIDogJ01hdE11bE5CaXRzJyxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyA/IHt4OiAxLCB5OiBNYXRoLmNlaWwoZGltQk91dGVyIC8gY29tcG9uZW50cyksIHo6IGJhdGNoU2l6ZX0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbWF0TXVsTkJpdHMgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IG1heENvbXB1dGVXb3JrZ3JvdXBTaXplczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gY29udGV4dC5nZXRNYXhDb21wdXRlV29ya2dyb3VwU2l6ZXMoKTtcbiAgY29uc3QgbWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplID0gY29udGV4dC5nZXRNYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZXNpemUoKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1hdE11bE5CaXRzUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcywgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVzLCBtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1hdE11bE5CaXRzQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8TWF0TXVsTkJpdHNBdHRyaWJ1dGVzLCBrZXlvZiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk+KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldEVsZW1lbnRBdCwgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgVW5pZm9ybURhdGFFbGVtZW50VHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuaW50ZXJmYWNlIFBhZEF0dHJpYnV0ZXMge1xuICAvLyAwLWNvbnN0YW50LCAxLXJlZmxlY3QsIDItZWRnZSwgMy13cmFwXG4gIHJlYWRvbmx5IG1vZGU6IG51bWJlcjtcbiAgcmVhZG9ubHkgdmFsdWU6IG51bWJlcjtcbiAgcmVhZG9ubHkgcGFkczogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gZmV3IGlucHV0cycpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0ICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQxNikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZSBtdXN0IGJlIGZsb2F0IG9yIGZsb2F0MTYuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSAyKSB7XG4gICAgbGV0IHZhbGlkUGFkcyA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAqIDIgPT09IGlucHV0c1sxXS5kaW1zWzBdO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YWxpZFBhZHMgPSBpbnB1dHNbM10uZGltc1swXSAqIDIgPT09IGlucHV0c1sxXS5kaW1zWzBdO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkUGFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGdldFBhZENvbnN0YW50ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KHVuaWZvcm1zLmNvbnN0YW50X3ZhbHVlKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFJlZmxlY3QgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9IDIgKiAoaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IF8ybl8xIC0gaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkRWRnZSA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7YmxvY2t9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGA7XG59O1xuXG5jb25zdCBnZXRQYWRXcmFwID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcbiAgICAgICAgICAgICAgICAgIGsgKz0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICBrIC09IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkU25pcHBldCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogc3RyaW5nID0+IHtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZ2V0UGFkQ29uc3RhbnQob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBnZXRQYWRSZWZsZWN0KG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0UGFkRWRnZShvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGdldFBhZFdyYXAob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVQYWRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBTaGFwZVV0aWwucGFkU2hhcGUoaW5wdXRzWzBdLmRpbXMuc2xpY2UoKSwgYXR0cmlidXRlcy5wYWRzKTtcbiAgY29uc3QgaW5wdXREaW1zID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5wYWRzfV07XG4gIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCh7dHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLCBkYXRhOiBhdHRyaWJ1dGVzLnZhbHVlfSk7XG4gIH1cblxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXREaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgIGNvbnN0IHBhZFNuaXBwZXQgPSBnZXRQYWRTbmlwcGV0KG91dHB1dCwgaW5wdXREaW1zLmxlbmd0aCwgYXR0cmlidXRlcyk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID1cbiAgICAgICAgW3tuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMucGFkcy5sZW5ndGh9XTtcbiAgICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAwKSB7XG4gICAgICB1bmlmb3Jtcy5wdXNoKHtuYW1lOiAnY29uc3RhbnRfdmFsdWUnLCB0eXBlOiBkYXRhVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgwKTtcbiAgICAgICAgICAgICR7cGFkU25pcHBldH1cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdQYWQnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7YXR0cmlidXRlcy5tb2RlfWAsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBQYWRBdHRyaWJ1dGVzID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgYmlnSW50NjRQYWRzID0gaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbnB1dHMubGVuZ3RoID49IDMgJiYgaW5wdXRzWzJdLmRhdGEpID8gaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdIDogMC4wO1xuXG4gICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICAgIGNvbnN0IHVwZGF0ZVBhZHMgPSBuZXcgSW50MzJBcnJheSgyICogaW5wdXRSYW5rKS5maWxsKDApO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID49IDQpIHtcbiAgICAgIGNvbnN0IGF4ZXMgPSBpbnB1dHNbM10uZ2V0QmlnSW50NjRBcnJheSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZVBhZHNbTnVtYmVyKGF4ZXNbaV0pXSA9IE51bWJlcihiaWdJbnQ2NFBhZHNbaV0pO1xuICAgICAgICB1cGRhdGVQYWRzW051bWJlcihheGVzW2ldKSArIGlucHV0UmFua10gPSBOdW1iZXIoYmlnSW50NjRQYWRzW2kgKyBheGVzLmxlbmd0aF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiaWdJbnQ2NFBhZHMuZm9yRWFjaCgodiwgaSkgPT4gdXBkYXRlUGFkc1tOdW1iZXIoaSldID0gKE51bWJlcih2KSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhZHM6IG51bWJlcltdID0gW107XG4gICAgdXBkYXRlUGFkcy5mb3JFYWNoKHYgPT4gcGFkcy5wdXNoKHYpKTtcblxuICAgIHJldHVybiB7bW9kZTogYXR0cmlidXRlcy5tb2RlLCB2YWx1ZSwgcGFkc307XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlcyA9IGNyZWF0ZVBhZEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVBhZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcyksIHtpbnB1dHM6IFswXX0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtQb29sQ29udlV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG4vLyBUT0RPOiBzdXBwb3J0OlxuLy8gLSBjZWlsX21vZGUgICAgICAgICAgICAgICAgIFwidGVzdF9tYXhwb29sXzJkX2NlaWxcIlxuLy8gLSBzdG9yYWdlX29yZGVyICAgICAgICAgICAgIFwidGVzdF9tYXhwb29sX3dpdGhfYXJnbWF4XzJkX3ByZWNvbXB1dGVkX3N0cmlkZXNcIlxuLy8gLSBbTWF4UG9vbF0gZGlsYXRpb25zICAgICAgIFwidGVzdF9tYXhwb29sXzJkX2RpbGF0aW9uc1wiXG4vLyAtIFtNYXhQb29sXSBvdXRwdXRbMV0gICAgICAgXCJ0ZXN0X21heHBvb2xfd2l0aF9hcmdtYXhfMmRfcHJlY29tcHV0ZWRfcGFkc1wiXG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmIChlbnYud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50ICYmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUgPSA8QXR0cmlidXRlVHlwZSBleHRlbmRzIEF2ZXJhZ2VQb29sQXR0cmlidXRlc3xNYXhQb29sQXR0cmlidXRlcz4oXG4gICAgaW5wdXQ6IFRlbnNvclZpZXcsIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZVR5cGUsIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4pOiBbQXR0cmlidXRlVHlwZSwgbnVtYmVyW11dID0+IHtcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QgPSBpbnB1dC5kaW1zLnNsaWNlKCk7XG4gIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdC5zcGxpY2UoMSwgMCwgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnBvcCgpISk7ICAvLyBNb3ZlIGNoYW5uZWwgdG8gdGhlIHNlY29uZCBwb3NpdGlvbi5cbiAgfVxuICBjb25zdCBoYXNEaWxhdGlvbnMgPSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCAnZGlsYXRpb25zJyk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzLnNsaWNlKCk7XG4gIGNvbnN0IGRpbGF0aW9uczogbnVtYmVyW10gPSBoYXNEaWxhdGlvbnMgPyAoYXR0cmlidXRlcyBhcyBNYXhQb29sQXR0cmlidXRlcykuZGlsYXRpb25zLnNsaWNlKCkgOiBbXTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBQb29sQ29udlV0aWwuYWRqdXN0UG9vbEF0dHJpYnV0ZXMoaXNHbG9iYWxPcGVyYXRvciwgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LCBrZXJuZWxTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWRzKTtcblxuICBjb25zdCBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0ID0gUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF0dHJpYnV0ZXMuYXV0b1BhZCk7XG5cbiAgY29uc3QgbmV3QXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzRGlsYXRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGRpbGF0aW9ucywgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXl9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHtrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXl9KTtcbiAgfVxuICBjb25zdCBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QgPSBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnNsaWNlKCk7XG4gIG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdC5wdXNoKG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdC5zcGxpY2UoMSwgMSlbMF0pO1xuICByZXR1cm4gW25ld0F0dHJpYnV0ZXMsIGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0IDogb3V0cHV0U2hhcGVBc0NoYW5uZWxGaXJzdF07XG59O1xuXG5jb25zdCBnZXRVbmlmb3JtQW5kUGFkSW5mbyA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzfE1heFBvb2xBdHRyaWJ1dGVzPihcbiAgICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSk6IFtQcm9ncmFtVW5pZm9ybVtdLCBVbmlmb3Jtc0FycmF5VHlwZSwgYm9vbGVhbiwgYm9vbGVhbiwgYm9vbGVhbl0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID1cbiAgICAgIFt7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga2VybmVsU2l6ZX1dO1xuICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbe25hbWU6ICdvdXRwdXRTaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2tlcm5lbFNpemUnLCB0eXBlOiAndTMyJ31dO1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGNvbnN0IGt3ID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHN3ID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XG4gICAgY29uc3QgcHdFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHB3U3RhcnRFbmROb3RaZXJvID0gISEocHdTdGFydCArIHB3RW5kKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga3d9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzd30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHB3U3RhcnR9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwd0VuZH0sXG4gICAgKTtcbiAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgICB7bmFtZTogJ2t3JywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ3N3JywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ3B3U3RhcnQnLCB0eXBlOiAndTMyJ30sXG4gICAgICAgIHtuYW1lOiAncHdFbmQnLCB0eXBlOiAndTMyJ30pO1xuXG4gICAgbGV0IHBoU3RhcnRFbmROb3RaZXJvID0gZmFsc2U7XG4gICAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBraCA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IHNoID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IHBoU3RhcnQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAvIDIgLSAyXTtcbiAgICAgIGNvbnN0IHBoRW5kID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLSAyXTtcbiAgICAgIHBoU3RhcnRFbmROb3RaZXJvID0gISEocGhTdGFydCArIHBoRW5kKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtofSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2h9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwaFN0YXJ0fSxcbiAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwaEVuZH0pO1xuXG4gICAgICB1bmlmb3Jtcy5wdXNoKFxuICAgICAgICAgIHtuYW1lOiAna2gnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnc2gnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAncGhTdGFydCcsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICB7bmFtZTogJ3BoRW5kJywgdHlwZTogJ3UzMid9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCB0cnVlLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0NoYW5uZWxzTGFzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC4nKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsU3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga2VybmVsU3RyaWRlc30sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMucGFkc30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlc30pO1xuICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICAgIHtuYW1lOiAna2VybmVsU3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGtlcm5lbFN0cmlkZXMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGh9KTtcblxuICAgIGNvbnN0IGhhc1BhZHMgPSBhdHRyaWJ1dGVzLnBhZHMucmVkdWNlKChzdW0sIGN1cikgPT4gc3VtICsgY3VyKTtcbiAgICByZXR1cm4gW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsICEhaGFzUGFkcywgZmFsc2UsIGZhbHNlXTtcbiAgfVxufTtcblxuY29uc3QgZ2VuZXJhdGVQb29saW5nQ29kZSA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzfE1heFBvb2xBdHRyaWJ1dGVzPihcbiAgICBzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlciwgeDogSW5kaWNlc0hlbHBlciwgcmFuazogbnVtYmVyLCBvdXRwdXRTaGFwZVJhbms6IG51bWJlciwgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSxcbiAgICBvcDE6IHN0cmluZywgb3AyOiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIsIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSwgaGFzUGFkczogYm9vbGVhbiwgcHdTdGFydEVuZE5vdFplcm86IGJvb2xlYW4sXG4gICAgcGhTdGFydEVuZE5vdFplcm86IGJvb2xlYW4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGRhdGFUeXBlID0geC50eXBlLnZhbHVlO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgeC50eXBlLnRlbnNvciwgb3V0cHV0U2hhcGVSYW5rKTtcblxuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGxldCBjb2RlVyA9ICcnO1xuICAgIGxldCBjb2RlSCA9ICcnO1xuICAgIGxldCBjb2RlSEVuZCA9ICcnO1xuICAgIGNvbnN0IGRpbUlkeFcgPSByYW5rIC0gKGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDEpO1xuICAgIGlmIChwd1N0YXJ0RW5kTm90WmVybykge1xuICAgICAgY29kZVcgPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeFd9XSA9IGluZGljZXNbJHtkaW1JZHhXfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7ZGltSWR4V31dIDwgMCB8fCB4SW5kaWNlc1ske2RpbUlkeFd9XVxuICAgICAgICAgICAgICAgICAgICAgID49IHVuaWZvcm1zLnhfc2hhcGVbJHtkaW1JZHhXfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZVcgPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeFd9XSA9IGluZGljZXNbJHtkaW1JZHhXfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgICAgICB9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGRpbUlkeEggPSByYW5rIC0gKGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDIpO1xuICAgICAgaWYgKHBoU3RhcnRFbmROb3RaZXJvKSB7XG4gICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhIfV0gPSBpbmRpY2VzWyR7ZGltSWR4SH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2RpbUlkeEh9XSA8IDAgfHwgeEluZGljZXNbJHtkaW1JZHhIfV0gPj0gdW5pZm9ybXMueF9zaGFwZVske2RpbUlkeEh9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQgKz0gaTMyKHVuaWZvcm1zLmt3KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4SH1dID0gaW5kaWNlc1ske2RpbUlkeEh9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIGNvZGVIRW5kID0gYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgIH1cblxuICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oJHtzdGFydH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHtjb2RlSH1cbiAgICAgICAgICAgICAgJHtjb2RlV31cbiAgICAgICAgICAgICAgJHtjb2RlSEVuZH1cbiAgICAgICAgICAgICAgJHtvcDJ9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YDtcbiAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LicpO1xuICAgIH1cbiAgICBjb25zdCBzdHJpZGVzUmFuayA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHBhZHNSYW5rID0gYXR0cmlidXRlcy5wYWRzLmxlbmd0aDtcbiAgICBsZXQgcGFkQ29kZSA9ICcnO1xuICAgIGlmIChoYXNQYWRzKSB7XG4gICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7c3RyaWRlc1Jhbmt9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgke3N0YXJ0fSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7c3RyaWRlc1JhbmsgLSAxfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzJywgJ2onLCBzdHJpZGVzUmFuayl9O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMua2VybmVsU3RyaWRlcycsICdqJywgc3RyaWRlc1JhbmspfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske3N0cmlkZXNSYW5rIC0gMX1dID0gb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dTsgaiA8ICR7cmFua311OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzW2pdID0gaW5kaWNlc1tqXSAqICR7XG4gICAgICAgIGdldEVsZW1lbnRBdCgndW5pZm9ybXMuc3RyaWRlcycsIGBqIC0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dWAsIHN0cmlkZXNSYW5rKX1cbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3JhbmsgLSBzdHJpZGVzUmFua311XSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgJ2ogLSAydScsIHBhZHNSYW5rKX07XG4gICAgICAgICAgICAgICAgICAke3BhZENvZGV9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHtvcDJ9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YDtcbiAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnfCdOQ0hXJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb29sQ29tbW9uQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNlaWxNb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5jb25zdCBjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBQb29sQ29tbW9uQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICAgIChgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthdHRyaWJ1dGVzLmNlaWxNb2RlfTske2F0dHJpYnV0ZXMuYXV0b1BhZH07JHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aH1gKTtcblxuY29uc3QgY3JlYXRlQXZlcmFnZVBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT5cbiAgICAoYCR7Y3JlYXRlU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyl9OyR7YXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWR9YCk7XG5cbmNvbnN0IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICAgIChgJHtjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKX07JHthdHRyaWJ1dGVzLnN0b3JhZ2VPcmRlcn07JHthdHRyaWJ1dGVzLmRpbGF0aW9uc31gKTtcblxuY29uc3QgcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFBvb2xDb21tb25BdHRyaWJ1dGVzID0+ICh7XG4gIGZvcm1hdDogYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J10sXG4gIGF1dG9QYWQ6IFsnTk9UU0VUJywgJ1ZBTElEJywgJ1NBTUVfVVBQRVInLCAnU0FNRV9MT1dFUiddW2F0dHJpYnV0ZXMuYXV0b19wYWQgYXMgbnVtYmVyXSxcbiAgY2VpbE1vZGU6IGF0dHJpYnV0ZXMuY2VpbF9tb2RlIGFzIG51bWJlcixcbiAga2VybmVsU2hhcGU6IGF0dHJpYnV0ZXMua2VybmVsX3NoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gIHN0cmlkZXM6IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICBwYWRzOiBhdHRyaWJ1dGVzLnBhZHMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbn0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjb3VudEluY2x1ZGVQYWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8gPVxuICAgIChuYW1lOiBzdHJpbmcsIGlucHV0OiBUZW5zb3JWaWV3LCBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBbYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZV0gPVxuICAgICAgICAgIGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShpbnB1dCwgYXR0cmlidXRlcywgaXNHbG9iYWxPcGVyYXRvcik7XG4gICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcblxuICAgICAgY29uc3Qgb3AxID0gJ3ZhbHVlICs9IHhfdmFsOyc7XG4gICAgICBsZXQgb3AyID0gJyc7XG4gICAgICBpZiAoYWRqdXN0ZWRBdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZCkge1xuICAgICAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCBoYXNQYWRzLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dID1cbiAgICAgICAgICBnZXRVbmlmb3JtQW5kUGFkSW5mbyhvdXRwdXRTaGFwZSwgYWRqdXN0ZWRBdHRyaWJ1dGVzKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0LmRpbXMsIG91dHB1dFNoYXBlKSk7XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc2hhZGVyQ2FjaGU6XG4gICAgICAgICAgICB7aGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtoYXNQYWRzfTske3B3U3RhcnRFbmROb3RaZXJvfTske3BoU3RhcnRFbmROb3RaZXJvfWAsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2U6IHNoYWRlckhlbHBlciA9PiBnZW5lcmF0ZVBvb2xpbmdDb2RlKFxuICAgICAgICAgICAgc2hhZGVySGVscGVyLCB4LCBpbnB1dC5kaW1zLmxlbmd0aCwgb3V0cHV0U2hhcGUubGVuZ3RoLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIG9wMSwgb3AyLCAwLjAsIHVuaWZvcm1zLFxuICAgICAgICAgICAgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvKSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgY291bnRJbmNsdWRlUGFkID0gKGF0dHJpYnV0ZXMuY291bnRfaW5jbHVkZV9wYWQgYXMgbnVtYmVyKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZSdcbiAgaWYgKGF0dHIuY2VpbE1vZGUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2wnKTtcbiAgfVxuICBjb25zdCBhdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSB7Y291bnRJbmNsdWRlUGFkLCAuLi5hdHRyLCBjYWNoZUtleTogJyd9O1xuICByZXR1cm4gey4uLmF2ZXJhZ2VQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZUF2ZXJhZ2VQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMoYXZlcmFnZVBvb2xBdHRyaWJ1dGVzKX07XG59O1xuXG5leHBvcnQgY29uc3QgYXZlcmFnZVBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKCdBdmVyYWdlUG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCBmYWxzZSwgYXR0cmlidXRlcykpO1xufTtcblxuY29uc3QgZ2xvYmFsUG9vbEF0dHJpYnV0ZXMgPSB7XG4gIGF1dG9QYWQ6ICcnLFxuICBjZWlsTW9kZTogMCxcbiAgY291bnRJbmNsdWRlUGFkOiBmYWxzZSxcbiAga2VybmVsU2hhcGU6IFtdLFxuICBzdHJpZGVzOiBbXSxcbiAgcGFkczogW10sXG4gIHN0b3JhZ2VPcmRlcjogMCxcbiAgZGlsYXRpb25zOiBbXVxufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J107XG4gIHJldHVybiB7Zm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2xvYmFsQXZlcmFnZVBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKCdHbG9iYWxBdmVyYWdlUG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCB0cnVlLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIE1heFBvb2xBdHRyaWJ1dGVzIGV4dGVuZHMgUG9vbENvbW1vbkF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHN0b3JhZ2VPcmRlcjogbnVtYmVyO1xuICByZWFkb25seSBkaWxhdGlvbnM6IG51bWJlcltdO1xufVxuXG5jb25zdCBjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8gPVxuICAgIChuYW1lOiBzdHJpbmcsIGlucHV0OiBUZW5zb3JWaWV3LCBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9XG4gICAgICAgICAgZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlKGlucHV0LCBhdHRyaWJ1dGVzLCBpc0dsb2JhbE9wZXJhdG9yKTtcbiAgICAgIGNvbnN0IG9wMSA9IGBcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XG4gICAgYDtcbiAgICAgIGNvbnN0IG9wMiA9ICcnO1xuICAgICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcy5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcbiAgICAgIGNvbnN0IFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCBoYXNQYWRzLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dID1cbiAgICAgICAgICBnZXRVbmlmb3JtQW5kUGFkSW5mbyhvdXRwdXRTaGFwZSwgYWRqdXN0ZWRBdHRyaWJ1dGVzKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0LmRpbXMsIG91dHB1dFNoYXBlKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBzaGFkZXJDYWNoZTpcbiAgICAgICAgICAgIHtoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2hhc1BhZHN9OyR7cHdTdGFydEVuZE5vdFplcm99OyR7cGhTdGFydEVuZE5vdFplcm99YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dC5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZTogc2hhZGVySGVscGVyID0+IGdlbmVyYXRlUG9vbGluZ0NvZGUoXG4gICAgICAgICAgICBzaGFkZXJIZWxwZXIsIHgsIGlucHV0LmRpbXMubGVuZ3RoLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGFkanVzdGVkQXR0cmlidXRlcywgb3AxLCBvcDIsXG4gICAgICAgICAgICAoaW5wdXQuZGF0YVR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYpID8gLTY1NTA0IDogLTFlNSwgdW5pZm9ybXMsIGhhc1BhZHMsIHB3U3RhcnRFbmROb3RaZXJvLFxuICAgICAgICAgICAgcGhTdGFydEVuZE5vdFplcm8pLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbWF4UG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKCdNYXhQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIGZhbHNlLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXhQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1heFBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3RvcmFnZU9yZGVyID0gYXR0cmlidXRlcy5zdG9yYWdlX29yZGVyIGFzIG51bWJlcjtcbiAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMgYXMgW251bWJlciwgbnVtYmVyXTtcblxuICBjb25zdCBhdHRyID0gcGFyc2VQb29sQ29tbW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZScgYW5kICdzdG9yYWdlX29yZGVyJ1xuICBpZiAoc3RvcmFnZU9yZGVyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG4gIGlmIChhdHRyLmNlaWxNb2RlICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgfVxuICBjb25zdCBtYXhQb29sQXR0cmlidXRlcyA9IHtzdG9yYWdlT3JkZXIsIGRpbGF0aW9ucywgLi4uYXR0ciwgY2FjaGVLZXk6ICcnfTtcbiAgcmV0dXJuIHsuLi5tYXhQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhtYXhQb29sQXR0cmlidXRlcyl9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBNYXhQb29sQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzIEZvcm1hdEF0dHJpYnV0ZXNbJ2Zvcm1hdCddO1xuICByZXR1cm4ge2Zvcm1hdCwgLi4uZ2xvYmFsUG9vbEF0dHJpYnV0ZXMsIGNhY2hlS2V5OiBmb3JtYXR9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbygnR2xvYmFsTWF4UG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCB0cnVlLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzQ29udGVudCA9IChzdGFydDogbnVtYmVyLCBsaW1pdDogbnVtYmVyLCBkZWx0YTogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHNhbWVTdGFydExpbWl0ID0gc3RhcnQgPT09IGxpbWl0O1xuICBjb25zdCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgPSBzdGFydCA8IGxpbWl0ICYmIGRlbHRhIDwgMDtcbiAgY29uc3QgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwID0gc3RhcnQgPiBsaW1pdCAmJiBkZWx0YSA+IDA7XG5cbiAgaWYgKHNhbWVTdGFydExpbWl0IHx8IGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCB8fCBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhbmdlIHRoZXNlIGlucHV0c1xcJyBjb250ZW50cyBhcmUgaW52YWxpZC4nKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlUmFuZ2VQcm9ncmFtSW5mbyA9IChzdGFydDogbnVtYmVyLCBsaW1pdDogbnVtYmVyLCBkZWx0YTogbnVtYmVyLCBkYXRhVHlwZTogRGF0YVR5cGUpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG51bUVsZW1lbnRzID0gTWF0aC5hYnMoTWF0aC5jZWlsKChsaW1pdCAtIHN0YXJ0KSAvIGRlbHRhKSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtudW1FbGVtZW50c107XG4gIGNvbnN0IG91dHB1dFNpemUgPSBudW1FbGVtZW50cztcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogZGF0YVR5cGUsIGRhdGE6IHN0YXJ0fSwge3R5cGU6IGRhdGFUeXBlLCBkYXRhOiBkZWx0YX0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IHdnc2xUeXBlID0gb3V0cHV0LnR5cGUudmFsdWU7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAge25hbWU6ICdvdXRwdXRTaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ3N0YXJ0JywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZX0sXG4gICAgICB7bmFtZTogJ2RlbHRhJywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZX1cbiAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMob3V0cHV0KX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdW5pZm9ybXMuc3RhcnQgKyAke3dnc2xUeXBlfShnbG9iYWxfaWR4KSAqIHVuaWZvcm1zLmRlbHRhO1xuICAgICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnUmFuZ2UnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7ZGF0YVR5cGV9YH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgIH0pXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGxpbWl0ID0gMDtcbiAgbGV0IGRlbHRhID0gMDtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMikge1xuICAgIHN0YXJ0ID0gY29udGV4dC5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICAgIGxpbWl0ID0gY29udGV4dC5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICAgIGRlbHRhID0gY29udGV4dC5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICB9IGVsc2UgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgIHN0YXJ0ID0gY29udGV4dC5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF07XG4gICAgbGltaXQgPSBjb250ZXh0LmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcbiAgICBkZWx0YSA9IGNvbnRleHQuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xuICB9XG4gIGlmIChlbnYud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50KSB7XG4gICAgdmFsaWRhdGVJbnB1dHNDb250ZW50KHN0YXJ0LCBsaW1pdCwgZGVsdGEpO1xuICB9XG5cbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJhbmdlUHJvZ3JhbUluZm8oc3RhcnQsIGxpbWl0LCBkZWx0YSwgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpLCB7aW5wdXRzOiBbXX0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRFbGVtZW50QXQsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9ICdoYWxmX3BpeGVsJ3wnYXN5bW1ldHJpYyd8J3B5dG9yY2hfaGFsZl9waXhlbCd8J3RmX2hhbGZfcGl4ZWxfZm9yX25uJ3wnYWxpZ25fY29ybmVycyd8XG4gICAgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSd8J2hhbGZfcGl4ZWxfc3ltbWV0cmljJztcblxudHlwZSBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSAnc3RyZXRjaCd8J25vdF9zbWFsbGVyJ3wnbm90X2xhcmdlcic7XG5cbnR5cGUgTW9kZSA9ICduZWFyZXN0J3wnbGluZWFyJ3wnY3ViaWMnO1xuXG50eXBlIE5lYXJlc3RNb2RlID0gJ3JvdW5kX3ByZWZlcl9mbG9vcid8J3JvdW5kX3ByZWZlcl9jZWlsJ3wnZmxvb3InfCdjZWlsJ3wnc2ltcGxlJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXNpemVBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYW50aWFsaWFzOiBudW1iZXI7XG4gIGF4ZXM6IG51bWJlcltdO1xuICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU7XG4gIGN1YmljQ29lZmZBOiBudW1iZXI7XG4gIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcjtcbiAga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIG1vZGU6IE1vZGU7XG4gIG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZTtcbn1cblxuY29uc3QgdmFsaWRhdGVTY2FsZXMgPSAoc2NhbGVzOiBudW1iZXJbXSwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBzY2FsZXMuZXZlcnkoKHZhbHVlKSA9PiB2YWx1ZSA+IDAgfHwgKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgLy8gQ2hlY2sgc2NhbGVzIGRpbXMgYmFzZWQgb24gbW9kZTogTElORUFSLCBDVUJJQ1xuICBpZiAoc2NhbGVzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAnbGluZWFyJykge1xuICAgICAgaWYgKCEoc2NhbGVzLmxlbmd0aCA9PT0gMiB8fCBzY2FsZXMubGVuZ3RoID09PSAzIHx8IChzY2FsZXMubGVuZ3RoID09PSA0ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbMV0gPT09IDEpIHx8XG4gICAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKSB8fFxuICAgICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDUgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGb3IgbGluZWFyIG1vZGUsIFJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgdG8gYmUgMkQsIDNELCA0RCB3aXRoIGVpdGhlciB0d28gb3V0ZXJtb3N0IG9yIG9uZSBpbm5lcm1vc3QgYW5kXG4gICAgICAgICAgICBvbmUgb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxLCBvciA1RCB3aXRoIHR3byBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDFgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMubW9kZSA9PT0gJ2N1YmljJykge1xuICAgICAgaWYgKCEoc2NhbGVzLmxlbmd0aCA9PT0gMiB8fCAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzFdID09PSAxKSB8fFxuICAgICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1szXSA9PT0gMSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuY29uc3QgdXBkYXRlU2NhbGVzID0gKHNjYWxlczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XG4gIGF4ZXMuZXZlcnkoKHZhbHVlKSA9PiB2YWx1ZSA+PSAwICYmIHZhbHVlIDwgcmFuayB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmsnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgY29uc3QgbmV3U2NhbGVzID0gbmV3IEFycmF5KHJhbmspLmZpbGwoMS4wKTtcbiAgYXhlcy5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IG5ld1NjYWxlc1t2YWx1ZV0gPSBzY2FsZXNbaW5kZXhdKTtcbiAgcmV0dXJuIG5ld1NjYWxlcztcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbjogbnVtYmVyLCBzY2FsZXM6IG51bWJlcltdLFxuICAgICBzaXplczogbnVtYmVyW10sIHJvaTogbnVtYmVyW10pOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IFtyb2lJbnB1dEluZGV4LCBzY2FsZXNJbnB1dEluZGV4LCBzaXplc0lucHV0SW5kZXhdID1cbiAgICAgICAgICAob3BzZXRWZXJzaW9uID4gMTApID8gWzEsIDIsIDNdIDogWy0xLCAoaW5wdXRzLmxlbmd0aCA+IDEpID8gMSA6IC0xLCAtMV07XG4gICAgICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICAgICAgaWYgKHJvaUlucHV0SW5kZXggPiAwICYmIGlucHV0cy5sZW5ndGggPiByb2lJbnB1dEluZGV4ICYmIGlucHV0c1tyb2lJbnB1dEluZGV4XS5kaW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5wdXRzW3JvaUlucHV0SW5kZXhdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiByb2kucHVzaCh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBSb0kgaW5wdXQgdG8gYmUgc3BlY2lmaWVkIHdoZW4gY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgaXMgdGZDcm9wQW5kUmVzaXplJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2FsZXNJbnB1dEluZGV4ID4gMCAmJiBpbnB1dHMubGVuZ3RoID4gc2NhbGVzSW5wdXRJbmRleCAmJiBpbnB1dHNbc2NhbGVzSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gc2NhbGVzLnB1c2godmFsdWUpKTtcbiAgICAgICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IDAgJiZcbiAgICAgICAgICAgIChzY2FsZXMubGVuZ3RoICE9PSByYW5rICYmIChvcHNldFZlcnNpb24gPj0gMTggJiYgc2NhbGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlU2NhbGVzKHNjYWxlcywgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVwZGF0ZVNjYWxlcyhzY2FsZXMsIGF0dHJpYnV0ZXMuYXhlcywgcmFuaykuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiBzY2FsZXNbaW5kZXhdID0gdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZXNJbnB1dEluZGV4ID4gMCAmJiBpbnB1dHMubGVuZ3RoID4gc2l6ZXNJbnB1dEluZGV4KSB7XG4gICAgICAgIGlucHV0c1tzaXplc0lucHV0SW5kZXhdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKCh2YWx1ZSkgPT4gc2l6ZXMucHVzaChOdW1iZXIodmFsdWUpKSk7XG4gICAgICAgIGlmIChzaXplcy5sZW5ndGggIT09IHJhbmsgfHwgKG9wc2V0VmVyc2lvbiA+PSAxOCAmJiBzaXplcy5sZW5ndGggPT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdSZXNpemUgcmVxdWlyZXMgXCJzaXplc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgcmFuayBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2NhbGVzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc2l6ZXMgIT09ICd1bmRlZmluZWQnICYmIHNjYWxlcy5sZW5ndGggPiAwICYmIHNpemVzLmxlbmd0aCA+IHJhbmspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gICAgICB9XG4gICAgfTtcblxuY29uc3QgZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlID1cbiAgICAoY29vcmRpbmF0ZVRyYW5zZmVyTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsIGRUeXBlOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgICAgICAgYGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHtkVHlwZX0geyBgICtcbiAgICAoKCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoY29vcmRpbmF0ZVRyYW5zZmVyTW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnYXN5bW1ldHJpYyc6XG4gICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICR7ZFR5cGV9KHhSZXNpemVkKSAvICR7ZFR5cGV9KHhTY2FsZSk7YDtcbiAgICAgICAgICAgIGNhc2UgJ3B5dG9yY2hfaGFsZl9waXhlbCc6XG4gICAgICAgICAgICAgIHJldHVybiBgaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkgLSAwLjU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjYXNlICd0Zl9oYWxmX3BpeGVsX2Zvcl9ubic6XG4gICAgICAgICAgICAgIHJldHVybiBgcmV0dXJuICgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKTtgO1xuICAgICAgICAgICAgY2FzZSAnYWxpZ25fY29ybmVycyc6XG4gICAgICAgICAgICAgIHJldHVybiBgaWYgKGxlbmd0aFJlc2l6ZWQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHdob2xlIHBhcnQgYW5kIHRoZSBmcmFjdGlvbmFsIHBhcnQgYXJlIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBkdWUgdG8gaW5hY2N1cmFjeSBvZiBmbG9hdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBwb2ludCBkaXZpc2lvbi4gQXMgYW4gZXhhbXBsZSwgZjMyKDIxKSAvIGYzMig3KSBtYXkgZXZhbHVhdGUgdG8gMi45OS4uLiBpbnN0ZWFkIG9mIDMsIGNhdXNpbmcgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0LWJ5LW9uZSBlcnJvciBsYXRlciBpbiBmbG9vcigpLlxuICAgICAgICAgICAgICAgICAgICBsZXQgd2hvbGUgPSAke2RUeXBlfSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAke2RUeXBlfSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpICUgKGxlbmd0aFJlc2l6ZWQgLSAxKSkgLyAke2RUeXBlfShsZW5ndGhSZXNpemVkIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aG9sZSArIGZyYWN0O1xuICAgICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjYXNlICd0Zl9jcm9wX2FuZF9yZXNpemUnOlxuICAgICAgICAgICAgICByZXR1cm4gYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHtkVHlwZX0ocm9pU3RhcnQpICogJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwgLSAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJHtkVHlwZX0oeFJlc2l6ZWQpICogJHtkVHlwZX0ocm9pRW5kIC0gcm9pU3RhcnQpICogJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwgLSAxKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgJHtkVHlwZX0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICR7ZFR5cGV9KHJvaVN0YXJ0ICsgcm9pRW5kKSAqICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsIC0gMSk7XG4gICAgICAgICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGNhc2UgJ2hhbGZfcGl4ZWxfc3ltbWV0cmljJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGBjb25zdCBvdXRwdXRXaWR0aCA9ICR7ZFR5cGV9eFNjYWxlICogJHtkVHlwZX0obGVuZ3RoUmVzaXplZCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHtkVHlwZX0obGVuZ3RoUmVzaXplZCkgLyBvdXRwdXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9ICR7ZFR5cGV9KGxlbmd0aE9yaWdpbmFsKSAvIDI7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjZW50ZXIgKiAoMSAtIGFkanVzdG1lbnQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArICgoJHtkVHlwZX0oeFJlc2l6ZWQpICsgMC41KSAvICR7ZFR5cGV9KHhTY2FsZSkpIC0gMC41O2A7XG4gICAgICAgICAgICBjYXNlICdoYWxmX3BpeGVsJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gKCgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSkgLSAwLjU7YDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2Nvb3JkaW5hdGVUcmFuc2Zlck1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCkgK1xuICAgICd9JztcblxuY29uc3QgZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsID0gKG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZSwgb3BzZXRWZXJzaW9uOiBudW1iZXIsIGRUeXBlOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgICBgZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogJHtkVHlwZX0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtkVHlwZX0ge2AgKyAoKCkgPT4ge1xuICAgICAgc3dpdGNoIChuZWFyZXN0TW9kZSkge1xuICAgICAgICBjYXNlICdyb3VuZF9wcmVmZXJfY2VpbCc6XG4gICAgICAgICAgcmV0dXJuICdpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgXFxcbiAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgIH0nO1xuICAgICAgICBjYXNlICdmbG9vcic6XG4gICAgICAgICAgcmV0dXJuICdyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsnO1xuICAgICAgICBjYXNlICdjZWlsJzpcbiAgICAgICAgICByZXR1cm4gJ3JldHVybiBjZWlsKHhPcmlnaW5hbCk7JztcbiAgICAgICAgY2FzZSAncm91bmRfcHJlZmVyX2Zsb29yJzpcbiAgICAgICAgICByZXR1cm4gJ2lmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyBcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgICAgICAgICAgfSc7XG4gICAgICAgIGNhc2UgJ3NpbXBsZSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKG9wc2V0VmVyc2lvbiA8IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lmIChpc0Rvd25TYW1wbGUpIFxcXG4gICAgICAgICAgICAgICAgICAgIHsgXFxcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyBcXFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7IFxcXG4gICAgICAgICAgICAgICAgICAgIH0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke25lYXJlc3RNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICB9XG4gICAgfSkoKSArXG4gICAgJ30nO1xuXG5jb25zdCB1cGRhdGVSb0kgPSAocm9pOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3Qgcm9pVG1wID0gbmV3IEFycmF5KHJhbmspLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyYW5rKS5maWxsKDEpKTtcbiAgY29uc3Qgcm9pTG9jYWwgPSByb2kubGVuZ3RoID09PSAwID8gcm9pVG1wIDogcm9pLnNsaWNlKCk7XG4gIGlmIChheGVzLmxlbmd0aCA+IDApIHtcbiAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgIHJvaVRtcFt2XSA9IHJvaUxvY2FsW2ldO1xuICAgICAgcm9pVG1wW2kgKyByYW5rXSA9IHJvaUxvY2FsW2F4ZXMubGVuZ3RoICsgaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvaVRtcDtcbiAgfVxuICByZXR1cm4gcm9pTG9jYWw7XG59O1xuXG5jb25zdCBpbml0T3V0cHV0U2hhcGUgPVxuICAgIChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgc2l6ZXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSk6XG4gICAgICAgIG51bWJlcltdID0+IHtcbiAgICAgICAgICBsZXQgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gICAgICAgICAgaWYgKHNpemVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChheGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRTaGFwZS5mb3JFYWNoKCh2KSA9PiBvdXRwdXRTaGFwZS5wdXNoKHYpKTtcbiAgICAgICAgICAgICAgaWYgKE1hdGgubWF4KC4uLmF4ZXMpID4gaW5wdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4ZXMgaXMgb3V0IG9mIGJvdW5kJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXhlcy5mb3JFYWNoKCh2LCBpKSA9PiBvdXRwdXRTaGFwZVt2XSA9IHNpemVzW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNpemVzLmZvckVhY2goKHYpID0+IG91dHB1dFNoYXBlLnB1c2godikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NhbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLm1hcCgodmFsdWUsIGluZGV4KSA9PiBNYXRoLnJvdW5kKHZhbHVlICogc2NhbGVzW2luZGV4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gICAgICAgIH07XG5cbmNvbnN0IGFkanVzdE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IHNjYWxlSW5Qb2xpY3kgPSAoKCkgPT4ge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpIHtcbiAgICAgIGNhc2UgJ25vdF9sYXJnZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbiguLi5hdHRyaWJ1dGVzLmF4ZXMubWFwKGkgPT4gc2NhbGVzW2ldKSwgTnVtYmVyLk1BWF9WQUxVRSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbiguLi5zY2FsZXMsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgY2FzZSAnbm90X3NtYWxsZXInOlxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5hdHRyaWJ1dGVzLmF4ZXMubWFwKGkgPT4gc2NhbGVzW2ldKSwgTnVtYmVyLk1JTl9WQUxVRSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCguLi5zY2FsZXMsIE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHthdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKTtcbiAgc2NhbGVzLmZpbGwoMS4wLCAwLCBzY2FsZXMubGVuZ3RoKTtcbiAgY29uc3QgYWRqdXN0ZWRPdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IHNjYWxlc1t2XSA9IHNjYWxlSW5Qb2xpY3kpO1xuICAgIGF0dHJpYnV0ZXMuYXhlcy5mb3JFYWNoKCh2KSA9PiBhZGp1c3RlZE91dHB1dFNoYXBlW3ZdID0gTWF0aC5yb3VuZChpbnB1dFNoYXBlW3ZdICogc2NhbGVzW3ZdKSk7XG4gIH0gZWxzZSB7XG4gICAgc2NhbGVzLmZpbGwoc2NhbGVJblBvbGljeSwgMCwgc2NhbGVzLmxlbmd0aCk7XG4gICAgYWRqdXN0ZWRPdXRwdXRTaGFwZS5mb3JFYWNoKCh2LCBpKSA9PiBhZGp1c3RlZE91dHB1dFNoYXBlW2ldID0gTWF0aC5yb3VuZCh2ICogc2NhbGVzW2ldKSk7XG4gIH1cbiAgcmV0dXJuIGFkanVzdGVkT3V0cHV0U2hhcGU7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyA9XG4gICAgKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc2NhbGVzTGVuZ3RoOiBudW1iZXIsXG4gICAgIHJvaUxlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IGBcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gYXJyYXk8JHtcbiAgICAgICAgb3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dFNoYXBlLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2NhbGVzJywgJ2knLCBzY2FsZXNMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCBgaSArICR7aW5wdXRTaGFwZS5sZW5ndGh9YCwgcm9pTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtvdXRwdXQudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsX2luZGljZXM7XG4gICAgfWA7XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgc2NhbGVzTGVuZ3RoOiBudW1iZXIsIHJvaUxlbmd0aDogbnVtYmVyLCB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuKTogc3RyaW5nID0+IGBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4OiB1MzI7XG4gICAgICAgIHZhciBzY2FsZSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zY2FsZXMnLCAnaScsIHNjYWxlc0xlbmd0aCl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsIGBpICsgJHtpbnB1dFNoYXBlLmxlbmd0aH1gLCByb2lMZW5ndGgpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxfaWR4ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgICBpZiAoISR7dXNlRXh0cmFwb2xhdGlvbn0gfHwgKG9yaWdpbmFsX2lkeCA+PSAwICYmIG9yaWdpbmFsX2lkeCA8ICR7b3V0cHV0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke291dHB1dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICcgaW5wdXRfaW5kZXgnKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgIH1gO1xuY29uc3QgY2hlY2tJbnB1dEluZGljZXMgPSAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogc3RyaW5nID0+IGBcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtpbnB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSAke2lucHV0LmluZGljZXNHZXQoJ2lucHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgaWYgKGlucHV0X2luZGV4IDwgMCB8fCBpbnB1dF9pbmRleCA+PSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gO1xuXG5jb25zdCBzZXRDaGFubmVsQW5kQmF0Y2hJbmRpY2VzID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIGNoYW5uZWxJZHg6IG51bWJlciwgYmF0Y2hJZHg6IG51bWJlciwgc3BhY2lhbERpbXM6IG51bWJlcik6IHN0cmluZyA9PlxuICAgICAgICBpbnB1dC5yYW5rID4gc3BhY2lhbERpbXMgPyBgXG4gICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgY2hhbm5lbElkeCwgJ2NoYW5uZWwnKX07XG4gICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgYmF0Y2hJZHgsICdiYXRjaCcpfTtcbmAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJztcblxuY29uc3QgYmlsaW5lYXJJbnRlcnBvbGF0aW9uID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4gICAgIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gICAgICBjb25zdCBbYmF0Y2hJZHgsIGhlaWdodElkeCwgd2lkdGhJZHgsIGNoYW5uZWxJZHhdID1cbiAgICAgICAgICBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiA/IFstMSwgMCwgMSwgLTFdIDogKGlzTmNodyA/IFswLCAyLCAzLCAxXSA6IFswLCAxLCAyLCAzXSk7XG4gICAgICBjb25zdCBkVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gICAgICByZXR1cm4gYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBoZWlnaHRJZHgsIGBtYXgoMCwgbWluKHJvdywgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgd2lkdGhJZHgsIGBtYXgoMCwgbWluKGNvbCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAyKX1cbiAgICAgIHJldHVybiAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICB9XG5cbiAgICBmbiBiaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgcm93OiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7aGVpZ2h0SWR4fV07XG4gICAgICB2YXIgY29sOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7d2lkdGhJZHh9XTtcbiAgICAgICR7XG4gICAgICAgICAgdXNlRXh0cmFwb2xhdGlvbiA/XG4gICAgICAgICAgICAgIGBpZiAocm93IDwgMCB8fCByb3cgPiAoJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkgfHwgY29sIDwgMCB8fCBjb2wgPiAoJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgfWAgOlxuICAgICAgICAgICAgICAnJ307XG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDIgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2NoYW5uZWxJZHh9XSlgIDogJzAnfTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7aW5wdXRTaGFwZS5sZW5ndGggPiAyID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtiYXRjaElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIHgxMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcbiAgICAgIHZhciB4MTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xuICAgICAgdmFyIHgyMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKHJvdyAtICR7ZFR5cGV9KHJvdzEpKTtcbiAgICAgIHZhciBkeDI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHJvdzIpIC0gcm93KTtcbiAgICAgIHZhciBkeTE6ICR7ZFR5cGV9ID0gYWJzKGNvbCAtICR7ZFR5cGV9KGNvbDEpKTtcbiAgICAgIHZhciBkeTI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KGNvbDIpIC0gY29sKTtcbiAgICAgIGlmIChyb3cxID09IHJvdzIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoY29sMSA9PSBjb2wyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xuICAgIH1gO1xuICAgIH07XG5cbmNvbnN0IGJpY3ViaWNJbnRlcnBvbGF0aW9uID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgcm9pOiByZWFkb25seSBudW1iZXJbXSwgY3ViaWNDb2VmZkE6IG51bWJlciwgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcbiAgICAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsIGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGlzMkQgPSBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMjtcbiAgICAgIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gICAgICBjb25zdCBbaGVpZ2h0SWR4LCB3aWR0aElkeF0gPSBpczJEID8gWzAsIDFdIDogaXNOY2h3ID8gWzIsIDNdIDogWzEsIDJdO1xuICAgICAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgICAgY29uc3QgY3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSAoaWR4OiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBpZHggPT09IGhlaWdodElkeCA/ICdyb3cnIDogJ2NvbCc7XG4gICAgICAgIHJldHVybiBgXG4gICAgICBmbiAke2RpcmVjdGlvbn1DdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9LCBvdXRwdXRfaW5kaWNlczogJHtcbiAgICAgICAgICAgIG91dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGlkeCl9O1xuICAgICAgICB2YXIgb3JpZ2luYWxJZHg6ICR7ZFR5cGV9ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgJHtzY2FsZXNbaWR4XX0sXG4gICAgICAgICR7b3V0cHV0U2hhcGVbaWR4XX0sICR7aW5wdXRTaGFwZVtpZHhdfSwgJHtyb2lbaWR4XX0sICR7cm9pW2lkeF19ICsgJHtpbnB1dFNoYXBlLmxlbmd0aH0pO1xuICAgICAgICB2YXIgZnJhY3RPcmlnaW5hbElkeDogJHtkVHlwZX0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XG5cbiAgICAgICAgaWYgKCR7dXNlRXh0cmFwb2xhdGlvbn0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke2lucHV0U2hhcGVbaWR4XX0gLSAxKSkpIHtcbiAgICAgICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwke2RUeXBlfSwgND4gPSBhcnJheTwke2RUeXBlfSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgJHtkaXJlY3Rpb259OiAke2RUeXBlfSA9IG9yaWdpbmFsSWR4ICsgJHtkVHlwZX0oaSk7XG4gICAgICAgICAgaWYgKCR7ZGlyZWN0aW9ufSA8IDAgfHwgJHtkaXJlY3Rpb259ID49ICR7aW5wdXRTaGFwZVtpZHhdfSkge1xuICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgIGlmIChleGNsdWRlT3V0c2lkZSkge1xuICAgICAgICAgICAgcmV0dXJuIGBjb2Vmc1tpICsgMV0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtgO1xuICAgICAgICAgIH0gZWxzZSBpZiAodXNlRXh0cmFwb2xhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O2A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtkaXJlY3Rpb259ID0gbWF4KDAsIG1pbigke2RpcmVjdGlvbn0sICR7aW5wdXRTaGFwZVtpZHhdfSAtIDEpKTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlc19jb3B5OiAke2lucHV0LnR5cGUuaW5kaWNlc30gPSBpbnB1dF9pbmRpY2VzO1xuICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlc19jb3B5JywgaWR4LCBgdTMyKCR7ZGlyZWN0aW9ufSlgKX07XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSAke1xuICAgICAgICAgICAgaWR4ID09PSBoZWlnaHRJZHggPyBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXNfY29weScpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Jvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKSd9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XG4gICAgICB9YDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBgXG4gICAgJHtjcmVhdGVDdWJpY0ludGVycG9sYXRpb25GdW5jdGlvbihoZWlnaHRJZHgpfTtcbiAgICAke2NyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uKHdpZHRoSWR4KX07XG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7ZFR5cGV9KSAtPiBhcnJheTwke2RUeXBlfSwgND4ge1xuICAgIHZhciBhYnNTID0gYWJzKHMpO1xuICAgIHZhciBjb2VmZnM6IGFycmF5PCR7ZFR5cGV9LCA0PiA9IGFycmF5PCR7ZFR5cGV9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7ZFR5cGV9ID0gMS4wIC0gYWJzUztcbiAgICB2YXIgdHdvTWludXNBYnNTOiAke2RUeXBlfSA9IDIuMCAtIGFic1M7XG4gICAgdmFyIG9uZVBsdXNBYnNTOiAke2RUeXBlfSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke2N1YmljQ29lZmZBfSAqIG9uZVBsdXNBYnNTIC0gNSAqICR7Y3ViaWNDb2VmZkF9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7XG4gICAgICAgICAgY3ViaWNDb2VmZkF9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7Y3ViaWNDb2VmZkF9O1xuICAgIGNvZWZmc1sxXSA9ICgoJHtjdWJpY0NvZWZmQX0gKyAyKSAqIGFic1MgLSAoJHtjdWJpY0NvZWZmQX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke2N1YmljQ29lZmZBfSArIDIpICogb25lTWludXNBYnNTIC0gKCR7Y3ViaWNDb2VmZkF9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcbiAgICBjb2VmZnNbM10gPSAoKCR7Y3ViaWNDb2VmZkF9ICogdHdvTWludXNBYnNTIC0gNSAqICR7Y3ViaWNDb2VmZkF9KSAqIHR3b01pbnVzQWJzUyArIDggKiAke1xuICAgICAgICAgIGN1YmljQ29lZmZBfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHtjdWJpY0NvZWZmQX07XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7ZFR5cGV9LCA0PiwgY29lZnM6IGFycmF5PCR7ZFR5cGV9LCA0PikgLT4gJHtkVHlwZX0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHtkVHlwZX0gPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XG4gIH1cblxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xuICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcbiAgfVxuICAgIGA7XG4gICAgfTtcblxuY29uc3QgdHJpbGluZWFySW50ZXJwb2xhdGlvbiA9XG4gICAgKGlucHV0OiBJbmRpY2VzSGVscGVyLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxuICAgICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBpc05jaHcgPSB0cnVlO1xuICAgICAgY29uc3QgW2JhdGNoSWR4LCBkZXB0aElkeCwgaGVpZ2h0SWR4LCB3aWR0aElkeCwgY2hhbm5lbElkeF0gPVxuICAgICAgICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAzID8gWy0xLCAwLCAxLCAyLCAtMV0gOiAoaXNOY2h3ID8gWzAsIDIsIDMsIDQsIDFdIDogWzAsIDEsIDIsIDMsIDRdKTtcbiAgICAgIGNvbnN0IGRUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgICAgIHJldHVybiBgXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGRlcHRoOnUzMiwgaGVpZ2h0OiB1MzIsIHdpZHRoOiB1MzIpIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBkZXB0aElkeCwgYG1heCgwLCBtaW4oZGVwdGgsICR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaGVpZ2h0SWR4LCBgbWF4KDAsIG1pbihoZWlnaHQsICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIHdpZHRoSWR4LCBgbWF4KDAsIG1pbih3aWR0aCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAzKX1cbiAgICAgIHJldHVybiAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICB9XG5cbiAgICBmbiB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIGRlcHRoOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZGVwdGhJZHh9XTtcbiAgICAgIHZhciBoZWlnaHQ6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtoZWlnaHRJZHh9XTtcbiAgICAgIHZhciB3aWR0aDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske3dpZHRoSWR4fV07XG4gICAgICAke1xuICAgICAgICAgIHVzZUV4dHJhcG9sYXRpb24gPyBgaWYgKGRlcHRoIDwgMCB8fCBkZXB0aCA+ICgke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkgfHwgd2lkdGggPCAwIHx8ICh3aWR0aCA+ICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpIHtcbiAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgIH1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyd9O1xuXG4gICAgZGVwdGggPSBtYXgoMCwgbWluKGRlcHRoLCAke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpKTtcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSk7XG4gICAgICB3aWR0aCA9IG1heCgwLCBtaW4od2lkdGgsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xuICAgICAgdmFyIGRlcHRoMTogdTMyID0gdTMyKGRlcHRoKTtcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XG4gICAgICB2YXIgZGVwdGgyOiB1MzIgPSB1MzIoZGVwdGggKyAxKTtcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke2lucHV0U2hhcGUubGVuZ3RoID4gMyA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7Y2hhbm5lbElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDMgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2JhdGNoSWR4fV0pYCA6ICcwJ307XG5cbiAgICAgIHZhciB4MTExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MTIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjEyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKGRlcHRoIC0gJHtkVHlwZX0oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShkZXB0aDIpIC0gZGVwdGgpO1xuICAgICAgdmFyIGR5MTogJHtkVHlwZX0gPSBhYnMoaGVpZ2h0IC0gJHtkVHlwZX0oaGVpZ2h0MSkpO1xuICAgICAgdmFyIGR5MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHtkVHlwZX0gPSBhYnMod2lkdGggLSAke2RUeXBlfSh3aWR0aDEpKTtcbiAgICAgIHZhciBkejI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHdpZHRoMikgLSB3aWR0aCk7XG4gICAgICBpZiAoZGVwdGgxID09IGRlcHRoMikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQxID09IGhlaWdodDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGgxID09IHdpZHRoMikge1xuICAgICAgICBkejEgPSAwLjU7XG4gICAgICAgIGR6MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExMSAqIGR4MiAqIGR5MiAqIGR6MiArIHgxMTIgKiBkeDIgKiBkeTIgKiBkejEgKyB4MTIxICogZHgyICogZHkxICpkejIgKyB4MTIyICogZHgyICogZHkxICogZHoxICtcbiAgICAgICAgICAgICAgeDIxMSAqIGR4MSAqIGR5MiAqIGR6MiArIHgyMTIgKiBkeDEgKiBkeTIgKiBkejEgKyB4MjIxICogZHgxICogZHkxICpkejIgKyB4MjIyICogZHgxICogZHkxICogZHoxKTtcbiAgICB9YDtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVSZXNpemVQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzLCBvcHNldFZlcnNpb246IG51bWJlciwgc2NhbGVzSW5wdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sIHJvaUlucHV0OiByZWFkb25seSBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dFRlbnNvci5kaW1zO1xuICAgICAgY29uc3Qgcm9pID0gdXBkYXRlUm9JKHJvaUlucHV0LCBhdHRyaWJ1dGVzLmF4ZXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcblxuICAgICAgbGV0IG91dHB1dFNoYXBlID0gaW5pdE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNjYWxlc0lucHV0LCBzaXplcywgYXR0cmlidXRlcy5heGVzKTtcbiAgICAgIGxldCBzY2FsZXMgPSBzY2FsZXNJbnB1dC5zbGljZSgpO1xuICAgICAgaWYgKHNjYWxlc0lucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzY2FsZXMgPSBpbnB1dFNoYXBlLm1hcCgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSA9PT0gMCA/IDEuMCA6IG91dHB1dFNoYXBlW2luZGV4XSAvIHZhbHVlKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5ICE9PSAnc3RyZXRjaCcpIHtcbiAgICAgICAgICBvdXRwdXRTaGFwZSA9IGFkanVzdE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNjYWxlcywgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dFRlbnNvci5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dFRlbnNvci5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IG5vU2NhbGUgPSBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gb3V0cHV0U2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGUuZXZlcnkoKGQsIGkpID0+IGQgPT09IG91dHB1dFNoYXBlW2ldKTtcbiAgICAgIGNvbnN0IHVzZUV4dHJhcG9sYXRpb24gPSBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgICAgIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlO1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke25vU2NhbGUgPyAnJyA6IGBcbiAgICAgICR7Z2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsIGRhdGFUeXBlKX07XG4gICAgICAkeygoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAke2NoZWNrSW5wdXRJbmRpY2VzKGlucHV0LCBpbnB1dFNoYXBlKX07XG4gICAgICAgICAgICAgICR7Z2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUsIG9wc2V0VmVyc2lvbiwgZGF0YVR5cGUpfTtcbiAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUsIHNjYWxlcy5sZW5ndGgsIHJvaS5sZW5ndGgsIHVzZUV4dHJhcG9sYXRpb24pfTtcbiAgICAgICAgICAgICAgYDtcbiAgICAgICAgICBjYXNlICdsaW5lYXInOlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgJHtjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXQsIGlucHV0U2hhcGUsIG91dHB1dFNoYXBlLCBzY2FsZXMubGVuZ3RoLCByb2kubGVuZ3RoKX07XG4gICAgICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2JpbGluZWFySW50ZXJwb2xhdGlvbihpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCB1c2VFeHRyYXBvbGF0aW9uLCBleHRyYXBvbGF0aW9uVmFsdWUpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDMgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dHJpbGluZWFySW50ZXJwb2xhdGlvbihpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCB1c2VFeHRyYXBvbGF0aW9uLCBleHRyYXBvbGF0aW9uVmFsdWUpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0xpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCl9O1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICBjYXNlICdjdWJpYyc6XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7XG4gICAgICAgICAgICAgICAgICAgIGJpY3ViaWNJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUsIHNjYWxlcywgcm9pLCBhdHRyaWJ1dGVzLmN1YmljQ29lZmZBLCB1c2VFeHRyYXBvbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWUsIGF0dHJpYnV0ZXMuZXhjbHVkZU91dHNpZGUpfWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0N1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICBgO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByZXNpemUgbW9kZScpO1xuICAgICAgICB9XG4gICAgICB9KSgpfTtcbiAgICAgIGB9XG4gICAgICAke1xuICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpXG4gICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NjYWxlcycsICdmMzInLCBzY2FsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdyb2knLCAnZjMyJywgcm9pLmxlbmd0aClcbiAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgJHtub1NjYWxlID8gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdOycgOiBgXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgICAgICAgcmV0dXJuIGBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzKSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO1xuICAgICAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICAgICAgICByZXR1cm4gYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7XG4gICAgICAgICAgICAgICAgKGlucHV0U2hhcGUubGVuZ3RoID09PSAyIHx8IGlucHV0U2hhcGUubGVuZ3RoID09PSA0KSA/ICdiaWxpbmVhckludGVycG9sYXRpb24nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyaWxpbmVhckludGVycG9sYXRpb24nfShvdXRwdXRfaW5kaWNlcyk7YDtcbiAgICAgICAgICBjYXNlICdjdWJpYyc6XG4gICAgICAgICAgICByZXR1cm4gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTsnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7YXR0cmlidXRlcy5tb2RlfWApO1xuICAgICAgICB9XG4gICAgICB9KSgpfTtcbmB9XG4gICAgICB9YDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ1Jlc2l6ZScsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX18JHtvcHNldFZlcnNpb259fCR7c2NhbGVzLmxlbmd0aCA+IDAgPyBzY2FsZXMgOiAnJ318JHtcbiAgICAgICAgICAgICAgc2l6ZXMubGVuZ3RoID4gMCA/IHNpemVzIDogJyd9fCR7cm9pLmxlbmd0aCA+IDAgPyByb2kgOiAnJ318JHtub1NjYWxlfXwke2lucHV0U2hhcGV9YCxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ11cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFRlbnNvci5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBzY2FsZXN9LFxuICAgICAgICAgICAge3R5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiByb2l9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSlcbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH07XG5cbmNvbnN0IGdldE9wc2V0VmVyc2lvbkZyb21DdXN0b21EYXRhQnVmZmVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogbnVtYmVyID0+IHtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlciA9IGNvbnRleHQuY3VzdG9tRGF0YUJ1ZmZlcjtcbiAgY29uc3QgY3VzdG9tRGF0YUJ1ZmZlcjMyID0gbmV3IFVpbnQzMkFycmF5KGN1c3RvbURhdGFCdWZmZXIsIGN1c3RvbURhdGFCdWZmZXIuYnl0ZU9mZnNldCwgMSk7XG4gIGNvbnN0IG9wc2V0VmVyc2lvbiA9IGN1c3RvbURhdGFCdWZmZXIzMlswXTtcbiAgcmV0dXJuIG9wc2V0VmVyc2lvbjtcbn07XG5cbmV4cG9ydCBjb25zdCByZXNpemUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3Qgc2NhbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBzaXplczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgcm9pOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8vIE5vdGUgdGhhdCBzY2FsZXMgaW4gcmVzaXplIGFyZSBhbHdheXMgZjMyLiByb2kgY2FuIGJlIGYzMiBvciBmMTYuXG4gIC8vIFRPRE86IEN1cnJlbnRseSB0aGlzIGNvZGUgZG9lcyBub3Qgc3VwcG9ydCBmMTYgZm9yIHJvaSB3aGVuIHBhc3NlZCBhcyBvcHRpb25hbCBpbnB1dC5cblxuICBjb25zdCBvcHNldFZlcnNpb24gPSBnZXRPcHNldFZlcnNpb25Gcm9tQ3VzdG9tRGF0YUJ1ZmZlcihjb250ZXh0KTtcbiAgaWYgKGF0dHJpYnV0ZXMuYW50aWFsaWFzICE9PSAwKSB7XG4gICAgdGhyb3cgRXJyb3IoJ09ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkJyk7XG4gIH1cbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbiwgc2NhbGVzLCBzaXplcywgcm9pKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgICAgY3JlYXRlUmVzaXplUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIGF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbiwgc2NhbGVzLCBzaXplcywgcm9pKSwge2lucHV0czogWzBdfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VSZXNpemVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUmVzaXplQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFudGlhbGlhcyA9IGF0dHJpYnV0ZXMuYW50aWFsaWFzIGFzIG51bWJlcjtcbiAgY29uc3QgYXhlcyA9IGF0dHJpYnV0ZXMuYXhlcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6IENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICAgIGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgYXMgQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU7XG4gIGNvbnN0IGN1YmljQ29lZmZBID0gYXR0cmlidXRlcy5jdWJpY0NvZWZmQSBhcyBudW1iZXI7XG4gIGNvbnN0IGV4Y2x1ZGVPdXRzaWRlID0gYXR0cmlidXRlcy5leGNsdWRlT3V0c2lkZSBhcyBudW1iZXIgIT09IDA7XG4gIGNvbnN0IGV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlIGFzIG51bWJlcjtcbiAgY29uc3Qga2VlcEFzcGVjdFJhdGlvUG9saWN5OiBLZWVwQXNwZWN0UmF0aW9Qb2xpY3kgPSBhdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeSBhcyBLZWVwQXNwZWN0UmF0aW9Qb2xpY3k7XG4gIGNvbnN0IG1vZGU6IE1vZGUgPSBhdHRyaWJ1dGVzLm1vZGUgYXMgTW9kZTtcbiAgLy8gSWYgbmVhcmVzdE1vZGUgaXMgbm90IHNwZWNpZmllZCwgdXNlIHNpbXBsZSBtb2RlLlxuICBjb25zdCBuZWFyZXN0TW9kZTogTmVhcmVzdE1vZGUgPSAoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSA9PT0gJycgPyAnc2ltcGxlJyA6IGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUpIGFzIE5lYXJlc3RNb2RlO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICBhbnRpYWxpYXMsXG4gICAgYXhlcyxcbiAgICBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSxcbiAgICBjdWJpY0NvZWZmQSxcbiAgICBleGNsdWRlT3V0c2lkZSxcbiAgICBleHRyYXBvbGF0aW9uVmFsdWUsXG4gICAga2VlcEFzcGVjdFJhdGlvUG9saWN5LFxuICAgIG1vZGUsXG4gICAgbmVhcmVzdE1vZGVcbiAgfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Y3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFdPUktHUk9VUF9TSVpFfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGludGVybGVhdmVkOiBib29sZWFuO1xuICByZWFkb25seSBudW1IZWFkczogbnVtYmVyO1xuICByZWFkb25seSByb3RhcnlFbWJlZGRpbmdEaW06IG51bWJlcjtcbiAgcmVhZG9ubHkgc2NhbGU6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgW2lucHV0LCBwb3NpdGlvbklkcywgY29zQ2FjaGUsIHNpbkNhY2hlXSA9IGlucHV0cztcbiAgY29uc3Qge251bUhlYWRzLCByb3RhcnlFbWJlZGRpbmdEaW19ID0gYXR0cmlidXRlcztcblxuICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IDMgJiYgaW5wdXQuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICd4JyBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zLCBnb3QgJHtpbnB1dC5kaW1zLmxlbmd0aH1gKTtcbiAgfVxuICBpZiAoIVNoYXBlVXRpbC5hcmVFcXVhbChwb3NpdGlvbklkcy5kaW1zLCBbXSkgJiYgIVNoYXBlVXRpbC5hcmVFcXVhbChwb3NpdGlvbklkcy5kaW1zLCBbMV0pICYmXG4gICAgICBwb3NpdGlvbklkcy5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAwLCAxLCBvciAyIGRpbWVuc2lvbnMsIGdvdCAke3Bvc2l0aW9uSWRzLmRpbXMubGVuZ3RofWApO1xuICB9XG4gIGlmIChjb3NDYWNoZS5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke2Nvc0NhY2hlLmRpbXMubGVuZ3RofWApO1xuICB9XG4gIGlmIChzaW5DYWNoZS5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Npbl9jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke3NpbkNhY2hlLmRpbXMubGVuZ3RofWApO1xuICB9XG4gIGlmICghU2hhcGVVdGlsLmFyZUVxdWFsKGNvc0NhY2hlLmRpbXMsIHNpbkNhY2hlLmRpbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dHMgXFwnY29zX2NhY2hlXFwnIGFuZCBcXCdzaW5fY2FjaGVcXCcgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgfVxuXG4gIGlmIChyb3RhcnlFbWJlZGRpbmdEaW0gPiAwICYmIG51bUhlYWRzID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1faGVhZHMgbXVzdCBiZSBwcm92aWRlZCBpZiByb3RhcnlfZW1iZWRkaW5nX2RpbSBpcyBzcGVjaWZpZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0LmRpbXNbMF07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDJdO1xuICBjb25zdCBtYXhTZXF1ZW5jZUxlbmd0aCA9IGNvc0NhY2hlLmRpbXNbMF07XG4gIGNvbnN0IGhpZGRlblNpemUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXQuZGltcywgMSkgLyBzZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgaGVhZFNpemUgPSByb3RhcnlFbWJlZGRpbmdEaW0gPT09IDAgPyBjb3NDYWNoZS5kaW1zWzFdICogMiA6IGhpZGRlblNpemUgLyBudW1IZWFkcztcbiAgaWYgKHJvdGFyeUVtYmVkZGluZ0RpbSA+IGhlYWRTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyb3RhcnlfZW1iZWRkaW5nX2RpbSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBoZWFkX3NpemUnKTtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbklkcy5kaW1zLmxlbmd0aCA9PT0gMikge1xuICAgIGlmIChiYXRjaFNpemUgIT09IHBvc2l0aW9uSWRzLmRpbXNbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDAgc2hvdWxkIGJlIG9mIHNpemUgYmF0Y2hfc2l6ZSwgZ290ICR7cG9zaXRpb25JZHMuZGltc1swXX1gKTtcbiAgICB9XG4gICAgaWYgKHNlcXVlbmNlTGVuZ3RoICE9PSBwb3NpdGlvbklkcy5kaW1zWzFdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBvZiBzaXplIHNlcXVlbmNlX2xlbmd0aCwgZ290ICR7cG9zaXRpb25JZHMuZGltc1sxXX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGVhZFNpemUgLyAyICE9PSBjb3NDYWNoZS5kaW1zWzFdICYmIHJvdGFyeUVtYmVkZGluZ0RpbSAvIDIgIT09IGNvc0NhY2hlLmRpbXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdjb3NfY2FjaGUnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBzYW1lIGFzIGhlYWRfc2l6ZSAvIDIgb3Igcm90YXJ5X2VtYmVkZGluZ19kaW0gLyAyLCBnb3QgJHtcbiAgICAgICAgY29zQ2FjaGUuZGltc1sxXX1gKTtcbiAgfVxuXG4gIGlmIChzZXF1ZW5jZUxlbmd0aCA+IG1heFNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVcGRhdGluZyBjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbiBSb3RhcnlFbWJlZGRpbmcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHtpbnRlcmxlYXZlZCwgbnVtSGVhZHMsIHJvdGFyeUVtYmVkZGluZ0RpbSwgc2NhbGV9ID0gYXR0cmlidXRlcztcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0c1swXS5kaW1zWzBdO1xuICAgICAgY29uc3QgYmF0Y2hTdHJpZGUgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRzWzBdLmRpbXMsIDEpO1xuICAgICAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dHNbMF0uZGltc1tpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IGhpZGRlblNpemUgPSBiYXRjaFN0cmlkZSAvIHNlcXVlbmNlTGVuZ3RoO1xuICAgICAgY29uc3QgaGFsZlJvdGFyeUVtYmVkZGluZ0RpbSA9IGlucHV0c1syXS5kaW1zWzFdO1xuICAgICAgY29uc3QgaGVhZFNpemUgPSByb3RhcnlFbWJlZGRpbmdEaW0gPT09IDAgPyBoYWxmUm90YXJ5RW1iZWRkaW5nRGltICogMiA6IGhpZGRlblNpemUgLyBudW1IZWFkcztcblxuICAgICAgLy8gUm90YXJ5IGVtYmVkZGluZ3Mgd2lsbCBiZSBjYWxjdWxhdGVkIGluIGEgcGFpci13aXNlIGZhc2hpb24uIEluIGFjY29yZGFuY2UsIHVzZSB0aGUgc2hhcGVcbiAgICAgIC8vIFtiYXRjaCBzaXplLCBzZXF1ZW5jZSBsZW5ndGgsIG51bSBvZiBoZWFkcywgbnVtIG9mIHBhaXJzIHRvIHJvdGF0ZSArIG51bSBvZiBkaW1zIHRvIGNvcHldXG4gICAgICAvLyB0byB1bmZvbGQgdGhlIGdsb2JhbCBpbmRleCBpbiBzaGFkZXIuXG4gICAgICBjb25zdCBnbG9iYWxTaGFwZSA9XG4gICAgICAgICAgbmV3IEFycmF5PG51bWJlcj4oYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgaGlkZGVuU2l6ZSAvIGhlYWRTaXplLCBoZWFkU2l6ZSAtIGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0pO1xuICAgICAgY29uc3QgZ2xvYmFsU3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhnbG9iYWxTaGFwZSk7XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBzY2FsZX0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGdsb2JhbFNoYXBlfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZ2xvYmFsU3RyaWRlc30sXG5cbiAgICAgICAgLy8gc3RyaWRlcyBmb3IgYWRkcmVzc2luZyB0aGUgaW5wdXQvb3V0cHV0IHRlbnNvciwgaW4gcGVybXV0YXRlZCBvcmRlciB0byBhbGlnbiB3aXRoIHRoZSB1bmZvbGRlZCBnbG9iYWwgaW5kZXgsXG4gICAgICAgIC8vIGkuZS4gQlNOSFxuICAgICAgICAuLi4oaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzID9cbiAgICAgICAgICAgICAgICBuZXcgQXJyYXk8UHJvZ3JhbVVuaWZvcm0+KHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFtiYXRjaFN0cmlkZSwgaGlkZGVuU2l6ZSwgaGVhZFNpemUsIDFdfSkgOlxuICAgICAgICAgICAgICAgIFtdKSxcbiAgICAgICAgLi4uKGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNCA/XG4gICAgICAgICAgICAgICAgbmV3IEFycmF5PFByb2dyYW1Vbmlmb3JtPihcbiAgICAgICAgICAgICAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogW2JhdGNoU3RyaWRlLCBoZWFkU2l6ZSwgc2VxdWVuY2VMZW5ndGggKiBoZWFkU2l6ZSwgMV19KSA6XG4gICAgICAgICAgICAgICAgW10pLFxuXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgaW5wdXRzWzJdLmRpbXMsIGlucHV0c1szXS5kaW1zLCBpbnB1dHNbMF0uZGltcyksXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25JZHMgPSBpbnB1dFZhcmlhYmxlKCdwb3NpdGlvbl9pZHMnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNvc0NhY2hlID0gaW5wdXRWYXJpYWJsZSgnY29zX2NhY2hlJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBzaW5DYWNoZSA9IGlucHV0VmFyaWFibGUoJ3Npbl9jYWNoZScsIGlucHV0c1szXS5kYXRhVHlwZSwgaW5wdXRzWzNdLmRpbXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcblxuICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtcyhbXG4gICAgICAgICAge25hbWU6ICdzY2FsZScsIHR5cGU6ICdmMzInfSxcbiAgICAgICAgICB7bmFtZTogJ2dsb2JhbF9zaGFwZScsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGdsb2JhbFNoYXBlLmxlbmd0aH0sXG4gICAgICAgICAge25hbWU6ICdnbG9iYWxfc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGdsb2JhbFN0cmlkZXMubGVuZ3RofSxcbiAgICAgICAgICB7bmFtZTogJ2lucHV0X291dHB1dF9zdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU3RyaWRlcy5sZW5ndGh9LFxuICAgICAgICBdKTtcblxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBwb3NpdGlvbklkcywgY29zQ2FjaGUsIHNpbkNhY2hlLCBvdXRwdXQpfVxuXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXT1JLR1JPVVBfU0laRSl9XG4gICAgICAgICAgbGV0IGhhbGZfcm90YXJ5X2VtYl9kaW0gPSB1bmlmb3Jtcy4ke2Nvc0NhY2hlLm5hbWV9X3NoYXBlWzFdO1xuICAgICAgICAgIGxldCBic25oID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzICUgdW5pZm9ybXMuZ2xvYmFsX3NoYXBlO1xuICAgICAgICAgIGxldCBzaXplID0gdW5pZm9ybXMuZ2xvYmFsX3NoYXBlWzBdICogdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXNbMF07XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygnc2l6ZScpfVxuXG4gICAgICAgICAgaWYgKGJzbmhbM10gPCBoYWxmX3JvdGFyeV9lbWJfZGltKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWRzX2lkeCA9XG4gICAgICAgICAgICAgICAgJHtwb3NpdGlvbklkcy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnYnNuaC54eScsIG91dHB1dFZhcmlhYmxlKCcnLCBwb3NpdGlvbklkcy50eXBlLnRlbnNvciwgMikpfTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZCA9XG4gICAgICAgICAgICAgICAgdTMyKCR7cG9zaXRpb25JZHMuZ2V0QnlPZmZzZXQoJ3Bvc2l0aW9uX2lkc19pZHgnKX0pICsgc2VsZWN0KDAsIGJzbmhbMV0sIHBvc2l0aW9uX2lkc19pZHggPT0gMCk7XG4gICAgICAgICAgICBsZXQgaSA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBzZWxlY3QoMCwgYnNuaFszXSwgJHtpbnRlcmxlYXZlZH0pO1xuICAgICAgICAgICAgbGV0IGogPSBpICsgc2VsZWN0KGhhbGZfcm90YXJ5X2VtYl9kaW0sIDEsICR7aW50ZXJsZWF2ZWR9KTtcbiAgICAgICAgICAgIGxldCByZSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2knKX0gKiAke2Nvc0NhY2hlLmdldCgncG9zaXRpb25faWQnLCAnYnNuaFszXScpfSAtXG4gICAgICAgICAgICAgICAgJHtpbnB1dC5nZXRCeU9mZnNldCgnaicpfSAqICR7c2luQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9O1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2knLCAncmUnKX1cbiAgICAgICAgICAgIGxldCBpbSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2knKX0gKiAke3NpbkNhY2hlLmdldCgncG9zaXRpb25faWQnLCAnYnNuaFszXScpfSArXG4gICAgICAgICAgICAgICAgJHtpbnB1dC5nZXRCeU9mZnNldCgnaicpfSAqICR7Y29zQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9O1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2onLCAnaW0nKX1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGsgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgaGFsZl9yb3RhcnlfZW1iX2RpbTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdrJywgaW5wdXQuZ2V0QnlPZmZzZXQoJ2snKSl9XG4gICAgICAgICAgfVxuICAgICAgICB9YDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdSb3RhcnlFbWJlZGRpbmcnLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgICAgICAgICAgICAgICBpbnRlcmxlYXZlZCxcbiAgICAgICAgICAgICAgICB9KS5jYWNoZUtleSxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnLCAncmFuaycsICdyYW5rJ10sXG4gICAgICAgIH0sXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShnbG9iYWxTaGFwZSkgLyBXT1JLR1JPVVBfU0laRSl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCByb3RhcnlFbWJlZGRpbmcgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJvdGFyeUVtYmVkZGluZ0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUm90YXJ5RW1iZWRkaW5nUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y2FzdFRvRjMyLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBzdW1WZWN0b3IsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBTa2lwTGF5ZXJOb3JtQXR0cmlidXRlcyB7XG4gIHNpbXBsaWZpZWQ6IGJvb2xlYW47XG4gIGVwc2lsb246IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAzIGlucHV0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0OiBUZW5zb3JWaWV3ID0gaW5wdXRzWzBdO1xuICBjb25zdCBza2lwOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzFdO1xuICBjb25zdCBnYW1tYTogVGVuc29yVmlldyA9IGlucHV0c1syXTtcblxuICBpZiAoaW5wdXQuZGF0YVR5cGUgIT09IHNraXAuZGF0YVR5cGUgfHwgaW5wdXQuZGF0YVR5cGUgIT09IGdhbW1hLmRhdGFUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUnKTtcbiAgfVxuXG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSAyRCBvciAzRCcpO1xuICB9XG5cbiAgaWYgKHNraXAuZGltcy5sZW5ndGggIT09IDMgJiYgc2tpcC5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGJlIDJEIG9yIDNEJyk7XG4gIH1cblxuICBjb25zdCBoaWRkZW5TaXplID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDFdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0LmRpbXNbaW5wdXQuZGltcy5sZW5ndGggLSAyXTtcbiAgaWYgKHNraXAuZGltc1tza2lwLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XG4gIH1cbiAgaWYgKHNraXAuZGltc1tza2lwLmRpbXMubGVuZ3RoIC0gMl0gIT09IHNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBsZW5ndGggYXMgaW5wdXQnKTtcbiAgfVxuXG4gIGlmIChnYW1tYS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2FtbWEgbXVzdCBiZSAxRCcpO1xuICB9XG4gIGlmIChnYW1tYS5kaW1zW2dhbW1hLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhbW1hIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dCcpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gMykge1xuICAgIGNvbnN0IGJldGE6IFRlbnNvclZpZXcgPSBpbnB1dHNbM107XG4gICAgaWYgKGJldGEuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmV0YSBtdXN0IGJlIDFEJyk7XG4gICAgfVxuICAgIGlmIChiZXRhLmRpbXNbYmV0YS5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XG4gICAgfVxuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gNCkge1xuICAgIGNvbnN0IGJpYXM6IFRlbnNvclZpZXcgPSBpbnB1dHNbNF07XG4gICAgaWYgKGJpYXMuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlhcyBtdXN0IGJlIDFEJyk7XG4gICAgfVxuICAgIGlmIChiaWFzLmRpbXNbYmlhcy5kaW1zLmxlbmd0aCAtIDFdICE9PSBoaWRkZW5TaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpYXMgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBjcmVhdGVTa2lwTGF5ZXJOb3JtUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMsIG91dHB1dENvdW50OiBudW1iZXIsIGlzVHJhaW5pbmc6IGJvb2xlYW4pOlxuICAgICAgICBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICAgICAgY29uc3Qgc2ltcGxpZmllZCA9IGF0dHJpYnV0ZXMuc2ltcGxpZmllZDtcblxuICAgICAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgICAgICBjb25zdCBpbnB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IGlucHV0U2l6ZTtcbiAgICAgICAgICBjb25zdCBoaWRkZW5TaXplID0gaW5wdXRTaGFwZS5zbGljZSgtMSlbMF07XG4gICAgICAgICAgY29uc3QgbWVhbkludlN0ZERldkRpbSA9IGlzVHJhaW5pbmcgPyBpbnB1dFNoYXBlLnNsaWNlKDAsIC0xKS5jb25jYXQoMSkgOiBbXTtcbiAgICAgICAgICBjb25zdCBoYXNCZXRhSW5wdXQgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHMubGVuZ3RoID4gMztcbiAgICAgICAgICBjb25zdCBoYXNCaWFzSW5wdXQgPSBpbnB1dHMubGVuZ3RoID4gNDtcbiAgICAgICAgICBjb25zdCBoYXNNZWFuT3V0cHV0ID0gaXNUcmFpbmluZyAmJiBvdXRwdXRDb3VudCA+IDE7XG4gICAgICAgICAgY29uc3QgaGFzSW52U3RkRGV2T3V0cHV0ID0gaXNUcmFpbmluZyAmJiBvdXRwdXRDb3VudCA+IDI7XG4gICAgICAgICAgY29uc3QgaGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCA9IG91dHB1dENvdW50ID4gMztcbiAgICAgICAgICBjb25zdCB3b3JrZ3JvdXBTaXplID0gNjQ7XG5cbiAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhoaWRkZW5TaXplKTtcblxuICAgICAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LFxuICAgICAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogY29tcG9uZW50c30sXG4gICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBoaWRkZW5TaXplfSxcbiAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5lcHNpbG9ufSxcbiAgICAgICAgICBdO1xuICAgICAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdW5pZm9ybXNBcnJheTogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAgICAgIHtuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJ30sXG4gICAgICAgICAgICAgIHtuYW1lOiAnY29tcG9uZW50cycsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICAgICAge25hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICAgICAge25hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2YzMid9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtcbiAgICAgICAgICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgICAgICAgICBpbnB1dFZhcmlhYmxlKCdza2lwJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcywgY29tcG9uZW50cyksXG4gICAgICAgICAgICAgIGlucHV0VmFyaWFibGUoJ2dhbW1hJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cyksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGhhc0JldGFJbnB1dCkge1xuICAgICAgICAgICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiZXRhJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY29tcG9uZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0JpYXNJbnB1dCkge1xuICAgICAgICAgICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY29tcG9uZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgICAgIGlmIChoYXNNZWFuT3V0cHV0KSB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdtZWFuX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzSW52U3RkRGV2T3V0cHV0KSB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdpbnZfc3RkX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCkge1xuICAgICAgICAgICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW5wdXRfc2tpcF9iaWFzX3N1bScsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgICAgICAgICBjb25zdCB2ZWNEYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gYFxuXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zQXJyYXkpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zaGFyZWQgOiBhcnJheTwke3ZlY0RhdGFUeXBlfSwgJHt3b3JrZ3JvdXBTaXplfT47XG4gICAgICB2YXI8d29ya2dyb3VwPiBzdW1fc3F1YXJlZF9zaGFyZWQgOiBhcnJheTwke3ZlY0RhdGFUeXBlfSwgJHt3b3JrZ3JvdXBTaXplfT47XG5cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbXG4gICAgICAgICAgICAgIHdvcmtncm91cFNpemUsIDEsIDFcbiAgICAgICAgICAgIF0pfVxuICAgICAgICBsZXQgaXggPSBsb2NhbF9pZC54O1xuICAgICAgICBsZXQgaXkgPSBnbG9iYWxfaWQueCAvICR7d29ya2dyb3VwU2l6ZX07XG5cbiAgICAgICAgbGV0IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ6IHUzMiA9IHVuaWZvcm1zLmhpZGRlbl9zaXplIC8gdW5pZm9ybXMuY29tcG9uZW50cztcbiAgICAgICAgdmFyIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLyAke3dvcmtncm91cFNpemV9O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gaXggKiBzdHJpZGUgKyBpeSAqIGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgICAgIGxldCBvZmZzZXQxZCA9IHN0cmlkZSAqIGl4O1xuICAgICAgICBpZiAoaXggPT0gJHt3b3JrZ3JvdXBTaXplIC0gMX0pIHtcbiAgICAgICAgICBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC0gc3RyaWRlICogaXg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHNraXBfdmFsdWUgPSBza2lwW29mZnNldCArIGldO1xuICAgICAgICAgIGxldCBiaWFzX3ZhbHVlID0gJHtoYXNCaWFzSW5wdXQgPyAnYmlhc1tvZmZzZXQxZCArIGldJyA6IGRhdGFUeXBlICsgJygwLjApJ307XG4gICAgICAgICAgbGV0IGlucHV0X3ZhbHVlID0geFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dF92YWx1ZSArIHNraXBfdmFsdWUgKyBiaWFzX3ZhbHVlO1xuICAgICAgICAgICR7aGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCA/ICdpbnB1dF9za2lwX2JpYXNfc3VtW29mZnNldCArIGldID0gdmFsdWU7JyA6ICcnfVxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHZhbHVlO1xuICAgICAgICAgIGxldCBmMzJfdmFsdWUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3ZhbHVlJyl9O1xuICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZTtcbiAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZSAqIGYzMl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZV9zaXplIDogdTMyID0gJHt3b3JrZ3JvdXBTaXplfTtcbiAgICAgICAgZm9yICh2YXIgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMTsgIGN1cnJfc2l6ZSA+IDA7IGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2Vfc2l6ZSA9IGN1cnJfc2l6ZSArIChyZWR1Y2Vfc2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChpeCA8IGN1cnJfc2l6ZSkge1xuICAgICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gc3VtX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gc3VtX3NxdWFyZWRfc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gc3VtX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IHNxdWFyZV9zdW0gPSBzdW1fc3F1YXJlZF9zaGFyZWRbMF07XG4gICAgICAgIGxldCBtZWFuID0gJHtzdW1WZWN0b3IoJ3N1bScsIGNvbXBvbmVudHMpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSk7XG4gICAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7c3VtVmVjdG9yKCdzcXVhcmVfc3VtJywgY29tcG9uZW50cyl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKSAke1xuICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4gKiBtZWFuJ30gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtoYXNNZWFuT3V0cHV0ID8gJ21lYW5fb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjsnIDogJyd9XG4gICAgICAgICR7aGFzSW52U3RkRGV2T3V0cHV0ID8gJ2ludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7JyA6ICcnfVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gJHtzaW1wbGlmaWVkID8gJycgOiBgLSAke2RhdGFUeXBlfShtZWFuKWB9KSAqXG4gICAgICAgICAgICAke2RhdGFUeXBlfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke2hhc0JldGFJbnB1dCA/ICcrIGJldGFbb2Zmc2V0MWQgKyBpXScgOiAnJ307XG4gICAgICAgIH1cbiAgICAgIH1gO1xuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XTtcbiAgICAgICAgICBpZiAob3V0cHV0Q291bnQgPiAxKSB7XG4gICAgICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0Q291bnQgPiAyKSB7XG4gICAgICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0cHV0Q291bnQgPiAzKSB7XG4gICAgICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IGlucHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgICAgIGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7aGFzTWVhbk91dHB1dH07JHtoYXNJbnZTdGREZXZPdXRwdXR9OyR7aGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dH1gLFxuICAgICAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogaW5wdXRzLm1hcCgoX2lucHV0LCBfaW5kZXgpID0+ICd0eXBlJylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7XG4gICAgICAgICAgICAgICAgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyBoaWRkZW5TaXplKSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5leHBvcnQgY29uc3Qgc2tpcExheWVyTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU2tpcExheWVyTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gVE9ETzogaW5pdGlhbGl6ZSBpc1RyYWluaW5nIGZyb20gQ29tcHV0ZUNvbnRleHRcbiAgY29uc3QgaXNUcmFpbmluZyA9IGZhbHNlO1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIC8vIE1lYW4gYW5kIEludlN0ZERldiBhcmUgb25seSB1c2VkIGluIHRyYWluaW5nIG1vZGUgYW5kIGFyZSBub3QgcmVxdWlyZWQgZm9yIGluZmVyZW5jZS5cbiAgLy8gVGhleSBhcmUgYWRkZWQgaGVyZSBmb3IgY29tcGxldGVuZXNzIG9ubHkuXG4gIGNvbnN0IG91dHB1dHMgPSBbMF07XG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMSkge1xuICAgIG91dHB1dHMucHVzaChpc1RyYWluaW5nID8gMSA6IC0zKTtcbiAgfVxuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDIpIHtcbiAgICBvdXRwdXRzLnB1c2goaXNUcmFpbmluZyA/IDIgOiAtMyk7XG4gIH1cbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAzKSB7XG4gICAgb3V0cHV0cy5wdXNoKDMpO1xuICB9XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGNyZWF0ZVNraXBMYXllck5vcm1Qcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcywgY29udGV4dC5vdXRwdXRDb3VudCwgaXNUcmFpbmluZyksIHtvdXRwdXRzfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG4gIHJlYWRvbmx5IGVuZHM6IG51bWJlcltdO1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggfHwgYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuZW5kcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gIH1cbiAgaW5wdXRzLnNsaWNlKDEpLmZvckVhY2goKF8sIGlkeCkgPT4ge1xuICAgIGlmIChpbnB1dHNbaWR4ICsgMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmIGlucHV0c1tpZHggKyAxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgcmVhZElucHV0ID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBpZHg6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaW5wdXQ6IG51bWJlcltdID0gW107XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gaWR4KSB7XG4gICAgaWYgKGlucHV0c1tpZHhdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgICAgaW5wdXRzW2lkeF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2godiA9PiBpbnB1dC5wdXNoKE51bWJlcih2KSkpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRzW2lkeF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyKSB7XG4gICAgICBpbnB1dHNbaWR4XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaCh2ID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgY3JlYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICAgICAgaWYgKGlucHV0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0czogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAxKTtcbiAgICAgICAgY29uc3QgZW5kczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAyKTtcbiAgICAgICAgbGV0IGF4ZXM6IG51bWJlcltdID0gcmVhZElucHV0KGlucHV0cywgMyk7XG4gICAgICAgIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGF4ZXMgPSBbLi4uQXJyYXkoaW5wdXRzWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3N0YXJ0cywgZW5kcywgYXhlc30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICB9XG4gICAgfTtcblxuY29uc3QgZml4U3RhcnRFbmRWYWx1ZXMgPVxuICAgICh2YWx1ZTogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHN0ZXBzOiByZWFkb25seSBudW1iZXJbXSk6XG4gICAgICAgIG51bWJlciA9PiB7XG4gICAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgKz0gaW5wdXRTaGFwZVtheGVzW2luZGV4XV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGVwc1tpbmRleF0gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3VmFsdWUsIGlucHV0U2hhcGVbYXhlc1tpbmRleF1dIC0gMSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3VmFsdWUsIGlucHV0U2hhcGVbYXhlc1tpbmRleF1dKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG5jb25zdCBjYWxjdWxhdGVJbnB1dEluZGljZXNJbXBsID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBzdHJpbmcgPT5cbiAgICAgICAgYGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke2lucHV0U2hhcGUubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc3RlcHMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaWducycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdGFydHMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBpbnB1dF9pbmRleCAvIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X2luZGV4ICUgaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSBpbnB1dF9pbmRleCAtIDF1ICsgc3RhcnRzX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICdpbnB1dF9pbmRleCcpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgICB9YDtcblxuY29uc3QgY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpO1xuICBjb25zdCBheGVzID0gKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSA/IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbLi4uQXJyYXkoaW5wdXRTaGFwZS5sZW5ndGgpLmtleXMoKV07XG4gIGxldCBzdGVwcyA9IHJlYWRJbnB1dChpbnB1dHMsIDQpO1xuICBzdGVwcy5mb3JFYWNoKChzdGVwKSA9PiBzdGVwICE9PSAwIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGVwIGNhbm5vdCBiZSAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgaWYgKHN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0ZXBzID0gQXJyYXkoYXhlcy5sZW5ndGgpLmZpbGwoMSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRzID0gYXR0cmlidXRlcy5zdGFydHMubWFwKChzdGFydCwgaSkgPT4gZml4U3RhcnRFbmRWYWx1ZXMoc3RhcnQsIGksIGlucHV0U2hhcGUsIGF4ZXMsIHN0ZXBzKSk7XG5cbiAgY29uc3QgZW5kcyA9IGF0dHJpYnV0ZXMuZW5kcy5tYXAoKGVuZCwgaSkgPT4gZml4U3RhcnRFbmRWYWx1ZXMoZW5kLCBpLCBpbnB1dFNoYXBlLCBheGVzLCBzdGVwcykpO1xuXG4gIGlmIChheGVzLmxlbmd0aCAhPT0gc3RhcnRzLmxlbmd0aCB8fCBheGVzLmxlbmd0aCAhPT0gZW5kcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0LCBlbmRzIGFuZCBheGVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cycpO1xuICB9XG5cbiAgaWYgKGF4ZXMubGVuZ3RoICE9PSBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFheGVzLmluY2x1ZGVzKGkpKSB7XG4gICAgICAgIHN0YXJ0cy5zcGxpY2UoaSwgMCwgMCk7XG4gICAgICAgIGVuZHMuc3BsaWNlKGksIDAsIGlucHV0U2hhcGVbaV0pO1xuICAgICAgICBzdGVwcy5zcGxpY2UoaSwgMCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNpZ25zID0gc3RlcHMubWFwKHN0ZXAgPT4gTWF0aC5zaWduKHN0ZXApKTtcbiAgLy8gQ29udmVydCBuZWdhdGl2ZSBzdGVwcyB0byBwb3NpdGl2ZSBzdGVwcyBhbmQgcmV2ZXJzZSBzdGFydHMgYW5kIGVuZHNcbiAgc3RlcHMuZm9yRWFjaCgoc3RlcCwgaSwgYXJyYXkpID0+IHtcbiAgICBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGNvbnN0IG51bVN0ZXBzID0gKGVuZHNbaV0gLSBzdGFydHNbaV0pIC8gc3RlcDtcbiAgICAgIGNvbnN0IG5ld0VuZCA9IHN0YXJ0c1tpXTtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbmV3RW5kICsgbnVtU3RlcHMgKiBzdGVwc1tpXTtcbiAgICAgIHN0YXJ0c1tpXSA9IG5ld1N0YXJ0O1xuICAgICAgZW5kc1tpXSA9IG5ld0VuZDtcbiAgICAgIGFycmF5W2ldID0gLXN0ZXA7XG4gICAgfVxuICB9KTtcbiAgLy8gT3V0cHV0IHJhbmsgaXMgZXhwZWN0ZWQgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dCByYW5rLlxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIGF4ZXMuZm9yRWFjaCgoYXhpcywgXykgPT4ge1xuICAgIG91dHB1dFNoYXBlW2F4aXNdID0gTWF0aC5jZWlsKChlbmRzW2F4aXNdIC0gc3RhcnRzW2F4aXNdKSAvIHN0ZXBzW2F4aXNdKTtcbiAgfSk7XG4gIGNvbnN0IG91dHB1dFRlbnNvckluZm86IFRlbnNvckluZm8gPSB7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9O1xuXG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICB7bmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnc3RhcnRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc3RhcnRzLmxlbmd0aH0sXG4gICAge25hbWU6ICdzaWducycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IHNpZ25zLmxlbmd0aH0sIHtuYW1lOiAnc3RlcHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdGVwcy5sZW5ndGh9XG4gIF07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdGFydHN9LFxuICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogc2lnbnN9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzdGVwc30sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIG91dHB1dFNoYXBlKVxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgJHtjYWxjdWxhdGVJbnB1dEluZGljZXNJbXBsKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgIGxldCBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpKX1cbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTbGljZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtzaWducy5sZW5ndGh9XyR7c3RhcnRzLmxlbmd0aH1fJHtzdGVwcy5sZW5ndGh9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtvdXRwdXRUZW5zb3JJbmZvXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwoaW5wdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgIH0pXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVTbGljZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcyksIHtpbnB1dHM6IFswXX0pO1xuICAvLyBpZiAoU2hhcGVVdGlsLnNpemUocHJvZ3JhbS5vdXRwdXRzWzBdLmRpbXMpID4gMCkge1xuICAvLyAgIGNvbnRleHQuY29tcHV0ZShwcm9ncmFtSW5mb0xvYWRlciwge2lucHV0czogWzBdfSk7XG4gIC8vIH0gZWxzZSB7XG4gIC8vICAgLy8gVE9ETzogc3VwcG9ydCBlbXB0eSBvdXRwdXRcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ3NsaWNlOiBvdXRwdXQgc2l6ZSBpcyAwJyk7XG4gIC8vIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNsaWNlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHN0YXJ0cyA9IGF0dHJpYnV0ZXMuc3RhcnRzIGFzIG51bWJlcltdO1xuICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzIGFzIG51bWJlcltdO1xuICBjb25zdCBheGVzID0gYXR0cmlidXRlcy5heGVzIGFzIG51bWJlcltdO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtzdGFydHMsIGVuZHMsIGF4ZXN9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcbi8vIHBlcmZvcm1hbmNlIGxpbWl0YXRpb25zIHdoZW4gdGhlIHJlZHVjZWQgYXhpcyBpcyBsb25nLiBOZWVkIHRvIGFkZFxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Z2V0TWF4Q29tcG9uZW50cywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgc3VtVmVjdG9yLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvZnRtYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCBjcmVhdGVTb2Z0bWF4UHJvZ3JhbUluZm8gPSAoaW5wdXQ6IFRlbnNvclZpZXcsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBzaGFwZSA9IGlucHV0LmRpbXM7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShzaGFwZSk7XG4gIGNvbnN0IFdHID0gNjQ7XG4gIGxldCBheGlzID0gYXR0cmlidXRlcy5heGlzO1xuICBpZiAoYXhpcyA8IDApIHtcbiAgICBheGlzID0gc2hhcGUubGVuZ3RoICsgYXhpcztcbiAgfVxuICBpZiAoYXhpcyA8IHNoYXBlLmxlbmd0aCAtIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvZnRtYXggb25seSBzdXBwb3J0cyBsYXN0IGF4aXMgZm9yIG5vdy4nKTtcbiAgfVxuXG4gIGNvbnN0IGNvbHMgPSBzaGFwZVtheGlzXTtcbiAgY29uc3Qgcm93cyA9IG91dHB1dFNpemUgLyBjb2xzO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhjb2xzKTtcbiAgY29uc3QgcGFja2VkQ29scyA9IGNvbHMgLyBjb21wb25lbnRzO1xuXG4gIGNvbnN0IG1heFZlY3RvciA9IChuYW1lOiBzdHJpbmcsIGNvbXBvbmVudHM6IG51bWJlcikgPT4ge1xuICAgIGlmIChjb21wb25lbnRzID09PSA0KSB7XG4gICAgICByZXR1cm4gYG1heChtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpLCBtYXgoJHtuYW1lfS56LCAke25hbWV9LncpKWA7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAyKSB7XG4gICAgICByZXR1cm4gYG1heCgke25hbWV9LngsICR7bmFtZX0ueSlgO1xuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMykge1xuICAgICAgcmV0dXJuIGBtYXgobWF4KCR7bmFtZX0ueCwgJHtuYW1lfS55KSwgJHtuYW1lfS56KWA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG4gIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCB2YWx1ZVR5cGUgPSB4LnR5cGUudmFsdWU7XG4gIC8vIDYuMi40IGluIHdnc2wgc3BlY1xuICBjb25zdCB0aHJlYWRNYXhEZWNsID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0LmRhdGFUeXBlKSA9PT0gJ2YzMicgP1xuICAgICAgYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTMuNDAyODIzZSszOGYpO2AgOlxuICAgICAgYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTY1NTA0LjBoKTtgO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7dmFsdWVUeXBlfSwgJHtXR30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3BhY2tlZENvbHMnLCAnaTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWR4KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke1dHfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke3RocmVhZE1heERlY2x9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7dmFsdWVUeXBlfSgke21heFZlY3RvcigndGhyZWFkU2hhcmVkWzBdJywgY29tcG9uZW50cyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7dmFsdWVUeXBlfSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7c3VtVmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NvZnRtYXgnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJ119LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IHNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiByb3dzfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW3t0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogcGFja2VkQ29sc31dXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNvZnRtYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNvZnRtYXhQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTb2Z0bWF4QXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlcn0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BsaXRBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xuICByZWFkb25seSBudW1PdXRwdXRzOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNwbGl0U2l6ZXM6IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlU3BsaXRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiBTcGxpdEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3Qgc3BsaXRTaXplczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGxldCBudW1PdXRwdXRzOiBudW1iZXIgPSBhdHRyaWJ1dGVzLm51bU91dHB1dHM7XG4gICAgICBpZiAoaW5wdXRzWzFdLmRpbXNbMF0gPiAwKSB7XG4gICAgICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCh2ID0+IHNwbGl0U2l6ZXMucHVzaChOdW1iZXIodikpKTtcbiAgICAgICAgbnVtT3V0cHV0cyA9IHNwbGl0U2l6ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7bnVtT3V0cHV0cywgYXhpczogYXR0cmlidXRlcy5heGlzLCBzcGxpdFNpemVzfSk7XG4gICAgfTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0SW5kZXhJbXBsID0gKG51bWJlck9mVGVuc29yczogbnVtYmVyKTogc3RyaW5nID0+IGBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc311OyBpICs9IDF1ICkge1xuICAgIGlmIChpbmRleCA8ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXMnLCAnaScsIG51bWJlck9mVGVuc29ycyl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7bnVtYmVyT2ZUZW5zb3JzfXU7XG59YDtcbmNvbnN0IHdyaXRlQnVmZmVyRGF0YUltcGwgPSAob3V0cHV0czogcmVhZG9ubHkgSW5kaWNlc0hlbHBlcltdKSA9PiB7XG4gIGNvbnN0IG51bWJlck9mVGVuc29ycyA9IG91dHB1dHMubGVuZ3RoO1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUZW5zb3JzOyArK2kpIHtcbiAgICBjb25zdCByZXR1cm5TbmlwcGV0ID0gb3V0cHV0c1tpXS5zZXRCeUluZGljZXMoJ2luZGljZXMnLCAnaW5wdXRbZ2xvYmFsX2lkeF0nKTtcbiAgICBpZiAobnVtYmVyT2ZUZW5zb3JzID09PSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChyZXR1cm5TbmlwcGV0KTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke2l9dSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IG51bWJlck9mVGVuc29ycyAtIDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7aX0pIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBgXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlcjogdTMyLCBpbmRpY2VzOiAke291dHB1dHNbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XG4gICAgICAgICR7Y29kZUxpbmVzLmpvaW4oJ1xcbicpfVxuICAgICAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVTcGxpdFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dHMgPSBuZXcgQXJyYXk8SW5kaWNlc0hlbHBlcj4oYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IHNpemVJblNwbGl0QXhpcyA9IG5ldyBBcnJheTxudW1iZXI+KGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gIGNvbnN0IG91dHB1dHNUZW5zb3JJbmZvOiBUZW5zb3JJbmZvW10gPSBbXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGVzOiBudW1iZXJbXVtdID0gW107XG4gIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFt7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBpbnB1dFNpemV9XTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLm51bU91dHB1dHM7IGkrKykge1xuICAgIHByZXZpb3VzU3VtICs9IGF0dHJpYnV0ZXMuc3BsaXRTaXplc1tpXTtcbiAgICBzaXplSW5TcGxpdEF4aXNbaV0gPSBwcmV2aW91c1N1bTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgICBvdXRwdXRTaGFwZVthdHRyaWJ1dGVzLmF4aXNdID0gYXR0cmlidXRlcy5zcGxpdFNpemVzW2ldO1xuICAgIG91dHB1dFNoYXBlcy5wdXNoKG91dHB1dFNoYXBlKTtcbiAgICBvdXRwdXRzW2ldID0gb3V0cHV0VmFyaWFibGUoYG91dHB1dCR7aX1gLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICBvdXRwdXRzVGVuc29ySW5mby5wdXNoKHtkaW1zOiBvdXRwdXRTaGFwZXNbaV0sIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9KTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVJblNwbGl0QXhpc30sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIC4uLm91dHB1dFNoYXBlcykpO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtcbiAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ2lucHV0X3NpemUnLCAndTMyJylcbiAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdzaXplX2luX3NwbGl0X2F4aXMnLCAndTMyJywgc2l6ZUluU3BsaXRBeGlzLmxlbmd0aClcbiAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgLi4ub3V0cHV0cyl9XG4gICR7Y2FsY3VsYXRlT3V0cHV0SW5kZXhJbXBsKHNpemVJblNwbGl0QXhpcy5sZW5ndGgpfVxuICAke3dyaXRlQnVmZmVyRGF0YUltcGwob3V0cHV0cyl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMuaW5wdXRfc2l6ZScpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke2lucHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICB2YXIgaW5kZXggPSAke2lucHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBheGlzKX07XG4gICAgbGV0IG91dHB1dF9udW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleCk7XG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xuICAgICAgaW5kZXggLT0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpcycsICdvdXRwdXRfbnVtYmVyIC0gMXUnLCBzaXplSW5TcGxpdEF4aXMubGVuZ3RoKX07XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2luZGljZXMnLCBheGlzLCAnaW5kZXgnKX07XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyLCBpbmRpY2VzLCBnbG9iYWxfaWR4KTtcbiAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NwbGl0JyxcbiAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXX0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBvdXRwdXRzVGVuc29ySW5mbyxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwoaW5wdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgIH0pXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc3BsaXQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID1cbiAgICAgIGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVTcGxpdEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwge2lucHV0czogWzBdfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTcGxpdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTcGxpdEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBheGlzID0gYXR0cmlidXRlcy5heGlzIGFzIG51bWJlcjtcbiAgY29uc3Qgc3BsaXRTaXplczogbnVtYmVyW10gPSBhdHRyaWJ1dGVzLnNwbGl0U2l6ZXMgYXMgbnVtYmVyW107XG4gIGNvbnN0IG51bU91dHB1dHMgPSBhdHRyaWJ1dGVzLm51bU91dHB1dHMgYXMgbnVtYmVyIDwgMCA/IHNwbGl0U2l6ZXMubGVuZ3RoIDogYXR0cmlidXRlcy5udW1PdXRwdXRzIGFzIG51bWJlcjtcbiAgaWYgKG51bU91dHB1dHMgIT09IHNwbGl0U2l6ZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmdoIG11c3QgYmUgZXF1YWwnKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzLCBudW1PdXRwdXRzLCBzcGxpdFNpemVzfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7QnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgY3JlYXRlV2hlcmVPcFByb2dyYW1TaGFkZXIgPVxuICAgIChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGRpbXNPdXRwdXQ6IHJlYWRvbmx5IG51bWJlcltdLCBpc0Jyb2FkY2FzdDogYm9vbGVhbixcbiAgICAgdHlwZU91dHB1dDogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X2RhdGEnLCB0eXBlT3V0cHV0LCBkaW1zT3V0cHV0Lmxlbmd0aCwgNCk7XG4gICAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYV9kYXRhJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIDQpO1xuICAgICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2JfZGF0YScsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCA0KTtcbiAgICAgIGNvbnN0IGMgPSBpbnB1dFZhcmlhYmxlKCdjX2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgNCk7XG5cbiAgICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gICAgICBjb25zdCBleHByZXNzaW9uID0gKGE6IHN0cmluZywgYjogc3RyaW5nLCBjOiBzdHJpbmcpID0+IGBzZWxlY3QoJHtifSwgJHthfSwgJHtjfSlgO1xuICAgICAgaWYgKCFpc0Jyb2FkY2FzdCkge1xuICAgICAgICBhc3NpZ25tZW50ID0gb3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICAgICAgZXhwcmVzc2lvbihhLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksIGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IHtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhX2RhdGFbaW5kZXhfYSR7eH1dW2NvbXBvbmVudF9hJHt4fV1gO1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25CID0gYGJfZGF0YVtpbmRleF9iJHt4fV1bY29tcG9uZW50X2Ike3h9XWA7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uQyA9IGBib29sKGNfZGF0YVtpbmRleF9jJHt4fV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHt4fSAqIDgpKSlgO1xuICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke3h9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYSR7eH0gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9iJHt4fSA9ICR7Yi5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Mke3h9ID0gJHtjLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBpbmRleF9hJHt4fSA9IG9mZnNldF9hJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Ike3h9ID0gb2Zmc2V0X2Ike3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYyR7eH0gPSBvZmZzZXRfYyR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYSR7eH0gPSBvZmZzZXRfYSR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYiR7eH0gPSBvZmZzZXRfYiR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYyR7eH0gPSBvZmZzZXRfYyR7eH0gJSA0dTtcbiAgICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7ZXhwcmVzc2lvbihleHByZXNzaW9uQSwgZXhwcmVzc2lvbkIsIGV4cHJlc3Npb25DKX0pO1xuICAgICAgICAgIGA7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlT3V0cHV0ID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDApfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDEpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDIpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDMpfVxuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGMsIGEsIGIsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxuICAgICAgICAke2Fzc2lnbm1lbnR9XG4gICAgICB9YDtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVXaGVyZU9wUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGRpbXNBID0gaW5wdXRzWzFdLmRpbXM7XG4gIGNvbnN0IGRpbXNCID0gaW5wdXRzWzJdLmRpbXM7XG4gIGNvbnN0IGRpbXNDID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dERhdGFUeXBlID0gaW5wdXRzWzFdLmRhdGFUeXBlO1xuXG4gIGNvbnN0IGlzQnJvYWRjYXN0ID0gIShTaGFwZVV0aWwuYXJlRXF1YWwoZGltc0EsIGRpbXNCKSAmJiBTaGFwZVV0aWwuYXJlRXF1YWwoZGltc0IsIGRpbXNDKSk7XG4gIGxldCBvdXRwdXRTaGFwZSA9IGRpbXNBO1xuICBsZXQgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGRpbXNBKTtcbiAgLy8gVE9ETzogZGVhbCB3aXRoIHplcm8tc2l6ZWQgdGVuc29ycyAoZWcuIGRpbXM9WzEsMF0pXG5cbiAgaWYgKGlzQnJvYWRjYXN0KSB7XG4gICAgY29uc3QgY2FsY3VsYXRlZFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZGltc0EsIGRpbXNCLCBmYWxzZSkhLCBkaW1zQywgZmFsc2UpO1xuICAgIGlmICghY2FsY3VsYXRlZFNoYXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcGVyZm9ybSB3aGVyZSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgIH1cbiAgICBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZWRTaGFwZTtcbiAgICBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICB9XG5cbiAgY29uc3QgdmVjU2l6ZSA9IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNCk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnV2hlcmUnLFxuICAgIHNoYWRlckNhY2hlOiB7aW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXX0sXG4gICAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyKSA9PlxuICAgICAgICBjcmVhdGVXaGVyZU9wUHJvZ3JhbVNoYWRlcihzaGFkZXJIZWxwZXIsIGlucHV0cywgb3V0cHV0U2hhcGUsIGlzQnJvYWRjYXN0LCBvdXRwdXREYXRhVHlwZSksXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIHZlYyBzaXplICovKX0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6XG4gICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHZlY1NpemV9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhkaW1zQywgZGltc0EsIGRpbXNCLCBvdXRwdXRTaGFwZSldLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHdoZXJlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVXaGVyZU9wUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7YXJnTWF4LCBhcmdNaW4sIHBhcnNlQXJnTWluTWF4QXR0cmlidXRlc30gZnJvbSAnLi9vcHMvYXJnbWlubWF4JztcbmltcG9ydCB7YXR0ZW50aW9ufSBmcm9tICcuL29wcy9hdHRlbnRpb24nO1xuaW1wb3J0IHtiYXRjaE5vcm19IGZyb20gJy4vb3BzL2JhdGNoLW5vcm0nO1xuaW1wb3J0IHtiaWFzQWRkfSBmcm9tICcuL29wcy9iaWFzLWFkZCc7XG5pbXBvcnQge2JpYXNTcGxpdEdlbHV9IGZyb20gJy4vb3BzL2JpYXMtc3BsaXQtZ2VsdSc7XG5pbXBvcnQgKiBhcyBiaW5hcnlPcHMgZnJvbSAnLi9vcHMvYmluYXJ5LW9wJztcbmltcG9ydCB7Y29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2NvbmNhdCc7XG5pbXBvcnQge2NvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2NvbnYnO1xuaW1wb3J0IHtjb252VHJhbnNwb3NlLCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9jb252LXRyYW5zcG9zZSc7XG5pbXBvcnQge2N1bXN1bSwgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9jdW1zdW0nO1xuaW1wb3J0IHtkZXB0aFRvU3BhY2UsIHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZGVwdGgtdG8tc3BhY2UnO1xuaW1wb3J0IHtlaW5zdW0sIHBhcnNlRWluc3VtQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZWluc3VtJztcbmltcG9ydCB7ZXhwYW5kfSBmcm9tICcuL29wcy9leHBhbmQnO1xuaW1wb3J0IHtmYXN0R2VsdX0gZnJvbSAnLi9vcHMvZmFzdC1nZWx1JztcbmltcG9ydCB7Z2F0aGVyLCBwYXJzZUdhdGhlckF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2dhdGhlcic7XG5pbXBvcnQge2dhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZ2F0aGVyLWVsZW1lbnRzJztcbmltcG9ydCB7Z2VtbSwgcGFyc2VHZW1tQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZ2VtbSc7XG5pbXBvcnQge2dyb3VwUXVlcnlBdHRlbnRpb24sIHBhcnNlR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbic7XG5pbXBvcnQge2luc3RhbmNlTm9ybX0gZnJvbSAnLi9vcHMvaW5zdGFuY2Utbm9ybSc7XG5pbXBvcnQge2xheWVyTm9ybX0gZnJvbSAnLi9vcHMvbGF5ZXItbm9ybSc7XG5pbXBvcnQge21hdE11bH0gZnJvbSAnLi9vcHMvbWF0bXVsJztcbmltcG9ydCB7bWF0TXVsTkJpdHMsIHBhcnNlTWF0TXVsTkJpdHNBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9tYXRtdWxuYml0cyc7XG5pbXBvcnQge211bHRpSGVhZEF0dGVudGlvbiwgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9tdWx0aWhlYWQtYXR0ZW50aW9uJztcbmltcG9ydCB7cGFkfSBmcm9tICcuL29wcy9wYWQnO1xuaW1wb3J0ICogYXMgcG9vbCBmcm9tICcuL29wcy9wb29sJztcbmltcG9ydCB7cmFuZ2V9IGZyb20gJy4vb3BzL3JhbmdlJztcbmltcG9ydCB7cmVkdWNlTDEsIHJlZHVjZUwyLCByZWR1Y2VMb2dTdW0sIHJlZHVjZUxvZ1N1bUV4cCwgcmVkdWNlTWF4LCByZWR1Y2VNZWFuLCByZWR1Y2VNaW4sIHJlZHVjZVByb2QsIHJlZHVjZVN1bSwgcmVkdWNlU3VtU3F1YXJlfSBmcm9tICcuL29wcy9yZWR1Y2UnO1xuaW1wb3J0IHtwYXJzZVJlc2l6ZUF0dHJpYnV0ZXMsIHJlc2l6ZX0gZnJvbSAnLi9vcHMvcmVzaXplJztcbmltcG9ydCB7cm90YXJ5RW1iZWRkaW5nfSBmcm9tICcuL29wcy9yb3RhcnktZW1iZWRkaW5nJztcbmltcG9ydCB7c2tpcExheWVyTm9ybX0gZnJvbSAnLi9vcHMvc2tpcC1sYXllci1ub3JtJztcbmltcG9ydCB7cGFyc2VTbGljZUF0dHJpYnV0ZXMsIHNsaWNlfSBmcm9tICcuL29wcy9zbGljZSc7XG5pbXBvcnQge3BhcnNlU29mdG1heEF0dHJpYnV0ZXMsIHNvZnRtYXh9IGZyb20gJy4vb3BzL3NvZnRtYXgnO1xuaW1wb3J0IHtwYXJzZVNwbGl0QXR0cmlidXRlcywgc3BsaXR9IGZyb20gJy4vb3BzL3NwbGl0JztcbmltcG9ydCB7dGlsZX0gZnJvbSAnLi9vcHMvdGlsZSc7XG5pbXBvcnQge3BhcnNlVHJhbnNwb3NlQXR0cmlidXRlcywgdHJhbnNwb3NlfSBmcm9tICcuL29wcy90cmFuc3Bvc2UnO1xuaW1wb3J0ICogYXMgdW5hcnlPcHMgZnJvbSAnLi9vcHMvdW5hcnktb3AnO1xuaW1wb3J0IHt3aGVyZX0gZnJvbSAnLi9vcHMvd2hlcmUnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFJ1bkZ1bmN0aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGU/OiB1bmtub3duKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgUGFyc2VBdHRyaWJ1dGVGdW5jdGlvbiA9IChhdHRyaWJ1dGVSYXc6IHVua25vd24pID0+IHVua25vd247XG5leHBvcnQgdHlwZSBPcGVyYXRvckltcGxlbWVudGF0aW9uID0gW1J1bkZ1bmN0aW9uXXxbUnVuRnVuY3Rpb24sIFBhcnNlQXR0cmlidXRlRnVuY3Rpb25dO1xuXG5leHBvcnQgY29uc3QgV0VCR1BVX09QX1JFU09MVkVfUlVMRVM6IE1hcDxzdHJpbmcsIE9wZXJhdG9ySW1wbGVtZW50YXRpb24+ID0gbmV3IE1hcChbXG4gIFsnQWJzJywgW3VuYXJ5T3BzLmFic11dLFxuICBbJ0Fjb3MnLCBbdW5hcnlPcHMuYWNvc11dLFxuICBbJ0Fjb3NoJywgW3VuYXJ5T3BzLmFjb3NoXV0sXG4gIFsnQWRkJywgW2JpbmFyeU9wcy5hZGRdXSxcbiAgWydBcmdNYXgnLCBbYXJnTWF4LCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXNdXSxcbiAgWydBcmdNaW4nLCBbYXJnTWluLCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXNdXSxcbiAgWydBc2luJywgW3VuYXJ5T3BzLmFzaW5dXSxcbiAgWydBc2luaCcsIFt1bmFyeU9wcy5hc2luaF1dLFxuICBbJ0F0YW4nLCBbdW5hcnlPcHMuYXRhbl1dLFxuICBbJ0F0YW5oJywgW3VuYXJ5T3BzLmF0YW5oXV0sXG4gIFsnQXR0ZW50aW9uJywgW2F0dGVudGlvbl1dLFxuICAvLyBUT0RPOiBzdXBwb3J0IG5ldyBhdHRyaWJ1dGVzIGZvciBBdmVyYWdlUG9vbC0xMFxuICBbJ0F2ZXJhZ2VQb29sJywgW3Bvb2wuYXZlcmFnZVBvb2wsIHBvb2wucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdXSxcbiAgWydCYXRjaE5vcm1hbGl6YXRpb24nLCBbYmF0Y2hOb3JtXV0sXG4gIFsnQmlhc0FkZCcsIFtiaWFzQWRkXV0sXG4gIFsnQmlhc1NwbGl0R2VsdScsIFtiaWFzU3BsaXRHZWx1XV0sXG4gIFsnQ2FzdCcsIFt1bmFyeU9wcy5jYXN0LCB1bmFyeU9wcy5wYXJzZUNhc3RBdHRyaWJ1dGVzXV0sXG4gIFsnQ2VpbCcsIFt1bmFyeU9wcy5jZWlsXV0sXG4gIFsnQ2xpcCcsIFt1bmFyeU9wcy5jbGlwXV0sXG4gIFsnQ29uY2F0JywgW2NvbmNhdCwgcGFyc2VDb25jYXRBdHRyaWJ1dGVzXV0sXG4gIFsnQ29udicsIFtjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzXV0sXG4gIFsnQ29udlRyYW5zcG9zZScsIFtjb252VHJhbnNwb3NlLCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXV0sXG4gIFsnQ29zJywgW3VuYXJ5T3BzLmNvc11dLFxuICBbJ0Nvc2gnLCBbdW5hcnlPcHMuY29zaF1dLFxuICBbJ0N1bVN1bScsIFtjdW1zdW0sIHBhcnNlQ3VtU3VtQXR0cmlidXRlc11dLFxuICBbJ0RlcHRoVG9TcGFjZScsIFtkZXB0aFRvU3BhY2UsIHBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlc11dLFxuICBbJ0RpdicsIFtiaW5hcnlPcHMuZGl2XV0sXG4gIFsnRWluc3VtJywgW2VpbnN1bSwgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzXV0sXG4gIFsnRWx1JywgW3VuYXJ5T3BzLmVsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcbiAgWydFcXVhbCcsIFtiaW5hcnlPcHMuZXF1YWxdXSxcbiAgWydFcmYnLCBbdW5hcnlPcHMuZXJmXV0sXG4gIFsnRXhwJywgW3VuYXJ5T3BzLmV4cF1dLFxuICBbJ0V4cGFuZCcsIFtleHBhbmRdXSxcbiAgWydGYXN0R2VsdScsIFtmYXN0R2VsdV1dLFxuICBbJ0Zsb29yJywgW3VuYXJ5T3BzLmZsb29yXV0sXG4gIFsnRnVzZWRDb252JywgW2NvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXNdXSxcbiAgWydHYXRoZXInLCBbZ2F0aGVyLCBwYXJzZUdhdGhlckF0dHJpYnV0ZXNdXSxcbiAgWydHYXRoZXJFbGVtZW50cycsIFtnYXRoZXJFbGVtZW50cywgcGFyc2VHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXNdXSxcbiAgWydHZWx1JywgW3VuYXJ5T3BzLmdlbHVdXSxcbiAgWydHZW1tJywgW2dlbW0sIHBhcnNlR2VtbUF0dHJpYnV0ZXNdXSxcbiAgWydHbG9iYWxBdmVyYWdlUG9vbCcsIFtwb29sLmdsb2JhbEF2ZXJhZ2VQb29sLCBwb29sLnBhcnNlR2xvYmFsQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnR2xvYmFsTWF4UG9vbCcsIFtwb29sLmdsb2JhbE1heFBvb2wsIHBvb2wucGFyc2VHbG9iYWxNYXhQb29sQXR0cmlidXRlc11dLFxuICBbJ0dyZWF0ZXInLCBbYmluYXJ5T3BzLmdyZWF0ZXJdXSxcbiAgWydHcmVhdGVyT3JFcXVhbCcsIFtiaW5hcnlPcHMuZ3JlYXRlck9yRXF1YWxdXSxcbiAgWydHcm91cFF1ZXJ5QXR0ZW50aW9uJywgW2dyb3VwUXVlcnlBdHRlbnRpb24sIHBhcnNlR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXNdXSxcbiAgWydIYXJkU2lnbW9pZCcsIFt1bmFyeU9wcy5oYXJkU2lnbW9pZCwgdW5hcnlPcHMucGFyc2VIYXJkU2lnbW9pZEF0dHJpYnV0ZXNdXSxcbiAgWydJbnN0YW5jZU5vcm1hbGl6YXRpb24nLCBbaW5zdGFuY2VOb3JtXV0sXG4gIFsnTGF5ZXJOb3JtYWxpemF0aW9uJywgW2xheWVyTm9ybV1dLFxuICBbJ0xlYWt5UmVsdScsIFt1bmFyeU9wcy5sZWFreVJlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnTGVzcycsIFtiaW5hcnlPcHMubGVzc11dLFxuICBbJ0xlc3NPckVxdWFsJywgW2JpbmFyeU9wcy5sZXNzT3JFcXVhbF1dLFxuICBbJ0xvZycsIFt1bmFyeU9wcy5sb2ddXSxcbiAgWydNYXRNdWwnLCBbbWF0TXVsXV0sXG4gIFsnTWF0TXVsTkJpdHMnLCBbbWF0TXVsTkJpdHMsIHBhcnNlTWF0TXVsTkJpdHNBdHRyaWJ1dGVzXV0sXG4gIC8vIFRPRE86IHN1cHBvcnQgbmV3IGF0dHJpYnV0ZXMgZm9yIE1heFBvb2wtOCBhbmQgTWF4UG9vbC0xMFxuICBbJ01heFBvb2wnLCBbcG9vbC5tYXhQb29sLCBwb29sLnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdXSxcbiAgWydNdWwnLCBbYmluYXJ5T3BzLm11bF1dLFxuICBbJ011bHRpSGVhZEF0dGVudGlvbicsIFttdWx0aUhlYWRBdHRlbnRpb24sIHBhcnNlTXVsdGlIZWFkQXR0ZW50aW9uQXR0cmlidXRlc11dLFxuICBbJ05lZycsIFt1bmFyeU9wcy5uZWddXSxcbiAgWydOb3QnLCBbdW5hcnlPcHMubm90XV0sXG4gIFsnUGFkJywgW3BhZF1dLFxuICBbJ1BvdycsIFtiaW5hcnlPcHMucG93XV0sXG4gIFsnUXVpY2tHZWx1JywgW3VuYXJ5T3BzLnF1aWNrZ2VsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcbiAgWydSYW5nZScsIFtyYW5nZV1dLFxuICBbJ1JlY2lwcm9jYWwnLCBbdW5hcnlPcHMucmVjaXByb2NhbF1dLFxuICBbJ1JlZHVjZU1pbicsIFtyZWR1Y2VNaW5dXSxcbiAgWydSZWR1Y2VNZWFuJywgW3JlZHVjZU1lYW5dXSxcbiAgWydSZWR1Y2VNYXgnLCBbcmVkdWNlTWF4XV0sXG4gIFsnUmVkdWNlU3VtJywgW3JlZHVjZVN1bV1dLFxuICBbJ1JlZHVjZVByb2QnLCBbcmVkdWNlUHJvZF1dLFxuICBbJ1JlZHVjZUwxJywgW3JlZHVjZUwxXV0sXG4gIFsnUmVkdWNlTDInLCBbcmVkdWNlTDJdXSxcbiAgWydSZWR1Y2VMb2dTdW0nLCBbcmVkdWNlTG9nU3VtXV0sXG4gIFsnUmVkdWNlTG9nU3VtRXhwJywgW3JlZHVjZUxvZ1N1bUV4cF1dLFxuICBbJ1JlZHVjZVN1bVNxdWFyZScsIFtyZWR1Y2VTdW1TcXVhcmVdXSxcbiAgWydSZWx1JywgW3VuYXJ5T3BzLnJlbHVdXSxcbiAgWydSZXNpemUnLCBbcmVzaXplLCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNdXSxcbiAgWydSb3RhcnlFbWJlZGRpbmcnLCBbcm90YXJ5RW1iZWRkaW5nXV0sXG4gIFsnU2lnbW9pZCcsIFt1bmFyeU9wcy5zaWdtb2lkXV0sXG4gIFsnU2luJywgW3VuYXJ5T3BzLnNpbl1dLFxuICBbJ1NpbmgnLCBbdW5hcnlPcHMuc2luaF1dLFxuICBbJ1NsaWNlJywgW3NsaWNlLCBwYXJzZVNsaWNlQXR0cmlidXRlc11dLFxuICBbJ1NraXBMYXllck5vcm1hbGl6YXRpb24nLCBbc2tpcExheWVyTm9ybV1dLFxuICBbJ1NwbGl0JywgW3NwbGl0LCBwYXJzZVNwbGl0QXR0cmlidXRlc11dLFxuICBbJ1NxcnQnLCBbdW5hcnlPcHMuc3FydF1dLFxuICBbJ1NvZnRtYXgnLCBbc29mdG1heCwgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc11dLFxuICBbJ1N1YicsIFtiaW5hcnlPcHMuc3ViXV0sXG4gIFsnVGFuJywgW3VuYXJ5T3BzLnRhbl1dLFxuICBbJ1RhbmgnLCBbdW5hcnlPcHMudGFuaF1dLFxuICBbJ1RocmVzaG9sZGVkUmVsdScsIFt1bmFyeU9wcy50aHJlc2hvbGRlZFJlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnVGlsZScsIFt0aWxlXV0sXG4gIFsnVHJhbnNwb3NlJywgW3RyYW5zcG9zZSwgcGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzXV0sXG4gIFsnV2hlcmUnLCBbd2hlcmVdXSxcbl0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge1dlYkdwdUJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmQtd2ViZ3B1JztcbmltcG9ydCB7TE9HX0RFQlVHfSBmcm9tICcuLi9sb2cnO1xuXG5pbXBvcnQge2NyZWF0ZVNoYWRlckhlbHBlcn0gZnJvbSAnLi9vcHMvY29tbW9uJztcbmltcG9ydCB7QXJ0aWZhY3QsIEdwdURhdGEsIFByb2dyYW1JbmZvfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBQcm9ncmFtTWFuYWdlciBpcyB0aGUgbWFpbiBjbGFzcyBiZWhpbmQgcnVubmluZyBjb21wdXRhdGlvbnNcbiAqIEl0IGJ1aWxkcyBQcm9ncmFtSW5mbydzIGludG8gQXJ0aWZhY3RzXG4gKiBJdCBjb21waWxlcyBnaXZlbiBQcm9ncmFtSW5mbydzIGludG8gV2ViR0wgUHJvcmFtcyAoY2FjaGVkIGFzIEFydGlmYWN0cylcbiAqIFVzZXMgdGhlIGFydGlmYWN0IHRvIHJ1biB0aGUgY29tcHV0YXRpb24gYnkgY2FsbGluZyBEcmF3IG9uXG4gKiB0aGUgV2ViR0wgZHJhd2luZyBidWZmZXJcbiAqIFByb2dyYW1NYW5hZ2VyIGF1dG9tYXRpY2FsbHkgbWFwcyAoYmluZHMpIGlucHV0IHZhcmlhYmxlcyB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBMb2NhdGlvbidzIGluIHRoZSBiaW5hcnkgcHJvZ3JhbVxuICovXG5leHBvcnQgY2xhc3MgUHJvZ3JhbU1hbmFnZXIge1xuICByZXBvOiBNYXA8dW5rbm93biwgQXJ0aWZhY3Q+OyAgLy8gdGhpcyBzaG91bGQgYmUgcGVyLXNlc3Npb24gb2JqZWN0XG4gIGF0dHJpYnV0ZXNCb3VuZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGJhY2tlbmQ6IFdlYkdwdUJhY2tlbmQpIHtcbiAgICB0aGlzLnJlcG8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzQm91bmQgPSBmYWxzZTtcbiAgfVxuICBnZXRBcnRpZmFjdChrZXk6IHVua25vd24pOiBBcnRpZmFjdHx1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XG4gIH1cbiAgc2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duLCBhcnRpZmFjdDogQXJ0aWZhY3QpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xuICB9XG4gIHJ1bihidWlsZEFydGlmYWN0OiBBcnRpZmFjdCwgaW5wdXRzOiBHcHVEYXRhW10sIG91dHB1dHM6IEdwdURhdGFbXSwgZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgdW5pZm9ybUJ1ZmZlckJpbmRpbmc6IEdQVUJpbmRpbmdSZXNvdXJjZXx1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5iYWNrZW5kLmRldmljZTtcbiAgICBjb25zdCBjb21wdXRlUGFzc0VuY29kZXIgPSB0aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7YmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB7YnVmZmVyOiBpbnB1dC5idWZmZXJ9fSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7YmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB7YnVmZmVyOiBvdXRwdXQuYnVmZmVyfX0pO1xuICAgIH1cbiAgICBpZiAodW5pZm9ybUJ1ZmZlckJpbmRpbmcpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7YmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB1bmlmb3JtQnVmZmVyQmluZGluZ30pO1xuICAgIH1cbiAgICBjb25zdCBiaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKFxuICAgICAgICB7bGF5b3V0OiBidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksIGVudHJpZXMsIGxhYmVsOiBidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWV9KTtcblxuICAgIGlmICh0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cyA9PT0gJ2NhcHR1cmluZycpIHtcbiAgICAgIGNvbnN0IGNvbW1hbmRJbmZvID0ge1xuICAgICAgICBrZXJuZWxJZDogdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCEsXG4gICAgICAgIGNvbXB1dGVQaXBlbGluZTogYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUsXG4gICAgICAgIGJpbmRHcm91cCxcbiAgICAgICAgZGlzcGF0Y2hHcm91cFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlc3Npb25Db21tYW5kTGlzdCA9IHRoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEpO1xuICAgICAgc2Vzc2lvbkNvbW1hbmRMaXN0IS5wdXNoKGNvbW1hbmRJbmZvKTtcbiAgICB9XG5cbiAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0UGlwZWxpbmUoYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUpO1xuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgYmluZEdyb3VwKTtcbiAgICBjb21wdXRlUGFzc0VuY29kZXIuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmRpc3BhdGNoR3JvdXApO1xuICAgIHRoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiArIDEpO1xuICAgIHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKztcblxuICAgIGlmICh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlciB8fFxuICAgICAgICB0aGlzLmJhY2tlbmQucXVlcnlUeXBlID09PSAnYXQtcGFzc2VzJykge1xuICAgICAgdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlcikge1xuICAgICAgdGhpcy5iYWNrZW5kLmZsdXNoKCk7XG4gICAgfVxuICAgIFRSQUNFX0ZVTkNfRU5EKGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSk7XG4gIH1cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyB0aGlzLnJlcG8uZm9yRWFjaChhID0+IHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0oYS5wcm9ncmFtKSk7XG4gIH1cbiAgYnVpbGQocHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IEFydGlmYWN0IHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKHByb2dyYW1JbmZvLm5hbWUpO1xuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XG4gICAgY29uc3QgZXh0ZW5zaW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoZGV2aWNlLmZlYXR1cmVzLmhhcygnc2hhZGVyLWYxNicpKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goJ2VuYWJsZSBmMTY7Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNoYWRlckhlbHBlciA9IGNyZWF0ZVNoYWRlckhlbHBlcihub3JtYWxpemVkRGlzcGF0Y2hHcm91cFNpemUsIHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKTtcbiAgICBjb25zdCB1c2VyQ29kZSA9IHByb2dyYW1JbmZvLmdldFNoYWRlclNvdXJjZShzaGFkZXJIZWxwZXIpO1xuICAgIGNvbnN0IGNvZGUgPSBgJHtleHRlbnNpb25zLmpvaW4oJ1xcbicpfVxcbiR7c2hhZGVySGVscGVyLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XFxuJHt1c2VyQ29kZX1gO1xuICAgIGNvbnN0IHNoYWRlck1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGUsIGxhYmVsOiBwcm9ncmFtSW5mby5uYW1lfSk7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdICR7cHJvZ3JhbUluZm8ubmFtZX0gc2hhZGVyIGNvZGU6ICR7Y29kZX1gKTtcblxuICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoXG4gICAgICAgIHtjb21wdXRlOiB7bW9kdWxlOiBzaGFkZXJNb2R1bGUsIGVudHJ5UG9pbnQ6ICdtYWluJ30sIGxheW91dDogJ2F1dG8nLCBsYWJlbDogcHJvZ3JhbUluZm8ubmFtZX0pO1xuXG4gICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgcmV0dXJuIHtwcm9ncmFtSW5mbywgY29tcHV0ZVBpcGVsaW5lLCB1bmlmb3JtVmFyaWFibGVzSW5mbzogc2hhZGVySGVscGVyLnZhcmlhYmxlc0luZm99O1xuICB9XG5cbiAgbm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUoZGlzcGF0Y2hHcm91cDogUmV0dXJuVHlwZTxQcm9ncmFtSW5mb1snZ2V0UnVuRGF0YSddPlsnZGlzcGF0Y2hHcm91cCddKTpcbiAgICAgIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgeCA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IGRpc3BhdGNoR3JvdXAgOiBkaXNwYXRjaEdyb3VwLng7XG4gICAgY29uc3QgeSA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IDEgOiAoZGlzcGF0Y2hHcm91cC55IHx8IDEpO1xuICAgIGNvbnN0IHogPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyAxIDogKGRpc3BhdGNoR3JvdXAueiB8fCAxKTtcbiAgICBjb25zdCBsaW1pdFBlckRpbWVuc2lvbiA9IHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO1xuICAgIGlmICh4IDw9IGxpbWl0UGVyRGltZW5zaW9uICYmIHkgPD0gbGltaXRQZXJEaW1lbnNpb24gJiYgeiA8PSBsaW1pdFBlckRpbWVuc2lvbikge1xuICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IHggKiB5ICogejtcbiAgICBsZXQgZGlzcGF0Y2hBdmVyYWdlID0gTWF0aC5jZWlsKE1hdGguc3FydChzaXplKSk7XG4gICAgaWYgKGRpc3BhdGNoQXZlcmFnZSA+IGxpbWl0UGVyRGltZW5zaW9uKSB7XG4gICAgICBkaXNwYXRjaEF2ZXJhZ2UgPSBNYXRoLmNlaWwoTWF0aC5jYnJ0KHNpemUpKTtcbiAgICAgIGlmIChkaXNwYXRjaEF2ZXJhZ2UgPiBsaW1pdFBlckRpbWVuc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2UsIDFdO1xuICAgIH1cbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0VudiwgVGVuc29yLCBUUkFDRSwgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkR9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7RGF0YVR5cGUsIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmltcG9ydCB7Y29uZmlndXJlTG9nZ2VyLCBMT0dfREVCVUd9IGZyb20gJy4vbG9nJztcbmltcG9ydCB7Y3JlYXRlVmlldywgVGVuc29yVmlld30gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge2NyZWF0ZUdwdURhdGFNYW5hZ2VyLCBkb3dubG9hZEdwdURhdGEsIEdwdURhdGFNYW5hZ2VyfSBmcm9tICcuL3dlYmdwdS9ncHUtZGF0YS1tYW5hZ2VyJztcbmltcG9ydCB7UnVuRnVuY3Rpb24sIFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTfSBmcm9tICcuL3dlYmdwdS9vcC1yZXNvbHZlLXJ1bGVzJztcbmltcG9ydCB7UHJvZ3JhbU1hbmFnZXJ9IGZyb20gJy4vd2ViZ3B1L3Byb2dyYW0tbWFuYWdlcic7XG5pbXBvcnQge0FkYXB0ZXJJbmZvLCBDb21wdXRlQ29udGV4dCwgR3B1QXJjaGl0ZWN0dXJlLCBHcHVEYXRhLCBHcHVWZW5kb3IsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgU2Vzc2lvblN0YXRlLCBUaW1lc3RhbXBRdWVyeX0gZnJvbSAnLi93ZWJncHUvdHlwZXMnO1xuXG5pbnRlcmZhY2UgQ29tbWFuZEluZm8ge1xuICByZWFkb25seSBrZXJuZWxJZDogbnVtYmVyO1xuICByZWFkb25seSBjb21wdXRlUGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcbiAgcmVhZG9ubHkgYmluZEdyb3VwOiBHUFVCaW5kR3JvdXA7XG4gIHJlYWRvbmx5IGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbn1cblxuaW50ZXJmYWNlIEtlcm5lbEluZm8ge1xuICByZWFkb25seSBrZXJuZWxUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGtlcm5lbE5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkga2VybmVsRW50cnk6IFJ1bkZ1bmN0aW9uO1xuICByZWFkb25seSBhdHRyaWJ1dGVzOiBbKChhdHRyaWJ1dGU6IHVua25vd24pID0+IHVua25vd24pfHVuZGVmaW5lZCwgdW5rbm93bl07XG59XG5cbmludGVyZmFjZSBQZW5kaW5nS2VybmVsSW5mbyB7XG4gIHJlYWRvbmx5IGtlcm5lbElkOiBudW1iZXI7XG4gIHJlYWRvbmx5IHByb2dyYW1OYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGlucHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcbiAgcmVhZG9ubHkgb3V0cHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcbn1cblxuY29uc3QgZ2V0UHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lLZXkgPVxuICAgIChpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgaW5wdXREZXBlbmRlbmNpZXM6IHJlYWRvbmx5IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10pOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKGlucHV0RGVwZW5kZW5jaWVzLmxlbmd0aCAhPT0gaW5wdXRUZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke2lucHV0RGVwZW5kZW5jaWVzLmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtcbiAgICAgICAgICAgIGlucHV0VGVuc29ycy5sZW5ndGh9LmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dEluZm9zOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGlucHV0VGVuc29yc1tpXS5kYXRhVHlwZTtcbiAgICAgICAgc3dpdGNoIChpbnB1dERlcGVuZGVuY2llc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ25vbmUnOiB7XG4gICAgICAgICAgICBpbnB1dEluZm9zLnB1c2goJycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3R5cGUnOiB7XG4gICAgICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdyYW5rJzoge1xuICAgICAgICAgICAgY29uc3QgcmFuayA9IGlucHV0VGVuc29yc1tpXS5kaW1zLmxlbmd0aDtcbiAgICAgICAgICAgIGlucHV0SW5mb3MucHVzaChgJHt0eXBlfTske3Jhbmt9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnZGltcyc6IHtcbiAgICAgICAgICAgIGNvbnN0IGRpbXMgPSBpbnB1dFRlbnNvcnNbaV0uZGltcy5qb2luKCcsJyk7XG4gICAgICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX07JHtkaW1zfWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7aW5wdXREZXBlbmRlbmNpZXNbaV19YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlucHV0SW5mb3Muam9pbignfCcpO1xuICAgIH07XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGtleSByZXByZXNlbnRpbmcgdGhlIHByb2dyYW0gZnJvbSB0aGUgcHJvZ3JhbSBpbmZvLCBpbnB1dCBzaGFwZXMgYW5kIHR5cGVzLlxuICpcbiAqIEByZXR1cm5zIGEgdW5pcXVlIGtleSBpcyBhIHNob3J0ZXIgc3RyaW5nIHRoYW4gdGhlIHNoYWRlciBzb3VyY2UsIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdG8gaWRlbnRpZnkgYVxuICogcHJvZ3JhbS4gaWYgdGhlIGtleSBpcyB0aGUgc2FtZSwgdGhlIHByb2dyYW0gc2hhZGVyIHNvdXJjZSBzaG91bGQgYmUgdGhlIHNhbWUsIHNvIHdlIGNhbiByZXVzZSB0aGUgcHJvZ3JhbS5cbiAqXG4gKi9cbmNvbnN0IGdldFByb2dyYW1JbmZvVW5pcXVlS2V5ID1cbiAgICAocHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgaXMxRGltZW5zaW9uRGlzcGF0Y2g6IGJvb2xlYW4pOiBzdHJpbmcgPT4ge1xuICAgICAgLy8gZmluYWwga2V5IGZvcm1hdDpcbiAgICAgIC8vIDxQUk9HUkFNX05BTUU+WzxQUk9HUkFNX0NVU1RPTV9DQUNIRV9ISU5UPl06aXMxRGltZW5zaW9uRGlzcGF0Y2g6PElOUFVUU19JTkZPXzA+fDxJTlBVVFNfSU5GT18xPnwuLi5cbiAgICAgIGxldCBrZXkgPSBwcm9ncmFtSW5mby5uYW1lO1xuICAgICAgaWYgKHByb2dyYW1JbmZvLnNoYWRlckNhY2hlPy5oaW50KSB7XG4gICAgICAgIGtleSArPSAnWycgKyBwcm9ncmFtSW5mby5zaGFkZXJDYWNoZS5oaW50ICsgJ10nO1xuICAgICAgfVxuICAgICAga2V5ICs9ICc6JyArIGlzMURpbWVuc2lvbkRpc3BhdGNoICtcbiAgICAgICAgICBgOiR7XG4gICAgICAgICAgICAgICAgIGdldFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5S2V5KFxuICAgICAgICAgICAgICAgICAgICAgaW5wdXRUZW5zb3JzLFxuICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbUluZm8uc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFycmF5PFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5PihpbnB1dFRlbnNvcnMubGVuZ3RoKS5maWxsKCdkaW1zJykpfWA7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbmNsYXNzIEFkYXB0ZXJJbmZvSW1wbCBpbXBsZW1lbnRzIEFkYXB0ZXJJbmZvIHtcbiAgcmVhZG9ubHkgYXJjaGl0ZWN0dXJlPzogc3RyaW5nO1xuICByZWFkb25seSB2ZW5kb3I/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlckluZm86IEdQVUFkYXB0ZXJJbmZvKSB7XG4gICAgaWYgKGFkYXB0ZXJJbmZvKSB7XG4gICAgICB0aGlzLmFyY2hpdGVjdHVyZSA9IGFkYXB0ZXJJbmZvLmFyY2hpdGVjdHVyZTtcbiAgICAgIHRoaXMudmVuZG9yID0gYWRhcHRlckluZm8udmVuZG9yO1xuICAgIH1cbiAgfVxuXG4gIGlzQXJjaGl0ZWN0dXJlKGFyY2hpdGVjdHVyZTogR3B1QXJjaGl0ZWN0dXJlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXJjaGl0ZWN0dXJlID09PSBhcmNoaXRlY3R1cmU7XG4gIH1cblxuICBpc1ZlbmRvcih2ZW5kb3I6IEdwdVZlbmRvcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZlbmRvciA9PT0gdmVuZG9yO1xuICB9XG59XG5cbi8qKlxuICogdGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byBzdG9yZSBzdGF0dXMgYW5kIGJlaW5nIHVzZWQgYXMgYSBzaW5nbGV0b24gZm9yIEpTRVAuIEl0IHdpbGwgYmUgcGFzc2VkIHRvIGpzZXBJbml0KCkgYXNcbiAqIHRoZSBmaXJzdCBwYXJhbWV0ZXIgc28gdGhhdCBpdCBpcyBzdG9yZWQgZm9yIGZ1dHVyZSB1c2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHcHVCYWNrZW5kIHtcbiAgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvSW1wbDtcbiAgZGV2aWNlOiBHUFVEZXZpY2U7XG4gIC8qKlxuICAgKiBhbiBpbnN0YW5jZSBvZiBHcHVEYXRhTWFuYWdlciB0byBtYW5hZ2UgYSBHcHVEYXRhSWQgLT4gR3B1QnVmZmVyIG1hcHBpbmdcbiAgICovXG4gIGdwdURhdGFNYW5hZ2VyOiBHcHVEYXRhTWFuYWdlcjtcbiAgLyoqXG4gICAqIGFuIGluc3RhbmNlIG9mIFByb2dyYW1NYW5hZ2VyIHRvIGJ1aWxkIGFuZCBydW4gV2ViR1BVIGNvbXB1dGUgc2hhZGVyIHByb2dyYW0sIGFuZCBtYW5hZ2UgYSBQcm9ncmFtS2V5IC0+IFByb2dyYW1cbiAgICogYXJ0aWZhY3RzIG1hcHBpbmdcbiAgICovXG4gIHByb2dyYW1NYW5hZ2VyOiBQcm9ncmFtTWFuYWdlcjtcblxuICAvKipcbiAgICogcmVwcmVzZW50aW5nIHRoZSBzZXNzaW9uIElEIG9mIHdoaWNoIGlzIGN1cnJlbnRseSBiZWluZyBydW4uXG4gICAqIGBudWxsYCBtZWFucyBubyBzZXNzaW9uIGlzIGJlaW5nIHJ1bi5cbiAgICogb25seSB2YWxpZCB3aGVuIHNlc3Npb24ucnVuIGlzIGV4ZWN1dGVkLlxuICAgKi9cbiAgY3VycmVudFNlc3Npb25JZDogbnVtYmVyfG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnRpbmcgdGhlIGtlcm5lbCBJRCBvZiB3aGljaCBpcyBjdXJyZW50bHkgYmVpbmcgY29tcHV0ZWQgKENQVSBjb2RlIHBlcnNwZWN0aXZlKS5cbiAgICogYG51bGxgIG1lYW5zIG5vIGtlcm5lbCBpcyBiZWluZyBjb21wdXRlZC5cbiAgICogb25seSBvbmUga2VybmVsIGNhbiBiZSBjb21wdXRlZCBhdCBhIG1vbWVudC5cbiAgICovXG4gIGN1cnJlbnRLZXJuZWxJZDogbnVtYmVyfG51bGwgPSBudWxsO1xuICAvKipcbiAgICogYSBsaXN0IG9mIHRlbXBvcmFyeSBHUFUgZGF0YSBmb3IgdGhlIGN1cnJlbnQga2VybmVsLiBzaG91bGQgcmVsZWFzZSB3aGVuIHRoZSBrZXJuZWwgZG9uZSBjb21wdXRhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgdGVtcG9yYXJ5RGF0YTogR3B1RGF0YVtdO1xuICAvKipcbiAgICogYSBLZXJuZWxJRCAtPiBhIEdQVSBkYXRhIGxpc3QsIHdoaWNoIHN0b3JlcyBwZXJzaXN0ZW50IEdQVSBkYXRhIG93bmVkIGJ5IHRoZSBzcGVjaWZpYyBrZXJuZWwuXG4gICAqL1xuICBwcml2YXRlIGtlcm5lbFBlcnNpc3RlbnREYXRhOiBNYXA8bnVtYmVyLCBHcHVEYXRhW10+O1xuICAvKipcbiAgICogYSBLZXJuZWxJRCAtPiBhIGN1c3RvbSBkYXRhLCB3aGljaCBzdG9yZXMgY3VzdG9tIGRhdGEgb3duZWQgYnkgdGhlIHNwZWNpZmljIGtlcm5lbC5cbiAgICovXG4gIHByaXZhdGUga2VybmVsQ3VzdG9tRGF0YTogTWFwPG51bWJlciwge1trZXk6IHN0cmluZ106IHVua25vd259PjtcbiAgLyoqXG4gICAqIGdldCB0aGUgY3VzdG9tIGRhdGEgb2YgdGhlIGN1cnJlbnQga2VybmVsXG4gICAqL1xuICBnZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKToge1trZXk6IHN0cmluZ106IHVua25vd259IHtcbiAgICBpZiAodGhpcy5jdXJyZW50S2VybmVsSWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvLyBLZXJuZWxJRCAtPiBrZXJuZWxJbmZvIG1hcHBpbmdcbiAga2VybmVsczogTWFwPG51bWJlciwgS2VybmVsSW5mbz47XG4gIHByaXZhdGUgY29tbWFuZEVuY29kZXI6IEdQVUNvbW1hbmRFbmNvZGVyfG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNvbXB1dGVQYXNzRW5jb2RlcjogR1BVQ29tcHV0ZVBhc3NFbmNvZGVyfG51bGwgPSBudWxsO1xuICBtYXhEaXNwYXRjaE51bWJlciA9IDE2O1xuICBwZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPSAwO1xuXG4gIC8vIGluZm8gb2Yga2VybmVscyBwZW5kaW5nIHN1Ym1pc3Npb24gZm9yIGEgc2luZ2xlIGJhdGNoXG4gIHByaXZhdGUgcGVuZGluZ0tlcm5lbHM6IFBlbmRpbmdLZXJuZWxJbmZvW10gPSBbXTtcbiAgLy8gcXVlcnlSZWFkQnVmZmVyIC0+IHBlbmRpbmdLZXJuZWxzIG1hcHBpbmcgZm9yIGFsbCB0aGUgYmF0Y2hlc1xuICBwcml2YXRlIHBlbmRpbmdRdWVyaWVzOiBNYXA8R1BVQnVmZmVyLCBQZW5kaW5nS2VybmVsSW5mb1tdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBxdWVyeVJlc29sdmVCdWZmZXI/OiBHUFVCdWZmZXI7XG4gIHByaXZhdGUgcXVlcnlTZXQ/OiBHUFVRdWVyeVNldDtcbiAgcHJpdmF0ZSBxdWVyeVRpbWVCYXNlPzogYmlnaW50O1xuICBxdWVyeVR5cGU6IFRpbWVzdGFtcFF1ZXJ5O1xuXG4gIGVudjogRW52O1xuICBzZXNzaW9uU3RhdHVzOiBTZXNzaW9uU3RhdGUgPSAnZGVmYXVsdCc7XG4gIC8qKlxuICAgKiBhIFNlc3Npb25JRCAtPiBDb21tYW5kSW5mb1tdIG1hcHBpbmcuIEl0J3MgdXNlZCB0byByZWNvcmQgYWxsIEdQVSBjb21tYW5kcyBmb3IgY29ycmVzcG9uZGluZyBzZXNzaW9uLlxuICAgKi9cbiAgY2FwdHVyZWRDb21tYW5kTGlzdDogTWFwPG51bWJlciwgQ29tbWFuZEluZm9bXT4gPSBuZXcgTWFwKCk7XG5cbiAgLyoqXG4gICAqIGEgU2Vzc2lvbklEIC0+IFBlbmRpbmdLZXJuZWxJbmZvW10gbWFwcGluZyBmb3IgcHJvZmlsaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBjYXB0dXJlZFBlbmRpbmdLZXJuZWxzOiBNYXA8bnVtYmVyLCBQZW5kaW5nS2VybmVsSW5mb1tdPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogYSBTZXNzaW9uSUQgLT4gYSBNYXAgb2YgKElucHV0T3V0cHV0SW5kZXggLT4gW0lELCBHUFVCdWZmZXJdKSBtYXBwaW5nLlxuICAgKi9cbiAgc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc6IE1hcDxudW1iZXIsIE1hcDxudW1iZXIsIFtudW1iZXIsIEdQVUJ1ZmZlcl0+PiA9IG5ldyBNYXAoKTtcblxuICBhc3luYyBpbml0aWFsaXplKGVudjogRW52LCBhZGFwdGVyOiBHUFVBZGFwdGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgY29uc3QgcmVxdWlyZWRGZWF0dXJlczogR1BVRmVhdHVyZU5hbWVbXSA9IFtdO1xuICAgIGNvbnN0IGRldmljZURlc2NyaXB0b3I6IEdQVURldmljZURlc2NyaXB0b3IgPSB7XG4gICAgICByZXF1aXJlZExpbWl0czoge1xuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLFxuICAgICAgICBtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6IGFkYXB0ZXIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxcbiAgICAgICAgbWF4QnVmZmVyU2l6ZTogYWRhcHRlci5saW1pdHMubWF4QnVmZmVyU2l6ZSxcbiAgICAgICAgbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAsXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVk6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVosXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWRGZWF0dXJlcyxcbiAgICB9O1xuXG4gICAgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnKSkge1xuICAgICAgcmVxdWlyZWRGZWF0dXJlcy5wdXNoKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnIGFzIEdQVUZlYXR1cmVOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCd0aW1lc3RhbXAtcXVlcnknKSkge1xuICAgICAgcmVxdWlyZWRGZWF0dXJlcy5wdXNoKCd0aW1lc3RhbXAtcXVlcnknKTtcbiAgICB9XG4gICAgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCdzaGFkZXItZjE2JykpIHtcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMucHVzaCgnc2hhZGVyLWYxNicpO1xuICAgIH1cblxuICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKGRldmljZURlc2NyaXB0b3IpO1xuICAgIHRoaXMuYWRhcHRlckluZm8gPSBuZXcgQWRhcHRlckluZm9JbXBsKGFkYXB0ZXIuaW5mbyB8fCBhd2FpdCBhZGFwdGVyLnJlcXVlc3RBZGFwdGVySW5mbygpKTtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyID0gY3JlYXRlR3B1RGF0YU1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlciA9IG5ldyBQcm9ncmFtTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLmtlcm5lbHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtlcm5lbEN1c3RvbURhdGEgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBzZXQgdXAgZmxhZ3MgZm9yIGxvZ2dlclxuICAgIGNvbmZpZ3VyZUxvZ2dlcihlbnYubG9nTGV2ZWwhLCAhIWVudi5kZWJ1Zyk7XG5cbiAgICAvLyBUT0RPOiBzZXQgdXAgZmxhZ3NcblxuICAgIHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yID0gZXYgPT4ge1xuICAgICAgaWYgKGV2LmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7ZXYuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICB0aGlzLmVudi53ZWJncHUsICdkZXZpY2UnLCB7dmFsdWU6IHRoaXMuZGV2aWNlLCB3cml0YWJsZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogZmFsc2V9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIHRoaXMuZW52LndlYmdwdSwgJ2FkYXB0ZXInLCB7dmFsdWU6IGFkYXB0ZXIsIHdyaXRhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiBmYWxzZX0pO1xuXG4gICAgLy8gaW5pdCBxdWVyeVR5cGUsIHdoaWNoIGlzIG5lY2Vzc2FyeSBmb3IgSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGVcbiAgICB0aGlzLnNldFF1ZXJ5VHlwZSgpO1xuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucXVlcnlTZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCk7XG4gIH1cblxuICBnZXRDb21tYW5kRW5jb2RlcigpOiBHUFVDb21tYW5kRW5jb2RlciB7XG4gICAgaWYgKCF0aGlzLmNvbW1hbmRFbmNvZGVyKSB7XG4gICAgICB0aGlzLmNvbW1hbmRFbmNvZGVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZEVuY29kZXI7XG4gIH1cblxuICBnZXRDb21wdXRlUGFzc0VuY29kZXIoKTogR1BVQ29tcHV0ZVBhc3NFbmNvZGVyIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKSB7XG4gICAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVQYXNzRGVzY3JpcHRvcjogR1BVQ29tcHV0ZVBhc3NEZXNjcmlwdG9yID0ge307XG5cbiAgICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSA9PT0gJ2F0LXBhc3NlcycpIHtcbiAgICAgICAgY29tcHV0ZVBhc3NEZXNjcmlwdG9yLnRpbWVzdGFtcFdyaXRlcyA9IHtcbiAgICAgICAgICBxdWVyeVNldDogdGhpcy5xdWVyeVNldCEsXG4gICAgICAgICAgYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDogdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyLFxuICAgICAgICAgIGVuZE9mUGFzc1dyaXRlSW5kZXg6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiArIDEsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyID0gY29tbWFuZEVuY29kZXIuYmVnaW5Db21wdXRlUGFzcyhjb21wdXRlUGFzc0Rlc2NyaXB0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXI7XG4gIH1cblxuICBlbmRDb21wdXRlUGFzcygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb21wdXRlUGFzc0VuY29kZXIpIHtcbiAgICAgIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLmVuZCgpO1xuICAgICAgdGhpcy5jb21wdXRlUGFzc0VuY29kZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb21tYW5kRW5jb2Rlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcblxuICAgIHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICBsZXQgcXVlcnlSZWFkQnVmZmVyOiBHUFVCdWZmZXI7XG4gICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIHRoaXMuY29tbWFuZEVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KFxuICAgICAgICAgIHRoaXMucXVlcnlTZXQhLCAwLCB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIsIHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyISwgMCk7XG5cbiAgICAgIHF1ZXJ5UmVhZEJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgIHtzaXplOiB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKiA4LCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUQgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVH0pO1xuXG4gICAgICB0aGlzLnBlbmRpbmdRdWVyaWVzLnNldChxdWVyeVJlYWRCdWZmZXIsIHRoaXMucGVuZGluZ0tlcm5lbHMpO1xuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIhLCAwLCBxdWVyeVJlYWRCdWZmZXIsIDAsIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiAqIDgpO1xuICAgIH1cblxuICAgIHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5jb21tYW5kRW5jb2Rlci5maW5pc2goKV0pO1xuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCk7XG4gICAgdGhpcy5jb21tYW5kRW5jb2RlciA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPSAwO1xuXG4gICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgIHZvaWQgcXVlcnlSZWFkQnVmZmVyIS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCBtYXBwZWREYXRhID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHF1ZXJ5UmVhZEJ1ZmZlci5nZXRNYXBwZWRSYW5nZSgpKTtcbiAgICAgICAgY29uc3QgcGVuZGluZ0tlcm5lbHMgPSB0aGlzLnBlbmRpbmdRdWVyaWVzLmdldChxdWVyeVJlYWRCdWZmZXIpITtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWREYXRhLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxJbmZvID0gcGVuZGluZ0tlcm5lbHNbaV07XG4gICAgICAgICAgY29uc3Qga2VybmVsSWQgPSBwZW5kaW5nS2VybmVsSW5mby5rZXJuZWxJZDtcbiAgICAgICAgICBjb25zdCBrZXJuZWxJbmZvID0gdGhpcy5rZXJuZWxzLmdldChrZXJuZWxJZCkhO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbFR5cGUgPSBrZXJuZWxJbmZvLmtlcm5lbFR5cGU7XG4gICAgICAgICAgY29uc3Qga2VybmVsTmFtZSA9IGtlcm5lbEluZm8ua2VybmVsTmFtZTtcbiAgICAgICAgICBjb25zdCBwcm9ncmFtTmFtZSA9IHBlbmRpbmdLZXJuZWxJbmZvLnByb2dyYW1OYW1lO1xuICAgICAgICAgIGNvbnN0IGlucHV0VGVuc29yVmlld3MgPSBwZW5kaW5nS2VybmVsSW5mby5pbnB1dFRlbnNvclZpZXdzO1xuICAgICAgICAgIGNvbnN0IG91dHB1dFRlbnNvclZpZXdzID0gcGVuZGluZ0tlcm5lbEluZm8ub3V0cHV0VGVuc29yVmlld3M7XG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lVTY0ID0gbWFwcGVkRGF0YVtpICogMl07XG4gICAgICAgICAgY29uc3QgZW5kVGltZVU2NCA9IG1hcHBlZERhdGFbaSAqIDIgKyAxXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5xdWVyeVRpbWVCYXNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5xdWVyeVRpbWVCYXNlID0gc3RhcnRUaW1lVTY0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IE51bWJlcihzdGFydFRpbWVVNjQgLSB0aGlzLnF1ZXJ5VGltZUJhc2UpO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBOdW1iZXIoZW5kVGltZVU2NCAtIHRoaXMucXVlcnlUaW1lQmFzZSk7XG5cbiAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHN0YXJ0VGltZSkgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGVuZFRpbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5jb3JyZWN0IHRpbWVzdGFtcCByYW5nZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5vbmRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmcub25kYXRhKHtcbiAgICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgaW5wdXRzTWV0YWRhdGE6IGlucHV0VGVuc29yVmlld3MubWFwKFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPT4gKHtkaW1zOiB2YWx1ZS5kaW1zLCBkYXRhVHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpfSkpLFxuICAgICAgICAgICAgICBvdXRwdXRzTWV0YWRhdGE6IG91dHB1dFRlbnNvclZpZXdzLm1hcChcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0+ICh7ZGltczogdmFsdWUuZGltcywgZGF0YVR5cGU6IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0pKSxcbiAgICAgICAgICAgICAga2VybmVsSWQsXG4gICAgICAgICAgICAgIGtlcm5lbFR5cGUsXG4gICAgICAgICAgICAgIGtlcm5lbE5hbWUsXG4gICAgICAgICAgICAgIHByb2dyYW1OYW1lLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHByaW50IHRoZSBwcm9maWxpbmcgbWVzc2FnZSB0byBjb25zb2xlXG4gICAgICAgICAgICBsZXQgaW5wdXRTaGFwZXMgPSAnJztcbiAgICAgICAgICAgIGlucHV0VGVuc29yVmlld3MuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICAgICAgaW5wdXRTaGFwZXMgKz0gYGlucHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRTaGFwZXMgPSAnJztcbiAgICAgICAgICAgIG91dHB1dFRlbnNvclZpZXdzLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIG91dHB1dFNoYXBlcyArPSBgb3V0cHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW3Byb2ZpbGluZ10ga2VybmVsIFwiJHtrZXJuZWxJZH18JHtrZXJuZWxUeXBlfXwke2tlcm5lbE5hbWV9fCR7cHJvZ3JhbU5hbWV9XCIgJHtpbnB1dFNoYXBlc30ke1xuICAgICAgICAgICAgICAgIG91dHB1dFNoYXBlc31leGVjdXRpb24gdGltZTogJHtlbmRUaW1lIC0gc3RhcnRUaW1lfSBuc2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBUUkFDRSgnR1BVJywgYCR7cHJvZ3JhbU5hbWV9Ojoke3N0YXJ0VGltZVU2NH06OiR7ZW5kVGltZVU2NH1gKTtcbiAgICAgICAgfVxuICAgICAgICBxdWVyeVJlYWRCdWZmZXIudW5tYXAoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUocXVlcnlSZWFkQnVmZmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJ1biBhIFdlYkdQVSBwcm9ncmFtLlxuICAgKiBAcGFyYW0gcHJvZ3JhbSBhIFByb2dyYW1JbmZvIGluc3RhbmNlXG4gICAqIEBwYXJhbSBpbnB1dFRlbnNvclZpZXdzIGEgVGVuc29yVmlldyBhcnJheS4gZWFjaCBlbGVtZW50IHJlcHJlc2VudHMgYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cyBpbiBHUFUuXG4gICAqIEBwYXJhbSBvdXRwdXRJbmRpY2VzIGFuIGluZGljZXMgYXJyYXkuIGVhY2ggZWxlbWVudCBjYW4gYmUgZWl0aGVyIC0xICh0ZW1wb3JhcnkgZGF0YSksIC0yIChwZXJzaXN0ZW50IGRhdGEpIG9yIGFuXG4gICAqIGluZGV4IHRvIHRoZSBrZXJuZWwncyBvdXRwdXQuXG4gICAqIEBwYXJhbSBjcmVhdGVLZXJuZWxPdXRwdXQgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhIHZhbHVlIHRvIGtlcm5lbCdzIG91dHB1dCB3aXRoIHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0gY3JlYXRlSW50ZXJtZWRpYXRlT3V0cHV0IGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBjcmVhdGUgYSB2YWx1ZSBhcyBhIGludGVybWVkaWF0ZSB2YWx1ZSwgZWl0aGVyIHRlbXBvcmFyeVxuICAgKiBvciBwZXJzaXN0ZW50IChvd25lZCBieSB0aGUgY3VycmVudCBrZXJuZWwpXG4gICAqIEByZXR1cm5zIGEgVGVuc29yVmlldyBhcnJheSByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICovXG4gIHJ1bihwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRUZW5zb3JWaWV3czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBvdXRwdXRJbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGNyZWF0ZUtlcm5lbE91dHB1dDogKGluZGV4OiBudW1iZXIsIGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBUZW5zb3JWaWV3LFxuICAgICAgY3JlYXRlSW50ZXJtZWRpYXRlT3V0cHV0OiAoZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pID0+IFRlbnNvclZpZXcsXG4gICAgICBvdXRwdXRDb3VudDogbnVtYmVyKTogVGVuc29yVmlld1tdIHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKHByb2dyYW0ubmFtZSk7XG4gICAgLy8gY3JlYXRlIGluZm8gZm9yIGlucHV0c1xuICAgIGNvbnN0IGlucHV0RGF0YXM6IEdwdURhdGFbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRUZW5zb3JWaWV3cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZGF0YSA9IGlucHV0VGVuc29yVmlld3NbaV0uZGF0YTtcbiAgICAgIC8vIGlmIHRlbnNvciB2aWV3IGRhdGEgaXMgMCwgaXQgbWVhbnMgdGhlIG91dHB1dCBpcyB6ZXJvLXNpemVkIHRlbnNvciwgYW5kIHRoZXJlIGlzIG5vIEdQVSBkYXRhIGZvciBpdC5cbiAgICAgIGlmIChkYXRhID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3B1RGF0YSA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KGRhdGEpO1xuICAgICAgaWYgKCFncHVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke2RhdGF9YCk7XG4gICAgICB9XG4gICAgICBpbnB1dERhdGFzLnB1c2goZ3B1RGF0YSk7XG4gICAgfVxuXG4gICAgY29uc3Qge291dHB1dHMsIGRpc3BhdGNoR3JvdXAsIHByb2dyYW1Vbmlmb3Jtc30gPSBwcm9ncmFtLmdldFJ1bkRhdGEoaW5wdXRUZW5zb3JWaWV3cyk7XG5cbiAgICAvLyBjaGVjayBvdXRwdXQgaW5kaWNlc1xuICAgIGNvbnN0IHZhbGlkYXRlZE91dHB1dEluZGljZXMgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aCA9PT0gMCA/IG91dHB1dHMubWFwKChfLCBpKSA9PiBpKSA6IG91dHB1dEluZGljZXM7XG4gICAgaWYgKHZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RoICE9PSBvdXRwdXRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke3ZhbGlkYXRlZE91dHB1dEluZGljZXMubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7b3V0cHV0cy5sZW5ndGh9LmApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpbmZvIGZvciBvdXRwdXRzXG4gICAgY29uc3Qgb3V0cHV0VGVuc29yVmlld3M6IFRlbnNvclZpZXdbXSA9IFtdO1xuICAgIGNvbnN0IG91dHB1dERhdGFzOiBHcHVEYXRhW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIHZhbHVlIC0xIGFuZCAtMiBhcmUgdXNlZCBmb3IgY3JlYXRpbmcgdGVtcG9yYXJ5IGFuZCBwZXJzaXN0ZW50IG91dHB1dHMuXG4gICAgICAvLyB2YWx1ZSAtMyBpcyB1c2VkIGZvciBwbGFjZWhvbGRlciBvdXRwdXQuIFNvIC0zLCAtMiwgLTEgYW5kIDAsIDEsIDIsIC4uLiBhcmUgdmFsaWRcbiAgICAgIC8vIG91dHB1dCBpbmRpY2VzLiBzZWUgdHlwZSBkZWZpbml0aW9uIG9mIENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldKSB8fCB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldIDwgLTMgfHxcbiAgICAgICAgICB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID49IG91dHB1dENvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7dmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzVGVtcG9yYXJ5ID0gdmFsaWRhdGVkT3V0cHV0SW5kaWNlc1tpXSA9PT0gLTE7XG4gICAgICBjb25zdCBpc1BlcnNpc3RlbnQgPSB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMjtcbiAgICAgIGNvbnN0IHRlbnNvclZpZXcgPSAoaXNUZW1wb3JhcnkgfHwgaXNQZXJzaXN0ZW50KSA/XG4gICAgICAgICAgY3JlYXRlSW50ZXJtZWRpYXRlT3V0cHV0KG91dHB1dHNbaV0uZGF0YVR5cGUsIG91dHB1dHNbaV0uZGltcykgOlxuICAgICAgICAgIGNyZWF0ZUtlcm5lbE91dHB1dCh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldLCBvdXRwdXRzW2ldLmRhdGFUeXBlLCBvdXRwdXRzW2ldLmRpbXMpO1xuICAgICAgb3V0cHV0VGVuc29yVmlld3MucHVzaCh0ZW5zb3JWaWV3KTtcbiAgICAgIC8vIGlmIHRlbnNvciB2aWV3IGRhdGEgaXMgMCwgaXQgbWVhbnMgdGhlIG91dHB1dCBpcyB6ZXJvLXNpemVkIHRlbnNvciwgYW5kIHRoZXJlIGlzIG5vIEdQVSBkYXRhIGZvciBpdC5cbiAgICAgIGlmICh0ZW5zb3JWaWV3LmRhdGEgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodGVuc29yVmlldy5kYXRhKTtcbiAgICAgIGlmICghZ3B1RGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7dGVuc29yVmlldy5kYXRhfWApO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGVtcG9yYXJ5KSB7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKGdwdURhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGVyc2lzdGVudCkge1xuICAgICAgICBsZXQgcGVyc2lzdGVudERhdGEgPSB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCEpO1xuICAgICAgICBpZiAoIXBlcnNpc3RlbnREYXRhKSB7XG4gICAgICAgICAgcGVyc2lzdGVudERhdGEgPSBbXTtcbiAgICAgICAgICB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCEsIHBlcnNpc3RlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBwZXJzaXN0ZW50RGF0YS5wdXNoKGdwdURhdGEpO1xuICAgICAgfVxuICAgICAgb3V0cHV0RGF0YXMucHVzaChncHVEYXRhKTtcbiAgICB9XG5cbiAgICAvLyB3aGVuIHRoZXJlIGFyZSBhbnkgemVyby1zaXplZCB0ZW5zb3IgaW4gdGhlIGlucHV0cyBvciBvdXRwdXRzLCB3ZSBzaG91bGQgcmVwb3J0IGVycm9yIHVubGVzcyBhbGwgb3V0cHV0cyBhcmVcbiAgICAvLyB6ZXJvLXNpemVkIHRlbnNvcnMuXG4gICAgaWYgKGlucHV0RGF0YXMubGVuZ3RoICE9PSBpbnB1dFRlbnNvclZpZXdzLmxlbmd0aCB8fCBvdXRwdXREYXRhcy5sZW5ndGggIT09IG91dHB1dFRlbnNvclZpZXdzLmxlbmd0aCkge1xuICAgICAgLy8gaWYgYWxsIG91dHB1dHMgYXJlIHplcm8tc2l6ZWQgdGVuc29ycywgdGhlcmUgaXMgbm8gbmVlZCB0byBydW4gdGhlIHByb2dyYW0uXG4gICAgICBpZiAob3V0cHV0RGF0YXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIFRSQUNFX0ZVTkNfRU5EKHByb2dyYW0ubmFtZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRUZW5zb3JWaWV3cztcbiAgICAgIH1cbiAgICAgIC8vIGlmIHNvbWUgb3V0cHV0cyBhcmUgemVyby1zaXplZCB0ZW5zb3JzLCByZXBvcnQgYW4gZXJyb3IuXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogc28gZmFyIHdlIGRvbid0IHNlZSBhbnkgdXNlIGNhc2UgdGhhdCBvdXRwdXRzIGluY2x1ZGUgYm90aCB6ZXJvLXNpemVkIHRlbnNvcnMgYW5kIG5vbi16ZXJvLXNpemVkIHRlbnNvcnMuXG4gICAgICAvLyBJZiB3ZSBzZWUgc3VjaCB1c2UgY2FzZSwgd2UgbmVlZCB0byBtYWtlIGEgY2hhbmdlIGhlcmUgdG8gc3VwcG9ydCBpdC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUHJvZ3JhbSAke3Byb2dyYW0ubmFtZX0gaGFzIHplcm8tc2l6ZWQgdGVuc29yKHMpIGluIGlucHV0cyBvciBvdXRwdXRzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgbm93LmApO1xuICAgIH1cblxuICAgIC8vIGxvYWQgdW5pZm9ybXNcbiAgICAvLyBUT0RPOiBhZGQgY2FjaGUgZm9yIHVuaWZvcm0gKGlzIGl0IG5lY2Vzc2FyeT8pXG4gICAgLy9cbiAgICBsZXQgdW5pZm9ybUJ1ZmZlckJpbmRpbmc6IEdQVUJpbmRpbmdSZXNvdXJjZXx1bmRlZmluZWQ7XG4gICAgaWYgKHByb2dyYW1Vbmlmb3Jtcykge1xuICAgICAgbGV0IGN1cnJlbnRPZmZzZXQgPSAwO1xuICAgICAgY29uc3Qgb2Zmc2V0czogbnVtYmVyW10gPSBbXTtcblxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLmZvckVhY2godiA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2Ygdi5kYXRhID09PSAnbnVtYmVyJyA/IFt2LmRhdGFdIDogdi5kYXRhO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL1dHU0wvI2FsaWdub2ZcbiAgICAgICAgY29uc3Qgc2l6ZU9mRWxlbWVudCA9IHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNiA/IDIgOiA0O1xuICAgICAgICBsZXQgc2l6ZU9mVmVjT3JNYXQ7XG4gICAgICAgIGxldCBiYXNlQWxpZ25tZW50O1xuICAgICAgICBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2KSB7XG4gICAgICAgICAgYmFzZUFsaWdubWVudCA9IGRhdGEubGVuZ3RoID4gNCA/IDE2IDogKGRhdGEubGVuZ3RoID4gMiA/IDggOiBkYXRhLmxlbmd0aCAqIHNpemVPZkVsZW1lbnQpO1xuICAgICAgICAgIHNpemVPZlZlY09yTWF0ID0gZGF0YS5sZW5ndGggPiA0ID8gMTYgOiBzaXplT2ZFbGVtZW50ICogZGF0YS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZUFsaWdubWVudCA9IGRhdGEubGVuZ3RoIDw9IDIgPyBkYXRhLmxlbmd0aCAqIHNpemVPZkVsZW1lbnQgOiAxNjtcbiAgICAgICAgICBzaXplT2ZWZWNPck1hdCA9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwoY3VycmVudE9mZnNldCAvIGJhc2VBbGlnbm1lbnQpICogYmFzZUFsaWdubWVudDtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKGN1cnJlbnRPZmZzZXQpO1xuICAgICAgICAvLyBGb3Igbm9uLWZsb2F0MTYgdHlwZSwgd2hlbiBkYXRhLmxlbmd0aCA+IDQsIHRoZSB1bmlmb3JtIHZhcmlhYmxlIGlzIG9mIHR5cGUgYXJyYXk8dmVjNDxpMzJ8dTMyfGYzMj4sTj4sIHdoZXJlXG4gICAgICAgIC8vIE4gPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA0KSBhbmQgU2l6ZU9mKHZlYzQ8aTMyfHUzMnxmMzI+KSA9IDE2LiBUaGUgdG90YWwgYnl0ZSBsZW5ndGggaXMgTiAqXG4gICAgICAgIC8vIFNpemVPZih2ZWM0PGkzMnx1MzJ8ZjMyPikuIEZvciBmbG9hdDE2IHR5cGUsIHdoZW4gZGF0YS5sZW5ndGggPiA0LCB0aGUgdW5pZm9ybSB2YXJpYWJsZSBpcyBvZiB0eXBlXG4gICAgICAgIC8vIGFycmF5PG1hdDJ4NDxmMTY+LE4+LCB3aGVyZSBOID0gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gOCkgYW5kIFNpemVPZihtYXQyeDQ8ZjE2PikgPSAxNi4gVGhlIHRvdGFsIGJ5dGVcbiAgICAgICAgLy8gbGVuZ3RoIGlzIE4gKiBTaXplT2YobWF0Mng0PGYxNj4pLlxuICAgICAgICBjb25zdCBlbGVtZW50UGVyVmVjT3JNYXQgPSB2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYgPyA4IDogNDtcbiAgICAgICAgY3VycmVudE9mZnNldCArPSBkYXRhLmxlbmd0aCA+IDQgPyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyBlbGVtZW50UGVyVmVjT3JNYXQpICogc2l6ZU9mVmVjT3JNYXQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNZWV0IGFsaWdubWVudCBvZiBzdHJ1Y3QgaGVyZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1dHU0wvI2FsaWdubWVudC1hbmQtc2l6ZS4gRm9yIHNpbXBsaWNpdHksIHNldFxuICAgICAgLy8gbWF4QWxpZ25tZW50T2ZGaWVsZCB0byAxNiBzaW5jZSB0aGUgdW5kZXJseWluZyBidWZmZXIgaGFzIGJlZW4gcm91bmRlZCB1cCB0byAxNi5cbiAgICAgIGNvbnN0IG1heEFsaWdubWVudE9mRmllbGQgPSAxNjtcbiAgICAgIGN1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwoY3VycmVudE9mZnNldCAvIG1heEFsaWdubWVudE9mRmllbGQpICogbWF4QWxpZ25tZW50T2ZGaWVsZDtcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN1cnJlbnRPZmZzZXQpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0c1tpXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiB2LmRhdGEgPT09ICdudW1iZXInID8gW3YuZGF0YV0gOiB2LmRhdGE7XG4gICAgICAgIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmludDMyKSB7XG4gICAgICAgICAgbmV3IEludDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLnVpbnQzMikge1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNikge1xuICAgICAgICAgIC8vIFRPRE86IHVzZSBGbG9hdDE2QXJyYXkuXG4gICAgICAgICAgbmV3IFVpbnQxNkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZTogJHt0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2LnR5cGUpfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgdW5pZm9ybUJ1ZmZlckRhdGEgPVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoY3VycmVudE9mZnNldCwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKTtcbiAgICAgIHRoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKHVuaWZvcm1CdWZmZXJEYXRhLmJ1ZmZlciwgMCwgYXJyYXlCdWZmZXIsIDAsIGN1cnJlbnRPZmZzZXQpO1xuICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHVuaWZvcm1CdWZmZXJEYXRhLmlkKTtcbiAgICAgIHVuaWZvcm1CdWZmZXJCaW5kaW5nID0ge29mZnNldDogMCwgc2l6ZTogY3VycmVudE9mZnNldCwgYnVmZmVyOiB1bmlmb3JtQnVmZmVyRGF0YS5idWZmZXJ9O1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwID0gdGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShkaXNwYXRjaEdyb3VwKTtcbiAgICBjb25zdCBpczFEaW1lbnNpb25EaXNwYXRjaCA9IG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdID09PSAxICYmIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdID09PSAxO1xuICAgIC8vIGdldCBwcm9ncmFtIGluZm9cbiAgICBjb25zdCBrZXkgPSBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleShwcm9ncmFtLCBpbnB1dFRlbnNvclZpZXdzLCBpczFEaW1lbnNpb25EaXNwYXRjaCk7XG4gICAgbGV0IGFydGlmYWN0ID0gdGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChrZXkpO1xuICAgIGlmICghYXJ0aWZhY3QpIHtcbiAgICAgIGFydGlmYWN0ID0gdGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZChwcm9ncmFtLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cCk7XG4gICAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KGtleSwgYXJ0aWZhY3QpO1xuICAgICAgTE9HX0RFQlVHKCdpbmZvJywgKCkgPT4gYFthcnRpZmFjdF0ga2V5OiAke2tleX0sIHByb2dyYW1OYW1lOiAke3Byb2dyYW0ubmFtZX1gKTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSB1bmlmb3JtIHZhcmlhYmxlc1xuICAgIGlmIChwcm9ncmFtVW5pZm9ybXMgJiYgYXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8pIHtcbiAgICAgIGlmIChwcm9ncmFtVW5pZm9ybXMubGVuZ3RoICE9PSBhcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIHZhcmlhYmxlcyBjb3VudCBtaXNtYXRjaDogZXhwZWN0ICR7YXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7XG4gICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXMubGVuZ3RofSBpbiBwcm9ncmFtIFwiJHthcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lfVwiLmApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtVW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdW5pZm9ybSA9IHByb2dyYW1Vbmlmb3Jtc1tpXTtcbiAgICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IHVuaWZvcm0udHlwZTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gdHlwZW9mIHVuaWZvcm0uZGF0YSA9PT0gJ251bWJlcicgPyAxIDogdW5pZm9ybS5kYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgW3R5cGUsIGxlbmd0aF0gPSBhcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mb1tpXTtcbiAgICAgICAgaWYgKGFjdHVhbFR5cGUgIT09IHR5cGUgfHwgYWN0dWFsTGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gdmFyaWFibGUgJHtpfSBtaXNtYXRjaDogZXhwZWN0IHR5cGUgJHt0eXBlfSB3aXRoIHNpemUgJHtsZW5ndGh9LCBnb3QgdHlwZSAke1xuICAgICAgICAgICAgICBhY3R1YWxUeXBlfSB3aXRoIHNpemUgJHthY3R1YWxMZW5ndGh9IGluIHByb2dyYW0gXCIke2FydGlmYWN0LnByb2dyYW1JbmZvLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBMT0dfREVCVUcoXG4gICAgICAgICdpbmZvJyxcbiAgICAgICAgKCkgPT4gYFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHtwcm9ncmFtLm5hbWV9XCIgKGtleT0ke2tleX0pIHdpdGggJHtub3JtYWxpemVkRGlzcGF0Y2hHcm91cFswXX14JHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdfXgke25vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdfWApO1xuXG4gICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScgfHwgdGhpcy5zZXNzaW9uU3RhdHVzID09PSAnY2FwdHVyaW5nJykge1xuICAgICAgY29uc3QgcGVuZGluZ0tlcm5lbEluZm86IFBlbmRpbmdLZXJuZWxJbmZvID0ge1xuICAgICAgICBrZXJuZWxJZDogdGhpcy5jdXJyZW50S2VybmVsSWQhLFxuICAgICAgICBwcm9ncmFtTmFtZTogYXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSxcbiAgICAgICAgaW5wdXRUZW5zb3JWaWV3cyxcbiAgICAgICAgb3V0cHV0VGVuc29yVmlld3MsXG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHBlbmRpbmdLZXJuZWxJbmZvKTtcblxuICAgICAgaWYgKHRoaXMuc2Vzc2lvblN0YXR1cyA9PT0gJ2NhcHR1cmluZycpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvblBlbmRpbmdLZXJuZWxzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKTtcbiAgICAgICAgc2Vzc2lvblBlbmRpbmdLZXJuZWxzIS5wdXNoKHBlbmRpbmdLZXJuZWxJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bihhcnRpZmFjdCwgaW5wdXREYXRhcywgb3V0cHV0RGF0YXMsIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwLCB1bmlmb3JtQnVmZmVyQmluZGluZyk7XG5cbiAgICBUUkFDRV9GVU5DX0VORChwcm9ncmFtLm5hbWUpO1xuICAgIHJldHVybiBvdXRwdXRUZW5zb3JWaWV3cztcbiAgfVxuXG4gIHVwbG9hZChncHVEYXRhSWQ6IG51bWJlciwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIudXBsb2FkKGdwdURhdGFJZCwgZGF0YSk7XG4gIH1cblxuICBtZW1jcHkoc3JjOiBudW1iZXIsIGRzdDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5tZW1jcHkoc3JjLCBkc3QpO1xuICB9XG5cbiAgYXN5bmMgZG93bmxvYWQoZ3B1RGF0YUlkOiBudW1iZXIsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBtYXkgYmUgY2hhbmdlZCBhZnRlciB0aGUgYXN5bmMgZnVuY3Rpb24gaXMgY2FsbGVkLiBzbyB3ZSB1c2UgYSBnZXR0ZXIgZnVuY3Rpb24gdG8gbWFrZSBzdXJlXG4gICAgLy8gdGhlIGJ1ZmZlciBpcyB1cC10by1kYXRlLlxuICAgIGF3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQoZ3B1RGF0YUlkLCBnZXRUYXJnZXRCdWZmZXIpO1xuICB9XG5cbiAgYWxsb2Moc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZSkuaWQ7XG4gIH1cblxuICBmcmVlKHB0cjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHB0cik7XG4gIH1cblxuICBjcmVhdGVLZXJuZWwoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24sIGtlcm5lbE5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IG9wID0gV0VCR1BVX09QX1JFU09MVkVfUlVMRVMuZ2V0KGtlcm5lbFR5cGUpO1xuICAgIGlmICghb3ApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHtrZXJuZWxUeXBlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGtlcm5lbEluZm86IEtlcm5lbEluZm8gPSB7XG4gICAgICBrZXJuZWxUeXBlLFxuICAgICAga2VybmVsTmFtZSxcbiAgICAgIGtlcm5lbEVudHJ5OiBvcFswXSxcbiAgICAgIGF0dHJpYnV0ZXM6IFtvcFsxXSwgYXR0cmlidXRlXSxcbiAgICB9O1xuICAgIHRoaXMua2VybmVscy5zZXQoa2VybmVsSWQsIGtlcm5lbEluZm8pO1xuICB9XG5cbiAgcmVsZWFzZUtlcm5lbChrZXJuZWxJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgcGVyc2lzdGVudERhdGEgPSB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKHBlcnNpc3RlbnREYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgcGVyc2lzdGVudERhdGEpIHtcbiAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGRhdGEuaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUoa2VybmVsSWQpO1xuICAgIH1cblxuICAgIHRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUoa2VybmVsSWQpO1xuICAgIHRoaXMua2VybmVscy5kZWxldGUoa2VybmVsSWQpO1xuICB9XG5cbiAgY29tcHV0ZUtlcm5lbChrZXJuZWxJZDogbnVtYmVyLCBjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgZXJyb3JzOiBBcnJheTxQcm9taXNlPHN0cmluZ3xudWxsPj4pOiBudW1iZXIge1xuICAgIGNvbnN0IGtlcm5lbCA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpO1xuICAgIGlmICgha2VybmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHtrZXJuZWxJZH1gKTtcbiAgICB9XG4gICAgY29uc3Qga2VybmVsVHlwZSA9IGtlcm5lbC5rZXJuZWxUeXBlO1xuICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWwua2VybmVsTmFtZTtcbiAgICBjb25zdCBrZXJuZWxFbnRyeSA9IGtlcm5lbC5rZXJuZWxFbnRyeTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ga2VybmVsLmF0dHJpYnV0ZXM7XG4gICAgaWYgKHRoaXMuY3VycmVudEtlcm5lbElkICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudEtlcm5lbElkID0ga2VybmVsSWQ7XG5cbiAgICAvLyBwYXJzZSBhdHRyaWJ1dGVzIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChhdHRyaWJ1dGVzWzBdKSB7XG4gICAgICBhdHRyaWJ1dGVzWzFdID0gYXR0cmlidXRlc1swXShhdHRyaWJ1dGVzWzFdKTtcbiAgICAgIGF0dHJpYnV0ZXNbMF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKCdpbmZvJywgKCkgPT4gYFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiLi4uYCk7XG5cbiAgICBjb25zdCB1c2VFcnJvclNjb3BlID0gdGhpcy5lbnYuZGVidWc7XG5cbiAgICB0aGlzLnRlbXBvcmFyeURhdGEgPSBbXTtcbiAgICB0cnkge1xuICAgICAgaWYgKHVzZUVycm9yU2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoJ3ZhbGlkYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAga2VybmVsRW50cnkoY29udGV4dCwgYXR0cmlidXRlc1sxXSk7XG4gICAgICByZXR1cm4gMDsgIC8vIE9SVF9PS1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIiBmYWlsZWQuICR7ZX1gKSk7XG4gICAgICByZXR1cm4gMTsgIC8vIE9SVF9GQUlMXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh1c2VFcnJvclNjb3BlKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHRoaXMuZGV2aWNlLnBvcEVycm9yU2NvcGUoKS50aGVuKFxuICAgICAgICAgICAgZXJyID0+IGVyciA/IGBHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIjogJHtlcnIubWVzc2FnZX1gIDogbnVsbCkpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGRhdGEgb2YgdGhpcy50ZW1wb3JhcnlEYXRhKSB7XG4gICAgICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShkYXRhLmlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGVtcG9yYXJ5RGF0YSA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50S2VybmVsSWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vICNyZWdpb24gZXh0ZXJuYWwgYnVmZmVyXG4gIHJlZ2lzdGVyQnVmZmVyKHNlc3Npb25JZDogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBidWZmZXI6IEdQVUJ1ZmZlciwgc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKCFzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKSB7XG4gICAgICBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQoc2Vzc2lvbklkLCBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2aW91c0J1ZmZlciA9IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuZ2V0KGluZGV4KTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXIsIHNpemUsIHByZXZpb3VzQnVmZmVyPy5bMV0pO1xuICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuc2V0KGluZGV4LCBbaWQsIGJ1ZmZlcl0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICB1bnJlZ2lzdGVyQnVmZmVycyhzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldChzZXNzaW9uSWQpO1xuICAgIGlmIChzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nKSB7XG4gICAgICBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nLmZvckVhY2goYnVmZmVySW5mbyA9PiB0aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXJJbmZvWzFdKSk7XG4gICAgICB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgfVxuICBnZXRCdWZmZXIoZ3B1RGF0YUlkOiBudW1iZXIpOiBHUFVCdWZmZXIge1xuICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldChncHVEYXRhSWQpO1xuICAgIGlmICghZ3B1RGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke2dwdURhdGFJZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGdwdURhdGEuYnVmZmVyO1xuICB9XG4gIGNyZWF0ZURvd25sb2FkZXIoZ3B1QnVmZmVyOiBHUFVCdWZmZXIsIHNpemU6IG51bWJlciwgdHlwZTogVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyk6XG4gICAgICAoKSA9PiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZT4ge1xuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZG93bmxvYWRHcHVEYXRhKHRoaXMsIGdwdUJ1ZmZlciwgc2l6ZSk7XG4gICAgICByZXR1cm4gY3JlYXRlVmlldyhkYXRhLmJ1ZmZlciwgdHlwZSk7XG4gICAgfTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG4gIHdyaXRlVGltZXN0YW1wKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdpbnNpZGUtcGFzc2VzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyIGFzIGFueSkud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCwgaW5kZXgpO1xuICB9XG4gIHNldFF1ZXJ5VHlwZSgpOiB2b2lkIHtcbiAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdub25lJztcbiAgICBpZiAodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ubW9kZSA9PT0gJ2RlZmF1bHQnIHx8XG4gICAgICAgICh0eXBlb2YgdGhpcy5lbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gdGhpcy5lbnYud2FzbS50cmFjZSA6IHRoaXMuZW52LnRyYWNlKSkge1xuICAgICAgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJykpIHtcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnaW5zaWRlLXBhc3Nlcyc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygndGltZXN0YW1wLXF1ZXJ5JykpIHtcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnYXQtcGFzc2VzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScgJiYgdHlwZW9mIHRoaXMucXVlcnlTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXQgPSB0aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7XG4gICAgICAgICAgdHlwZTogJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgY291bnQ6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAge3NpemU6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyICogOCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmVCZWdpbigpOiB2b2lkIHtcbiAgICBMT0dfREVCVUcoJ2luZm8nLCAnY2FwdHVyZUJlZ2luJyk7XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Quc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnY2FwdHVyaW5nJztcbiAgfVxuICBjYXB0dXJlRW5kKCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdjYXB0dXJlRW5kJyk7XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XG4gIH1cbiAgcmVwbGF5KCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdyZXBsYXknKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAncmVwbGF5aW5nJztcbiAgICBjb25zdCBzZXNzaW9uQ29tbWFuZExpc3QgPSB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpO1xuICAgIGNvbnN0IHNlc3Npb25QZW5kaW5nS2VybmVscyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2Vzc2lvbkNvbW1hbmRMaXN0IS5sZW5ndGg7XG4gICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVQYXNzRW5jb2RlciA9IHRoaXMuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7XG4gICAgICBjb25zdCBjb21tYW5kID0gc2Vzc2lvbkNvbW1hbmRMaXN0IVtpXTtcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShjb21tYW5kLmNvbXB1dGVQaXBlbGluZSk7XG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGNvbW1hbmQuYmluZEdyb3VwKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uY29tbWFuZC5kaXNwYXRjaEdyb3VwKTtcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSk7XG4gICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrO1xuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHNlc3Npb25QZW5kaW5nS2VybmVscyFbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgfHwgdGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XG4gICAgICAgIHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLm1heERpc3BhdGNoTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XG4gIH1cblxuICBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy51bnJlZ2lzdGVyQnVmZmVycyhzZXNzaW9uSWQpO1xuICAgIGlmICh0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHNlc3Npb25JZCkpIHtcbiAgICAgIHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5oYXMoc2Vzc2lvbklkKSkge1xuICAgICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLm9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkKTtcbiAgfVxuXG4gIG9uUnVuU3RhcnQoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgdGhpcy5zZXRRdWVyeVR5cGUoKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHR5cGUge09ydFdhc21Nb2R1bGV9IGZyb20gJy4uL3dhc20tdHlwZXMnO1xuaW1wb3J0IHtEYXRhVHlwZSwgZ2V0VGVuc29yRWxlbWVudFNpemV9IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxuaW1wb3J0IHtXZWJHcHVCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQtd2ViZ3B1JztcbmltcG9ydCB7TE9HX0RFQlVHfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge0FkYXB0ZXJJbmZvLCBDb21wdXRlQ29udGV4dCwgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZywgUHJvZ3JhbUluZm99IGZyb20gJy4vd2ViZ3B1L3R5cGVzJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG5jbGFzcyBUZW5zb3JWaWV3SW1wbCBpbXBsZW1lbnRzIFRlbnNvclZpZXcge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLCBwdWJsaWMgcmVhZG9ubHkgZGF0YVR5cGU6IG51bWJlciwgcHVibGljIHJlYWRvbmx5IGRhdGE6IG51bWJlcixcbiAgICAgIHB1YmxpYyByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXSkge31cblxuICBnZXRGbG9hdDMyQXJyYXkoKTogRmxvYXQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IEZsb2F0MzJBcnJheSgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIGdldEJpZ0ludDY0QXJyYXkoKTogQmlnSW50NjRBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDY0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMCA/IG5ldyBCaWdJbnQ2NEFycmF5KCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQmlnSW50NjRBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIGdldEludDMyQXJyYXkoKTogSW50MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMCA/IG5ldyBJbnQzMkFycmF5KCkgOiBuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIHJlc2hhcGUobmV3RGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3IHtcbiAgICBpZiAoU2hhcGVVdGlsLnNpemUobmV3RGltcykgIT09IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXcgc2hhcGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZW5zb3JWaWV3SW1wbCh0aGlzLm1vZHVsZSwgdGhpcy5kYXRhVHlwZSwgdGhpcy5kYXRhLCBuZXdEaW1zKTtcbiAgfVxufVxuXG5jbGFzcyBDb21wdXRlQ29udGV4dEltcGwgaW1wbGVtZW50cyBDb21wdXRlQ29udGV4dCB7XG4gIHJlYWRvbmx5IGFkYXB0ZXJJbmZvOiBBZGFwdGVySW5mbztcbiAgcmVhZG9ubHkgb3BLZXJuZWxDb250ZXh0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xuICBnZXQga2VybmVsQ3VzdG9tRGF0YSgpOiB7W2tleTogc3RyaW5nXTogdW5rbm93bn0ge1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbEN1c3RvbURhdGE7XG4gIH1cbiAgZ2V0IGN1c3RvbURhdGFCdWZmZXIoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsIHRoaXMuY3VzdG9tRGF0YU9mZnNldCArIHRoaXMuY3VzdG9tRGF0YVNpemUpO1xuICB9XG4gIHByaXZhdGUgY3VzdG9tRGF0YU9mZnNldCA9IDA7XG4gIHByaXZhdGUgY3VzdG9tRGF0YVNpemUgPSAwO1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZHVsZTogT3J0V2FzbU1vZHVsZSwgcHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kLCBjb250ZXh0RGF0YU9mZnNldDogbnVtYmVyKSB7XG4gICAgdGhpcy5hZGFwdGVySW5mbyA9IGJhY2tlbmQuYWRhcHRlckluZm87XG4gICAgY29uc3QgaGVhcFUzMiA9IG1vZHVsZS5IRUFQVTMyO1xuXG4gICAgLy8gZXh0cmFjdCBjb250ZXh0IGRhdGFcbiAgICBsZXQgZGF0YUluZGV4ID0gKGNvbnRleHREYXRhT2Zmc2V0ID4+PiAyKTtcbiAgICB0aGlzLm9wS2VybmVsQ29udGV4dCA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgIGNvbnN0IGlucHV0Q291bnQgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICB0aGlzLm91dHB1dENvdW50ID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgdGhpcy5jdXN0b21EYXRhT2Zmc2V0ID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgdGhpcy5jdXN0b21EYXRhU2l6ZSA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuXG4gICAgY29uc3QgaW5wdXRzOiBUZW5zb3JWaWV3W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgIGNvbnN0IGRhdGEgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgIGNvbnN0IGRpbSA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgICAgY29uc3QgZGltczogbnVtYmVyW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGltOyBkKyspIHtcbiAgICAgICAgZGltcy5wdXNoKGhlYXBVMzJbZGF0YUluZGV4KytdKTtcbiAgICAgIH1cbiAgICAgIGlucHV0cy5wdXNoKG5ldyBUZW5zb3JWaWV3SW1wbChtb2R1bGUsIGRhdGFUeXBlLCBkYXRhLCBkaW1zKSk7XG4gICAgfVxuICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICB9XG5cbiAgZ2V0TWF4Q29tcHV0ZVdvcmtncm91cFNpemVzKCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCwgdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZLFxuICAgICAgdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaXG4gICAgXTtcbiAgfVxuXG4gIGdldE1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU7XG4gIH1cblxuICBjb21wdXRlKHByb2dyYW06IFByb2dyYW1JbmZvLCBpbnB1dHNPdXRwdXRzTWFwcGluZz86IENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcpOiBUZW5zb3JWaWV3W10ge1xuICAgIC8vIHByZXBhcmUgaW5wdXRzLiBpbnB1dHMgc2hvdWxkIGFsd2F5cyBiZSB2YWxpZCBkYXRhLlxuICAgIGNvbnN0IG1hcHBlZElucHV0cyA9XG4gICAgICAgIGlucHV0c091dHB1dHNNYXBwaW5nPy5pbnB1dHM/Lm1hcChpID0+IHR5cGVvZiBpID09PSAnbnVtYmVyJyA/IHRoaXMuaW5wdXRzW2ldIDogaSkgPz8gdGhpcy5pbnB1dHM7XG4gICAgLy8gcHJlcGFyZSBvdXRwdXRzLlxuICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBpbnB1dHNPdXRwdXRzTWFwcGluZz8ub3V0cHV0cyA/PyBbXTtcbiAgICBjb25zdCBjcmVhdGVLZXJuZWxPdXRwdXQgPSAoaW5kZXg6IG51bWJlciwgZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3ID0+XG4gICAgICAgIG5ldyBUZW5zb3JWaWV3SW1wbCh0aGlzLm1vZHVsZSwgZGF0YVR5cGUsIHRoaXMub3V0cHV0KGluZGV4LCBkaW1zKSwgZGltcyk7XG4gICAgY29uc3QgY3JlYXRlVGVtcG9yYXJ5T3V0cHV0ID0gKGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldyA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IGdldFRlbnNvckVsZW1lbnRTaXplKGRhdGFUeXBlKTtcbiAgICAgIGlmICghZWxlbWVudFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJTaXplID0gZWxlbWVudFNpemUgKiBTaGFwZVV0aWwuc2l6ZShkaW1zKTtcbiAgICAgIGNvbnN0IGdwdURhdGFJZCA9IGJ1ZmZlclNpemUgPiAwID8gdGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShidWZmZXJTaXplKS5pZCA6IDA7XG4gICAgICByZXR1cm4gbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCBkYXRhVHlwZSwgZ3B1RGF0YUlkLCBkaW1zKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQucnVuKFxuICAgICAgICBwcm9ncmFtLCBtYXBwZWRJbnB1dHMsIG91dHB1dEluZGljZXMsIGNyZWF0ZUtlcm5lbE91dHB1dCwgY3JlYXRlVGVtcG9yYXJ5T3V0cHV0LCB0aGlzLm91dHB1dENvdW50KTtcbiAgfVxuXG4gIG91dHB1dChpbmRleDogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLm1vZHVsZS5zdGFja1NhdmUoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDEgKyBkaW1zLmxlbmd0aCkgKiA0IC8qIHNpemVvZihzaXplX3QpICovKTtcbiAgICAgIGxldCBvZmZzZXQgPSBkYXRhID4+IDI7XG4gICAgICB0aGlzLm1vZHVsZS5IRUFQVTMyW29mZnNldCsrXSA9IGRpbXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kdWxlLkhFQVBVMzJbb2Zmc2V0KytdID0gZGltc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCEodGhpcy5vcEtlcm5lbENvbnRleHQsIGluZGV4LCBkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSBrZXJuZWwncyBvdXRwdXRbJHtpbmRleH1dIHdpdGggZGltcyBbJHtkaW1zfV0uIGAgK1xuICAgICAgICAgICdJZiB5b3UgYXJlIHJ1bm5pbmcgd2l0aCBwcmUtYWxsb2NhdGVkIG91dHB1dCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3V0cHV0IHR5cGUvZGltcyBhcmUgY29ycmVjdC4gJyArXG4gICAgICAgICAgYEVycm9yOiAke2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMubW9kdWxlLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBKU0VQIHdpdGggV2ViR1BVIGJhY2tlbmQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWQgKFwiX09ydEluaXRcIiBpcyBjYWxsZWQpLCBvbmNlIGZvclxuICogZWFjaCBvZiB0aGUgZm9sbG93aW5nIEVQcyBpZiB0aGV5IGFyZSBzcGVjaWZpZWQ6XG4gKiAtIFwid2ViZ3B1XCJcbiAqIC0gXCJ3ZWJublwiXG4gKlxuICogRm9yIFdlYkdQVSwgdGhpcyBmdW5jdGlvbiBleHBlY3RzOlxuICogIC0gV2ViR1BVIGlzIGVuYWJsZWQgaW4gYnVpbGQgKEJVSUxEX0RFRlMuRElTQUJMRV9KU0VQID09PSBmYWxzZSkuXG4gKiAgLSBXZWJHUFUgaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuIChhIHZhbGlkIEdQVUFkYXB0ZXIgaXMgcGFzc2VkIGluKVxuICpcbiAqIEZvciBXZWJOTiwgdGhpcyBmdW5jdGlvbiBleHBlY3RzOlxuICogLSBXZWJOTiBpcyBlbmFibGVkIGluIGJ1aWxkIChCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCA9PT0gZmFsc2UpLlxuICogLSBXZWJOTiBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC4gKG5hdmlnYXRvci5tbCBpcyBub3QgdW5kZWZpbmVkKVxuICpcbiAqIElmIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbm90IGJ1aWx0IHdpdGggSlNFUCBzdXBwb3J0LCB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gZXJyb3IuIFRoaXMgd2lsbCBpbnZhbGlkYXRlXG4gKiAnd2ViZ3B1Jy8nd2Vibm4nIGJhY2tlbmQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgRVAsIGVpdGhlciBcIndlYmdwdVwiIG9yIFwid2Vibm5cIlxuICogQHBhcmFtIG1vZHVsZSAtIHRoZSBPUlQgV2ViQXNzZW1ibHkgbW9kdWxlXG4gKiBAcGFyYW0gZW52IC0gdGhlIE9SVCBlbnZpcm9ubWVudCB2YXJpYWJsZSAob3J0LmVudilcbiAqIEBwYXJhbSBncHVBZGFwdGVyIC0gdGhlIHByZS1jcmVhdGVkIEdQVSBhZGFwdGVyXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0ID1cbiAgICBhc3luYyhuYW1lOiAnd2ViZ3B1J3wnd2Vibm4nLCBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsIGVudjogRW52LCBncHVBZGFwdGVyPzogR1BVQWRhcHRlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBqc2VwSW5pdCA9IG1vZHVsZS5qc2VwSW5pdDtcbiAgaWYgKCFqc2VwSW5pdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuJyk7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gJ3dlYmdwdScpIHtcbiAgICBjb25zdCBiYWNrZW5kID0gbmV3IFdlYkdwdUJhY2tlbmQoKTtcbiAgICBhd2FpdCBiYWNrZW5kLmluaXRpYWxpemUoZW52LCBncHVBZGFwdGVyISk7XG5cbiAgICBqc2VwSW5pdCgnd2ViZ3B1JywgW1xuICAgICAgLy8gYmFja2VuZFxuICAgICAgYmFja2VuZCxcblxuICAgICAgLy8ganNlcEFsbG9jKClcbiAgICAgIChzaXplOiBudW1iZXIpID0+IGJhY2tlbmQuYWxsb2Moc2l6ZSksXG5cbiAgICAgIC8vIGpzZXBGcmVlKClcbiAgICAgIChwdHI6IG51bWJlcikgPT4gYmFja2VuZC5mcmVlKHB0ciksXG5cbiAgICAgIC8vIGpzZXBDb3B5KHNyYywgZHN0LCBzaXplLCBpc1NvdXJjZUdwdSlcbiAgICAgIChzcmM6IG51bWJlciwgZHN0OiBudW1iZXIsIHNpemU6IG51bWJlciwgaXNTb3VyY2VHcHUgPSBmYWxzZSkgPT4ge1xuICAgICAgICBpZiAoaXNTb3VyY2VHcHUpIHtcbiAgICAgICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0ganNlcENvcHlHcHVUb0dwdTogc3JjPSR7c3JjfSwgZHN0PSR7ZHN0fSwgc2l6ZT0ke3NpemV9YCk7XG4gICAgICAgICAgYmFja2VuZC5tZW1jcHkoc3JjLCBkc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7c3JjfSwgZ3B1RGF0YUlkPSR7ZHN0fSwgc2l6ZT0ke3NpemV9YCk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IG1vZHVsZS5IRUFQVTguc3ViYXJyYXkoc3JjID4+PiAwLCAoc3JjID4+PiAwKSArIHNpemUpO1xuICAgICAgICAgIGJhY2tlbmQudXBsb2FkKGRzdCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIGpzZXBDb3B5QXN5bmMoc3JjLCBkc3QsIHNpemUpXG4gICAgICBhc3luYyhncHVEYXRhSWQ6IG51bWJlciwgZGF0YU9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIpOlxuICAgICAgICAgIFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgICAgICAgICAoKSA9PiBgW1dlYkdQVV0ganNlcENvcHlHcHVUb0NwdTogZ3B1RGF0YUlkPSR7Z3B1RGF0YUlkfSwgZGF0YU9mZnNldD0ke2RhdGFPZmZzZXR9LCBzaXplPSR7c2l6ZX1gKTtcblxuICAgICAgICAgICAgYXdhaXQgYmFja2VuZC5kb3dubG9hZChcbiAgICAgICAgICAgICAgICBncHVEYXRhSWQsICgpID0+IG1vZHVsZS5IRUFQVTguc3ViYXJyYXkoZGF0YU9mZnNldCA+Pj4gMCwgKGRhdGFPZmZzZXQgPj4+IDApICsgc2l6ZSkpO1xuICAgICAgICAgIH0sXG5cbiAgICAgIC8vIGpzZXBDcmVhdGVLZXJuZWxcbiAgICAgIChrZXJuZWxUeXBlOiBzdHJpbmcsIGtlcm5lbElkOiBudW1iZXIsIGF0dHJpYnV0ZTogdW5rbm93bikgPT4gYmFja2VuZC5jcmVhdGVLZXJuZWwoXG4gICAgICAgICAga2VybmVsVHlwZSwga2VybmVsSWQsIGF0dHJpYnV0ZSwgbW9kdWxlLlVURjhUb1N0cmluZyhtb2R1bGUuX0pzZXBHZXROb2RlTmFtZSEoa2VybmVsSWQpKSksXG5cbiAgICAgIC8vIGpzZXBSZWxlYXNlS2VybmVsXG4gICAgICAoa2VybmVsOiBudW1iZXIpID0+IGJhY2tlbmQucmVsZWFzZUtlcm5lbChrZXJuZWwpLFxuXG4gICAgICAvLyBqc2VwUnVuXG4gICAgICAoa2VybmVsOiBudW1iZXIsIGNvbnRleHREYXRhT2Zmc2V0OiBudW1iZXIsIHNlc3Npb25IYW5kbGU6IG51bWJlciwgZXJyb3JzOiBBcnJheTxQcm9taXNlPHN0cmluZ3xudWxsPj4pID0+IHtcbiAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICAgKCkgPT4gYFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtzZXNzaW9uSGFuZGxlfSwga2VybmVsPSR7a2VybmVsfSwgY29udGV4dERhdGFPZmZzZXQ9JHtcbiAgICAgICAgICAgICAgICBjb250ZXh0RGF0YU9mZnNldH1gKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBDb21wdXRlQ29udGV4dEltcGwobW9kdWxlLCBiYWNrZW5kLCBjb250ZXh0RGF0YU9mZnNldCk7XG4gICAgICAgIHJldHVybiBiYWNrZW5kLmNvbXB1dGVLZXJuZWwoa2VybmVsLCBjb250ZXh0LCBlcnJvcnMpO1xuICAgICAgfSxcbiAgICAgIC8vIGpzZXBDYXB0dXJlQmVnaW5cbiAgICAgICgpID0+IGJhY2tlbmQuY2FwdHVyZUJlZ2luKCksXG4gICAgICAvLyBqc2VwQ2FwdHVyZUVuZFxuICAgICAgKCkgPT4gYmFja2VuZC5jYXB0dXJlRW5kKCksXG4gICAgICAvLyBqc2VwUmVwbGF5XG4gICAgICAoKSA9PiBiYWNrZW5kLnJlcGxheSgpXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAganNlcEluaXQoJ3dlYm5uJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFdlYk5OIEFQSSBjdXJyZW50bHkgZG9lcyBub3QgaGF2ZSBhIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmaWxlLiBUaGlzIGZpbGUgaXMgYSB3b3JrYXJvdW5kIHdpdGggdHlwZXMgZ2VuZXJhdGVkIGZyb21cbi8vIFdlYk5OIEFQSSBzcGVjaWZpY2F0aW9uLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYm1hY2hpbmVsZWFybmluZy93ZWJubi9pc3N1ZXMvNjc3XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwianNlcC93ZWJubi93ZWJubi5kLnRzXCIgLz5cblxuaW1wb3J0IHtFbnYsIEluZmVyZW5jZVNlc3Npb24sIFRlbnNvcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlciwgU2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhLCBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSwgVGVuc29yTWV0YWRhdGF9IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0IHtzZXRSdW5PcHRpb25zfSBmcm9tICcuL3J1bi1vcHRpb25zJztcbmltcG9ydCB7c2V0U2Vzc2lvbk9wdGlvbnN9IGZyb20gJy4vc2Vzc2lvbi1vcHRpb25zJztcbmltcG9ydCB7ZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtLCBnZXRUZW5zb3JFbGVtZW50U2l6ZSwgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLCBsb2dMZXZlbFN0cmluZ1RvRW51bSwgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcsIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtLCB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3J9IGZyb20gJy4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHthbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuaW1wb3J0IHtsb2FkRmlsZX0gZnJvbSAnLi93YXNtLXV0aWxzLWxvYWQtZmlsZSc7XG5cbi8vICNyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogVGhlcmUgYXJlIDQgZGlmZmVyZW50IFwiaW5pdGlhbGl6YXRpb25cIiBzdGVwcyBmb3IgT1JULiBUaGV5IGhhcHBlbiBpbiBkaWZmZXJlbnQgcGxhY2VzIGFuZCBkaWZmZXJlbnQgdGltZS5cbiAqXG4gKiAxLiBKYXZhU2NyaXB0IGluaXRpYWxpemF0aW9uIGZvciBvbm54cnVudGltZS1jb21tb24gYW5kIG9ubnhydW50aW1lLXdlYi5cbiAqICAgIFRoaXMgaXMgdGhlIGZpcnN0IGluaXRpYWxpemF0aW9uIHN0ZXAuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGNhbGxzIG9ubnhydW50aW1lLWNvbW1vbidzIHJlZ2lzdGVyQmFja2VuZCgpXG4gKiBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBhbGwgdGhlIGF2YWlsYWJsZSBiYWNrZW5kcy4gVGhlIGJhY2tlbmQgcmVnaXN0cmF0aW9uIGlzIHZlcnkgZmFzdC4gSXQgb25seVxuICogcmVnaXN0ZXJzIHRoZSBiYWNrZW5kIG5hbWUgd2l0aCB0aGUgdW5pbml0aWFsaXplZCBiYWNrZW5kIG9iamVjdC4gTm8gaGVhdnkgaW5pdGlhbGl6YXRpb24gaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICBSZWZlciB0byB3ZWIvbGliL2luZGV4LnRzIGZvciB0aGUgYmFja2VuZCByZWdpc3RyYXRpb24uXG4gKlxuICogMi4gV2ViQXNzZW1ibHkgYXJ0aWZhY3QgaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBhbnkgcmVnaXN0ZXJlZCB3YXNtIGJhY2tlbmQgaXMgdXNlZCBmb3IgdGhlIGZpcnN0IHRpbWUgKGllLiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIG9yXG4gKiBgb3J0LlRyYWluaW5nU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkKS4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgICAtIGNyZWF0ZSBhIHByb3h5IHdvcmtlciBhbmQgbWFrZSBzdXJlIHRoZSBwcm94eSB3b3JrZXIgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtZXNzYWdlcywgaWYgcHJveHkgaXMgZW5hYmxlZC5cbiAqICAgICAtIHBlcmZvcm0gZmVhdHVyZSBkZXRlY3Rpb24sIGxvY2F0ZSBjb3JyZWN0IFdlYkFzc2VtYmx5IGFydGlmYWN0IHBhdGggYW5kIGNhbGwgdGhlIEVtc2NyaXB0ZW4gZ2VuZXJhdGVkXG4gKiBKYXZhU2NyaXB0IGNvZGUgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViQXNzZW1ibHkgcnVudGltZS5cbiAqICAgICAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtd2FzbScuXG4gKiAgICAgICAgIC0gZG93bmxvYWRpbmcgdGhlICdvcnQtd2FzbXsuLi59Lndhc20nIGZpbGUgaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICAgICAgIC0gaWYgbXVsdGktdGhyZWFkIGlzIGVuYWJsZWQsIG9uZSBvciBtb3JlIHdlYndvcmtlciB3aWxsIGJlIGNyZWF0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUFRocmVhZCB0aHJlYWRwb29sLlxuICpcbiAqIDMuIE9SVCBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyBhZnRlciBzdGVwIDIuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIHBlcmZvcm1zIE9OTlggUnVudGltZSBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqIEZ1bmN0aW9uIGBfT3J0SW5pdCgpYCBpcyBjYWxsZWQgaW4gdGhpcyBzdGVwLlxuICogICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LW9ydCcuXG4gKiAgICAgLSBsb2dnaW5nIGxldmVsIChvcnQuZW52LmxvZ0xldmVsKSBhbmQgdGhyZWFkIG51bWJlciAob3J0LmVudi53YXNtLm51bVRocmVhZHMpIGFyZSBzZXQgaW4gdGhpcyBzdGVwLlxuICpcbiAqIDQuIFNlc3Npb24gaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIG9yIGBvcnQuVHJhaW5pbmdTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQuIFVubGlrZSB0aGUgZmlyc3QgM1xuICogc3RlcHMgKHRoZXkgb25seSBjYWxsZWQgb25jZSksIHRoaXMgc3RlcCB3aWxsIGJlIGRvbmUgZm9yIGVhY2ggc2Vzc2lvbi4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGVcbiAqIGZvbGxvd2luZ3M6XG4gKiAgICBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgVVJMOlxuICogICAgLSBkb3dubG9hZCB0aGUgbW9kZWwgZGF0YSBmcm9tIHRoZSBVUkwuXG4gKiAgICAtIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC4gKHByb3h5OiAnY29weS1mcm9tJylcbiAqICAgIC0gZGVyZWZlcmVuY2UgdGhlIG1vZGVsIGJ1ZmZlci4gVGhpcyBzdGVwIGFsbG93cyB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcbiAqXG4gKiAgICBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgVWludDhBcnJheSBvYmplY3Q6XG4gKiAgICAtIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC4gKHByb3h5OiAnY29weS1mcm9tJylcbiAqICAgIC0gY2FsbCBgX09ydENyZWF0ZVNlc3Npb24oKWAgdG8gY3JlYXRlIHRoZSBzZXNzaW9uLiAocHJveHk6ICdjcmVhdGUnKVxuICpcbiAqXG4gKi9cblxuLyoqXG4gKiBpbml0aWFsaXplIE9SVCBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcGFyYW0gbnVtVGhyZWFkcyBTZXRHbG9iYWxJbnRyYU9wTnVtVGhyZWFkcyhudW1UaHJlYWRzKVxuICogQHBhcmFtIGxvZ2dpbmdMZXZlbCBDcmVhdGVFbnYoc3RhdGljX2Nhc3Q8T3J0TG9nZ2luZ0xldmVsPihsb2dnaW5nX2xldmVsKSlcbiAqL1xuY29uc3QgaW5pdE9ydCA9IChudW1UaHJlYWRzOiBudW1iZXIsIGxvZ2dpbmdMZXZlbDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IGVycm9yQ29kZSA9IGdldEluc3RhbmNlKCkuX09ydEluaXQobnVtVGhyZWFkcywgbG9nZ2luZ0xldmVsKTtcbiAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogaW5pdGlhbGl6ZSBydW50aW1lIGVudmlyb25tZW50LlxuICogQHBhcmFtIGVudiBwYXNzZWQgaW4gdGhlIGVudmlyb25tZW50IGNvbmZpZyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0UnVudGltZSA9IGFzeW5jKGVudjogRW52KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIC8vIGluaXQgT1JUXG4gIGluaXRPcnQoZW52Lndhc20ubnVtVGhyZWFkcyEsIGxvZ0xldmVsU3RyaW5nVG9FbnVtKGVudi5sb2dMZXZlbCkpO1xufTtcblxuLyoqXG4gKiBwZXJmb3JtIEVQIHNwZWNpZmljIGluaXRpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSBlbnZcbiAqIEBwYXJhbSBlcE5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRFcCA9IGFzeW5jKGVudjogRW52LCBlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICBjb25zdCBpbml0SnNlcCA9IHJlcXVpcmUoJy4vanNlcC9pbml0JykuaW5pdDtcblxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJncHUnKSB7XG4gICAgICAvLyBwZXJmb3JtIFdlYkdQVSBhdmFpbGFiaWxpdHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmdwdSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlciB8IG51bGw7XG4gICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgLy8gaWYgYWRhcHRlciBpcyBub3Qgc2V0LCByZXF1ZXN0IGEgbmV3IGFkYXB0ZXIuXG4gICAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9IGVudi53ZWJncHUucG93ZXJQcmVmZXJlbmNlO1xuICAgICAgICBpZiAocG93ZXJQcmVmZXJlbmNlICE9PSB1bmRlZmluZWQgJiYgcG93ZXJQcmVmZXJlbmNlICE9PSAnbG93LXBvd2VyJyAmJlxuICAgICAgICAgICAgcG93ZXJQcmVmZXJlbmNlICE9PSAnaGlnaC1wZXJmb3JtYW5jZScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcG93ZXJQcmVmZXJlbmNlIHNldHRpbmc6IFwiJHtwb3dlclByZWZlcmVuY2V9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JjZUZhbGxiYWNrQWRhcHRlciA9IGVudi53ZWJncHUuZm9yY2VGYWxsYmFja0FkYXB0ZXI7XG4gICAgICAgIGlmIChmb3JjZUZhbGxiYWNrQWRhcHRlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBmb3JjZUZhbGxiYWNrQWRhcHRlciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtmb3JjZUZhbGxiYWNrQWRhcHRlcn1cImApO1xuICAgICAgICB9XG4gICAgICAgIGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKHtwb3dlclByZWZlcmVuY2UsIGZvcmNlRmFsbGJhY2tBZGFwdGVyfSk7XG4gICAgICAgIGlmICghYWRhcHRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgR1BVIGFkYXB0ZXIuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBhZGFwdGVyIGlzIHNldCwgdmFsaWRhdGUgaXQuXG4gICAgICAgIGlmICh0eXBlb2YgYWRhcHRlci5saW1pdHMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBhZGFwdGVyLmZlYXR1cmVzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGFkYXB0ZXIucmVxdWVzdERldmljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBpbml0SnNlcCgnd2ViZ3B1JywgZ2V0SW5zdGFuY2UoKSwgZW52LCBhZGFwdGVyKTtcbiAgICB9XG4gICAgaWYgKGVwTmFtZSA9PT0gJ3dlYm5uJykge1xuICAgICAgLy8gcGVyZm9ybSBXZWJOTiBhdmFpbGFiaWxpdHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhKG5hdmlnYXRvciBhcyB1bmtub3duIGFzIHttbDogdW5rbm93bn0pLm1sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGluaXRKc2VwKCd3ZWJubicsIGdldEluc3RhbmNlKCksIGVudik7XG4gICAgfVxuICB9XG59O1xuXG4vLyAjZW5kcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIHZhbGlkIGRhdGEgbG9jYXRpb25zIGZvciBpbnB1dC9vdXRwdXQgdGVuc29ycy5cbiAqL1xudHlwZSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dCA9ICdjcHUnfCdjcHUtcGlubmVkJ3wnZ3B1LWJ1ZmZlcic7XG5cbnR5cGUgSU9CaW5kaW5nU3RhdGUgPSB7XG4gIC8qKlxuICAgKiB0aGUgaGFuZGxlIG9mIElPIGJpbmRpbmcuXG4gICAqL1xuICByZWFkb25seSBoYW5kbGU6IG51bWJlcjtcblxuICAvKipcbiAgICogdGhlIHByZWZlcnJlZCBsb2NhdGlvbiBmb3IgZWFjaCBvdXRwdXQgdGVuc29yLlxuICAgKlxuICAgKiB2YWx1ZSBpcyBvbmUgb2YgJ2NwdScsICdjcHUtcGlubmVkJywgJ2dwdS1idWZmZXInLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiByZWFkb25seSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdO1xuXG4gIC8qKlxuICAgKiBlbnVtIHZhbHVlIG9mIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gZm9yIGVhY2ggb3V0cHV0IHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IHJlYWRvbmx5IG51bWJlcltdO1xufTtcblxuLyoqXG4gKiAgdHVwbGUgZWxlbWVudHMgYXJlOiBJbmZlcmVuY2VTZXNzaW9uIElEOyBpbnB1dE5hbWVzVVRGOEVuY29kZWQ7IG91dHB1dE5hbWVzVVRGOEVuY29kZWQ7IGJpbmRpbmdTdGF0ZVxuICovXG50eXBlIFNlc3Npb25NZXRhZGF0YSA9IFtcbiAgaW5mZXJlbmNlU2Vzc2lvbklkOiBudW1iZXIsIGlucHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sIG91dHB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdLFxuICBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlfG51bGwsIGVuYWJsZUdyYXBoQ2FwdHVyZTogYm9vbGVhbiwgaW5wdXRPdXRwdXRCb3VuZDogYm9vbGVhblxuXTtcblxuY29uc3QgYWN0aXZlU2Vzc2lvbnMgPSBuZXcgTWFwPG51bWJlciwgU2Vzc2lvbk1ldGFkYXRhPigpO1xuXG4vKipcbiAqIGdldCB0aGUgaW5wdXQvb3V0cHV0IGNvdW50IG9mIHRoZSBzZXNzaW9uLlxuICogQHBhcmFtIHNlc3Npb25IYW5kbGUgdGhlIGhhbmRsZSByZXByZXNlbnRpbmcgdGhlIHNlc3Npb24uIHNob3VsZCBiZSBub24temVyby5cbiAqIEByZXR1cm5zIGEgdHVwbGUgaW5jbHVkaW5nIDIgbnVtYmVycywgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBjb3VudCBhbmQgb3V0cHV0IGNvdW50LlxuICovXG5jb25zdCBnZXRTZXNzaW9uSW5wdXRPdXRwdXRDb3VudCA9IChzZXNzaW9uSGFuZGxlOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDgpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIDQpO1xuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFt3YXNtLkhFQVAzMltkYXRhT2Zmc2V0IC8gNF0sIHdhc20uSEVBUDMyW2RhdGFPZmZzZXQgLyA0ICsgMV1dO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBhbGxvY2F0ZSB0aGUgbWVtb3J5IGFuZCBtZW1jcHkgdGhlIGV4dGVybmFsIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWwgLSB0aGUgZXh0ZXJuYWwgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIG1vZGVsIGRhdGEuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLlxuICogQHJldHVybnMgYSAyLWVsZW1lbnRzIHR1cGxlIC0gdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIGFsbG9jYXRlZCBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSAobW9kZWw6IFVpbnQ4QXJyYXkpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcbiAgaWYgKG1vZGVsRGF0YU9mZnNldCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHttb2RlbC5ieXRlTGVuZ3RofS5gKTtcbiAgfVxuICB3YXNtLkhFQVBVOC5zZXQobW9kZWwsIG1vZGVsRGF0YU9mZnNldCk7XG4gIHJldHVybiBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbC5ieXRlTGVuZ3RoXTtcbn07XG5cbi8qKlxuICogY3JlYXRlIGFuIGluZmVyZW5jZSBzZXNzaW9uIGZyb20gYSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWxEYXRhIC0gZWl0aGVyIGEgVWludDhBcnJheSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCBkYXRhLCBvciBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGVcbiAqICAgICBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIGFuIG9wdGlvbmFsIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIDMtZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyBbc2Vzc2lvbiBoYW5kbGUsIGlucHV0IG5hbWVzLCBvdXRwdXQgbmFtZXNdXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMoXG4gICAgbW9kZWxEYXRhOiBVaW50OEFycmF5fFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+ID0+IHtcbiAgbGV0IG1vZGVsRGF0YU9mZnNldDogbnVtYmVyLCBtb2RlbERhdGFMZW5ndGg6IG51bWJlcjtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxEYXRhKSkge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgaXMgYW4gYXJyYXksIGl0IG11c3QgYmUgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIG1vZGVsIGRhdGFcbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gbW9kZWxEYXRhO1xuICB9IGVsc2UgaWYgKG1vZGVsRGF0YS5idWZmZXIgPT09IHdhc20uSEVBUFU4LmJ1ZmZlcikge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgdXNlcyB0aGUgc2FtZSBidWZmZXIgYXMgdGhlIFdBU00gaGVhcCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0LlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBbbW9kZWxEYXRhLmJ5dGVPZmZzZXQsIG1vZGVsRGF0YS5ieXRlTGVuZ3RoXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC5cbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihtb2RlbERhdGEpO1xuICB9XG5cbiAgbGV0IHNlc3Npb25IYW5kbGUgPSAwO1xuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICBsZXQgaW9CaW5kaW5nSGFuZGxlID0gMDtcbiAgbGV0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcblxuICB0cnkge1xuICAgIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXSA9IHNldFNlc3Npb25PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnM/LmV4dGVybmFsRGF0YSAmJiB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhKSB7XG4gICAgICBjb25zdCBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBvcHRpb25zLmV4dGVybmFsRGF0YSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUucGF0aDtcbiAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2gobG9hZEZpbGUodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUuZGF0YSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhIShwYXRoLCBkYXRhKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyB3YWl0IGZvciBhbGwgZXh0ZXJuYWwgZGF0YSBmaWxlcyB0byBiZSBsb2FkZWRcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGxvYWRpbmdQcm9taXNlcyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcm92aWRlciBvZiBvcHRpb25zPy5leGVjdXRpb25Qcm92aWRlcnMgPz8gW10pIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyTmFtZSA9IHR5cGVvZiBwcm92aWRlciA9PT0gJ3N0cmluZycgPyBwcm92aWRlciA6IHByb3ZpZGVyLm5hbWU7XG4gICAgICBpZiAocHJvdmlkZXJOYW1lID09PSAnd2Vibm4nKSB7XG4gICAgICAgIGlmICh3YXNtLmN1cnJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgaXMgYWxyZWFkeSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCB3ZWJubk9wdGlvbnMgPSBwcm92aWRlciBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0KT8uY29udGV4dDtcbiAgICAgICAgICBjb25zdCBncHVEZXZpY2UgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5PcHRpb25zV2ViR3B1KT8uZ3B1RGV2aWNlO1xuICAgICAgICAgIGNvbnN0IGRldmljZVR5cGUgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LmRldmljZVR5cGU7XG4gICAgICAgICAgY29uc3QgbnVtVGhyZWFkcyA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8ubnVtVGhyZWFkcztcbiAgICAgICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LnBvd2VyUHJlZmVyZW5jZTtcbiAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGNvbnRleHQgYXMgTUxDb250ZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZ3B1RGV2aWNlKSB7XG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gYXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoZ3B1RGV2aWNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KHtkZXZpY2VUeXBlLCBudW1UaHJlYWRzLCBwb3dlclByZWZlcmVuY2V9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FzbS5jdXJyZW50Q29udGV4dCA9IGF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2Vzc2lvbkhhbmRsZSA9IGF3YWl0IHdhc20uX09ydENyZWF0ZVNlc3Npb24obW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGgsIHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgY3JlYXRlIGEgc2Vzc2lvbi4nKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBjdXJyZW50IE1MQ29udGV4dCBhZnRlciBzZXNzaW9uIGNyZWF0aW9uXG4gICAgaWYgKHdhc20uY3VycmVudENvbnRleHQpIHtcbiAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgW2lucHV0Q291bnQsIG91dHB1dENvdW50XSA9IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50KHNlc3Npb25IYW5kbGUpO1xuXG4gICAgY29uc3QgZW5hYmxlR3JhcGhDYXB0dXJlID0gISFvcHRpb25zPy5lbmFibGVHcmFwaENhcHR1cmU7XG5cbiAgICBjb25zdCBpbnB1dE5hbWVzID0gW107XG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uX09ydEdldElucHV0TmFtZShzZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGdldCBhbiBpbnB1dCBuYW1lLicpO1xuICAgICAgfVxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZSk7XG4gICAgICBpbnB1dE5hbWVzLnB1c2god2FzbS5VVEY4VG9TdHJpbmcobmFtZSkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLl9PcnRHZXRPdXRwdXROYW1lKHNlc3Npb25IYW5kbGUsIGkpO1xuICAgICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLicpO1xuICAgICAgfVxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWUpO1xuICAgICAgY29uc3QgbmFtZVN0cmluZyA9IHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpO1xuICAgICAgb3V0cHV0TmFtZXMucHVzaChuYW1lU3RyaW5nKTtcblxuICAgICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaCgnZ3B1LWJ1ZmZlcicpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdHlwZW9mIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICBvcHRpb25zLnByZWZlcnJlZE91dHB1dExvY2F0aW9uIDpcbiAgICAgICAgICAgIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bbmFtZVN0cmluZ10gPz8gJ2NwdSc7XG4gICAgICAgIGlmIChsb2NhdGlvbiAhPT0gJ2NwdScgJiYgbG9jYXRpb24gIT09ICdjcHUtcGlubmVkJyAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7bG9jYXRpb259LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke1xuICAgICAgICAgICAgICBsb2NhdGlvbn0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1c2UgSU8gYmluZGluZyBvbmx5IHdoZW4gYXQgbGVhc3Qgb25lIG91dHB1dCBpcyBwcmVmZmVyZWQgdG8gYmUgb24gR1BVLlxuICAgIGxldCBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlfG51bGwgPSBudWxsO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnNvbWUobCA9PiBsID09PSAnZ3B1LWJ1ZmZlcicpKSB7XG4gICAgICBpb0JpbmRpbmdIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVCaW5kaW5nKHNlc3Npb25IYW5kbGUpO1xuICAgICAgaWYgKGlvQmluZGluZ0hhbmRsZSA9PT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBjcmVhdGUgSU8gYmluZGluZy4nKTtcbiAgICAgIH1cblxuICAgICAgYmluZGluZ1N0YXRlID0ge1xuICAgICAgICBoYW5kbGU6IGlvQmluZGluZ0hhbmRsZSxcbiAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOiBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMubWFwKGwgPT4gZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGwpKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYWN0aXZlU2Vzc2lvbnMuc2V0KFxuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkLCBiaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZSwgZmFsc2VdKTtcbiAgICByZXR1cm4gW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXMsIG91dHB1dE5hbWVzXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKGJ1ZiA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaChidWYgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcblxuICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ0hhbmRsZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25IYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uX2ZyZWUobW9kZWxEYXRhT2Zmc2V0KTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKGFsbG9jID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcblxuICAgIC8vIHVubW91bnQgZXh0ZXJuYWwgZGF0YSBpZiBuZWNlc3NhcnlcbiAgICB3YXNtLnVubW91bnRFeHRlcm5hbERhdGE/LigpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVsZWFzZVNlc3Npb24gPSAoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHNlc3Npb24gPSBhY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7c2Vzc2lvbklkfWApO1xuICB9XG4gIGNvbnN0IFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWQsIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsIGlvQmluZGluZ1N0YXRlLCBlbmFibGVHcmFwaENhcHR1cmVdID0gc2Vzc2lvbjtcblxuICBpZiAoaW9CaW5kaW5nU3RhdGUpIHtcbiAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlKSB7XG4gICAgICB3YXNtLl9PcnRDbGVhckJvdW5kT3V0cHV0cyhpb0JpbmRpbmdTdGF0ZS5oYW5kbGUpO1xuICAgIH1cbiAgICB3YXNtLl9PcnRSZWxlYXNlQmluZGluZyhpb0JpbmRpbmdTdGF0ZS5oYW5kbGUpO1xuICB9XG5cbiAgd2FzbS5qc2VwT25SZWxlYXNlU2Vzc2lvbj8uKHNlc3Npb25JZCk7XG5cbiAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goYnVmID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XG4gIG91dHB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaChidWYgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSk7XG4gIGFjdGl2ZVNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvciA9XG4gICAgKHRlbnNvcjogVGVuc29yTWV0YWRhdGF8bnVsbCwgdGVuc29ySGFuZGxlczogbnVtYmVyW10sIGFsbG9jczogbnVtYmVyW10sIHNlc3Npb25JZDogbnVtYmVyLCBpbmRleDogbnVtYmVyLFxuICAgICBlbmFibGVHcmFwaENhcHR1cmUgPSBmYWxzZSk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCF0ZW5zb3IpIHtcbiAgICAgICAgdGVuc29ySGFuZGxlcy5wdXNoKDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcbiAgICAgIGNvbnN0IGRpbXMgPSB0ZW5zb3JbMV07XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRlbnNvclszXTtcblxuICAgICAgbGV0IHJhd0RhdGE6IG51bWJlcjtcbiAgICAgIGxldCBkYXRhQnl0ZUxlbmd0aDogbnVtYmVyO1xuXG4gICAgICBpZiAoZGF0YVR5cGUgPT09ICdzdHJpbmcnICYmIGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIGxvY2F0aW9uICE9PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEV4dGVybmFsIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGZvciBpbnB1dC9vdXRwdXQgaW5kZXggJHtpbmRleH0gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgY29uc3QgZ3B1QnVmZmVyID0gdGVuc29yWzJdLmdwdUJ1ZmZlciBhcyBHUFVCdWZmZXI7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRTaXplSW5CeXRlcyA9IGdldFRlbnNvckVsZW1lbnRTaXplKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSkhO1xuICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IGRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSkgKiBlbGVtZW50U2l6ZUluQnl0ZXM7XG5cbiAgICAgICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLmpzZXBSZWdpc3RlckJ1ZmZlcjtcbiAgICAgICAgaWYgKCFyZWdpc3RlckJ1ZmZlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmF3RGF0YSA9IHJlZ2lzdGVyQnVmZmVyKHNlc3Npb25JZCwgaW5kZXgsIGdwdUJ1ZmZlciwgZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IDQgKiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgICAgICBhbGxvY3MucHVzaChyYXdEYXRhKTtcbiAgICAgICAgICBsZXQgZGF0YUluZGV4ID0gcmF3RGF0YSAvIDQ7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7aX0gaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXNtLkhFQVBVMzJbZGF0YUluZGV4KytdID0gYWxsb2NXYXNtU3RyaW5nKGRhdGFbaV0sIGFsbG9jcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgICAgIHdhc20uSEVBUFU4LnNldChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhQnl0ZUxlbmd0aCksIHJhd0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgICAgIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoNCAqIGRpbXMubGVuZ3RoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBkaW1JbmRleCA9IGRpbXNPZmZzZXQgLyA0O1xuICAgICAgICBkaW1zLmZvckVhY2goZCA9PiB3YXNtLkhFQVAzMltkaW1JbmRleCsrXSA9IGQpO1xuICAgICAgICBjb25zdCB0ZW5zb3IgPSB3YXNtLl9PcnRDcmVhdGVUZW5zb3IoXG4gICAgICAgICAgICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksIHJhd0RhdGEsIGRhdGFCeXRlTGVuZ3RoLCBkaW1zT2Zmc2V0LCBkaW1zLmxlbmd0aCxcbiAgICAgICAgICAgIGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bShsb2NhdGlvbikpO1xuICAgICAgICBpZiAodGVuc29yID09PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke3Nlc3Npb25JZH0sIGluZGV4PSR7aW5kZXh9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRlbnNvckhhbmRsZXMucHVzaCh0ZW5zb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICAgICAgfVxuICAgIH07XG5cbi8qKlxuICogcGVyZm9ybSBpbmZlcmVuY2UgcnVuXG4gKi9cbmV4cG9ydCBjb25zdCBydW4gPSBhc3luYyhcbiAgICBzZXNzaW9uSWQ6IG51bWJlciwgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSwgaW5wdXRUZW5zb3JzOiBUZW5zb3JNZXRhZGF0YVtdLCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgICBvdXRwdXRUZW5zb3JzOiBBcnJheTxUZW5zb3JNZXRhZGF0YXxudWxsPiwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XG4gIGNvbnN0IGlucHV0TmFtZXNVVEY4RW5jb2RlZCA9IHNlc3Npb25bMV07XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzJdO1xuICBjb25zdCBpb0JpbmRpbmdTdGF0ZSA9IHNlc3Npb25bM107XG4gIGNvbnN0IGVuYWJsZUdyYXBoQ2FwdHVyZSA9IHNlc3Npb25bNF07XG4gIGNvbnN0IGlucHV0T3V0cHV0Qm91bmQgPSBzZXNzaW9uWzVdO1xuXG4gIGNvbnN0IGlucHV0Q291bnQgPSBpbnB1dEluZGljZXMubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRDb3VudCA9IG91dHB1dEluZGljZXMubGVuZ3RoO1xuXG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgbGV0IHJ1bk9wdGlvbnNBbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgaW5wdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBvdXRwdXRUZW5zb3JIYW5kbGVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE91dHB1dEFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBiZWZvcmVSdW5TdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIGNvbnN0IGlucHV0VmFsdWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiA0KTtcbiAgY29uc3QgaW5wdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogNCk7XG4gIGNvbnN0IG91dHB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuICBjb25zdCBvdXRwdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuXG4gIHRyeSB7XG4gICAgW3J1bk9wdGlvbnNIYW5kbGUsIHJ1bk9wdGlvbnNBbGxvY3NdID0gc2V0UnVuT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIC8vIGNyZWF0ZSBpbnB1dCB0ZW5zb3JzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIHByZXBhcmVJbnB1dE91dHB1dFRlbnNvcihcbiAgICAgICAgICBpbnB1dFRlbnNvcnNbaV0sIGlucHV0VGVuc29ySGFuZGxlcywgaW5wdXRPdXRwdXRBbGxvY3MsIHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzW2ldLCBlbmFibGVHcmFwaENhcHR1cmUpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBvdXRwdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICAgIG91dHB1dFRlbnNvcnNbaV0sIG91dHB1dFRlbnNvckhhbmRsZXMsIGlucHV0T3V0cHV0QWxsb2NzLCBzZXNzaW9uSWQsIGlucHV0Q291bnQgKyBvdXRwdXRJbmRpY2VzW2ldLFxuICAgICAgICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSk7XG4gICAgfVxuXG4gICAgbGV0IGlucHV0VmFsdWVzSW5kZXggPSBpbnB1dFZhbHVlc09mZnNldCAvIDQ7XG4gICAgbGV0IGlucHV0TmFtZXNJbmRleCA9IGlucHV0TmFtZXNPZmZzZXQgLyA0O1xuICAgIGxldCBvdXRwdXRWYWx1ZXNJbmRleCA9IG91dHB1dFZhbHVlc09mZnNldCAvIDQ7XG4gICAgbGV0IG91dHB1dE5hbWVzSW5kZXggPSBvdXRwdXROYW1lc09mZnNldCAvIDQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIHdhc20uSEVBUFUzMltpbnB1dFZhbHVlc0luZGV4KytdID0gaW5wdXRUZW5zb3JIYW5kbGVzW2ldO1xuICAgICAgd2FzbS5IRUFQVTMyW2lucHV0TmFtZXNJbmRleCsrXSA9IGlucHV0TmFtZXNVVEY4RW5jb2RlZFtpbnB1dEluZGljZXNbaV1dO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIHdhc20uSEVBUFUzMltvdXRwdXRWYWx1ZXNJbmRleCsrXSA9IG91dHB1dFRlbnNvckhhbmRsZXNbaV07XG4gICAgICB3YXNtLkhFQVBVMzJbb3V0cHV0TmFtZXNJbmRleCsrXSA9IG91dHB1dE5hbWVzVVRGOEVuY29kZWRbb3V0cHV0SW5kaWNlc1tpXV07XG4gICAgfVxuXG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCAmJiBpb0JpbmRpbmdTdGF0ZSAmJiAhaW5wdXRPdXRwdXRCb3VuZCkge1xuICAgICAgY29uc3Qge2hhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkfSA9IGlvQmluZGluZ1N0YXRlO1xuXG4gICAgICBpZiAoaW5wdXROYW1lc1VURjhFbmNvZGVkLmxlbmd0aCAhPT0gaW5wdXRDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7XG4gICAgICAgICAgICBpbnB1dENvdW50fSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7aW5wdXROYW1lc1VURjhFbmNvZGVkLmxlbmd0aH0pLmApO1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIGlucHV0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpbnB1dEluZGljZXNbaV07XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydEJpbmRJbnB1dChoYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sIGlucHV0VGVuc29ySGFuZGxlc1tpXSk7XG4gICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBpbnB1dFske2l9XSBmb3Igc2Vzc2lvbj0ke3Nlc3Npb25JZH0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcHJvY2VzcyBwcmUtYWxsb2NhdGVkIG91dHB1dHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IG91dHB1dEluZGljZXNbaV07XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gb3V0cHV0VGVuc29yc1tpXT8uWzNdOyAgLy8gdW5kZWZpbmVkIG1lYW5zIG91dHB1dCBpcyBub3QgcHJlLWFsbG9jYXRlZC5cblxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgcHJlLWFsbG9jYXRlZC4gYmluZCB0aGUgdGVuc29yLlxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgMCk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuIHJlc2V0IHByZWZlcnJlZCBsb2NhdGlvbi5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPVxuICAgICAgICAgICAgICB3YXNtLl9PcnRCaW5kT3V0cHV0KGhhbmRsZSwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sIDAsIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWRbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBvdXRwdXRbJHtpfV0gdG8gJHtvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbaV19IGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChcbiAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZSwgdHJ1ZV0pO1xuICAgIH1cblxuICAgIHdhc20uanNlcE9uUnVuU3RhcnQ/LihzZXNzaW9uSGFuZGxlKTtcbiAgICBsZXQgZXJyb3JDb2RlOiBudW1iZXI7XG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCAmJiBpb0JpbmRpbmdTdGF0ZSkge1xuICAgICAgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0UnVuV2l0aEJpbmRpbmcoXG4gICAgICAgICAgc2Vzc2lvbkhhbmRsZSwgaW9CaW5kaW5nU3RhdGUuaGFuZGxlLCBvdXRwdXRDb3VudCwgb3V0cHV0VmFsdWVzT2Zmc2V0LCBydW5PcHRpb25zSGFuZGxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0UnVuKFxuICAgICAgICAgIHNlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNPZmZzZXQsIGlucHV0VmFsdWVzT2Zmc2V0LCBpbnB1dENvdW50LCBvdXRwdXROYW1lc09mZnNldCwgb3V0cHV0Q291bnQsXG4gICAgICAgICAgb3V0cHV0VmFsdWVzT2Zmc2V0LCBydW5PcHRpb25zSGFuZGxlKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcignZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0OiBUZW5zb3JNZXRhZGF0YVtdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRlbnNvciA9IHdhc20uSEVBUFUzMltvdXRwdXRWYWx1ZXNPZmZzZXQgLyA0ICsgaV07XG4gICAgICBpZiAodGVuc29yID09PSBvdXRwdXRUZW5zb3JIYW5kbGVzW2ldKSB7XG4gICAgICAgIC8vIG91dHB1dCB0ZW5zb3IgaXMgcHJlLWFsbG9jYXRlZC4gbm8gbmVlZCB0byBjb3B5IGRhdGEuXG4gICAgICAgIG91dHB1dC5wdXNoKG91dHB1dFRlbnNvcnNbaV0hKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gICAgICAvLyBzdGFjayBhbGxvY2F0ZSA0IHBvaW50ZXIgdmFsdWVcbiAgICAgIGNvbnN0IHRlbnNvckRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoNCAqIDQpO1xuXG4gICAgICBsZXQga2VlcE91dHB1dFRlbnNvciA9IGZhbHNlO1xuICAgICAgbGV0IHR5cGU6IFRlbnNvci5UeXBlfHVuZGVmaW5lZCwgZGF0YU9mZnNldCA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRHZXRUZW5zb3JEYXRhKFxuICAgICAgICAgICAgdGVuc29yLCB0ZW5zb3JEYXRhT2Zmc2V0LCB0ZW5zb3JEYXRhT2Zmc2V0ICsgNCwgdGVuc29yRGF0YU9mZnNldCArIDgsIHRlbnNvckRhdGFPZmZzZXQgKyAxMik7XG4gICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke2l9LmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZW5zb3JEYXRhSW5kZXggPSB0ZW5zb3JEYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBkYXRhT2Zmc2V0ID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgY29uc3QgZGltc09mZnNldCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGNvbnN0IGRpbXNMZW5ndGggPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBjb25zdCBkaW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGltcy5wdXNoKHdhc20uSEVBUFUzMltkaW1zT2Zmc2V0IC8gNCArIGldKTtcbiAgICAgICAgfVxuICAgICAgICB3YXNtLl9PcnRGcmVlKGRpbXNPZmZzZXQpO1xuXG4gICAgICAgIGNvbnN0IHNpemUgPSBkaW1zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpO1xuICAgICAgICB0eXBlID0gdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZGF0YVR5cGUpO1xuXG4gICAgICAgIGNvbnN0IHByZWZlcnJlZExvY2F0aW9uID0gaW9CaW5kaW5nU3RhdGU/Lm91dHB1dFByZWZlcnJlZExvY2F0aW9uc1tvdXRwdXRJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdncHUtYnVmZmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJpbmdEYXRhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzVG9SZWFkID0gaSA9PT0gc2l6ZSAtIDEgPyB1bmRlZmluZWQgOiB3YXNtLkhFQVBVMzJbZGF0YUluZGV4XSAtIG9mZnNldDtcbiAgICAgICAgICAgIHN0cmluZ0RhdGEucHVzaCh3YXNtLlVURjhUb1N0cmluZyhvZmZzZXQsIG1heEJ5dGVzVG9SZWFkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBzdHJpbmdEYXRhLCAnY3B1J10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIGEgY2VydGFpbiBvdXRwdXQncyBwcmVmZXJyZWQgbG9jYXRpb24gaXMgR1BVIGJ1dCB0aGUgdGVuc29yIGlzIGVtcHR5LCB3ZSBzdGlsbCBuZWVkIHRvIGNyZWF0ZSBhIENQVVxuICAgICAgICAgIC8vIHRlbnNvciBmb3IgaXQuIFRoZXJlIGlzIG5vIG1hcHBpbmcgR1BVIGJ1ZmZlciBmb3IgYW4gZW1wdHkgdGVuc29yLlxuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInICYmIHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRCdWZmZXIgPSB3YXNtLmpzZXBHZXRCdWZmZXI7XG4gICAgICAgICAgICBpZiAoIWdldEJ1ZmZlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBncHVCdWZmZXIgPSBnZXRCdWZmZXIoZGF0YU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IGdldFRlbnNvckVsZW1lbnRTaXplKGRhdGFUeXBlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50U2l6ZSA9PT0gdW5kZWZpbmVkIHx8ICFpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG8gbm90IHJlbGVhc2UgdGhlIHRlbnNvciByaWdodCBub3cuIGl0IHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB1c2VyIGNhbGxzIHRlbnNvci5kaXNwb3NlKCkuXG4gICAgICAgICAgICBrZWVwT3V0cHV0VGVuc29yID0gdHJ1ZTtcblxuICAgICAgICAgICAgb3V0cHV0LnB1c2goW1xuICAgICAgICAgICAgICB0eXBlLCBkaW1zLCB7XG4gICAgICAgICAgICAgICAgZ3B1QnVmZmVyLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkOiB3YXNtLmpzZXBDcmVhdGVEb3dubG9hZGVyIShncHVCdWZmZXIsIHNpemUgKiBlbGVtZW50U2l6ZSwgdHlwZSksXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ2dwdS1idWZmZXInXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKHR5cGUpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyB0eXBlZEFycmF5Q29uc3RydWN0b3Ioc2l6ZSk7XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgLnNldCh3YXNtLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoKSk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgZGF0YSwgJ2NwdSddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBkYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgd2FzbS5fZnJlZShkYXRhT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBPdXRwdXRUZW5zb3IpIHtcbiAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW9CaW5kaW5nU3RhdGUgJiYgIWVuYWJsZUdyYXBoQ2FwdHVyZSkge1xuICAgICAgd2FzbS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaW9CaW5kaW5nU3RhdGUuaGFuZGxlKTtcbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChcbiAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZSwgZmFsc2VdKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShiZWZvcmVSdW5TdGFjayk7XG5cbiAgICBpbnB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCh2ID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIG91dHB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCh2ID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIGlucHV0T3V0cHV0QWxsb2NzLmZvckVhY2gocCA9PiB3YXNtLl9mcmVlKHApKTtcblxuICAgIGlmIChydW5PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhydW5PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgcnVuT3B0aW9uc0FsbG9jcy5mb3JFYWNoKHAgPT4gd2FzbS5fZnJlZShwKSk7XG4gIH1cbn07XG5cbi8qKlxuICogZW5kIHByb2ZpbGluZ1xuICovXG5leHBvcnQgY29uc3QgZW5kUHJvZmlsaW5nID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZXNzaW9uIGlkJyk7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XG5cbiAgLy8gcHJvZmlsZSBmaWxlIG5hbWUgaXMgbm90IHVzZWQgeWV0LCBidXQgaXQgbXVzdCBiZSBmcmVlZC5cbiAgY29uc3QgcHJvZmlsZUZpbGVOYW1lID0gd2FzbS5fT3J0RW5kUHJvZmlsaW5nKHNlc3Npb25IYW5kbGUpO1xuICBpZiAocHJvZmlsZUZpbGVOYW1lID09PSAwKSB7XG4gICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLicpO1xuICB9XG4gIHdhc20uX09ydEZyZWUocHJvZmlsZUZpbGVOYW1lKTtcbn07XG5cbmV4cG9ydCBjb25zdCBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyA9ICh0ZW5zb3JzOiByZWFkb25seSBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdKTogQXJyYXlCdWZmZXJMaWtlW10gPT4ge1xuICBjb25zdCBidWZmZXJzOiBBcnJheUJ1ZmZlckxpa2VbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlbnNvciBvZiB0ZW5zb3JzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgJiYgJ2J1ZmZlcicgaW4gZGF0YSkge1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEuYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2VudiwgSW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtPcnRXYXNtTWVzc2FnZSwgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSwgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsIFRlbnNvck1ldGFkYXRhfSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnLi93YXNtLWNvcmUtaW1wbCc7XG5pbXBvcnQge2luaXRpYWxpemVXZWJBc3NlbWJseX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHtpbXBvcnRQcm94eVdvcmtlcn0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XG5cbmNvbnN0IGlzUHJveHkgPSAoKTogYm9vbGVhbiA9PiAhIWVudi53YXNtLnByb3h5ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgcHJveHlXb3JrZXI6IFdvcmtlcnx1bmRlZmluZWQ7XG5sZXQgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBhYm9ydGVkID0gZmFsc2U7XG5sZXQgdGVtcG9yYXJ5T2JqZWN0VXJsOiBzdHJpbmd8dW5kZWZpbmVkO1xuXG50eXBlIFByb21pc2VDYWxsYmFja3M8VCA9IHZvaWQ+ID0gW3Jlc29sdmU6IChyZXN1bHQ6IFQpID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbjogdW5rbm93bikgPT4gdm9pZF07XG5sZXQgaW5pdFdhc21DYWxsYmFja3M6IFByb21pc2VDYWxsYmFja3M7XG5jb25zdCBxdWV1ZWRDYWxsYmFja3M6IE1hcDxPcnRXYXNtTWVzc2FnZVsndHlwZSddLCBBcnJheTxQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+Pj4gPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGVucXVldWVDYWxsYmFja3MgPSAodHlwZTogT3J0V2FzbU1lc3NhZ2VbJ3R5cGUnXSwgY2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzPHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHF1ZXVlID0gcXVldWVkQ2FsbGJhY2tzLmdldCh0eXBlKTtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgcXVldWUucHVzaChjYWxsYmFja3MpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlZENhbGxiYWNrcy5zZXQodHlwZSwgW2NhbGxiYWNrc10pO1xuICB9XG59O1xuXG5jb25zdCBlbnN1cmVXb3JrZXIgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXppbmcgfHwgIWluaXRpYWxpemVkIHx8IGFib3J0ZWQgfHwgIXByb3h5V29ya2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3b3JrZXIgbm90IHJlYWR5Jyk7XG4gIH1cbn07XG5cbmNvbnN0IG9uUHJveHlXb3JrZXJNZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XG4gIHN3aXRjaCAoZXYuZGF0YS50eXBlKSB7XG4gICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1sxXShldi5kYXRhLmVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzWzBdKCk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcG9yYXJ5T2JqZWN0VXJsKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGVtcG9yYXJ5T2JqZWN0VXJsKTtcbiAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5pdC1lcCc6XG4gICAgY2FzZSAnY29weS1mcm9tJzpcbiAgICBjYXNlICdjcmVhdGUnOlxuICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgIGNhc2UgJ3J1bic6XG4gICAgY2FzZSAnZW5kLXByb2ZpbGluZyc6IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlZENhbGxiYWNrcy5nZXQoZXYuZGF0YS50eXBlKSE7XG4gICAgICBpZiAoZXYuZGF0YS5lcnIpIHtcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzFdKGV2LmRhdGEuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpIVswXShldi5kYXRhLm91dCEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gIH1cbn07XG5cblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgPSBhc3luYygpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbml0aWFsaXppbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpcGxlIGNhbGxzIHRvIFxcJ2luaXRXYXNtKClcXCcgZGV0ZWN0ZWQuJyk7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdFdhc20oKVxcJyBmYWlsZWQuJyk7XG4gIH1cblxuICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHByb3h5V29ya2VyPy50ZXJtaW5hdGUoKTtcblxuICAgICAgdm9pZCBpbXBvcnRQcm94eVdvcmtlcigpLnRoZW4oKFtvYmplY3RVcmwsIHdvcmtlcl0pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm94eVdvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgICBwcm94eVdvcmtlci5vbmVycm9yID0gKGV2OiBFcnJvckV2ZW50KSA9PiByZWplY3QoZXYpO1xuICAgICAgICAgIHByb3h5V29ya2VyLm9ubWVzc2FnZSA9IG9uUHJveHlXb3JrZXJNZXNzYWdlO1xuICAgICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzID0gW3Jlc29sdmUsIHJlamVjdF07XG4gICAgICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7dHlwZTogJ2luaXQtd2FzbScsIGluIDogZW52fTtcbiAgICAgICAgICBwcm94eVdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICB0ZW1wb3JhcnlPYmplY3RVcmwgPSBvYmplY3RVcmw7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJlamVjdCk7XG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KGVudi53YXNtKTtcbiAgICAgIGF3YWl0IGNvcmUuaW5pdFJ1bnRpbWUoZW52KTtcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVPcnRFcCA9IGFzeW5jKGVwTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2luaXQtZXAnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHt0eXBlOiAnaW5pdC1lcCcsIGluIDoge2VwTmFtZSwgZW52fX07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgY29yZS5pbml0RXAoZW52LCBlcE5hbWUpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY29weUZyb21FeHRlcm5hbEJ1ZmZlciA9IGFzeW5jKGJ1ZmZlcjogVWludDhBcnJheSk6IFByb21pc2U8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXI+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXI+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2NvcHktZnJvbScsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0ge3R5cGU6ICdjb3B5LWZyb20nLCBpbiA6IHtidWZmZXJ9fTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCBbYnVmZmVyLmJ1ZmZlcl0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb3JlLmNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYnVmZmVyKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlc3Npb24gPVxuICAgIGFzeW5jKG1vZGVsOiBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcnxVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICAgIFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPiA9PiB7XG4gICAgICAgICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHVuc3VwcG9ydGVkIG9wdGlvbnNcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gb3B0aW9uIFwicHJlZmVycmVkT3V0cHV0TG9jYXRpb25cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuc3VyZVdvcmtlcigpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdjcmVhdGUnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0ge3R5cGU6ICdjcmVhdGUnLCBpbiA6IHttb2RlbCwgb3B0aW9uczogey4uLm9wdGlvbnN9fX07XG4gICAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZTogVHJhbnNmZXJhYmxlW10gPSBbXTtcbiAgICAgICAgICAgICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZS5wdXNoKG1vZGVsLmJ1ZmZlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG5leHBvcnQgY29uc3QgcmVsZWFzZVNlc3Npb24gPSBhc3luYyhzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdyZWxlYXNlJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7dHlwZTogJ3JlbGVhc2UnLCBpbiA6IHNlc3Npb25JZH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29yZS5yZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMoXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsIGlucHV0SW5kaWNlczogbnVtYmVyW10sIGlucHV0czogVGVuc29yTWV0YWRhdGFbXSwgb3V0cHV0SW5kaWNlczogbnVtYmVyW10sXG4gICAgb3V0cHV0czogQXJyYXk8VGVuc29yTWV0YWRhdGF8bnVsbD4sIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8VGVuc29yTWV0YWRhdGFbXT4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIC8vIGNoZWNrIGlucHV0cyBsb2NhdGlvblxuICAgIGlmIChpbnB1dHMuc29tZSh0ID0+IHRbM10gIT09ICdjcHUnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgIH1cbiAgICAvLyBjaGVjayBvdXRwdXRzIGxvY2F0aW9uXG4gICAgaWYgKG91dHB1dHMuc29tZSh0ID0+IHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3J1bicsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6YWJsZUlucHV0cyA9IGlucHV0cyBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdOyAgLy8gZXZlcnkgaW5wdXQgaXMgb24gQ1BVLlxuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPVxuICAgICAgICAgIHt0eXBlOiAncnVuJywgaW4gOiB7c2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0czogc2VyaWFsaXphYmxlSW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvcHRpb25zfX07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgY29yZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyhzZXJpYWxpemFibGVJbnB1dHMpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29yZS5ydW4oc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBlbmRQcm9maWxpbmcgPSBhc3luYyhzZXNzaW9uSWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdlbmQtcHJvZmlsaW5nJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7dHlwZTogJ2VuZC1wcm9maWxpbmcnLCBpbiA6IHNlc3Npb25JZH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29yZS5lbmRQcm9maWxpbmcoc2Vzc2lvbklkKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9uLCBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciwgU2Vzc2lvbkhhbmRsZXIsIFRlbnNvciwgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkR9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsIFRlbnNvck1ldGFkYXRhfSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCB7Y29weUZyb21FeHRlcm5hbEJ1ZmZlciwgY3JlYXRlU2Vzc2lvbiwgZW5kUHJvZmlsaW5nLCByZWxlYXNlU2Vzc2lvbiwgcnVufSBmcm9tICcuL3Byb3h5LXdyYXBwZXInO1xuaW1wb3J0IHtpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGV9IGZyb20gJy4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtpc05vZGV9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xuaW1wb3J0IHtsb2FkRmlsZX0gZnJvbSAnLi93YXNtLXV0aWxzLWxvYWQtZmlsZSc7XG5cbmV4cG9ydCBjb25zdCBlbmNvZGVUZW5zb3JNZXRhZGF0YSA9ICh0ZW5zb3I6IFRlbnNvciwgZ2V0TmFtZTogKCkgPT4gc3RyaW5nKTogVGVuc29yTWV0YWRhdGEgPT4ge1xuICBzd2l0Y2ggKHRlbnNvci5sb2NhdGlvbikge1xuICAgIGNhc2UgJ2NwdSc6XG4gICAgICByZXR1cm4gW3RlbnNvci50eXBlLCB0ZW5zb3IuZGltcywgdGVuc29yLmRhdGEsICdjcHUnXTtcbiAgICBjYXNlICdncHUtYnVmZmVyJzpcbiAgICAgIHJldHVybiBbdGVuc29yLnR5cGUsIHRlbnNvci5kaW1zLCB7Z3B1QnVmZmVyOiB0ZW5zb3IuZ3B1QnVmZmVyfSwgJ2dwdS1idWZmZXInXTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7dGVuc29yLmxvY2F0aW9ufSBmb3IgJHtnZXROYW1lKCl9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBkZWNvZGVUZW5zb3JNZXRhZGF0YSA9ICh0ZW5zb3I6IFRlbnNvck1ldGFkYXRhKTogVGVuc29yID0+IHtcbiAgc3dpdGNoICh0ZW5zb3JbM10pIHtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3IodGVuc29yWzBdLCB0ZW5zb3JbMl0sIHRlbnNvclsxXSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICAgICAgaWYgKCFpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUoZGF0YVR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZGF0YVR5cGV9IGZvciBkZXNlcmlhbGl6aW5nIEdQVSB0ZW5zb3JgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtncHVCdWZmZXIsIGRvd25sb2FkLCBkaXNwb3NlfSA9IHRlbnNvclsyXTtcbiAgICAgIHJldHVybiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIHtkYXRhVHlwZSwgZGltczogdGVuc29yWzFdLCBkb3dubG9hZCwgZGlzcG9zZX0pO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7dGVuc29yWzNdfWApO1xuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIge1xuICBwcml2YXRlIHNlc3Npb25JZDogbnVtYmVyO1xuXG4gIGlucHV0TmFtZXM6IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogc3RyaW5nW107XG5cbiAgYXN5bmMgZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkocGF0aDogc3RyaW5nKTogUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4ge1xuICAgIC8vIGZldGNoIG1vZGVsIGZyb20gdXJsIGFuZCBtb3ZlIHRvIHdhc20gaGVhcC5cbiAgICByZXR1cm4gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihhd2FpdCBsb2FkRmlsZShwYXRoKSk7XG4gIH1cblxuICBhc3luYyBsb2FkTW9kZWwocGF0aE9yQnVmZmVyOiBzdHJpbmd8VWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG4gICAgbGV0IG1vZGVsOiBQYXJhbWV0ZXJzPHR5cGVvZiBjcmVhdGVTZXNzaW9uPlswXTtcblxuICAgIGlmICh0eXBlb2YgcGF0aE9yQnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGlzTm9kZSkge1xuICAgICAgICAvLyBub2RlXG4gICAgICAgIG1vZGVsID0gYXdhaXQgbG9hZEZpbGUocGF0aE9yQnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJyb3dzZXJcbiAgICAgICAgLy8gZmV0Y2ggbW9kZWwgYW5kIGNvcHkgdG8gd2FzbSBoZWFwLlxuICAgICAgICBtb2RlbCA9IGF3YWl0IHRoaXMuZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkocGF0aE9yQnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwgPSBwYXRoT3JCdWZmZXI7XG4gICAgfVxuXG4gICAgW3RoaXMuc2Vzc2lvbklkLCB0aGlzLmlucHV0TmFtZXMsIHRoaXMub3V0cHV0TmFtZXNdID0gYXdhaXQgY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucyk7XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgfVxuXG4gIGFzeW5jIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHJlbGVhc2VTZXNzaW9uKHRoaXMuc2Vzc2lvbklkKTtcbiAgfVxuXG4gIGFzeW5jIHJ1bihmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLCBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTpcbiAgICAgIFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBpbnB1dEFycmF5OiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZWVkcykuZm9yRWFjaChrdnAgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbnB1dE5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtuYW1lfSdgKTtcbiAgICAgIH1cbiAgICAgIGlucHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgaW5wdXRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb3V0cHV0QXJyYXk6IEFycmF5PFRlbnNvcnxudWxsPiA9IFtdO1xuICAgIGNvbnN0IG91dHB1dEluZGljZXM6IG51bWJlcltdID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMoZmV0Y2hlcykuZm9yRWFjaChrdnAgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgb3V0cHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgb3V0cHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0cyA9XG4gICAgICAgIGlucHV0QXJyYXkubWFwKCh0LCBpKSA9PiBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgaW5wdXQgXCIke3RoaXMuaW5wdXROYW1lc1tpbnB1dEluZGljZXNbaV1dfVwiYCkpO1xuICAgIGNvbnN0IG91dHB1dHMgPSBvdXRwdXRBcnJheS5tYXAoXG4gICAgICAgICh0LCBpKSA9PiB0ID8gZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1tvdXRwdXRJbmRpY2VzW2ldXX1cImApIDogbnVsbCk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcnVuKHRoaXMuc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCByZXN1bHRNYXA6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdE1hcFt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dXSA9IG91dHB1dEFycmF5W2ldID8/IGRlY29kZVRlbnNvck1ldGFkYXRhKHJlc3VsdHNbaV0pO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZmlsaW5nXG4gIH1cblxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdm9pZCBlbmRQcm9maWxpbmcodGhpcy5zZXNzaW9uSWQpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QmFja2VuZCwgZW52LCBJbmZlcmVuY2VTZXNzaW9uLCBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtpbml0aWFsaXplT3J0RXAsIGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWV9IGZyb20gJy4vd2FzbS9wcm94eS13cmFwcGVyJztcbmltcG9ydCB7T25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyfSBmcm9tICcuL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZSc7XG5pbXBvcnQge3NjcmlwdFNyY30gZnJvbSAnLi93YXNtL3dhc20tdXRpbHMtaW1wb3J0JztcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIGFsbCBmbGFncyBmb3IgV2ViQXNzZW1ibHkuXG4gKlxuICogVGhvc2UgZmxhZ3MgYXJlIGFjY2Vzc2libGUgZnJvbSBgb3J0LmVudi53YXNtYC4gVXNlcnMgYXJlIGFsbG93IHRvIHNldCB0aG9zZSBmbGFncyBiZWZvcmUgdGhlIGZpcnN0IGluZmVyZW5jZSBzZXNzaW9uXG4gKiBiZWluZyBjcmVhdGVkLCB0byBvdmVycmlkZSBkZWZhdWx0IHZhbHVlLlxuICovXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZUZsYWdzID0gKCk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIGVudi53YXNtLmluaXRUaW1lb3V0ICE9PSAnbnVtYmVyJyB8fCBlbnYud2FzbS5pbml0VGltZW91dCA8IDApIHtcbiAgICBlbnYud2FzbS5pbml0VGltZW91dCA9IDA7XG4gIH1cblxuICBpZiAoZW52Lndhc20uc2ltZCA9PT0gZmFsc2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ0RlcHJlY2F0ZWQgcHJvcGVydHkgXCJlbnYud2FzbS5zaW1kXCIgaXMgc2V0IHRvIGZhbHNlLiAnICtcbiAgICAgICAgJ25vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLnByb3h5ICE9PSAnYm9vbGVhbicpIHtcbiAgICBlbnYud2FzbS5wcm94eSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS50cmFjZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZW52Lndhc20udHJhY2UgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20ubnVtVGhyZWFkcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIoZW52Lndhc20ubnVtVGhyZWFkcykgfHwgZW52Lndhc20ubnVtVGhyZWFkcyA8PSAwKSB7XG4gICAgLy8gVGhlIGZvbGxvd2luZyBsb2dpYyBvbmx5IGFwcGxpZXMgd2hlbiBgb3J0LmVudi53YXNtLm51bVRocmVhZHNgIGlzIG5vdCBzZXQgYnkgdXNlci4gV2Ugd2lsbCBhbHdheXMgaG9ub3IgdXNlcidzXG4gICAgLy8gc2V0dGluZyBpZiBpdCBpcyBwcm92aWRlZC5cblxuICAgIC8vIEJyb3dzZXI6IHdoZW4gY3Jvc3NPcmlnaW5Jc29sYXRlZCBpcyBmYWxzZSwgU2hhcmVkQXJyYXlCdWZmZXIgaXMgbm90IGF2YWlsYWJsZSBzbyBXZWJBc3NlbWJseSB0aHJlYWRzIHdpbGwgbm90XG4gICAgLy8gd29yay4gSW4gdGhpcyBjYXNlLCB3ZSB3aWxsIHNldCBudW1UaHJlYWRzIHRvIDEuXG4gICAgLy9cbiAgICAvLyBUaGVyZSBpcyBhbiBleGNlcHRpb246IHdoZW4gdGhlIGJyb3dzZXIgaXMgY29uZmlndXJlZCB0byBmb3JjZS1lbmFibGUgU2hhcmVkQXJyYXlCdWZmZXIgKGUuZy4gQ2hyb211aW0gd2l0aFxuICAgIC8vIC0tZW5hYmxlLWZlYXR1cmVzPVNoYXJlZEFycmF5QnVmZmVyKSwgaXQgaXMgcG9zc2libGUgdGhhdCBgc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkYCBpcyBmYWxzZSBhbmRcbiAgICAvLyBTaGFyZWRBcnJheUJ1ZmZlciBpcyBhdmFpbGFibGUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c3VhbGx5IGZvciB0ZXN0aW5nLiBJbiB0aGlzIGNhc2UsICB3ZSB3aWxsIHN0aWxsIHNldFxuICAgIC8vIG51bVRocmVhZHMgdG8gMSBoZXJlLiBJZiB3ZSB3YW50IHRvIGVuYWJsZSBtdWx0aS10aHJlYWRpbmcgaW4gdGVzdCwgd2Ugc2hvdWxkIHNldCBgb3J0LmVudi53YXNtLm51bVRocmVhZHNgIHRvIGFcbiAgICAvLyB2YWx1ZSBncmVhdGVyIHRoYW4gMS5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcbiAgICAgIGVudi53YXNtLm51bVRocmVhZHMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1DcHVMb2dpY2FsQ29yZXMgPVxuICAgICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgnbm9kZTpvcycpLmNwdXMoKS5sZW5ndGggOiBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtcbiAgICAgIGVudi53YXNtLm51bVRocmVhZHMgPSBNYXRoLm1pbig0LCBNYXRoLmNlaWwoKG51bUNwdUxvZ2ljYWxDb3JlcyB8fCAxKSAvIDIpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9EWU5BTUlDX0lNUE9SVCkge1xuICAgIC8vIG92ZXJ3cml0ZSB3YXNtIHBhdGhzIG92ZXJyaWRlIGlmIG5vdCBzZXRcbiAgICBpZiAoZW52Lndhc20ud2FzbVBhdGhzID09PSB1bmRlZmluZWQgJiYgc2NyaXB0U3JjICYmIHNjcmlwdFNyYy5pbmRleE9mKCdibG9iOicpICE9PSAwKSB7XG4gICAgICBlbnYud2FzbS53YXNtUGF0aHMgPSBzY3JpcHRTcmMuc3Vic3RyaW5nKDAsIHNjcmlwdFNyYy5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQgaW1wbGVtZW50cyBCYWNrZW5kIHtcbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgdGhlIFdlYkFzc2VtYmx5IGJhY2tlbmQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGZvciBlYWNoIGJhY2tlbmQgbmFtZS4gSXQgd2lsbCBiZSBjYWxsZWQgdGhlIGZpcnN0IHRpbWUgd2hlblxuICAgKiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZCB3aXRoIGEgcmVnaXN0ZXJlZCBiYWNrZW5kIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSByZWdpc3RlcmVkIGJhY2tlbmQgbmFtZS5cbiAgICovXG4gIGFzeW5jIGluaXQoYmFja2VuZE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIHBvcHVsYXRlIHdhc20gZmxhZ3NcbiAgICBpbml0aWFsaXplRmxhZ3MoKTtcblxuICAgIC8vIGluaXQgd2FzbVxuICAgIGF3YWl0IGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUoKTtcblxuICAgIC8vIHBlcmZvcm1lIEVQIHNwZWNpZmljIGluaXRpYWxpemF0aW9uXG4gICAgYXdhaXQgaW5pdGlhbGl6ZU9ydEVwKGJhY2tlbmROYW1lKTtcbiAgfVxuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+O1xuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+O1xuICBhc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihwYXRoT3JCdWZmZXI6IHN0cmluZ3xVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPiB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIoKTtcbiAgICBhd2FpdCBoYW5kbGVyLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGFuZGxlcik7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZH0gZnJvbSAnLi9iYWNrZW5kLXdhc20nO1xuZXhwb3J0IGNvbnN0IHdhc21CYWNrZW5kID0gbmV3IE9ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kKCk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cblxuLy8gV2UgdXNlIFwicmVxdWlyZVwiIGluc3RlYWQgb2YgXCJpbXBvcnRcIiBoZXJlIGJlY2F1c2UgaW1wb3J0IHN0YXRlbWVudCBtdXN0IGJlIHB1dCBpbiB0b3AgbGV2ZWwuIE91ciBjdXJyZW50IGNvZGUgZG9lc1xuLy8gbm90IGFsbG93IGJ1bmRsZXIgdG8gdHJlZS1zaGFraW5nIGNvZGUgYXMgZXhwZWN0ZWQgYmVjYXVzZSBzb21lIGNvZGVzIGFyZSB0cmVhdGVkIGFzIGhhdmluZyBzaWRlIGVmZmVjdHMuXG4vLyBTbyB3ZSBpbXBvcnQgY29kZSBpbnNpZGUgdGhlIGlmLWNsYXVzZSB0byBhbGxvdyBidW5kbGVyIHJlbW92ZSB0aGUgY29kZSBzYWZlbHkuXG5cbmV4cG9ydCAqIGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQgKiBhcyBvcnQgZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmV4cG9ydCBkZWZhdWx0IG9ydDtcblxuaW1wb3J0IHtyZWdpc3RlckJhY2tlbmQsIGVudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi92ZXJzaW9uJztcblxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR0wpIHtcbiAgY29uc3Qgb25ueGpzQmFja2VuZCA9IHJlcXVpcmUoJy4vYmFja2VuZC1vbm54anMnKS5vbm54anNCYWNrZW5kO1xuICByZWdpc3RlckJhY2tlbmQoJ3dlYmdsJywgb25ueGpzQmFja2VuZCwgLTEwKTtcbn1cblxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTSkge1xuICBjb25zdCB3YXNtQmFja2VuZCA9IEJVSUxEX0RFRlMuRElTQUJMRV9UUkFJTklORyA/IHJlcXVpcmUoJy4vYmFja2VuZC13YXNtLWluZmVyZW5jZScpLndhc21CYWNrZW5kIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2JhY2tlbmQtd2FzbS10cmFpbmluZycpLndhc21CYWNrZW5kO1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQKSB7XG4gICAgcmVnaXN0ZXJCYWNrZW5kKCd3ZWJncHUnLCB3YXNtQmFja2VuZCwgNSk7XG4gICAgcmVnaXN0ZXJCYWNrZW5kKCd3ZWJubicsIHdhc21CYWNrZW5kLCA1KTtcbiAgfVxuICByZWdpc3RlckJhY2tlbmQoJ2NwdScsIHdhc21CYWNrZW5kLCAxMCk7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2FzbScsIHdhc21CYWNrZW5kLCAxMCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnYudmVyc2lvbnMsICd3ZWInLCB7dmFsdWU6IHZlcnNpb24sIGVudW1lcmFibGU6IHRydWV9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMTkuMCc7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQWdCTSxVQUNBLDBCQVlPLGlCQXdDUCxnQ0F3Q087QUE3R2I7OztBQWdCQSxNQUFNLFdBQXFDLG9CQUFJLElBQUc7QUFDbEQsTUFBTSwyQkFBcUMsQ0FBQTtBQVlwQyxNQUFNLGtCQUFrQixDQUFDLE1BQWMsU0FBa0IsYUFBMEI7QUFDeEYsWUFBSSxXQUFXLE9BQU8sUUFBUSxTQUFTLGNBQWMsT0FBTyxRQUFRLGtDQUFrQyxZQUFZO0FBQ2hILGdCQUFNLGlCQUFpQixTQUFTLElBQUksSUFBSTtBQUN4QyxjQUFJLG1CQUFtQixRQUFXO0FBQ2hDLHFCQUFTLElBQUksTUFBTSxFQUFDLFNBQVMsU0FBUSxDQUFDO3FCQUM3QixlQUFlLFdBQVcsVUFBVTtBQUU3QztxQkFDUyxlQUFlLGFBQWEsVUFBVTtBQUMvQyxnQkFBSSxlQUFlLFlBQVksU0FBUztBQUN0QyxvQkFBTSxJQUFJLE1BQU0sNEJBQTRCLElBQUksb0JBQW9CLFFBQVEsRUFBRTs7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QUFNLGdCQUFnQixLQUE0QjtBQUNsRCxvQkFBZ0IsU0FBUyxlQUFlLEdBQUc7QUFBQSxFQUM3QztBQUVBLE1BQUksTUFBMEI7QUFDNUIsVUFBTUMsZUFBYyxPQUE4Qiw4RUFBb0MsY0FDcEMsS0FBbUM7QUFDckYsUUFBSSxNQUEwQjtBQUM1QixzQkFBZ0IsVUFBVUEsY0FBYSxDQUFDO0FBQ3hDLHNCQUFnQixTQUFTQSxjQUFhLENBQUM7QUFBQSxJQUN6QztBQUNBLG9CQUFnQixPQUFPQSxjQUFhLEVBQUU7QUFDdEMsb0JBQWdCLFFBQVFBLGNBQWEsRUFBRTtBQUFBLEVBQ3pDO0FBRUEsU0FBTyxlQUFlQyxLQUFJLFVBQVUsT0FBTyxFQUFDLE9BQU9DLFVBQVMsWUFBWSxLQUFJLENBQUM7IiwKICAibmFtZXMiOiBbImkiLCAiZW52IiwgIlRlbnNvciIsICJUZW5zb3IiLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJUZW5zb3IiLCAiVHJhaW5pbmdTZXNzaW9uIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgIlRyYWluaW5nU2Vzc2lvbiIsICJlbnYiLCAiZW52IiwgIndhc20iLCAid2FzbSIsICJ3YXNtIiwgImxvY2F0aW9uIiwgInBhZCIsICJpbml0IiwgIm9mZnNldHMiLCAiaW5kaWNlcyIsICJpbXBsIiwgInZhbGlkYXRlSW5wdXRzIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgInZhbGlkYXRlSW5wdXRzIiwgImkiLCAidHJhbnNwb3NlIiwgIm91dHB1dFZhcmlhYmxlIiwgImlubmVyRWxlbWVudFNpemUiLCAicGFkIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgIm91dHB1dFNoYXBlIiwgInRyYW5zcG9zZWRXZWlnaHQiLCAiY29udklucHV0cyIsICJpbm5lckVsZW1lbnRTaXplIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInBlcm1GdW5jdGlvbkJvZHkiLCAic3ltYm9sIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJjYWxjdWxhdGVPdXRwdXRTaGFwZSIsICJmYXN0R2VsdSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUiLCAidmFsaWRhdGVJbnB1dHMiLCAiZ2V0T3V0cHV0U2hhcGUiLCAidmFsaWRhdGVJbnB1dHMiLCAiY3JlYXRlQ29uY2F0UHJvZ3JhbUluZm8iLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImRhdGFUeXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29tcG9uZW50cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJhIiwgImIiLCAiYyIsICJmYXN0R2VsdSIsICJlbnYiLCAiaSIsICJlbnYiLCAiZW52IiwgIndhc20iLCAibG9jYXRpb24iLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImluaXRpYWxpemluZyIsICJpbml0aWFsaXplZCIsICJhYm9ydGVkIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJUZW5zb3IiLCAiY29weUZyb21FeHRlcm5hbEJ1ZmZlciIsICJjcmVhdGVTZXNzaW9uIiwgInJlbGVhc2VTZXNzaW9uIiwgInJ1biIsICJlbmRQcm9maWxpbmciLCAiZW52IiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgIlRyYWluaW5nU2Vzc2lvbiIsICJlbnYiLCAidmVyc2lvbiIsICJ3YXNtQmFja2VuZCIsICJlbnYiLCAidmVyc2lvbiJdCn0K
